(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.dagre = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

module.exports = {
  graphlib: require("@dagrejs/graphlib"),

  layout: require("./lib/layout"),
  debug: require("./lib/debug"),
  util: {
    time: require("./lib/util").time,
    notime: require("./lib/util").notime
  },
  version: require("./lib/version")
};

},{"./lib/debug":6,"./lib/layout":8,"./lib/util":27,"./lib/version":28,"@dagrejs/graphlib":29}],2:[function(require,module,exports){
"use strict";

let greedyFAS = require("./greedy-fas");
let uniqueId = require("./util").uniqueId;

module.exports = {
  run: run,
  undo: undo
};

function run(g) {
  let fas = (g.graph().acyclicer === "greedy"
    ? greedyFAS(g, weightFn(g))
    : dfsFAS(g));
  fas.forEach(e => {
    let label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, uniqueId("rev"));
  });

  function weightFn(g) {
    return e => {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  let fas = [];
  let stack = {};
  let visited = {};

  function dfs(v) {
    if (visited.hasOwnProperty(v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    g.outEdges(v).forEach(e => {
      if (stack.hasOwnProperty(e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  g.nodes().forEach(dfs);
  return fas;
}

function undo(g) {
  g.edges().forEach(e => {
    let label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      let forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}

},{"./greedy-fas":7,"./util":27}],3:[function(require,module,exports){
let util = require("./util");

module.exports = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    let children = g.children(v);
    let node = g.node(v);
    if (children.length) {
      children.forEach(dfs);
    }

    if (node.hasOwnProperty("minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (let rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  g.children().forEach(dfs);
}

function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  let label = { width: 0, height: 0, rank: rank, borderType: prop };
  let prev = sgNode[prop][rank - 1];
  let curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}

},{"./util":27}],4:[function(require,module,exports){
"use strict";

module.exports = {
  adjust: adjust,
  undo: undo
};

function adjust(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  g.nodes().forEach(v => swapWidthHeightOne(g.node(v)));
  g.edges().forEach(e => swapWidthHeightOne(g.edge(e)));
}

function swapWidthHeightOne(attrs) {
  let w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  g.nodes().forEach(v => reverseYOne(g.node(v)));

  g.edges().forEach(e => {
    let edge = g.edge(e);
    edge.points.forEach(reverseYOne);
    if (edge.hasOwnProperty("y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  g.nodes().forEach(v => swapXYOne(g.node(v)));

  g.edges().forEach(e => {
    let edge = g.edge(e);
    edge.points.forEach(swapXYOne);
    if (edge.hasOwnProperty("x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  let x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}

},{}],5:[function(require,module,exports){
/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

class List {
  constructor() {
    let sentinel = {};
    sentinel._next = sentinel._prev = sentinel;
    this._sentinel = sentinel;
  }

  dequeue() {
    let sentinel = this._sentinel;
    let entry = sentinel._prev;
    if (entry !== sentinel) {
      unlink(entry);
      return entry;
    }
  }

  enqueue(entry) {
    let sentinel = this._sentinel;
    if (entry._prev && entry._next) {
      unlink(entry);
    }
    entry._next = sentinel._next;
    sentinel._next._prev = entry;
    sentinel._next = entry;
    entry._prev = sentinel;
  }

  toString() {
    let strs = [];
    let sentinel = this._sentinel;
    let curr = sentinel._prev;
    while (curr !== sentinel) {
      strs.push(JSON.stringify(curr, filterOutLinks));
      curr = curr._prev;
    }
    return "[" + strs.join(", ") + "]";
  }
}

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}

module.exports = List;

},{}],6:[function(require,module,exports){
let util = require("./util");
let Graph = require("@dagrejs/graphlib").Graph;

module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  let layerMatrix = util.buildLayerMatrix(g);

  let h = new Graph({ compound: true, multigraph: true }).setGraph({});

  g.nodes().forEach(v => {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  g.edges().forEach(e => h.setEdge(e.v, e.w, {}, e.name));

  layerMatrix.forEach((layer, i) => {
    let layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    layer.reduce((u, v) => {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}

},{"./util":27,"@dagrejs/graphlib":29}],7:[function(require,module,exports){
let Graph = require("@dagrejs/graphlib").Graph;
let List = require("./data/list");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;

let DEFAULT_WEIGHT_FN = () => 1;

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  let results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return results.flatMap(e => g.outEdges(e.v, e.w));
}

function doGreedyFAS(g, buckets, zeroIdx) {
  let results = [];
  let sources = buckets[buckets.length - 1];
  let sinks = buckets[0];

  let entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (let i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  let results = collectPredecessors ? [] : undefined;

  g.inEdges(entry.v).forEach(edge => {
    let weight = g.edge(edge);
    let uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  g.outEdges(entry.v).forEach(edge => {
    let weight = g.edge(edge);
    let w = edge.w;
    let wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  let fasGraph = new Graph();
  let maxIn = 0;
  let maxOut = 0;

  g.nodes().forEach(v => {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  g.edges().forEach(e => {
    let prevWeight = fasGraph.edge(e.v, e.w) || 0;
    let weight = weightFn(e);
    let edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  let buckets = range(maxOut + maxIn + 3).map(() => new List());
  let zeroIdx = maxIn + 1;

  fasGraph.nodes().forEach(v => {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}

function range(limit) {
  const range = [];
  for (let i = 0; i < limit; i++) {
    range.push(i);
  }

  return range;
}

},{"./data/list":5,"@dagrejs/graphlib":29}],8:[function(require,module,exports){
"use strict";

let acyclic = require("./acyclic");
let normalize = require("./normalize");
let rank = require("./rank");
let normalizeRanks = require("./util").normalizeRanks;
let parentDummyChains = require("./parent-dummy-chains");
let removeEmptyRanks = require("./util").removeEmptyRanks;
let nestingGraph = require("./nesting-graph");
let addBorderSegments = require("./add-border-segments");
let coordinateSystem = require("./coordinate-system");
let order = require("./order");
let position = require("./position");
let util = require("./util");
let Graph = require("@dagrejs/graphlib").Graph;

module.exports = layout;

function layout(g, opts) {
  let time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", () => {
    let layoutGraph =
      time("  buildLayoutGraph", () => buildLayoutGraph(g));
    time("  runLayout",        () => runLayout(layoutGraph, time));
    time("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g));
  time("    removeSelfEdges",        () => removeSelfEdges(g));
  time("    acyclic",                () => acyclic.run(g));
  time("    nestingGraph.run",       () => nestingGraph.run(g));
  time("    rank",                   () => rank(util.asNonCompoundGraph(g)));
  time("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g));
  time("    removeEmptyRanks",       () => removeEmptyRanks(g));
  time("    nestingGraph.cleanup",   () => nestingGraph.cleanup(g));
  time("    normalizeRanks",         () => normalizeRanks(g));
  time("    assignRankMinMax",       () => assignRankMinMax(g));
  time("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g));
  time("    normalize.run",          () => normalize.run(g));
  time("    parentDummyChains",      () => parentDummyChains(g));
  time("    addBorderSegments",      () => addBorderSegments(g));
  time("    order",                  () => order(g));
  time("    insertSelfEdges",        () => insertSelfEdges(g));
  time("    adjustCoordinateSystem", () => coordinateSystem.adjust(g));
  time("    position",               () => position(g));
  time("    positionSelfEdges",      () => positionSelfEdges(g));
  time("    removeBorderNodes",      () => removeBorderNodes(g));
  time("    normalize.undo",         () => normalize.undo(g));
  time("    fixupEdgeLabelCoords",   () => fixupEdgeLabelCoords(g));
  time("    undoCoordinateSystem",   () => coordinateSystem.undo(g));
  time("    translateGraph",         () => translateGraph(g));
  time("    assignNodeIntersects",   () => assignNodeIntersects(g));
  time("    reversePoints",          () => reversePointsForReversedEdges(g));
  time("    acyclic.undo",           () => acyclic.undo(g));
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  inputGraph.nodes().forEach(v => {
    let inputLabel = inputGraph.node(v);
    let layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      inputLabel.rank = layoutLabel.rank;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  inputGraph.edges().forEach(e => {
    let inputLabel = inputGraph.edge(e);
    let layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (layoutLabel.hasOwnProperty("x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
let graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
let graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
let nodeNumAttrs = ["width", "height"];
let nodeDefaults = { width: 0, height: 0 };
let edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
let edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
let edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  let g = new Graph({ multigraph: true, compound: true });
  let graph = canonicalize(inputGraph.graph());

  g.setGraph(Object.assign({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    util.pick(graph, graphAttrs)));

  inputGraph.nodes().forEach(v => {
    let node = canonicalize(inputGraph.node(v));
    const newNode = selectNumberAttrs(node, nodeNumAttrs);
    Object.keys(nodeDefaults).forEach(k => {
      if (newNode[k] === undefined) {
        newNode[k] = nodeDefaults[k];
      }
    });

    g.setNode(v, newNode);
    g.setParent(v, inputGraph.parent(v));
  });

  inputGraph.edges().forEach(e => {
    let edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, Object.assign({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      util.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  let graph = g.graph();
  graph.ranksep /= 2;
  g.edges().forEach(e => {
    let edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  g.edges().forEach(e => {
    let edge = g.edge(e);
    if (edge.width && edge.height) {
      let v = g.node(e.v);
      let w = g.node(e.w);
      let label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  let maxRank = 0;
  g.nodes().forEach(v => {
    let node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = Math.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  g.nodes().forEach(v => {
    let node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  let minX = Number.POSITIVE_INFINITY;
  let maxX = 0;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = 0;
  let graphLabel = g.graph();
  let marginX = graphLabel.marginx || 0;
  let marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    let x = attrs.x;
    let y = attrs.y;
    let w = attrs.width;
    let h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  g.nodes().forEach(v => getExtremes(g.node(v)));
  g.edges().forEach(e => {
    let edge = g.edge(e);
    if (edge.hasOwnProperty("x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  g.nodes().forEach(v => {
    let node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  g.edges().forEach(e => {
    let edge = g.edge(e);
    edge.points.forEach(p => {
      p.x -= minX;
      p.y -= minY;
    });
    if (edge.hasOwnProperty("x")) { edge.x -= minX; }
    if (edge.hasOwnProperty("y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  g.edges().forEach(e => {
    let edge = g.edge(e);
    let nodeV = g.node(e.v);
    let nodeW = g.node(e.w);
    let p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  g.edges().forEach(e => {
    let edge = g.edge(e);
    if (edge.hasOwnProperty("x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  g.edges().forEach(e => {
    let edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  g.nodes().forEach(v => {
    if (g.children(v).length) {
      let node = g.node(v);
      let t = g.node(node.borderTop);
      let b = g.node(node.borderBottom);
      let l = g.node(node.borderLeft[node.borderLeft.length - 1]);
      let r = g.node(node.borderRight[node.borderRight.length - 1]);

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  g.nodes().forEach(v => {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  g.edges().forEach(e => {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  layers.forEach(layer => {
    var orderShift = 0;
    layer.forEach((v, i) => {
      var node = g.node(v);
      node.order = i + orderShift;
      (node.selfEdges || []).forEach(selfEdge => {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  g.nodes().forEach(v => {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return util.mapValues(util.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  if (attrs) {
    Object.entries(attrs).forEach(([k, v]) => {
      if (typeof k === "string") {
        k = k.toLowerCase();
      }

      newAttrs[k] = v;
    });
  }
  return newAttrs;
}

},{"./acyclic":2,"./add-border-segments":3,"./coordinate-system":4,"./nesting-graph":9,"./normalize":10,"./order":15,"./parent-dummy-chains":20,"./position":22,"./rank":24,"./util":27,"@dagrejs/graphlib":29}],9:[function(require,module,exports){
let util = require("./util");

module.exports = {
  run,
  cleanup,
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundaries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  let root = util.addDummyNode(g, "root", {}, "_root");
  let depths = treeDepths(g);
  let height = Math.max(...Object.values(depths)) - 1; // Note: depths is an Object not an array
  let nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  g.edges().forEach(e => g.edge(e).minlen *= nodeSep);

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  let weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  g.children().forEach(child => dfs(g, root, nodeSep, weight, height, depths, child));

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs(g, root, nodeSep, weight, height, depths, v) {
  let children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  let top = util.addBorderNode(g, "_bt");
  let bottom = util.addBorderNode(g, "_bb");
  let label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  children.forEach(child => {
    dfs(g, root, nodeSep, weight, height, depths, child);

    let childNode = g.node(child);
    let childTop = childNode.borderTop ? childNode.borderTop : child;
    let childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    let thisWeight = childNode.borderTop ? weight : 2 * weight;
    let minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      children.forEach(child => dfs(child, depth + 1));
    }
    depths[v] = depth;
  }
  g.children().forEach(v => dfs(v, 1));
  return depths;
}

function sumWeights(g) {
  return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  g.edges().forEach(e => {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}

},{"./util":27}],10:[function(require,module,exports){
"use strict";

let util = require("./util");

module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  g.edges().forEach(edge => normalizeEdge(g, edge));
}

function normalizeEdge(g, e) {
  let v = e.v;
  let vRank = g.node(v).rank;
  let w = e.w;
  let wRank = g.node(w).rank;
  let name = e.name;
  let edgeLabel = g.edge(e);
  let labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  let dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo(g) {
  g.graph().dummyChains.forEach(v => {
    let node = g.node(v);
    let origLabel = node.edgeLabel;
    let w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}

},{"./util":27}],11:[function(require,module,exports){
module.exports = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  let prev = {},
    rootPrev;

  vs.forEach(v => {
    let child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      children.forEach(function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.sortBy(subgraphs, "order").reduce(function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}

},{}],12:[function(require,module,exports){
module.exports = barycenter;

function barycenter(g, movable = []) {
  return movable.map(v => {
    let inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      let result = inV.reduce((acc, e) => {
        let edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}


},{}],13:[function(require,module,exports){
let Graph = require("@dagrejs/graphlib").Graph;
let util = require("../util");

module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  let root = createRootNode(g),
    result = new Graph({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(v => g.node(v));

  g.nodes().forEach(v => {
    let node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      g[relationship](v).forEach(e => {
        let u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = edge !== undefined ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (node.hasOwnProperty("minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = util.uniqueId("_root"))));
  return v;
}

},{"../util":27,"@dagrejs/graphlib":29}],14:[function(require,module,exports){
"use strict";

let zipObject = require("../util").zipObject;

module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  let cc = 0;
  for (let i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  let southPos = zipObject(southLayer, southLayer.map((v, i) => i));
  let southEntries = northLayer.flatMap(v => {
    return g.outEdges(v).map(e => {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }).sort((a, b) => a.pos - b.pos);
  });

  // Build the accumulator tree
  let firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  let treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  let tree = new Array(treeSize).fill(0);

  // Calculate the weighted crossings
  let cc = 0;
  southEntries.forEach(entry => {
    let index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    let weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  });

  return cc;
}

},{"../util":27}],15:[function(require,module,exports){
"use strict";

let initOrder = require("./init-order");
let crossCount = require("./cross-count");
let sortSubgraph = require("./sort-subgraph");
let buildLayerGraph = require("./build-layer-graph");
let addSubgraphConstraints = require("./add-subgraph-constraints");
let Graph = require("@dagrejs/graphlib").Graph;
let util = require("../util");

module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g, opts) {
  if (opts && typeof opts.customOrder === 'function') {
    opts.customOrder(g, order);
    return;
  }

  let maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");

  let layering = initOrder(g);
  assignOrder(g, layering);

  if (opts && opts.disableOptimalOrderHeuristic) {
    return;
  }

  let bestCC = Number.POSITIVE_INFINITY,
    best;

  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    let cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = Object.assign({}, layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return ranks.map(function(rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  let cg = new Graph();
  layerGraphs.forEach(function(lg) {
    let root = lg.graph().root;
    let sorted = sortSubgraph(lg, root, cg, biasRight);
    sorted.vs.forEach((v, i) => lg.node(v).order = i);
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  Object.values(layering).forEach(layer => layer.forEach((v, i) => g.node(v).order = i));
}

},{"../util":27,"./add-subgraph-constraints":11,"./build-layer-graph":13,"./cross-count":14,"./init-order":16,"./sort-subgraph":18,"@dagrejs/graphlib":29}],16:[function(require,module,exports){
"use strict";

let util = require("../util");

module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  let visited = {};
  let simpleNodes = g.nodes().filter(v => !g.children(v).length);
  let maxRank = Math.max(...simpleNodes.map(v => g.node(v).rank));
  let layers = util.range(maxRank + 1).map(() => []);

  /* 
   * The following code uses dfs to iterate nodes which will case
   * "maximum call stack size exceeded" error when handling large graphs.
   * Change it to using bfs instead.
   *
   * function dfs(v) {
   *   if (visited[v]) return;
   *   visited[v] = true;
   *   let node = g.node(v);
   *   layers[node.rank].push(v);
   *   g.successors(v).forEach(dfs);
   * }
   *
   * let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
   * orderedVs.forEach(dfs);
   */

  function bfs(startV) { 
    const queue = [startV];

    while (queue.length > 0) {
      const v = queue.shift();

      if (visited[v]) continue;

      visited[v] = true;
      const node = g.node(v);
      layers[node.rank].push(v);

      g.successors(v).forEach(neighbor => queue.push(neighbor));
    }
  }

  let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
  orderedVs.forEach(bfs); 

  return layers;
}

},{"../util":27}],17:[function(require,module,exports){
"use strict";

let util = require("../util");

module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  let mappedEntries = {};
  entries.forEach((entry, i) => {
    let tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (entry.barycenter !== undefined) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  cg.edges().forEach(e => {
    let entryV = mappedEntries[e.v];
    let entryW = mappedEntries[e.w];
    if (entryV !== undefined && entryW !== undefined) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  let sourceSet = Object.values(mappedEntries).filter(entry => !entry.indegree);

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  let entries = [];

  function handleIn(vEntry) {
    return uEntry => {
      if (uEntry.merged) {
        return;
      }
      if (uEntry.barycenter === undefined ||
          vEntry.barycenter === undefined ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return wEntry => {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    let entry = sourceSet.pop();
    entries.push(entry);
    entry["in"].reverse().forEach(handleIn(entry));
    entry.out.forEach(handleOut(entry));
  }

  return entries.filter(entry => !entry.merged).map(entry => {
    return util.pick(entry, ["vs", "i", "barycenter", "weight"]);
  });
}

function mergeEntries(target, source) {
  let sum = 0;
  let weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}

},{"../util":27}],18:[function(require,module,exports){
let barycenter = require("./barycenter");
let resolveConflicts = require("./resolve-conflicts");
let sort = require("./sort");

module.exports = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  let movable = g.children(v);
  let node = g.node(v);
  let bl = node ? node.borderLeft : undefined;
  let br = node ? node.borderRight: undefined;
  let subgraphs = {};

  if (bl) {
    movable = movable.filter(w => w !== bl && w !== br);
  }

  let barycenters = barycenter(g, movable);
  barycenters.forEach(entry => {
    if (g.children(entry.v).length) {
      let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (subgraphResult.hasOwnProperty("barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  let entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  let result = sort(entries, biasRight);

  if (bl) {
    result.vs = [bl, result.vs, br].flat(true);
    if (g.predecessors(bl).length) {
      let blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!result.hasOwnProperty("barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  entries.forEach(entry => {
    entry.vs = entry.vs.flatMap(v => {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    });
  });
}

function mergeBarycenters(target, other) {
  if (target.barycenter !== undefined) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}

},{"./barycenter":12,"./resolve-conflicts":17,"./sort":19}],19:[function(require,module,exports){
let util = require("../util");

module.exports = sort;

function sort(entries, biasRight) {
  let parts = util.partition(entries, entry => {
    return entry.hasOwnProperty("barycenter");
  });
  let sortable = parts.lhs,
    unsortable = parts.rhs.sort((a, b) => b.i - a.i),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  sortable.forEach(entry => {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  let result = { vs: vs.flat(true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  let last;
  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return (entryV, entryW) => {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}

},{"../util":27}],20:[function(require,module,exports){
module.exports = parentDummyChains;

function parentDummyChains(g) {
  let postorderNums = postorder(g);

  g.graph().dummyChains.forEach(v => {
    let node = g.node(v);
    let edgeObj = node.edgeObj;
    let pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    let path = pathData.path;
    let lca = pathData.lca;
    let pathIdx = 0;
    let pathV = path[pathIdx];
    let ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  let vPath = [];
  let wPath = [];
  let low = Math.min(postorderNums[v].low, postorderNums[w].low);
  let lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  let parent;
  let lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder(g) {
  let result = {};
  let lim = 0;

  function dfs(v) {
    let low = lim;
    g.children(v).forEach(dfs);
    result[v] = { low: low, lim: lim++ };
  }
  g.children().forEach(dfs);

  return result;
}

},{}],21:[function(require,module,exports){
"use strict";

let Graph = require("@dagrejs/graphlib").Graph;
let util = require("../util");

/*
 * This module provides coordinate assignment based on Brandes and KÃ¶pf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  let conflicts = {};

  function visitLayer(prevLayer, layer) {
    let
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = layer[layer.length - 1];

    layer.forEach((v, i) => {
      let w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        layer.slice(scanPos, i+1).forEach(scanNode => {
          g.predecessors(scanNode).forEach(u => {
            let uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  layering.length && layering.reduce(visitLayer);

  return conflicts;
}

function findType2Conflicts(g, layering) {
  let conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    let v;
    util.range(southPos, southEnd).forEach(i => {
      v = south[i];
      if (g.node(v).dummy) {
        g.predecessors(v).forEach(u => {
          let uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    let prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    south.forEach((v, southLookahead) => {
      if (g.node(v).dummy === "border") {
        let predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  layering.length && layering.reduce(visitLayer);

  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return g.predecessors(v).find(u => g.node(u).dummy);
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w;
    w = tmp;
  }

  let conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w;
    w = tmp;
  }
  return !!conflicts[v] && conflicts[v].hasOwnProperty(w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  let root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  layering.forEach(layer => {
    layer.forEach((v, order) => {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  layering.forEach(layer => {
    let prevIdx = -1;
    layer.forEach(v => {
      let ws = neighborFn(v);
      if (ws.length) {
        ws = ws.sort((a, b) => pos[a] - pos[b]);
        let mp = (ws.length - 1) / 2;
        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          let w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  let xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    let stack = blockG.nodes();
    let elem = stack.pop();
    let visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce((acc, e) => {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    let min = blockG.outEdges(elem).reduce((acc, e) => {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    let node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  Object.keys(align).forEach(v => xs[v] = xs[root[v]]);

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  let blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  layering.forEach(layer => {
    let u;
    layer.forEach(v => {
      let vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return Object.values(xss).reduce((currentMinAndXs, xs) => {
    let max = Number.NEGATIVE_INFINITY;
    let min = Number.POSITIVE_INFINITY;

    Object.entries(xs).forEach(([v, x]) => {
      let halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    const newMin = max - min;
    if (newMin < currentMinAndXs[0]) {
      currentMinAndXs = [newMin, xs];
    }
    return currentMinAndXs;
  }, [Number.POSITIVE_INFINITY, null])[1];
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  let alignToVals = Object.values(alignTo),
    alignToMin = Math.min(...alignToVals),
    alignToMax = Math.max(...alignToVals);

  ["u", "d"].forEach(vert => {
    ["l", "r"].forEach(horiz => {
      let alignment = vert + horiz,
        xs = xss[alignment];

      if (xs === alignTo) return;

      let xsVals = Object.values(xs);
      let delta = alignToMin - Math.min(...xsVals);
      if (horiz !== "l") {
        delta = alignToMax - Math.max(...xsVals);
      }

      if (delta) {
        xss[alignment] = util.mapValues(xs, x => x + delta);
      }
    });
  });
}

function balance(xss, align) {
  return util.mapValues(xss.ul, (num, v) => {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      let xs = Object.values(xss).map(xs => xs[v]).sort((a, b) => a - b);
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  let layering = util.buildLayerMatrix(g);
  let conflicts = Object.assign(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  let xss = {};
  let adjustedLayering;
  ["u", "d"].forEach(vert => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach(horiz => {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map(inner => {
          return Object.values(inner).reverse();
        });
      }

      let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      let align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      let xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = util.mapValues(xs, x => -x);
      }
      xss[vert + horiz] = xs;
    });
  });


  let smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return (g, v, w) => {
    let vLabel = g.node(v);
    let wLabel = g.node(w);
    let sum = 0;
    let delta;

    sum += vLabel.width / 2;
    if (vLabel.hasOwnProperty("labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (wLabel.hasOwnProperty("labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}

},{"../util":27,"@dagrejs/graphlib":29}],22:[function(require,module,exports){
"use strict";

let util = require("../util");
let positionX = require("./bk").positionX;

module.exports = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  Object.entries(positionX(g)).forEach(([v, x]) => g.node(v).x = x);
}

function positionY(g) {
  let layering = util.buildLayerMatrix(g);
  let rankSep = g.graph().ranksep;
  let prevY = 0;
  layering.forEach(layer => {
    const maxHeight = layer.reduce((acc, v) => {
      const height = g.node(v).height;
      if (acc > height) {
        return acc;
      } else {
        return height;
      }
    }, 0);
    layer.forEach(v => g.node(v).y = prevY + maxHeight / 2);
    prevY += maxHeight + rankSep;
  });
}


},{"../util":27,"./bk":21}],23:[function(require,module,exports){
"use strict";

var Graph = require("@dagrejs/graphlib").Graph;
var slack = require("./util").slack;

module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    g.nodeEdges(v).forEach(e => {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  t.nodes().forEach(dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  const edges = g.edges();

  return edges.reduce((acc, edge) => {
    let edgeSlack = Number.POSITIVE_INFINITY;
    if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
      edgeSlack = slack(g, edge);
    }

    if (edgeSlack < acc[0]) {
      return [edgeSlack, edge];
    }

    return acc;
  }, [Number.POSITIVE_INFINITY, null])[1];
}

function shiftRanks(t, g, delta) {
  t.nodes().forEach(v => g.node(v).rank += delta);
}

},{"./util":26,"@dagrejs/graphlib":29}],24:[function(require,module,exports){
"use strict";

var rankUtil = require("./util");
var longestPath = rankUtil.longestPath;
var feasibleTree = require("./feasible-tree");
var networkSimplex = require("./network-simplex");

module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;

function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}

function networkSimplexRanker(g) {
  networkSimplex(g);
}

},{"./feasible-tree":23,"./network-simplex":25,"./util":26}],25:[function(require,module,exports){
"use strict";

var feasibleTree = require("./feasible-tree");
var slack = require("./util").slack;
var initRank = require("./util").longestPath;
var preorder = require("@dagrejs/graphlib").alg.preorder;
var postorder = require("@dagrejs/graphlib").alg.postorder;
var simplify = require("../util").simplify;

module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  vs.forEach(v => assignCutValue(t, g, v));
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  g.nodeEdges(child).forEach(e => {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  tree.neighbors(v).forEach(w => {
    if (!visited.hasOwnProperty(w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return tree.edges().find(e => tree.edge(e).cutvalue < 0);
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = g.edges().filter(edge => {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return candidates.reduce((acc, edge) => {
    if (slack(g, edge) < slack(g, acc)) {
      return edge;
    }

    return acc;
  });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = t.nodes().find(v => !g.node(v).parent);
  var vs = preorder(t, root);
  vs = vs.slice(1);
  vs.forEach(v => {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}

},{"../util":27,"./feasible-tree":23,"./util":26,"@dagrejs/graphlib":29}],26:[function(require,module,exports){
"use strict";

module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (visited.hasOwnProperty(v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = Math.min(...g.outEdges(v).map(e => {
      if (e == null) {
        return Number.POSITIVE_INFINITY;
      }

      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY) {
      rank = 0;
    }

    return (label.rank = rank);
  }

  g.sources().forEach(dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}

},{}],27:[function(require,module,exports){
/* eslint "no-console": off */

"use strict";

let Graph = require("@dagrejs/graphlib").Graph;

module.exports = {
  addBorderNode,
  addDummyNode,
  asNonCompoundGraph,
  buildLayerMatrix,
  intersectRect,
  mapValues,
  maxRank,
  normalizeRanks,
  notime,
  partition,
  pick,
  predecessorWeights,
  range,
  removeEmptyRanks,
  simplify,
  successorWeights,
  time,
  uniqueId,
  zipObject,
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  let v;
  do {
    v = uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  let simplified = new Graph().setGraph(g.graph());
  g.nodes().forEach(v => simplified.setNode(v, g.node(v)));
  g.edges().forEach(e => {
    let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    let label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  g.nodes().forEach(v => {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  g.edges().forEach(e => {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  let weightMap = g.nodes().map(v => {
    let sucs = {};
    g.outEdges(v).forEach(e => {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  let weightMap = g.nodes().map(v => {
    let preds = {};
    g.inEdges(v).forEach(e => {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  let x = rect.x;
  let y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  let dx = point.x - x;
  let dy = point.y - y;
  let w = rect.width / 2;
  let h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  let sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  let layering = range(maxRank(g) + 1).map(() => []);
  g.nodes().forEach(v => {
    let node = g.node(v);
    let rank = node.rank;
    if (rank !== undefined) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  let min = Math.min(...g.nodes().map(v => {
    let rank = g.node(v).rank;
    if (rank === undefined) {
      return Number.MAX_VALUE;
    }

    return rank;
  }));
  g.nodes().forEach(v => {
    let node = g.node(v);
    if (node.hasOwnProperty("rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  let offset = Math.min(...g.nodes().map(v => g.node(v).rank));

  let layers = [];
  g.nodes().forEach(v => {
    let rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  let delta = 0;
  let nodeRankFactor = g.graph().nodeRankFactor;
  Array.from(layers).forEach((vs, i) => {
    if (vs === undefined && i % nodeRankFactor !== 0) {
      --delta;
    } else if (vs !== undefined && delta) {
      vs.forEach(v => g.node(v).rank += delta);
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  let node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  /*
   * The following code would throw "maximum call stack size exceeded" error
   * when handling large graphs. Change it to using for loop instead.
   *
   *  return Math.max(...g.nodes().map(v => {
   *    let rank = g.node(v).rank;
   *    if (rank === undefined) {
   *      return Number.MIN_VALUE;
   *    }
   *    return rank;
   *  }));
   */

  let maxRank = Number.MIN_VALUE;

  for (const v of g.nodes()) {
    let rank = g.node(v).rank;

    if (rank === undefined) {
      continue; 
    }

    if (rank > maxRank) {
      maxRank = rank;
    }
  }

  return maxRank;
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  let result = { lhs: [], rhs: [] };
  collection.forEach(value => {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  let start = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}

let idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

function range(start, limit, step = 1) {
  if (limit == null) {
    limit = start;
    start = 0;
  }

  let endCon = (i) => i < limit;
  if (step < 0) {
    endCon = (i) => limit < i;
  }

  const range = [];
  for (let i = start; endCon(i); i += step) {
    range.push(i);
  }

  return range;
}

function pick(source, keys) {
  const dest = {};
  for (const key of keys) {
    if (source[key] !== undefined) {
      dest[key] = source[key];
    }
  }

  return dest;
}

function mapValues(obj, funcOrProp) {
  let func = funcOrProp;
  if (typeof funcOrProp === 'string') {
    func = (val) => val[funcOrProp];
  }

  return Object.entries(obj).reduce((acc, [k, v]) => {
    acc[k] = func(v, k);
    return acc;
  }, {});
}

function zipObject(props, values) {
  return props.reduce((acc, key, i) => {
    acc[key] = values[i];
    return acc;
  }, {});
}

},{"@dagrejs/graphlib":29}],28:[function(require,module,exports){
module.exports = "1.1.1";

},{}],29:[function(require,module,exports){
/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = require("./lib");

module.exports = {
  Graph: lib.Graph,
  json: require("./lib/json"),
  alg: require("./lib/alg"),
  version: lib.version
};

},{"./lib":45,"./lib/alg":36,"./lib/json":46}],30:[function(require,module,exports){
module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (visited.hasOwnProperty(v)) return;
    visited[v] = true;
    cmpt.push(v);
    g.successors(v).forEach(dfs);
    g.predecessors(v).forEach(dfs);
  }

  g.nodes().forEach(function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

},{}],31:[function(require,module,exports){
module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * If the order is not "post", it will be treated as "pre".
 */
function dfs(g, vs, order) {
  if (!Array.isArray(vs)) {
    vs = [vs];
  }

  var navigation = g.isDirected() ? v => g.successors(v) : v => g.neighbors(v);
  var orderFunc = order === "post" ? postOrderDfs : preOrderDfs;

  var acc = [];
  var visited = {};
  vs.forEach(v => {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    orderFunc(v, navigation, visited, acc);
  });

  return acc;
}

function postOrderDfs(v, navigation, visited, acc) {
  var stack = [[v, false]];
  while (stack.length > 0) {
    var curr = stack.pop();
    if (curr[1]) {
      acc.push(curr[0]);
    } else {
      if (!visited.hasOwnProperty(curr[0])) {
        visited[curr[0]] = true;
        stack.push([curr[0], true]);
        forEachRight(navigation(curr[0]), w => stack.push([w, false]));
      }
    }
  }
}

function preOrderDfs(v, navigation, visited, acc) {
  var stack = [v];
  while (stack.length > 0) {
    var curr = stack.pop();
    if (!visited.hasOwnProperty(curr)) {
      visited[curr] = true;
      acc.push(curr);
      forEachRight(navigation(curr), w => stack.push(w));
    }
  }
}

function forEachRight(array, iteratee) {
  var length = array.length;
  while (length--) {
    iteratee(array[length], length, array);
  }

  return array;
}

},{}],32:[function(require,module,exports){
var dijkstra = require("./dijkstra");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return g.nodes().reduce(function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
    return acc;
  }, {});
}

},{"./dijkstra":33}],33:[function(require,module,exports){
var PriorityQueue = require("../data/priority-queue");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = () => 1;

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

},{"../data/priority-queue":43}],34:[function(require,module,exports){
var tarjan = require("./tarjan");

module.exports = findCycles;

function findCycles(g) {
  return tarjan(g).filter(function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}

},{"./tarjan":41}],35:[function(require,module,exports){
module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = () => 1;

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}

},{}],36:[function(require,module,exports){
module.exports = {
  components: require("./components"),
  dijkstra: require("./dijkstra"),
  dijkstraAll: require("./dijkstra-all"),
  findCycles: require("./find-cycles"),
  floydWarshall: require("./floyd-warshall"),
  isAcyclic: require("./is-acyclic"),
  postorder: require("./postorder"),
  preorder: require("./preorder"),
  prim: require("./prim"),
  tarjan: require("./tarjan"),
  topsort: require("./topsort")
};

},{"./components":30,"./dijkstra":33,"./dijkstra-all":32,"./find-cycles":34,"./floyd-warshall":35,"./is-acyclic":37,"./postorder":38,"./preorder":39,"./prim":40,"./tarjan":41,"./topsort":42}],37:[function(require,module,exports){
var topsort = require("./topsort");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}

},{"./topsort":42}],38:[function(require,module,exports){
var dfs = require("./dfs");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}

},{"./dfs":31}],39:[function(require,module,exports){
var dfs = require("./dfs");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

},{"./dfs":31}],40:[function(require,module,exports){
var Graph = require("../graph");
var PriorityQueue = require("../data/priority-queue");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  g.nodes().forEach(function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (parents.hasOwnProperty(v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

},{"../data/priority-queue":43,"../graph":44}],41:[function(require,module,exports){
module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!visited.hasOwnProperty(w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!visited.hasOwnProperty(v)) {
      dfs(v);
    }
  });

  return results;
}

},{}],42:[function(require,module,exports){
function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (stack.hasOwnProperty(node)) {
      throw new CycleException();
    }

    if (!visited.hasOwnProperty(node)) {
      stack[node] = true;
      visited[node] = true;
      g.predecessors(node).forEach(visit);
      delete stack[node];
      results.push(node);
    }
  }

  g.sinks().forEach(visit);

  if (Object.keys(visited).length !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

class CycleException extends Error {
  constructor() {
    super(...arguments);
  }
}

module.exports = topsort;
topsort.CycleException = CycleException;

},{}],43:[function(require,module,exports){
/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
class PriorityQueue {
  #arr = [];
  #keyIndices = {};

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this.#arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this.#arr.map(function(x) { return x.key; });
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this.#keyIndices.hasOwnProperty(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   *
   * @param {Object} key
   */
  priority(key) {
    var index = this.#keyIndices[key];
    if (index !== undefined) {
      return this.#arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if (this.size() === 0) {
      throw new Error("Queue underflow");
    }
    return this.#arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param {Object} key the key to add
   * @param {Number} priority the initial priority for the key
   */
  add(key, priority) {
    var keyIndices = this.#keyIndices;
    key = String(key);
    if (!keyIndices.hasOwnProperty(key)) {
      var arr = this.#arr;
      var index = arr.length;
      keyIndices[key] = index;
      arr.push({key: key, priority: priority});
      this.#decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this.#swap(0, this.#arr.length - 1);
    var min = this.#arr.pop();
    delete this.#keyIndices[min.key];
    this.#heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param {Object} key the key for which to raise priority
   * @param {Number} priority the new priority for the key
   */
  decrease(key, priority) {
    var index = this.#keyIndices[key];
    if (priority > this.#arr[index].priority) {
      throw new Error("New priority is greater than current priority. " +
          "Key: " + key + " Old: " + this.#arr[index].priority + " New: " + priority);
    }
    this.#arr[index].priority = priority;
    this.#decrease(index);
  }

  #heapify(i) {
    var arr = this.#arr;
    var l = 2 * i;
    var r = l + 1;
    var largest = i;
    if (l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if (r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if (largest !== i) {
        this.#swap(i, largest);
        this.#heapify(largest);
      }
    }
  }

  #decrease(index) {
    var arr = this.#arr;
    var priority = arr[index].priority;
    var parent;
    while (index !== 0) {
      parent = index >> 1;
      if (arr[parent].priority < priority) {
        break;
      }
      this.#swap(index, parent);
      index = parent;
    }
  }

  #swap(i, j) {
    var arr = this.#arr;
    var keyIndices = this.#keyIndices;
    var origArrI = arr[i];
    var origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices[origArrJ.key] = i;
    keyIndices[origArrI.key] = j;
  }
}

module.exports = PriorityQueue;

},{}],44:[function(require,module,exports){
"use strict";

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

class Graph {
  #isDirected = true;
  #isMultigraph = false;
  #isCompound = false;

  // Label for the graph itself
  #label;

  // Defaults to be set when creating a new node
  #defaultNodeLabelFn = () => undefined;

  // Defaults to be set when creating a new edge
  #defaultEdgeLabelFn = () => undefined;

  // v -> label
  #nodes = {};

  // v -> edgeObj
  #in = {};

  // u -> v -> Number
  #preds = {};

  // v -> edgeObj
  #out = {};

  // v -> w -> Number
  #sucs = {};

  // e -> edgeObj
  #edgeObjs = {};

  // e -> label
  #edgeLabels = {};

  /* Number of nodes in the graph. Should only be changed by the implementation. */
  #nodeCount = 0;

  /* Number of edges in the graph. Should only be changed by the implementation. */
  #edgeCount = 0;

  #parent;

  #children;

  constructor(opts) {
    if (opts) {
      this.#isDirected = opts.hasOwnProperty("directed") ? opts.directed : true;
      this.#isMultigraph = opts.hasOwnProperty("multigraph") ? opts.multigraph : false;
      this.#isCompound = opts.hasOwnProperty("compound") ? opts.compound : false;
    }

    if (this.#isCompound) {
      // v -> parent
      this.#parent = {};

      // v -> children
      this.#children = {};
      this.#children[GRAPH_NODE] = {};
    }
  }

  /* === Graph functions ========= */

  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  isDirected() {
    return this.#isDirected;
  }

  /**
   * Whether graph was created with 'multigraph' flag set to true or not.
   */
  isMultigraph() {
    return this.#isMultigraph;
  }

  /**
   * Whether graph was created with 'compound' flag set to true or not.
   */
  isCompound() {
    return this.#isCompound;
  }

  /**
   * Sets the label of the graph.
   */
  setGraph(label) {
    this.#label = label;
    return this;
  }

  /**
   * Gets the graph label.
   */
  graph() {
    return this.#label;
  }


  /* === Node functions ========== */

  /**
   * Sets the default node label. If newDefault is a function, it will be
   * invoked ach time when setting a label for a node. Otherwise, this label
   * will be assigned as default label in case if no label was specified while
   * setting a node.
   * Complexity: O(1).
   */
  setDefaultNodeLabel(newDefault) {
    this.#defaultNodeLabelFn = newDefault;
    if (typeof newDefault !== 'function') {
      this.#defaultNodeLabelFn = () => newDefault;
    }

    return this;
  }

  /**
   * Gets the number of nodes in the graph.
   * Complexity: O(1).
   */
  nodeCount() {
    return this.#nodeCount;
  }

  /**
   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
   * not included in list.
   * Complexity: O(1).
   */
  nodes() {
    return Object.keys(this.#nodes);
  }

  /**
   * Gets list of nodes without in-edges.
   * Complexity: O(|V|).
   */
  sources() {
    var self = this;
    return this.nodes().filter(v => Object.keys(self.#in[v]).length === 0);
  }

  /**
   * Gets list of nodes without out-edges.
   * Complexity: O(|V|).
   */
  sinks() {
    var self = this;
    return this.nodes().filter(v => Object.keys(self.#out[v]).length === 0);
  }

  /**
   * Invokes setNode method for each node in names list.
   * Complexity: O(|names|).
   */
  setNodes(vs, value) {
    var args = arguments;
    var self = this;
    vs.forEach(function(v) {
      if (args.length > 1) {
        self.setNode(v, value);
      } else {
        self.setNode(v);
      }
    });
    return this;
  }

  /**
   * Creates or updates the value for the node v in the graph. If label is supplied
   * it is set as the value for the node. If label is not supplied and the node was
   * created by this call then the default node label will be assigned.
   * Complexity: O(1).
   */
  setNode(v, value) {
    if (this.#nodes.hasOwnProperty(v)) {
      if (arguments.length > 1) {
        this.#nodes[v] = value;
      }
      return this;
    }

    this.#nodes[v] = arguments.length > 1 ? value : this.#defaultNodeLabelFn(v);
    if (this.#isCompound) {
      this.#parent[v] = GRAPH_NODE;
      this.#children[v] = {};
      this.#children[GRAPH_NODE][v] = true;
    }
    this.#in[v] = {};
    this.#preds[v] = {};
    this.#out[v] = {};
    this.#sucs[v] = {};
    ++this.#nodeCount;
    return this;
  }

  /**
   * Gets the label of node with specified name.
   * Complexity: O(|V|).
   */
  node(v) {
    return this.#nodes[v];
  }

  /**
   * Detects whether graph has a node with specified name or not.
   */
  hasNode(v) {
    return this.#nodes.hasOwnProperty(v);
  }

  /**
   * Remove the node with the name from the graph or do nothing if the node is not in
   * the graph. If the node was removed this function also removes any incident
   * edges.
   * Complexity: O(1).
   */
  removeNode(v) {
    var self = this;
    if (this.#nodes.hasOwnProperty(v)) {
      var removeEdge = e => self.removeEdge(self.#edgeObjs[e]);
      delete this.#nodes[v];
      if (this.#isCompound) {
        this.#removeFromParentsChildList(v);
        delete this.#parent[v];
        this.children(v).forEach(function(child) {
          self.setParent(child);
        });
        delete this.#children[v];
      }
      Object.keys(this.#in[v]).forEach(removeEdge);
      delete this.#in[v];
      delete this.#preds[v];
      Object.keys(this.#out[v]).forEach(removeEdge);
      delete this.#out[v];
      delete this.#sucs[v];
      --this.#nodeCount;
    }
    return this;
  }

  /**
   * Sets node p as a parent for node v if it is defined, or removes the
   * parent for v if p is undefined. Method throws an exception in case of
   * invoking it in context of noncompound graph.
   * Average-case complexity: O(1).
   */
  setParent(v, parent) {
    if (!this.#isCompound) {
      throw new Error("Cannot set parent in a non-compound graph");
    }

    if (parent === undefined) {
      parent = GRAPH_NODE;
    } else {
      // Coerce parent to string
      parent += "";
      for (var ancestor = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {
        if (ancestor === v) {
          throw new Error("Setting " + parent+ " as parent of " + v +
              " would create a cycle");
        }
      }

      this.setNode(parent);
    }

    this.setNode(v);
    this.#removeFromParentsChildList(v);
    this.#parent[v] = parent;
    this.#children[parent][v] = true;
    return this;
  }

  #removeFromParentsChildList(v) {
    delete this.#children[this.#parent[v]][v];
  }

  /**
   * Gets parent node for node v.
   * Complexity: O(1).
   */
  parent(v) {
    if (this.#isCompound) {
      var parent = this.#parent[v];
      if (parent !== GRAPH_NODE) {
        return parent;
      }
    }
  }

  /**
   * Gets list of direct children of node v.
   * Complexity: O(1).
   */
  children(v = GRAPH_NODE) {
    if (this.#isCompound) {
      var children = this.#children[v];
      if (children) {
        return Object.keys(children);
      }
    } else if (v === GRAPH_NODE) {
      return this.nodes();
    } else if (this.hasNode(v)) {
      return [];
    }
  }

  /**
   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  predecessors(v) {
    var predsV = this.#preds[v];
    if (predsV) {
      return Object.keys(predsV);
    }
  }

  /**
   * Return all nodes that are successors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  successors(v) {
    var sucsV = this.#sucs[v];
    if (sucsV) {
      return Object.keys(sucsV);
    }
  }

  /**
   * Return all nodes that are predecessors or successors of the specified node or undefined if
   * node v is not in the graph.
   * Complexity: O(|V|).
   */
  neighbors(v) {
    var preds = this.predecessors(v);
    if (preds) {
      const union = new Set(preds);
      for (var succ of this.successors(v)) {
        union.add(succ);
      }

      return Array.from(union.values());
    }
  }

  isLeaf(v) {
    var neighbors;
    if (this.isDirected()) {
      neighbors = this.successors(v);
    } else {
      neighbors = this.neighbors(v);
    }
    return neighbors.length === 0;
  }

  /**
   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
   * are also removed. In case of compound graph, if parent is rejected by filter,
   * than all its children are rejected too.
   * Average-case complexity: O(|E|+|V|).
   */
  filterNodes(filter) {
    var copy = new this.constructor({
      directed: this.#isDirected,
      multigraph: this.#isMultigraph,
      compound: this.#isCompound
    });

    copy.setGraph(this.graph());

    var self = this;
    Object.entries(this.#nodes).forEach(function([v, value]) {
      if (filter(v)) {
        copy.setNode(v, value);
      }
    });

    Object.values(this.#edgeObjs).forEach(function(e) {
      if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
        copy.setEdge(e, self.edge(e));
      }
    });

    var parents = {};
    function findParent(v) {
      var parent = self.parent(v);
      if (parent === undefined || copy.hasNode(parent)) {
        parents[v] = parent;
        return parent;
      } else if (parent in parents) {
        return parents[parent];
      } else {
        return findParent(parent);
      }
    }

    if (this.#isCompound) {
      copy.nodes().forEach(v => copy.setParent(v, findParent(v)));
    }

    return copy;
  }

  /* === Edge functions ========== */

  /**
   * Sets the default edge label or factory function. This label will be
   * assigned as default label in case if no label was specified while setting
   * an edge or this function will be invoked each time when setting an edge
   * with no label specified and returned value * will be used as a label for edge.
   * Complexity: O(1).
   */
  setDefaultEdgeLabel(newDefault) {
    this.#defaultEdgeLabelFn = newDefault;
    if (typeof newDefault !== 'function') {
      this.#defaultEdgeLabelFn = () => newDefault;
    }

    return this;
  }

  /**
   * Gets the number of edges in the graph.
   * Complexity: O(1).
   */
  edgeCount() {
    return this.#edgeCount;
  }

  /**
   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
   * Complexity: O(|E|).
   */
  edges() {
    return Object.values(this.#edgeObjs);
  }

  /**
   * Establish an edges path over the nodes in nodes list. If some edge is already
   * exists, it will update its label, otherwise it will create an edge between pair
   * of nodes with label provided or default label if no label provided.
   * Complexity: O(|nodes|).
   */
  setPath(vs, value) {
    var self = this;
    var args = arguments;
    vs.reduce(function(v, w) {
      if (args.length > 1) {
        self.setEdge(v, w, value);
      } else {
        self.setEdge(v, w);
      }
      return w;
    });
    return this;
  }

  /**
   * Creates or updates the label for the edge (v, w) with the optionally supplied
   * name. If label is supplied it is set as the value for the edge. If label is not
   * supplied and the edge was created by this call then the default edge label will
   * be assigned. The name parameter is only useful with multigraphs.
   */
  setEdge() {
    var v, w, name, value;
    var valueSpecified = false;
    var arg0 = arguments[0];

    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
      v = arg0.v;
      w = arg0.w;
      name = arg0.name;
      if (arguments.length === 2) {
        value = arguments[1];
        valueSpecified = true;
      }
    } else {
      v = arg0;
      w = arguments[1];
      name = arguments[3];
      if (arguments.length > 2) {
        value = arguments[2];
        valueSpecified = true;
      }
    }

    v = "" + v;
    w = "" + w;
    if (name !== undefined) {
      name = "" + name;
    }

    var e = edgeArgsToId(this.#isDirected, v, w, name);
    if (this.#edgeLabels.hasOwnProperty(e)) {
      if (valueSpecified) {
        this.#edgeLabels[e] = value;
      }
      return this;
    }

    if (name !== undefined && !this.#isMultigraph) {
      throw new Error("Cannot set a named edge when isMultigraph = false");
    }

    // It didn't exist, so we need to create it.
    // First ensure the nodes exist.
    this.setNode(v);
    this.setNode(w);

    this.#edgeLabels[e] = valueSpecified ? value : this.#defaultEdgeLabelFn(v, w, name);

    var edgeObj = edgeArgsToObj(this.#isDirected, v, w, name);
    // Ensure we add undirected edges in a consistent way.
    v = edgeObj.v;
    w = edgeObj.w;

    Object.freeze(edgeObj);
    this.#edgeObjs[e] = edgeObj;
    incrementOrInitEntry(this.#preds[w], v);
    incrementOrInitEntry(this.#sucs[v], w);
    this.#in[w][e] = edgeObj;
    this.#out[v][e] = edgeObj;
    this.#edgeCount++;
    return this;
  }

  /**
   * Gets the label for the specified edge.
   * Complexity: O(1).
   */
  edge(v, w, name) {
    var e = (arguments.length === 1
      ? edgeObjToId(this.#isDirected, arguments[0])
      : edgeArgsToId(this.#isDirected, v, w, name));
    return this.#edgeLabels[e];
  }

  /**
   * Gets the label for the specified edge and converts it to an object.
   * Complexity: O(1)
   */
  edgeAsObj() {
    const edge = this.edge(...arguments);
    if (typeof edge !== "object") {
      return {label: edge};
    }

    return edge;
  }

  /**
   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
   * Complexity: O(1).
   */
  hasEdge(v, w, name) {
    var e = (arguments.length === 1
      ? edgeObjToId(this.#isDirected, arguments[0])
      : edgeArgsToId(this.#isDirected, v, w, name));
    return this.#edgeLabels.hasOwnProperty(e);
  }

  /**
   * Removes the specified edge from the graph. No subgraphs are considered.
   * Complexity: O(1).
   */
  removeEdge(v, w, name) {
    var e = (arguments.length === 1
      ? edgeObjToId(this.#isDirected, arguments[0])
      : edgeArgsToId(this.#isDirected, v, w, name));
    var edge = this.#edgeObjs[e];
    if (edge) {
      v = edge.v;
      w = edge.w;
      delete this.#edgeLabels[e];
      delete this.#edgeObjs[e];
      decrementOrRemoveEntry(this.#preds[w], v);
      decrementOrRemoveEntry(this.#sucs[v], w);
      delete this.#in[w][e];
      delete this.#out[v][e];
      this.#edgeCount--;
    }
    return this;
  }

  /**
   * Return all edges that point to the node v. Optionally filters those edges down to just those
   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  inEdges(v, u) {
    var inV = this.#in[v];
    if (inV) {
      var edges = Object.values(inV);
      if (!u) {
        return edges;
      }
      return edges.filter(edge => edge.v === u);
    }
  }

  /**
   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  outEdges(v, w) {
    var outV = this.#out[v];
    if (outV) {
      var edges = Object.values(outV);
      if (!w) {
        return edges;
      }
      return edges.filter(edge => edge.w === w);
    }
  }

  /**
   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
   * down to just those between nodes v and w regardless of direction.
   * Complexity: O(|E|).
   */
  nodeEdges(v, w) {
    var inEdges = this.inEdges(v, w);
    if (inEdges) {
      return inEdges.concat(this.outEdges(v, w));
    }
  }
}

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (name === undefined ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

module.exports = Graph;

},{}],45:[function(require,module,exports){
// Includes only the "core" of graphlib
module.exports = {
  Graph: require("./graph"),
  version: require("./version")
};

},{"./graph":44,"./version":47}],46:[function(require,module,exports){
var Graph = require("./graph");

module.exports = {
  write: write,
  read: read
};

/**
 * Creates a JSON representation of the graph that can be serialized to a string with
 * JSON.stringify. The graph can later be restored using json.read.
 */
function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };

  if (g.graph() !== undefined) {
    json.value = structuredClone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return g.nodes().map(function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (nodeValue !== undefined) {
      node.value = nodeValue;
    }
    if (parent !== undefined) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return g.edges().map(function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (e.name !== undefined) {
      edge.name = e.name;
    }
    if (edgeValue !== undefined) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

/**
 * Takes JSON as input and returns the graph representation.
 *
 * @example
 * var g2 = graphlib.json.read(JSON.parse(str));
 * g2.nodes();
 * // ['a', 'b']
 * g2.edges()
 * // [ { v: 'a', w: 'b' } ]
 */
function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  json.nodes.forEach(function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  json.edges.forEach(function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}

},{"./graph":44}],47:[function(require,module,exports){
module.exports = '2.2.1';

},{}]},{},[1])(1)
});

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE={})}(this,(function(t){"use strict";const e="134",n=100,i=300,r=301,s=302,a=303,o=304,l=306,c=307,h=1e3,u=1001,d=1002,p=1003,m=1004,f=1005,g=1006,v=1007,y=1008,x=1009,_=1012,M=1014,b=1015,w=1016,S=1020,T=1022,E=1023,A=1026,L=1027,R=33776,C=33777,P=33778,I=33779,D=35840,N=35841,z=35842,B=35843,F=37492,O=37496,U=2300,H=2301,G=2302,k=2400,V=2401,W=2402,j=2500,q=2501,X=3e3,Y=3001,J=3007,Z=3002,Q=3004,K=3005,$=3006,tt=7680,et=35044,nt=35048,it="300 es";class rt{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}let st=1234567;const at=Math.PI/180,ot=180/Math.PI,lt=[];for(let t=0;t<256;t++)lt[t]=(t<16?"0":"")+t.toString(16);const ct="undefined"!=typeof crypto&&"randomUUID"in crypto;function ht(){if(ct)return crypto.randomUUID().toUpperCase();const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(lt[255&t]+lt[t>>8&255]+lt[t>>16&255]+lt[t>>24&255]+"-"+lt[255&e]+lt[e>>8&255]+"-"+lt[e>>16&15|64]+lt[e>>24&255]+"-"+lt[63&n|128]+lt[n>>8&255]+"-"+lt[n>>16&255]+lt[n>>24&255]+lt[255&i]+lt[i>>8&255]+lt[i>>16&255]+lt[i>>24&255]).toUpperCase()}function ut(t,e,n){return Math.max(e,Math.min(n,t))}function dt(t,e){return(t%e+e)%e}function pt(t,e,n){return(1-n)*t+n*e}function mt(t){return 0==(t&t-1)&&0!==t}function ft(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function gt(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var vt=Object.freeze({__proto__:null,DEG2RAD:at,RAD2DEG:ot,generateUUID:ht,clamp:ut,euclideanModulo:dt,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:pt,damp:function(t,e,n,i){return pt(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(dt(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(st=t%2147483647),st=16807*st%2147483647,(st-1)/2147483646},degToRad:function(t){return t*at},radToDeg:function(t){return t*ot},isPowerOfTwo:mt,ceilPowerOfTwo:ft,floorPowerOfTwo:gt,setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),c=s((e+i)/2),h=a((e+i)/2),u=s((e-i)/2),d=a((e-i)/2),p=s((i-e)/2),m=a((i-e)/2);switch(r){case"XYX":t.set(o*h,l*u,l*d,o*c);break;case"YZY":t.set(l*d,o*h,l*u,o*c);break;case"ZXZ":t.set(l*u,l*d,o*h,o*c);break;case"XZX":t.set(o*h,l*m,l*p,o*c);break;case"YXY":t.set(l*p,o*h,l*m,o*c);break;case"ZYZ":t.set(l*m,l*p,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}});class yt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}yt.prototype.isVector2=!0;class xt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=a,c[3]=e,c[4]=r,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],m=i[0],f=i[3],g=i[6],v=i[1],y=i[4],x=i[7],_=i[2],M=i[5],b=i[8];return r[0]=s*m+a*v+o*_,r[3]=s*f+a*y+o*M,r[6]=s*g+a*x+o*b,r[1]=l*m+c*v+h*_,r[4]=l*f+c*y+h*M,r[7]=l*g+c*x+h*b,r[2]=u*m+d*v+p*_,r[5]=u*f+d*y+p*M,r[8]=u*g+d*x+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8];return e*s*c-e*a*l-n*r*c+n*a*o+i*r*l-i*s*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=c*s-a*l,u=a*o-c*r,d=l*r-s*o,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=h*m,t[1]=(i*l-c*n)*m,t[2]=(a*n-i*s)*m,t[3]=u*m,t[4]=(c*e-i*o)*m,t[5]=(i*r-a*e)*m,t[6]=d*m,t[7]=(n*o-l*e)*m,t[8]=(s*e-n*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],a=i[6],o=i[1],l=i[4],c=i[7];return i[0]=e*r+n*o,i[3]=e*s+n*l,i[6]=e*a+n*c,i[1]=-n*r+e*o,i[4]=-n*s+e*l,i[7]=-n*a+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}function _t(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}xt.prototype.isMatrix3=!0;const Mt={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function bt(t,e){return new Mt[t](e)}function wt(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function St(t,e=0){let n=3735928559^e,i=1103547991^e;for(let e,r=0;r<t.length;r++)e=t.charCodeAt(r),n=Math.imul(n^e,2654435761),i=Math.imul(i^e,1597334677);return n=Math.imul(n^n>>>16,2246822507)^Math.imul(i^i>>>13,3266489909),i=Math.imul(i^i>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),4294967296*(2097151&i)+(n>>>0)}let Tt;class Et{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Tt&&(Tt=wt("canvas")),Tt.width=t.width,Tt.height=t.height;const n=Tt.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Tt}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let At=0;class Lt extends rt{constructor(t=Lt.DEFAULT_IMAGE,e=Lt.DEFAULT_MAPPING,n=1001,i=1001,r=1006,s=1008,a=1023,o=1009,l=1,c=3e3){super(),Object.defineProperty(this,"id",{value:At++}),this.uuid=ht(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new yt(0,0),this.repeat=new yt(1,1),this.center=new yt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=ht()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)i[t].isDataTexture?e.push(Rt(i[t].image)):e.push(Rt(i[t]))}else e=Rt(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==i)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case h:t.x=t.x-Math.floor(t.x);break;case u:t.x=t.x<0?0:1;break;case d:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case h:t.y=t.y-Math.floor(t.y);break;case u:t.y=t.y<0?0:1;break;case d:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function Rt(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Et.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Lt.DEFAULT_IMAGE=void 0,Lt.DEFAULT_MAPPING=i,Lt.prototype.isTexture=!0;class Ct{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,a=.1,o=t.elements,l=o[0],c=o[4],h=o[8],u=o[1],d=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(c-u)<s&&Math.abs(h-m)<s&&Math.abs(p-f)<s){if(Math.abs(c+u)<a&&Math.abs(h+m)<a&&Math.abs(p+f)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,y=(c+u)/4,x=(h+m)/4,_=(p+f)/4;return t>o&&t>v?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=y/n,r=x/n):o>v?o<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(o),n=y/i,r=_/i):v<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(v),n=x/r,i=_/r),this.set(n,i,r,e),this}let v=Math.sqrt((f-p)*(f-p)+(h-m)*(h-m)+(u-c)*(u-c));return Math.abs(v)<.001&&(v=1),this.x=(f-p)/v,this.y=(h-m)/v,this.z=(u-c)/v,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Ct.prototype.isVector4=!0;class Pt extends rt{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new Ct(0,0,t,e),this.scissorTest=!1,this.viewport=new Ct(0,0,t,e),this.texture=new Lt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:g,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Pt.prototype.isWebGLRenderTarget=!0;class It extends Pt{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}It.prototype.isWebGLMultipleRenderTargets=!0;class Dt extends Pt{constructor(t,e,n){super(t,e,n),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}Dt.prototype.isWebGLMultisampleRenderTarget=!0;class Nt{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,s,a){let o=n[i+0],l=n[i+1],c=n[i+2],h=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],m=r[s+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=c,void(t[e+3]=h);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(h!==m||o!==u||l!==d||c!==p){let t=1-a;const e=o*u+l*d+c*p+h*m,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,a=Math.sin(a*s)/r}const r=a*n;if(o=o*t+u*r,l=l*t+d*r,c=c*t+p*r,h=h*t+m*r,t===1-a){const t=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=t,l*=t,c*=t,h*=t}}t[e]=o,t[e+1]=l,t[e+2]=c,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,i,r,s){const a=n[i],o=n[i+1],l=n[i+2],c=n[i+3],h=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=a*p+c*h+o*d-l*u,t[e+1]=o*p+c*u+l*h-a*d,t[e+2]=l*p+c*d+a*u-o*h,t[e+3]=c*p-a*h-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(n/2),c=a(i/2),h=a(r/2),u=o(n/2),d=o(i/2),p=o(r/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],a=e[5],o=e[9],l=e[2],c=e[6],h=e[10],u=n+a+h;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-o)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>a&&n>h){const t=2*Math.sqrt(1+n-a-h);this._w=(c-o)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(a>h){const t=2*Math.sqrt(1+a-n-h);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(o+c)/t}else{const t=2*Math.sqrt(1+h-n-a);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(o+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ut(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,a=e._x,o=e._y,l=e._z,c=e._w;return this._x=n*c+s*a+i*l-r*o,this._y=i*c+s*o+r*a-n*l,this._z=r*c+s*l+n*o-i*a,this._w=s*c-n*a-i*o-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let a=s*t._w+n*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),h=Math.sin((1-e)*c)/l,u=Math.sin(e*c)/l;return this._w=s*h+this._w*u,this._x=n*h+this._x*u,this._y=i*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(r),n*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Nt.prototype.isQuaternion=!0;class zt{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Ft.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Ft.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,a=t.z,o=t.w,l=o*e+s*i-a*n,c=o*n+a*e-r*i,h=o*i+r*n-s*e,u=-r*e-s*n-a*i;return this.x=l*o+u*-r+c*-a-h*-s,this.y=c*o+u*-s+h*-r-l*-a,this.z=h*o+u*-a+l*-s-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,a=e.y,o=e.z;return this.x=i*o-r*a,this.y=r*s-n*o,this.z=n*a-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Bt.copy(this).projectOnVector(t),this.sub(Bt)}reflect(t){return this.sub(Bt.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ut(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}zt.prototype.isVector3=!0;const Bt=new zt,Ft=new Nt;class Ot{constructor(t=new zt(1/0,1/0,1/0),e=new zt(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],c=t[o+1],h=t[o+2];l<e&&(e=l),c<n&&(n=c),h<i&&(i=h),l>r&&(r=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),c=t.getY(o),h=t.getZ(o);l<e&&(e=l),c<n&&(n=c),h<i&&(i=h),l>r&&(r=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(e,n,i),this.max.set(r,s,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Ht.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),Gt.copy(e.boundingBox),Gt.applyMatrix4(t.matrixWorld),this.union(Gt));const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Ht),Ht.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Yt),Jt.subVectors(this.max,Yt),kt.subVectors(t.a,Yt),Vt.subVectors(t.b,Yt),Wt.subVectors(t.c,Yt),jt.subVectors(Vt,kt),qt.subVectors(Wt,Vt),Xt.subVectors(kt,Wt);let e=[0,-jt.z,jt.y,0,-qt.z,qt.y,0,-Xt.z,Xt.y,jt.z,0,-jt.x,qt.z,0,-qt.x,Xt.z,0,-Xt.x,-jt.y,jt.x,0,-qt.y,qt.x,0,-Xt.y,Xt.x,0];return!!Kt(e,kt,Vt,Wt,Jt)&&(e=[1,0,0,0,1,0,0,0,1],!!Kt(e,kt,Vt,Wt,Jt)&&(Zt.crossVectors(jt,qt),e=[Zt.x,Zt.y,Zt.z],Kt(e,kt,Vt,Wt,Jt)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Ht.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(Ht).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(Ut[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Ut[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Ut[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Ut[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Ut[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Ut[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Ut[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Ut[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Ut)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ot.prototype.isBox3=!0;const Ut=[new zt,new zt,new zt,new zt,new zt,new zt,new zt,new zt],Ht=new zt,Gt=new Ot,kt=new zt,Vt=new zt,Wt=new zt,jt=new zt,qt=new zt,Xt=new zt,Yt=new zt,Jt=new zt,Zt=new zt,Qt=new zt;function Kt(t,e,n,i,r){for(let s=0,a=t.length-3;s<=a;s+=3){Qt.fromArray(t,s);const a=r.x*Math.abs(Qt.x)+r.y*Math.abs(Qt.y)+r.z*Math.abs(Qt.z),o=e.dot(Qt),l=n.dot(Qt),c=i.dot(Qt);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return!1}return!0}const $t=new Ot,te=new zt,ee=new zt,ne=new zt;class ie{constructor(t=new zt,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):$t.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){ne.subVectors(t,this.center);const e=ne.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(ne.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return ee.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(te.copy(t.center).add(ee)),this.expandByPoint(te.copy(t.center).sub(ee)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const re=new zt,se=new zt,ae=new zt,oe=new zt,le=new zt,ce=new zt,he=new zt;class ue{constructor(t=new zt,e=new zt(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,re)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=re.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(re.copy(this.direction).multiplyScalar(e).add(this.origin),re.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){se.copy(t).add(e).multiplyScalar(.5),ae.copy(e).sub(t).normalize(),oe.copy(this.origin).sub(se);const r=.5*t.distanceTo(e),s=-this.direction.dot(ae),a=oe.dot(this.direction),o=-oe.dot(ae),l=oe.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*o-a,u=s*a-o,p=r*c,h>=0)if(u>=-p)if(u<=p){const t=1/c;h*=t,u*=t,d=h*(h+s*u+2*a)+u*(s*h+u+2*o)+l}else u=r,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u=-r,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u<=-p?(h=Math.max(0,-(-s*r+a)),u=h>0?-r:Math.min(Math.max(-r,-o),r),d=-h*h+u*(u+2*o)+l):u<=p?(h=0,u=Math.min(Math.max(-r,-o),r),d=u*(u+2*o)+l):(h=Math.max(0,-(s*r+a)),u=h>0?r:Math.min(Math.max(-r,-o),r),d=-h*h+u*(u+2*o)+l);else u=s>0?-r:r,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),i&&i.copy(ae).multiplyScalar(u).add(se),d}intersectSphere(t,e){re.subVectors(t.center,this.origin);const n=re.dot(this.direction),i=re.dot(re)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),c>=0?(r=(t.min.y-u.y)*c,s=(t.max.y-u.y)*c):(r=(t.max.y-u.y)*c,s=(t.min.y-u.y)*c),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),h>=0?(a=(t.min.z-u.z)*h,o=(t.max.z-u.z)*h):(a=(t.max.z-u.z)*h,o=(t.min.z-u.z)*h),n>o||a>i?null:((a>n||n!=n)&&(n=a),(o<i||i!=i)&&(i=o),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,re)}intersectTriangle(t,e,n,i,r){le.subVectors(e,t),ce.subVectors(n,t),he.crossVectors(le,ce);let s,a=this.direction.dot(he);if(a>0){if(i)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}oe.subVectors(this.origin,t);const o=s*this.direction.dot(ce.crossVectors(oe,ce));if(o<0)return null;const l=s*this.direction.dot(le.cross(oe));if(l<0)return null;if(o+l>a)return null;const c=-s*oe.dot(he);return c<0?null:this.at(c/a,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class de{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,a,o,l,c,h,u,d,p,m,f){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new de).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/pe.setFromMatrixColumn(t,0).length(),r=1/pe.setFromMatrixColumn(t,1).length(),s=1/pe.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(i),l=Math.sin(i),c=Math.cos(r),h=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*h,i=a*c,r=a*h;e[0]=o*c,e[4]=-o*h,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-a*o,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*o}else if("YXZ"===t.order){const t=o*c,n=o*h,i=l*c,r=l*h;e[0]=t+r*a,e[4]=i*a-n,e[8]=s*l,e[1]=s*h,e[5]=s*c,e[9]=-a,e[2]=n*a-i,e[6]=r+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*c,n=o*h,i=l*c,r=l*h;e[0]=t-r*a,e[4]=-s*h,e[8]=i+n*a,e[1]=n+i*a,e[5]=s*c,e[9]=r-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*c,n=s*h,i=a*c,r=a*h;e[0]=o*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=o*h,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*c,e[4]=r-t*h,e[8]=i*h+n,e[1]=h,e[5]=s*c,e[9]=-a*c,e[2]=-l*c,e[6]=n*h+i,e[10]=t-r*h}else if("XZY"===t.order){const t=s*o,n=s*l,i=a*o,r=a*l;e[0]=o*c,e[4]=-h,e[8]=l*c,e[1]=t*h+r,e[5]=s*c,e[9]=n*h-i,e[2]=i*h-n,e[6]=a*c,e[10]=r*h+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(fe,t,ge)}lookAt(t,e,n){const i=this.elements;return xe.subVectors(t,e),0===xe.lengthSq()&&(xe.z=1),xe.normalize(),ve.crossVectors(n,xe),0===ve.lengthSq()&&(1===Math.abs(n.z)?xe.x+=1e-4:xe.z+=1e-4,xe.normalize(),ve.crossVectors(n,xe)),ve.normalize(),ye.crossVectors(xe,ve),i[0]=ve.x,i[4]=ye.x,i[8]=xe.x,i[1]=ve.y,i[5]=ye.y,i[9]=xe.y,i[2]=ve.z,i[6]=ye.z,i[10]=xe.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],m=n[6],f=n[10],g=n[14],v=n[3],y=n[7],x=n[11],_=n[15],M=i[0],b=i[4],w=i[8],S=i[12],T=i[1],E=i[5],A=i[9],L=i[13],R=i[2],C=i[6],P=i[10],I=i[14],D=i[3],N=i[7],z=i[11],B=i[15];return r[0]=s*M+a*T+o*R+l*D,r[4]=s*b+a*E+o*C+l*N,r[8]=s*w+a*A+o*P+l*z,r[12]=s*S+a*L+o*I+l*B,r[1]=c*M+h*T+u*R+d*D,r[5]=c*b+h*E+u*C+d*N,r[9]=c*w+h*A+u*P+d*z,r[13]=c*S+h*L+u*I+d*B,r[2]=p*M+m*T+f*R+g*D,r[6]=p*b+m*E+f*C+g*N,r[10]=p*w+m*A+f*P+g*z,r[14]=p*S+m*L+f*I+g*B,r[3]=v*M+y*T+x*R+_*D,r[7]=v*b+y*E+x*C+_*N,r[11]=v*w+y*A+x*P+_*z,r[15]=v*S+y*L+x*I+_*B,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],a=t[5],o=t[9],l=t[13],c=t[2],h=t[6],u=t[10],d=t[14];return t[3]*(+r*o*h-i*l*h-r*a*u+n*l*u+i*a*d-n*o*d)+t[7]*(+e*o*d-e*l*u+r*s*u-i*s*d+i*l*c-r*o*c)+t[11]*(+e*l*h-e*a*d-r*s*h+n*s*d+r*a*c-n*l*c)+t[15]*(-i*a*c-e*o*h+e*a*u+i*s*h-n*s*u+n*o*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],p=t[12],m=t[13],f=t[14],g=t[15],v=h*f*l-m*u*l+m*o*d-a*f*d-h*o*g+a*u*g,y=p*u*l-c*f*l-p*o*d+s*f*d+c*o*g-s*u*g,x=c*m*l-p*h*l+p*a*d-s*m*d-c*a*g+s*h*g,_=p*h*o-c*m*o-p*a*u+s*m*u+c*a*f-s*h*f,M=e*v+n*y+i*x+r*_;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/M;return t[0]=v*b,t[1]=(m*u*r-h*f*r-m*i*d+n*f*d+h*i*g-n*u*g)*b,t[2]=(a*f*r-m*o*r+m*i*l-n*f*l-a*i*g+n*o*g)*b,t[3]=(h*o*r-a*u*r-h*i*l+n*u*l+a*i*d-n*o*d)*b,t[4]=y*b,t[5]=(c*f*r-p*u*r+p*i*d-e*f*d-c*i*g+e*u*g)*b,t[6]=(p*o*r-s*f*r-p*i*l+e*f*l+s*i*g-e*o*g)*b,t[7]=(s*u*r-c*o*r+c*i*l-e*u*l-s*i*d+e*o*d)*b,t[8]=x*b,t[9]=(p*h*r-c*m*r-p*n*d+e*m*d+c*n*g-e*h*g)*b,t[10]=(s*m*r-p*a*r+p*n*l-e*m*l-s*n*g+e*a*g)*b,t[11]=(c*a*r-s*h*r-c*n*l+e*h*l+s*n*d-e*a*d)*b,t[12]=_*b,t[13]=(c*m*i-p*h*i+p*n*u-e*m*u-c*n*f+e*h*f)*b,t[14]=(p*a*i-s*m*i-p*n*o+e*m*o+s*n*f-e*a*f)*b,t[15]=(s*h*i-c*a*i+c*n*o-e*h*o-s*n*u+e*a*u)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,a=t.y,o=t.z,l=r*s,c=r*a;return this.set(l*s+n,l*a-i*o,l*o+i*a,0,l*a+i*o,c*a+n,c*o-i*s,0,l*o-i*a,c*o+i*s,r*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,a=e._z,o=e._w,l=r+r,c=s+s,h=a+a,u=r*l,d=r*c,p=r*h,m=s*c,f=s*h,g=a*h,v=o*l,y=o*c,x=o*h,_=n.x,M=n.y,b=n.z;return i[0]=(1-(m+g))*_,i[1]=(d+x)*_,i[2]=(p-y)*_,i[3]=0,i[4]=(d-x)*M,i[5]=(1-(u+g))*M,i[6]=(f+v)*M,i[7]=0,i[8]=(p+y)*b,i[9]=(f-v)*b,i[10]=(1-(u+m))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=pe.set(i[0],i[1],i[2]).length();const s=pe.set(i[4],i[5],i[6]).length(),a=pe.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],me.copy(this);const o=1/r,l=1/s,c=1/a;return me.elements[0]*=o,me.elements[1]*=o,me.elements[2]*=o,me.elements[4]*=l,me.elements[5]*=l,me.elements[6]*=l,me.elements[8]*=c,me.elements[9]*=c,me.elements[10]*=c,e.setFromRotationMatrix(me),n.x=r,n.y=s,n.z=a,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*r/(e-t),l=2*r/(n-i),c=(e+t)/(e-t),h=(n+i)/(n-i),u=-(s+r)/(s-r),d=-2*s*r/(s-r);return a[0]=o,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,s){const a=this.elements,o=1/(e-t),l=1/(n-i),c=1/(s-r),h=(e+t)*o,u=(n+i)*l,d=(s+r)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}de.prototype.isMatrix4=!0;const pe=new zt,me=new de,fe=new zt(0,0,0),ge=new zt(1,1,1),ve=new zt,ye=new zt,xe=new zt,_e=new de,Me=new Nt;class be{constructor(t=0,e=0,n=0,i=be.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],a=i[8],o=i[1],l=i[5],c=i[9],h=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(ut(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-ut(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(ut(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-ut(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(ut(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-ut(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return _e.makeRotationFromQuaternion(t),this.setFromRotationMatrix(_e,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Me.setFromEuler(this),this.setFromQuaternion(Me,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new zt(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}be.prototype.isEuler=!0,be.DefaultOrder="XYZ",be.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class we{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let Se=0;const Te=new zt,Ee=new Nt,Ae=new de,Le=new zt,Re=new zt,Ce=new zt,Pe=new Nt,Ie=new zt(1,0,0),De=new zt(0,1,0),Ne=new zt(0,0,1),ze={type:"added"},Be={type:"removed"};class Fe extends rt{constructor(){super(),Object.defineProperty(this,"id",{value:Se++}),this.uuid=ht(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Fe.DefaultUp.clone();const t=new zt,e=new be,n=new Nt,i=new zt(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new de},normalMatrix:{value:new xt}}),this.matrix=new de,this.matrixWorld=new de,this.matrixAutoUpdate=Fe.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new we,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Ee.setFromAxisAngle(t,e),this.quaternion.multiply(Ee),this}rotateOnWorldAxis(t,e){return Ee.setFromAxisAngle(t,e),this.quaternion.premultiply(Ee),this}rotateX(t){return this.rotateOnAxis(Ie,t)}rotateY(t){return this.rotateOnAxis(De,t)}rotateZ(t){return this.rotateOnAxis(Ne,t)}translateOnAxis(t,e){return Te.copy(t).applyQuaternion(this.quaternion),this.position.add(Te.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Ie,t)}translateY(t){return this.translateOnAxis(De,t)}translateZ(t){return this.translateOnAxis(Ne,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Ae.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Le.copy(t):Le.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Re.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ae.lookAt(Re,Le,this.up):Ae.lookAt(Le,Re,this.up),this.quaternion.setFromRotationMatrix(Ae),i&&(Ae.extractRotation(i.matrixWorld),Ee.setFromRotationMatrix(Ae),this.quaternion.premultiply(Ee.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(ze)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Be)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Be)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Ae.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),Ae.multiply(t.parent.matrixWorld)),t.applyMatrix4(Ae),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Re,t,Ce),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Re,Pe,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}Fe.DefaultUp=new zt(0,1,0),Fe.DefaultMatrixAutoUpdate=!0,Fe.prototype.isObject3D=!0;const Oe=new zt,Ue=new zt,He=new zt,Ge=new zt,ke=new zt,Ve=new zt,We=new zt,je=new zt,qe=new zt,Xe=new zt;class Ye{constructor(t=new zt,e=new zt,n=new zt){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Oe.subVectors(t,e),i.cross(Oe);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){Oe.subVectors(i,e),Ue.subVectors(n,e),He.subVectors(t,e);const s=Oe.dot(Oe),a=Oe.dot(Ue),o=Oe.dot(He),l=Ue.dot(Ue),c=Ue.dot(He),h=s*l-a*a;if(0===h)return r.set(-2,-1,-1);const u=1/h,d=(l*o-a*c)*u,p=(s*c-a*o)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Ge),Ge.x>=0&&Ge.y>=0&&Ge.x+Ge.y<=1}static getUV(t,e,n,i,r,s,a,o){return this.getBarycoord(t,e,n,i,Ge),o.set(0,0),o.addScaledVector(r,Ge.x),o.addScaledVector(s,Ge.y),o.addScaledVector(a,Ge.z),o}static isFrontFacing(t,e,n,i){return Oe.subVectors(n,e),Ue.subVectors(t,e),Oe.cross(Ue).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Oe.subVectors(this.c,this.b),Ue.subVectors(this.a,this.b),.5*Oe.cross(Ue).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Ye.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Ye.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return Ye.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return Ye.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Ye.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,a;ke.subVectors(i,n),Ve.subVectors(r,n),je.subVectors(t,n);const o=ke.dot(je),l=Ve.dot(je);if(o<=0&&l<=0)return e.copy(n);qe.subVectors(t,i);const c=ke.dot(qe),h=Ve.dot(qe);if(c>=0&&h<=c)return e.copy(i);const u=o*h-c*l;if(u<=0&&o>=0&&c<=0)return s=o/(o-c),e.copy(n).addScaledVector(ke,s);Xe.subVectors(t,r);const d=ke.dot(Xe),p=Ve.dot(Xe);if(p>=0&&d<=p)return e.copy(r);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(Ve,a);const f=c*p-d*h;if(f<=0&&h-c>=0&&d-p>=0)return We.subVectors(r,i),a=(h-c)/(h-c+(d-p)),e.copy(i).addScaledVector(We,a);const g=1/(f+m+u);return s=m*g,a=u*g,e.copy(n).addScaledVector(ke,s).addScaledVector(Ve,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Je=0;class Ze extends rt{constructor(){super(),Object.defineProperty(this,"id",{value:Je++}),this.uuid=ht(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=E,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=n,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=tt,this.stencilZFail=tt,this.stencilZPass=tt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==E&&(n.format=this.format),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}Ze.prototype.isMaterial=!0;const Qe={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ke={h:0,s:0,l:0},$e={h:0,s:0,l:0};function tn(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function en(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function nn(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class rn{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=dt(t,1),e=ut(e,0,1),n=ut(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=tn(r,i,t+1/3),this.g=tn(r,i,t),this.b=tn(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[1],r=n[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Qe[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=en(t.r),this.g=en(t.g),this.b=en(t.b),this}copyLinearToSRGB(t){return this.r=nn(t.r),this.g=nn(t.g),this.b=nn(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let a,o;const l=(s+r)/2;if(s===r)a=0,o=0;else{const t=r-s;switch(o=l<=.5?t/(r+s):t/(2-r-s),r){case e:a=(n-i)/t+(n<i?6:0);break;case n:a=(i-e)/t+2;break;case i:a=(e-n)/t+4}a/=6}return t.h=a,t.s=o,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Ke),Ke.h+=t,Ke.s+=e,Ke.l+=n,this.setHSL(Ke.h,Ke.s,Ke.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Ke),t.getHSL($e);const n=pt(Ke.h,$e.h,e),i=pt(Ke.s,$e.s,e),r=pt(Ke.l,$e.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}rn.NAMES=Qe,rn.prototype.isColor=!0,rn.prototype.r=1,rn.prototype.g=1,rn.prototype.b=1;class sn extends Ze{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new rn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}sn.prototype.isMeshBasicMaterial=!0;const an=new zt,on=new yt;class ln{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=et,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new rn),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new yt),e[n++]=r.x,e[n++]=r.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new zt),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new Ct),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)on.fromBufferAttribute(this,e),on.applyMatrix3(t),this.setXY(e,on.x,on.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)an.fromBufferAttribute(this,e),an.applyMatrix3(t),this.setXYZ(e,an.x,an.y,an.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)an.x=this.getX(e),an.y=this.getY(e),an.z=this.getZ(e),an.applyMatrix4(t),this.setXYZ(e,an.x,an.y,an.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)an.x=this.getX(e),an.y=this.getY(e),an.z=this.getZ(e),an.applyNormalMatrix(t),this.setXYZ(e,an.x,an.y,an.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)an.x=this.getX(e),an.y=this.getY(e),an.z=this.getZ(e),an.transformDirection(t),this.setXYZ(e,an.x,an.y,an.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==et&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}ln.prototype.isBufferAttribute=!0;class cn extends ln{constructor(t,e,n){super(new Int8Array(t),e,n)}}class hn extends ln{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class un extends ln{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class dn extends ln{constructor(t,e,n){super(new Int16Array(t),e,n)}}class pn extends ln{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class mn extends ln{constructor(t,e,n){super(new Int32Array(t),e,n)}}class fn extends ln{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class gn extends ln{constructor(t,e,n){super(new Uint16Array(t),e,n)}}gn.prototype.isFloat16BufferAttribute=!0;class vn extends ln{constructor(t,e,n){super(new Float32Array(t),e,n)}}class yn extends ln{constructor(t,e,n){super(new Float64Array(t),e,n)}}let xn=0;const _n=new de,Mn=new Fe,bn=new zt,wn=new Ot,Sn=new Ot,Tn=new zt;class En extends rt{constructor(){super(),Object.defineProperty(this,"id",{value:xn++}),this.uuid=ht(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(_t(t)>65535?fn:pn)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new xt).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return _n.makeRotationFromQuaternion(t),this.applyMatrix4(_n),this}rotateX(t){return _n.makeRotationX(t),this.applyMatrix4(_n),this}rotateY(t){return _n.makeRotationY(t),this.applyMatrix4(_n),this}rotateZ(t){return _n.makeRotationZ(t),this.applyMatrix4(_n),this}translate(t,e,n){return _n.makeTranslation(t,e,n),this.applyMatrix4(_n),this}scale(t,e,n){return _n.makeScale(t,e,n),this.applyMatrix4(_n),this}lookAt(t){return Mn.lookAt(t),Mn.updateMatrix(),this.applyMatrix4(Mn.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(bn).negate(),this.translate(bn.x,bn.y,bn.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new vn(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Ot);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new zt(-1/0,-1/0,-1/0),new zt(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];wn.setFromBufferAttribute(n),this.morphTargetsRelative?(Tn.addVectors(this.boundingBox.min,wn.min),this.boundingBox.expandByPoint(Tn),Tn.addVectors(this.boundingBox.max,wn.max),this.boundingBox.expandByPoint(Tn)):(this.boundingBox.expandByPoint(wn.min),this.boundingBox.expandByPoint(wn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new ie);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new zt,1/0);if(t){const n=this.boundingSphere.center;if(wn.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Sn.setFromBufferAttribute(n),this.morphTargetsRelative?(Tn.addVectors(wn.min,Sn.min),wn.expandByPoint(Tn),Tn.addVectors(wn.max,Sn.max),wn.expandByPoint(Tn)):(wn.expandByPoint(Sn.min),wn.expandByPoint(Sn.max))}wn.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)Tn.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(Tn));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)Tn.fromBufferAttribute(s,e),a&&(bn.fromBufferAttribute(t,e),Tn.add(bn)),i=Math.max(i,n.distanceToSquared(Tn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,a=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new ln(new Float32Array(4*a),4));const o=e.tangent.array,l=[],c=[];for(let t=0;t<a;t++)l[t]=new zt,c[t]=new zt;const h=new zt,u=new zt,d=new zt,p=new yt,m=new yt,f=new yt,g=new zt,v=new zt;function y(t,e,n){h.fromArray(i,3*t),u.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),m.fromArray(s,2*e),f.fromArray(s,2*n),u.sub(h),d.sub(h),m.sub(p),f.sub(p);const r=1/(m.x*f.y-f.x*m.y);isFinite(r)&&(g.copy(u).multiplyScalar(f.y).addScaledVector(d,-m.y).multiplyScalar(r),v.copy(d).multiplyScalar(m.x).addScaledVector(u,-f.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(v),c[e].add(v),c[n].add(v))}let x=this.groups;0===x.length&&(x=[{start:0,count:n.length}]);for(let t=0,e=x.length;t<e;++t){const e=x[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)y(n[t+0],n[t+1],n[t+2])}const _=new zt,M=new zt,b=new zt,w=new zt;function S(t){b.fromArray(r,3*t),w.copy(b);const e=l[t];_.copy(e),_.sub(b.multiplyScalar(b.dot(e))).normalize(),M.crossVectors(w,e);const n=M.dot(c[t])<0?-1:1;o[4*t]=_.x,o[4*t+1]=_.y,o[4*t+2]=_.z,o[4*t+3]=n}for(let t=0,e=x.length;t<e;++t){const e=x[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)S(n[t+0]),S(n[t+1]),S(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new ln(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new zt,r=new zt,s=new zt,a=new zt,o=new zt,l=new zt,c=new zt,h=new zt;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),m=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,m),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),a.add(c),o.add(c),l.add(c),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],a=s.array,o=s.itemSize*e,l=Math.min(a.length,r.length-o);for(let t=0,e=o;t<l;t++,e++)r[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Tn.fromBufferAttribute(t,e),Tn.normalize(),t.setXYZ(e,Tn.x,Tn.y,Tn.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let a=0,o=0;for(let r=0,l=e.length;r<l;r++){a=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)s[o++]=n[a++]}return new ln(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new En,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],a=r[i];for(let e=0,i=a.length;e<i;e++){const i=t(a[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];s.push(i.toJSON(t.data))}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}En.prototype.isBufferGeometry=!0;const An=new de,Ln=new ue,Rn=new ie,Cn=new zt,Pn=new zt,In=new zt,Dn=new zt,Nn=new zt,zn=new zt,Bn=new zt,Fn=new zt,On=new zt,Un=new yt,Hn=new yt,Gn=new yt,kn=new zt,Vn=new zt;class Wn extends Fe{constructor(t=new En,e=new sn){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Rn.copy(n.boundingSphere),Rn.applyMatrix4(r),!1===t.ray.intersectsSphere(Rn))return;if(An.copy(r).invert(),Ln.copy(t.ray).applyMatrix4(An),null!==n.boundingBox&&!1===Ln.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,h=n.attributes.uv2,u=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=u.length;n<p;n++){const p=u[n],m=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(r.count,Math.min(p.start+p.count,d.start+d.count));n<i;n+=3){const i=r.getX(n),u=r.getX(n+1),d=r.getX(n+2);s=jn(this,m,t,Ln,a,o,l,c,h,i,u,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),u=Math.min(r.count,d.start+d.count);n<u;n+=3){const u=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=jn(this,i,t,Ln,a,o,l,c,h,u,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}else if(void 0!==a)if(Array.isArray(i))for(let n=0,r=u.length;n<r;n++){const r=u[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(a.count,Math.min(r.start+r.count,d.start+d.count));n<i;n+=3){s=jn(this,p,t,Ln,a,o,l,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),r=Math.min(a.count,d.start+d.count);n<r;n+=3){s=jn(this,i,t,Ln,a,o,l,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function jn(t,e,n,i,r,s,a,o,l,c,h,u){Cn.fromBufferAttribute(r,c),Pn.fromBufferAttribute(r,h),In.fromBufferAttribute(r,u);const d=t.morphTargetInfluences;if(s&&d){Bn.set(0,0,0),Fn.set(0,0,0),On.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(Dn.fromBufferAttribute(n,c),Nn.fromBufferAttribute(n,h),zn.fromBufferAttribute(n,u),a?(Bn.addScaledVector(Dn,e),Fn.addScaledVector(Nn,e),On.addScaledVector(zn,e)):(Bn.addScaledVector(Dn.sub(Cn),e),Fn.addScaledVector(Nn.sub(Pn),e),On.addScaledVector(zn.sub(In),e)))}Cn.add(Bn),Pn.add(Fn),In.add(On)}t.isSkinnedMesh&&(t.boneTransform(c,Cn),t.boneTransform(h,Pn),t.boneTransform(u,In));const p=function(t,e,n,i,r,s,a,o){let l;if(l=1===e.side?i.intersectTriangle(a,s,r,!0,o):i.intersectTriangle(r,s,a,2!==e.side,o),null===l)return null;Vn.copy(o),Vn.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(Vn);return c<n.near||c>n.far?null:{distance:c,point:Vn.clone(),object:t}}(t,e,n,i,Cn,Pn,In,kn);if(p){o&&(Un.fromBufferAttribute(o,c),Hn.fromBufferAttribute(o,h),Gn.fromBufferAttribute(o,u),p.uv=Ye.getUV(kn,Cn,Pn,In,Un,Hn,Gn,new yt)),l&&(Un.fromBufferAttribute(l,c),Hn.fromBufferAttribute(l,h),Gn.fromBufferAttribute(l,u),p.uv2=Ye.getUV(kn,Cn,Pn,In,Un,Hn,Gn,new yt));const t={a:c,b:h,c:u,normal:new zt,materialIndex:0};Ye.getNormal(Cn,Pn,In,t.normal),p.face=t}return p}Wn.prototype.isMesh=!0;class qn extends En{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const a=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const o=[],l=[],c=[],h=[];let u=0,d=0;function p(t,e,n,i,r,s,p,m,f,g,v){const y=s/f,x=p/g,_=s/2,M=p/2,b=m/2,w=f+1,S=g+1;let T=0,E=0;const A=new zt;for(let s=0;s<S;s++){const a=s*x-M;for(let o=0;o<w;o++){const u=o*y-_;A[t]=u*i,A[e]=a*r,A[n]=b,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=m>0?1:-1,c.push(A.x,A.y,A.z),h.push(o/f),h.push(1-s/g),T+=1}}for(let t=0;t<g;t++)for(let e=0;e<f;e++){const n=u+e+w*t,i=u+e+w*(t+1),r=u+(e+1)+w*(t+1),s=u+(e+1)+w*t;o.push(n,i,s),o.push(i,r,s),E+=6}a.addGroup(d,E,v),d+=E,u+=T}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(o),this.setAttribute("position",new vn(l,3)),this.setAttribute("normal",new vn(c,3)),this.setAttribute("uv",new vn(h,2))}static fromJSON(t){return new qn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Xn(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function Yn(t){const e={};for(let n=0;n<t.length;n++){const i=Xn(t[n]);for(const t in i)e[t]=i[t]}return e}const Jn={clone:Xn,merge:Yn};class Zn extends Ze{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Xn(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Zn.prototype.isShaderMaterial=!0;class Qn extends Fe{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new de,this.projectionMatrix=new de,this.projectionMatrixInverse=new de}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Qn.prototype.isCamera=!0;class Kn extends Qn{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*ot*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*at*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*ot*Math.atan(Math.tan(.5*at*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*at*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/a,i*=s.width/t,n*=s.height/a}const a=this.filmOffset;0!==a&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Kn.prototype.isPerspectiveCamera=!0;const $n=90;class ti extends Fe{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Kn($n,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new zt(1,0,0)),this.add(i);const r=new Kn($n,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new zt(-1,0,0)),this.add(r);const s=new Kn($n,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new zt(0,1,0)),this.add(s);const a=new Kn($n,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new zt(0,-1,0)),this.add(a);const o=new Kn($n,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new zt(0,0,1)),this.add(o);const l=new Kn($n,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new zt(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,a,o,l]=this.children,c=t.xr.enabled,h=t.getRenderTarget();t.xr.enabled=!1;const u=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=u,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(h),t.xr.enabled=c}}class ei extends Lt{constructor(t,e,n,i,s,a,o,l,c,h){super(t=void 0!==t?t:[],e=void 0!==e?e:r,n,i,s,a,o,l,c,h),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}ei.prototype.isCubeTexture=!0;class ni extends Pt{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new ei(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:g,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=E,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},i=new qn(5,5,5),r=new Zn({name:"CubemapFromEquirect",uniforms:Xn(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=e;const s=new Wn(i,r),a=e.minFilter;e.minFilter===y&&(e.minFilter=g);return new ti(1,10,this).update(t,s),e.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}ni.prototype.isWebGLCubeRenderTarget=!0;const ii=new zt,ri=new zt,si=new xt;class ai{constructor(t=new zt(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=ii.subVectors(n,e).cross(ri.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(ii),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||si.getNormalMatrix(t),i=this.coplanarPoint(ii).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}ai.prototype.isPlane=!0;const oi=new ie,li=new zt;class ci{constructor(t=new ai,e=new ai,n=new ai,i=new ai,r=new ai,s=new ai){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],h=n[7],u=n[8],d=n[9],p=n[10],m=n[11],f=n[12],g=n[13],v=n[14],y=n[15];return e[0].setComponents(a-i,h-o,m-u,y-f).normalize(),e[1].setComponents(a+i,h+o,m+u,y+f).normalize(),e[2].setComponents(a+r,h+l,m+d,y+g).normalize(),e[3].setComponents(a-r,h-l,m-d,y-g).normalize(),e[4].setComponents(a-s,h-c,m-p,y-v).normalize(),e[5].setComponents(a+s,h+c,m+p,y+v).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),oi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(oi)}intersectsSprite(t){return oi.center.set(0,0,0),oi.radius=.7071067811865476,oi.applyMatrix4(t.matrixWorld),this.intersectsSphere(oi)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(li.x=i.normal.x>0?t.max.x:t.min.x,li.y=i.normal.y>0?t.max.y:t.min.y,li.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(li)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function hi(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function ui(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,a=t.createBuffer();t.bindBuffer(i,a),t.bufferData(i,r,s),e.onUploadCallback();let o=5126;return r instanceof Float32Array?o=5126:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?o=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):o=5123:r instanceof Int16Array?o=5122:r instanceof Uint32Array?o=5125:r instanceof Int32Array?o=5124:r instanceof Int8Array?o=5120:(r instanceof Uint8Array||r instanceof Uint8ClampedArray)&&(o=5121),{buffer:a,type:o,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(!function(e,i,r){const s=i.array,a=i.updateRange;t.bindBuffer(r,e),-1===a.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):t.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,e,r),s.version=e.version)}}}class di extends En{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,a=Math.floor(n),o=Math.floor(i),l=a+1,c=o+1,h=t/a,u=e/o,d=[],p=[],m=[],f=[];for(let t=0;t<c;t++){const e=t*u-s;for(let n=0;n<l;n++){const i=n*h-r;p.push(i,-e,0),m.push(0,0,1),f.push(n/a),f.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new vn(p,3)),this.setAttribute("normal",new vn(m,3)),this.setAttribute("uv",new vn(f,2))}static fromJSON(t){return new di(t.width,t.height,t.widthSegments,t.heightSegments)}}const pi={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},mi={common:{diffuse:{value:new rn(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new xt},uv2Transform:{value:new xt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new yt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new rn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new rn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xt}},sprite:{diffuse:{value:new rn(16777215)},opacity:{value:1},center:{value:new yt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xt}}},fi={basic:{uniforms:Yn([mi.common,mi.specularmap,mi.envmap,mi.aomap,mi.lightmap,mi.fog]),vertexShader:pi.meshbasic_vert,fragmentShader:pi.meshbasic_frag},lambert:{uniforms:Yn([mi.common,mi.specularmap,mi.envmap,mi.aomap,mi.lightmap,mi.emissivemap,mi.fog,mi.lights,{emissive:{value:new rn(0)}}]),vertexShader:pi.meshlambert_vert,fragmentShader:pi.meshlambert_frag},phong:{uniforms:Yn([mi.common,mi.specularmap,mi.envmap,mi.aomap,mi.lightmap,mi.emissivemap,mi.bumpmap,mi.normalmap,mi.displacementmap,mi.fog,mi.lights,{emissive:{value:new rn(0)},specular:{value:new rn(1118481)},shininess:{value:30}}]),vertexShader:pi.meshphong_vert,fragmentShader:pi.meshphong_frag},standard:{uniforms:Yn([mi.common,mi.envmap,mi.aomap,mi.lightmap,mi.emissivemap,mi.bumpmap,mi.normalmap,mi.displacementmap,mi.roughnessmap,mi.metalnessmap,mi.fog,mi.lights,{emissive:{value:new rn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:pi.meshphysical_vert,fragmentShader:pi.meshphysical_frag},toon:{uniforms:Yn([mi.common,mi.aomap,mi.lightmap,mi.emissivemap,mi.bumpmap,mi.normalmap,mi.displacementmap,mi.gradientmap,mi.fog,mi.lights,{emissive:{value:new rn(0)}}]),vertexShader:pi.meshtoon_vert,fragmentShader:pi.meshtoon_frag},matcap:{uniforms:Yn([mi.common,mi.bumpmap,mi.normalmap,mi.displacementmap,mi.fog,{matcap:{value:null}}]),vertexShader:pi.meshmatcap_vert,fragmentShader:pi.meshmatcap_frag},points:{uniforms:Yn([mi.points,mi.fog]),vertexShader:pi.points_vert,fragmentShader:pi.points_frag},dashed:{uniforms:Yn([mi.common,mi.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:pi.linedashed_vert,fragmentShader:pi.linedashed_frag},depth:{uniforms:Yn([mi.common,mi.displacementmap]),vertexShader:pi.depth_vert,fragmentShader:pi.depth_frag},normal:{uniforms:Yn([mi.common,mi.bumpmap,mi.normalmap,mi.displacementmap,{opacity:{value:1}}]),vertexShader:pi.meshnormal_vert,fragmentShader:pi.meshnormal_frag},sprite:{uniforms:Yn([mi.sprite,mi.fog]),vertexShader:pi.sprite_vert,fragmentShader:pi.sprite_frag},background:{uniforms:{uvTransform:{value:new xt},t2D:{value:null}},vertexShader:pi.background_vert,fragmentShader:pi.background_frag},cube:{uniforms:Yn([mi.envmap,{opacity:{value:1}}]),vertexShader:pi.cube_vert,fragmentShader:pi.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:pi.equirect_vert,fragmentShader:pi.equirect_frag},distanceRGBA:{uniforms:Yn([mi.common,mi.displacementmap,{referencePosition:{value:new zt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:pi.distanceRGBA_vert,fragmentShader:pi.distanceRGBA_frag},shadow:{uniforms:Yn([mi.lights,mi.fog,{color:{value:new rn(0)},opacity:{value:1}}]),vertexShader:pi.shadow_vert,fragmentShader:pi.shadow_frag}};function gi(t,e,n,i,r){const s=new rn(0);let a,o,c=0,h=null,u=0,d=null;function p(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),c=e,p(s,c)},getClearAlpha:function(){return c},setClearAlpha:function(t){c=t,p(s,c)},render:function(n,r){let m=!1,f=!0===r.isScene?r.background:null;f&&f.isTexture&&(f=e.get(f));const g=t.xr,v=g.getSession&&g.getSession();v&&"additive"===v.environmentBlendMode&&(f=null),null===f?p(s,c):f&&f.isColor&&(p(f,1),m=!0),(t.autoClear||m)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===l)?(void 0===o&&(o=new Wn(new qn(1,1,1),new Zn({name:"BackgroundCubeMaterial",uniforms:Xn(fi.cube.uniforms),vertexShader:fi.cube.vertexShader,fragmentShader:fi.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(o)),o.material.uniforms.envMap.value=f,o.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,h===f&&u===f.version&&d===t.toneMapping||(o.material.needsUpdate=!0,h=f,u=f.version,d=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null)):f&&f.isTexture&&(void 0===a&&(a=new Wn(new di(2,2),new Zn({name:"BackgroundMaterial",uniforms:Xn(fi.background.uniforms),vertexShader:fi.background.vertexShader,fragmentShader:fi.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),a.material.uniforms.uvTransform.value.copy(f.matrix),h===f&&u===f.version&&d===t.toneMapping||(a.material.needsUpdate=!0,h=f,u=f.version,d=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function vi(t,e,n,i){const r=t.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),a=i.isWebGL2||null!==s,o={},l=d(null);let c=l;function h(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function u(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function m(t){f(t,0)}function f(n,r){const s=c.newAttributes,a=c.enabledAttributes,o=c.attributeDivisors;if(s[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==r){(i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r}}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function v(e,n,r,s,a,o){!0!==i.isWebGL2||5124!==r&&5125!==r?t.vertexAttribPointer(e,n,r,s,a,o):t.vertexAttribIPointer(e,n,r,a,o)}function y(){x(),c!==l&&(c=l,h(c.object))}function x(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,u,y,x){let _=!1;if(a){const e=function(e,n,r){const a=!0===r.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let h=c[a];void 0===h&&(h=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[a]=h);return h}(y,u,l);c!==e&&(c=e,h(c.object)),_=function(t,e){const n=c.attributes,i=t.attributes;let r=0;for(const t in i){const e=n[t],s=i[t];if(void 0===e)return!0;if(e.attribute!==s)return!0;if(e.data!==s.data)return!0;r++}return c.attributesNum!==r||c.index!==e}(y,x),_&&function(t,e){const n={},i=t.attributes;let r=0;for(const t in i){const e=i[t],s={};s.attribute=e,e.data&&(s.data=e.data),n[t]=s,r++}c.attributes=n,c.attributesNum=r,c.index=e}(y,x)}else{const t=!0===l.wireframe;c.geometry===y.id&&c.program===u.id&&c.wireframe===t||(c.geometry=y.id,c.program=u.id,c.wireframe=t,_=!0)}!0===r.isInstancedMesh&&(_=!0),null!==x&&n.update(x,34963),_&&(!function(r,s,a,o){if(!1===i.isWebGL2&&(r.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=o.attributes,c=a.getAttributes(),h=s.defaultAttributeValues;for(const e in c){const i=c[e];if(i.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&r.instanceMatrix&&(s=r.instanceMatrix),"instanceColor"===e&&r.instanceColor&&(s=r.instanceColor)),void 0!==s){const e=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const c=l.buffer,h=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n&&n.isInstancedInterleavedBuffer){for(let t=0;t<i.locationSize;t++)f(i.location+t,n.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<i.locationSize;t++)m(i.location+t);t.bindBuffer(34962,c);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,h,e,l*u,(d+a/i.locationSize*t)*u)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<i.locationSize;t++)f(i.location+t,s.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<i.locationSize;t++)m(i.location+t);t.bindBuffer(34962,c);for(let t=0;t<i.locationSize;t++)v(i.location+t,a/i.locationSize,h,e,a*u,a/i.locationSize*t*u)}}else if(void 0!==h){const n=h[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i.location,n);break;case 3:t.vertexAttrib3fv(i.location,n);break;case 4:t.vertexAttrib4fv(i.location,n);break;default:t.vertexAttrib1fv(i.location,n)}}}}g()}(r,l,u,y),null!==x&&t.bindBuffer(34963,n.get(x).buffer))},reset:y,resetDefaultState:x,dispose:function(){y();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)u(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:m,disableUnusedAttributes:g}}function yi(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,a,o){if(0===o)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,i,a,o),n.update(a,s,o)}}function xi(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=r(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||e.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=t.getParameter(34930),u=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),m=t.getParameter(34921),f=t.getParameter(36347),g=t.getParameter(36348),v=t.getParameter(36349),y=u>0,x=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:y,floatFragmentTextures:x,floatVertexTextures:y&&x,maxSamples:s?t.getParameter(36183):0}}function _i(t){const e=this;let n=null,i=0,r=!1,s=!1;const a=new ai,o=new xt,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function h(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;o.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)a.copy(t[e]).applyMatrix4(r,o),a.normal.toArray(c,n),c[n+3]=a.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const a=0!==t.length||e||0!==i||r;return r=e,n=h(t,s,0),i=t.length,a},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,a,o){const u=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,m=t.get(e);if(!r||null===u||0===u.length||s&&!p)s?h(null):c();else{const t=s?0:i,e=4*t;let r=m.clippingState||null;l.value=r,r=h(u,a,e,o);for(let t=0;t!==e;++t)r[t]=n[t];m.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Mi(t){let e=new WeakMap;function n(t,e){return e===a?t.mapping=r:e===o&&(t.mapping=s),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping;if(s===a||s===o){if(e.has(r)){return n(e.get(r).texture,r.mapping)}{const s=r.image;if(s&&s.height>0){const a=t.getRenderTarget(),o=new ni(s.height/2);return o.fromEquirectangularTexture(t,r),e.set(r,o),t.setRenderTarget(a),r.addEventListener("dispose",i),n(o.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}fi.physical={uniforms:Yn([fi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new yt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new rn(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new yt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new rn(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new rn(1,1,1)},specularColorMap:{value:null}}]),vertexShader:pi.meshphysical_vert,fragmentShader:pi.meshphysical_frag};class bi extends Qn{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,a=i+e,o=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}bi.prototype.isOrthographicCamera=!0;class wi extends Zn{constructor(t){super(t),this.type="RawShaderMaterial"}}wi.prototype.isRawShaderMaterial=!0;const Si=Math.pow(2,8),Ti=[.125,.215,.35,.446,.526,.582],Ei=5+Ti.length,Ai=20,Li={[X]:0,[Y]:1,[Z]:2,[Q]:3,[K]:4,[$]:5,[J]:6},Ri=new bi,{_lodPlanes:Ci,_sizeLods:Pi,_sigmas:Ii}=Hi(),Di=new rn;let Ni=null;const zi=(1+Math.sqrt(5))/2,Bi=1/zi,Fi=[new zt(1,1,1),new zt(-1,1,1),new zt(1,1,-1),new zt(-1,1,-1),new zt(0,zi,Bi),new zt(0,zi,-Bi),new zt(Bi,0,zi),new zt(-Bi,0,zi),new zt(zi,Bi,0),new zt(-zi,Bi,0)];class Oi{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(t),n=new zt(0,1,0);return new wi({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:Li[3e3]},outputEncoding:{value:Li[3e3]}},vertexShader:ji(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${qi()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}(Ai),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Ni=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=Wi(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=Vi(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<Ci.length;t++)Ci[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Ni),t.scissorTest=!1,ki(t,0,0,t.width,t.height)}_fromTexture(t){Ni=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:p,minFilter:p,generateMipmaps:!1,type:x,format:1023,encoding:Ui(t)?t.encoding:Z,depthBuffer:!1},n=Gi(e);return n.depthBuffer=!t,this._pingPongRenderTarget=Gi(e),n}_compileMaterial(t){const e=new Wn(Ci[0],t);this._renderer.compile(e,Ri)}_sceneToCubeUV(t,e,n,i){const r=new Kn(90,1,e,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.outputEncoding,h=o.toneMapping;o.getClearColor(Di),o.toneMapping=0,o.outputEncoding=X,o.autoClear=!1;const u=new sn({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),d=new Wn(new qn,u);let p=!1;const m=t.background;m?m.isColor&&(u.color.copy(m),t.background=null,p=!0):(u.color.copy(Di),p=!0);for(let e=0;e<6;e++){const n=e%3;0==n?(r.up.set(0,s[e],0),r.lookAt(a[e],0,0)):1==n?(r.up.set(0,0,s[e]),r.lookAt(0,a[e],0)):(r.up.set(0,s[e],0),r.lookAt(0,0,a[e])),ki(i,n*Si,e>2?Si:0,Si,Si),o.setRenderTarget(i),p&&o.render(d,r),o.render(t,r)}d.geometry.dispose(),d.material.dispose(),o.toneMapping=h,o.outputEncoding=c,o.autoClear=l,t.background=m}_setEncoding(t,e){!0===this._renderer.capabilities.isWebGL2&&e.format===E&&e.type===x&&e.encoding===Y?t.value=Li[3e3]:t.value=Li[e.encoding]}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===r||t.mapping===s;i?null==this._cubemapShader&&(this._cubemapShader=Wi()):null==this._equirectShader&&(this._equirectShader=Vi());const a=i?this._cubemapShader:this._equirectShader,o=new Wn(Ci[0],a),l=a.uniforms;l.envMap.value=t,i||l.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(l.inputEncoding,t),this._setEncoding(l.outputEncoding,e.texture),ki(e,0,0,3*Si,2*Si),n.setRenderTarget(e),n.render(o,Ri)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<Ei;e++){const n=Math.sqrt(Ii[e]*Ii[e]-Ii[e-1]*Ii[e-1]),i=Fi[(e-1)%Fi.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new Wn(Ci[i],l),h=l.uniforms,u=Pi[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,m=isFinite(r)?1+Math.floor(3*p):Ai;m>Ai&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const f=[];let g=0;for(let t=0;t<Ai;++t){const e=t/p,n=Math.exp(-e*e/2);f.push(n),0==t?g+=n:t<m&&(g+=2*n)}for(let t=0;t<f.length;t++)f[t]=f[t]/g;h.envMap.value=t.texture,h.samples.value=m,h.weights.value=f,h.latitudinal.value="latitudinal"===s,a&&(h.poleAxis.value=a),h.dTheta.value=d,h.mipInt.value=8-n,this._setEncoding(h.inputEncoding,t.texture),this._setEncoding(h.outputEncoding,t.texture);const v=Pi[i];ki(e,3*Math.max(0,Si-2*v),(0===i?0:2*Si)+2*v*(i>4?i-8+4:0),3*v,2*v),o.setRenderTarget(e),o.render(c,Ri)}}function Ui(t){return void 0!==t&&t.type===x&&(t.encoding===X||t.encoding===Y||t.encoding===J)}function Hi(){const t=[],e=[],n=[];let i=8;for(let r=0;r<Ei;r++){const s=Math.pow(2,i);e.push(s);let a=1/s;r>4?a=Ti[r-8+4-1]:0==r&&(a=0),n.push(a);const o=1/(s-1),l=-o/2,c=1+o/2,h=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,d=6,p=3,m=2,f=1,g=new Float32Array(p*d*u),v=new Float32Array(m*d*u),y=new Float32Array(f*d*u);for(let t=0;t<u;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];g.set(i,p*d*t),v.set(h,m*d*t);const r=[t,t,t,t,t,t];y.set(r,f*d*t)}const x=new En;x.setAttribute("position",new ln(g,p)),x.setAttribute("uv",new ln(v,m)),x.setAttribute("faceIndex",new ln(y,f)),t.push(x),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}function Gi(t){const e=new Pt(3*Si,3*Si,t);return e.texture.mapping=l,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ki(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function Vi(){const t=new yt(1,1);return new wi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:Li[3e3]},outputEncoding:{value:Li[3e3]}},vertexShader:ji(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${qi()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function Wi(){return new wi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Li[3e3]},outputEncoding:{value:Li[3e3]}},vertexShader:ji(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${qi()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:0,depthTest:!1,depthWrite:!1})}function ji(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function qi(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function Xi(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(l){if(l&&l.isTexture&&!1===l.isRenderTargetTexture){const c=l.mapping,h=c===a||c===o,u=c===r||c===s;if(h||u){if(e.has(l))return e.get(l).texture;{const r=l.image;if(h&&r&&r.height>0||u&&r&&function(t){let e=0;const n=6;for(let i=0;i<n;i++)void 0!==t[i]&&e++;return e===n}(r)){const r=t.getRenderTarget();null===n&&(n=new Oi(t));const s=h?n.fromEquirectangular(l):n.fromCubemap(l);return e.set(l,s),t.setRenderTarget(r),l.addEventListener("dispose",i),s.texture}return null}}}return l},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function Yi(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function Ji(t,e,n,i){const r={},s=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete r[o.id];const l=s.get(o);l&&(e.remove(l),s.delete(o)),i.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],i=t.index,r=t.attributes.position;let a=0;if(null!==i){const t=i.array;a=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{const t=r.array;a=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}const o=new(_t(n)>65535?fn:pn)(n,1);o.version=a;const l=s.get(t);l&&e.remove(l),s.set(t,o)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",a),r[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const i=t.morphAttributes;for(const t in i){const n=i[t];for(let t=0,i=n.length;t<i;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return s.get(t)}}}function Zi(t,e,n,i){const r=i.isWebGL2;let s,a,o;this.setMode=function(t){s=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,a,e*o),n.update(i,s,1)},this.renderInstances=function(i,l,c){if(0===c)return;let h,u;if(r)h=t,u="drawElementsInstanced";else if(h=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](s,l,a,i*o,c),n.update(l,s,c)}}function Qi(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}class Ki extends Lt{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=p,this.minFilter=p,this.wrapR=u,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}function $i(t,e){return t[0]-e[0]}function tr(t,e){return Math.abs(e[1])-Math.abs(t[1])}function er(t,e){let n=1;const i=e.isInterleavedBufferAttribute?e.data.array:e.array;i instanceof Int8Array?n=127:i instanceof Int16Array?n=32767:i instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),t.divideScalar(n)}function nr(t,e,n){const i={},r=new Float32Array(8),s=new WeakMap,a=new zt,o=[];for(let t=0;t<8;t++)o[t]=[t,0];return{update:function(l,c,h,u){const d=l.morphTargetInfluences;if(!0===e.isWebGL2){const i=c.morphAttributes.position.length;let r=s.get(c);if(void 0===r||r.count!==i){void 0!==r&&r.texture.dispose();const t=void 0!==c.morphAttributes.normal,n=c.morphAttributes.position,o=c.morphAttributes.normal||[],l=!0===t?2:1;let h=c.attributes.position.count*l,u=1;h>e.maxTextureSize&&(u=Math.ceil(h/e.maxTextureSize),h=e.maxTextureSize);const d=new Float32Array(h*u*4*i),p=new Ki(d,h,u,i);p.format=E,p.type=b;const m=4*l;for(let e=0;e<i;e++){const i=n[e],r=o[e],s=h*u*4*e;for(let e=0;e<i.count;e++){a.fromBufferAttribute(i,e),!0===i.normalized&&er(a,i);const n=e*m;d[s+n+0]=a.x,d[s+n+1]=a.y,d[s+n+2]=a.z,d[s+n+3]=0,!0===t&&(a.fromBufferAttribute(r,e),!0===r.normalized&&er(a,r),d[s+n+4]=a.x,d[s+n+5]=a.y,d[s+n+6]=a.z,d[s+n+7]=0)}}r={count:i,texture:p,size:new yt(h,u)},s.set(c,r)}let o=0;for(let t=0;t<d.length;t++)o+=d[t];const l=c.morphTargetsRelative?1:1-o;u.getUniforms().setValue(t,"morphTargetBaseInfluence",l),u.getUniforms().setValue(t,"morphTargetInfluences",d),u.getUniforms().setValue(t,"morphTargetsTexture",r.texture,n),u.getUniforms().setValue(t,"morphTargetsTextureSize",r.size)}else{const e=void 0===d?0:d.length;let n=i[c.id];if(void 0===n||n.length!==e){n=[];for(let t=0;t<e;t++)n[t]=[t,0];i[c.id]=n}for(let t=0;t<e;t++){const e=n[t];e[0]=t,e[1]=d[t]}n.sort(tr);for(let t=0;t<8;t++)t<e&&n[t][1]?(o[t][0]=n[t][0],o[t][1]=n[t][1]):(o[t][0]=Number.MAX_SAFE_INTEGER,o[t][1]=0);o.sort($i);const s=c.morphAttributes.position,a=c.morphAttributes.normal;let l=0;for(let t=0;t<8;t++){const e=o[t],n=e[0],i=e[1];n!==Number.MAX_SAFE_INTEGER&&i?(s&&c.getAttribute("morphTarget"+t)!==s[n]&&c.setAttribute("morphTarget"+t,s[n]),a&&c.getAttribute("morphNormal"+t)!==a[n]&&c.setAttribute("morphNormal"+t,a[n]),r[t]=i,l+=i):(s&&!0===c.hasAttribute("morphTarget"+t)&&c.deleteAttribute("morphTarget"+t),a&&!0===c.hasAttribute("morphNormal"+t)&&c.deleteAttribute("morphNormal"+t),r[t]=0)}const h=c.morphTargetsRelative?1:1-l;u.getUniforms().setValue(t,"morphTargetBaseInfluence",h),u.getUniforms().setValue(t,"morphTargetInfluences",r)}}}}function ir(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const a=i.render.frame,o=t.geometry,l=e.get(t,o);return r.get(l)!==a&&(e.update(l),r.set(l,a)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){r=new WeakMap}}}Ki.prototype.isDataTexture2DArray=!0;class rr extends Lt{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=p,this.minFilter=p,this.wrapR=u,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}rr.prototype.isDataTexture3D=!0;const sr=new Lt,ar=new Ki,or=new rr,lr=new ei,cr=[],hr=[],ur=new Float32Array(16),dr=new Float32Array(9),pr=new Float32Array(4);function mr(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=cr[r];if(void 0===s&&(s=new Float32Array(r),cr[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function fr(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function gr(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function vr(t,e){let n=hr[e];void 0===n&&(n=new Int32Array(e),hr[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function yr(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function xr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(fr(n,e))return;t.uniform2fv(this.addr,e),gr(n,e)}}function _r(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(fr(n,e))return;t.uniform3fv(this.addr,e),gr(n,e)}}function Mr(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(fr(n,e))return;t.uniform4fv(this.addr,e),gr(n,e)}}function br(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fr(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),gr(n,e)}else{if(fr(n,i))return;pr.set(i),t.uniformMatrix2fv(this.addr,!1,pr),gr(n,i)}}function wr(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fr(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),gr(n,e)}else{if(fr(n,i))return;dr.set(i),t.uniformMatrix3fv(this.addr,!1,dr),gr(n,i)}}function Sr(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fr(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),gr(n,e)}else{if(fr(n,i))return;ur.set(i),t.uniformMatrix4fv(this.addr,!1,ur),gr(n,i)}}function Tr(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Er(t,e){const n=this.cache;fr(n,e)||(t.uniform2iv(this.addr,e),gr(n,e))}function Ar(t,e){const n=this.cache;fr(n,e)||(t.uniform3iv(this.addr,e),gr(n,e))}function Lr(t,e){const n=this.cache;fr(n,e)||(t.uniform4iv(this.addr,e),gr(n,e))}function Rr(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Cr(t,e){const n=this.cache;fr(n,e)||(t.uniform2uiv(this.addr,e),gr(n,e))}function Pr(t,e){const n=this.cache;fr(n,e)||(t.uniform3uiv(this.addr,e),gr(n,e))}function Ir(t,e){const n=this.cache;fr(n,e)||(t.uniform4uiv(this.addr,e),gr(n,e))}function Dr(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||sr,r)}function Nr(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||or,r)}function zr(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||lr,r)}function Br(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||ar,r)}function Fr(t,e){t.uniform1fv(this.addr,e)}function Or(t,e){const n=mr(e,this.size,2);t.uniform2fv(this.addr,n)}function Ur(t,e){const n=mr(e,this.size,3);t.uniform3fv(this.addr,n)}function Hr(t,e){const n=mr(e,this.size,4);t.uniform4fv(this.addr,n)}function Gr(t,e){const n=mr(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function kr(t,e){const n=mr(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Vr(t,e){const n=mr(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Wr(t,e){t.uniform1iv(this.addr,e)}function jr(t,e){t.uniform2iv(this.addr,e)}function qr(t,e){t.uniform3iv(this.addr,e)}function Xr(t,e){t.uniform4iv(this.addr,e)}function Yr(t,e){t.uniform1uiv(this.addr,e)}function Jr(t,e){t.uniform2uiv(this.addr,e)}function Zr(t,e){t.uniform3uiv(this.addr,e)}function Qr(t,e){t.uniform4uiv(this.addr,e)}function Kr(t,e,n){const i=e.length,r=vr(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTexture2D(e[t]||sr,r[t])}function $r(t,e,n){const i=e.length,r=vr(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTextureCube(e[t]||lr,r[t])}function ts(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return yr;case 35664:return xr;case 35665:return _r;case 35666:return Mr;case 35674:return br;case 35675:return wr;case 35676:return Sr;case 5124:case 35670:return Tr;case 35667:case 35671:return Er;case 35668:case 35672:return Ar;case 35669:case 35673:return Lr;case 5125:return Rr;case 36294:return Cr;case 36295:return Pr;case 36296:return Ir;case 35678:case 36198:case 36298:case 36306:case 35682:return Dr;case 35679:case 36299:case 36307:return Nr;case 35680:case 36300:case 36308:case 36293:return zr;case 36289:case 36303:case 36311:case 36292:return Br}}(e.type)}function es(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Fr;case 35664:return Or;case 35665:return Ur;case 35666:return Hr;case 35674:return Gr;case 35675:return kr;case 35676:return Vr;case 5124:case 35670:return Wr;case 35667:case 35671:return jr;case 35668:case 35672:return qr;case 35669:case 35673:return Xr;case 5125:return Yr;case 36294:return Jr;case 36295:return Zr;case 36296:return Qr;case 35678:case 36198:case 36298:case 36306:case 35682:return Kr;case 35680:case 36300:case 36308:case 36293:return $r}}(e.type)}function ns(t){this.id=t,this.seq=[],this.map={}}es.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),gr(e,t)},ns.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const is=/(\w+)(\])?(\[|\.)?/g;function rs(t,e){t.seq.push(e),t.map[e.id]=e}function ss(t,e,n){const i=t.name,r=i.length;for(is.lastIndex=0;;){const s=is.exec(i),a=is.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];if(l&&(o|=0),void 0===c||"["===c&&a+2===r){rs(n,void 0===c?new ts(o,t,e):new es(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new ns(o),rs(n,t)),n=t}}}function as(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);ss(n,t.getUniformLocation(e,n.name),this)}}function os(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}as.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},as.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},as.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],a=n[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,i)}},as.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let ls=0;function cs(t){switch(t){case X:return["Linear","( value )"];case Y:return["sRGB","( value )"];case Z:return["RGBE","( value )"];case Q:return["RGBM","( value, 7.0 )"];case K:return["RGBM","( value, 16.0 )"];case $:return["RGBD","( value, 256.0 )"];case J:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function hs(t,e,n){const i=t.getShaderParameter(e,35713),r=t.getShaderInfoLog(e).trim();return i&&""===r?"":n.toUpperCase()+"\n\n"+r+"\n\n"+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function us(t,e){const n=cs(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function ds(t,e){const n=cs(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function ps(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function ms(t){return""!==t}function fs(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function gs(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const vs=/^[ \t]*#include +<([\w\d./]+)>/gm;function ys(t){return t.replace(vs,xs)}function xs(t,e){const n=pi[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return ys(n)}const _s=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Ms=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function bs(t){return t.replace(Ms,Ss).replace(_s,ws)}function ws(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ss(t,e,n,i)}function Ss(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function Ts(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Es(t,e,n,i){const a=t.getContext(),o=n.defines;let h=n.vertexShader,u=n.fragmentShader;const d=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),p=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case r:case s:e="ENVMAP_TYPE_CUBE";break;case l:case c:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),m=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case s:case c:e="ENVMAP_MODE_REFRACTION"}return e}(n),f=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),g=t.gammaFactor>0?t.gammaFactor:1,v=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ms).join("\n")}(n),y=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(o),x=a.createProgram();let _,M,b=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(_=[y].filter(ms).join("\n"),_.length>0&&(_+="\n"),M=[v,y].filter(ms).join("\n"),M.length>0&&(M+="\n")):(_=[Ts(n),"#define SHADER_NAME "+n.shaderName,y,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+g,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+m:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+d:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(ms).join("\n"),M=[v,Ts(n),"#define SHADER_NAME "+n.shaderName,y,"#define GAMMA_FACTOR "+g,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+p:"",n.envMap?"#define "+m:"",n.envMap?"#define "+f:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+d:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?pi.tonemapping_pars_fragment:"",0!==n.toneMapping?ps("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.format===T?"#define OPAQUE":"",pi.encodings_pars_fragment,n.map?us("mapTexelToLinear",n.mapEncoding):"",n.matcap?us("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?us("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?us("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.specularColorMap?us("specularColorMapTexelToLinear",n.specularColorMapEncoding):"",n.sheenColorMap?us("sheenColorMapTexelToLinear",n.sheenColorMapEncoding):"",n.lightMap?us("lightMapTexelToLinear",n.lightMapEncoding):"",ds("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(ms).join("\n")),h=ys(h),h=fs(h,n),h=gs(h,n),u=ys(u),u=fs(u,n),u=gs(u,n),h=bs(h),u=bs(u),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(b="#version 300 es\n",_=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+_,M=["#define varying in",n.glslVersion===it?"":"out highp vec4 pc_fragColor;",n.glslVersion===it?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+M);const w=b+M+u,S=os(a,35633,b+_+h),E=os(a,35632,w);if(a.attachShader(x,S),a.attachShader(x,E),void 0!==n.index0AttributeName?a.bindAttribLocation(x,0,n.index0AttributeName):!0===n.morphTargets&&a.bindAttribLocation(x,0,"position"),a.linkProgram(x),t.debug.checkShaderErrors){const t=a.getProgramInfoLog(x).trim(),e=a.getShaderInfoLog(S).trim(),n=a.getShaderInfoLog(E).trim();let i=!0,r=!0;if(!1===a.getProgramParameter(x,35714)){i=!1;const e=hs(a,S,"vertex"),n=hs(a,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+a.getError()+" - VALIDATE_STATUS "+a.getProgramParameter(x,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(r=!1);r&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:_},fragmentShader:{log:n,prefix:M}})}let A,L;return a.deleteShader(S),a.deleteShader(E),this.getUniforms=function(){return void 0===A&&(A=new as(a,x)),A},this.getAttributes=function(){return void 0===L&&(L=function(t,e){const n={},i=t.getProgramParameter(e,35721);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),s=i.name;let a=1;35674===i.type&&(a=2),35675===i.type&&(a=3),35676===i.type&&(a=4),n[s]={type:i.type,location:t.getAttribLocation(e,s),locationSize:a}}return n}(a,x)),L},this.destroy=function(){i.releaseStatesOfProgram(this),a.deleteProgram(x),this.program=void 0},this.name=n.shaderName,this.id=ls++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=S,this.fragmentShader=E,this}function As(t,e,n,i,r,s,a){const o=[],h=r.isWebGL2,u=r.logarithmicDepthBuffer,d=r.floatVertexTextures,p=r.maxVertexUniforms,m=r.vertexTextures;let f=r.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},v=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function y(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=X,h&&t&&t.isTexture&&t.format===E&&t.type===x&&t.encoding===Y&&(e=X),e}return{getParameters:function(s,o,v,x,_){const M=x.fog,b=s.isMeshStandardMaterial?x.environment:null,w=(s.isMeshStandardMaterial?n:e).get(s.envMap||b),S=g[s.type],T=_.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(d)return 1024;{const t=p,n=Math.floor((t-20)/4),i=Math.min(n,e.length);return i<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+i+"."),0):i}}(_):0;let E,A;if(null!==s.precision&&(f=r.getMaxPrecision(s.precision),f!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",f,"instead.")),S){const t=fi[S];E=t.vertexShader,A=t.fragmentShader}else E=s.vertexShader,A=s.fragmentShader;const L=t.getRenderTarget(),R=s.alphaTest>0,C=s.clearcoat>0;return{isWebGL2:h,shaderID:S,shaderName:s.type,vertexShader:E,fragmentShader:A,defines:s.defines,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:f,instancing:!0===_.isInstancedMesh,instancingColor:!0===_.isInstancedMesh&&null!==_.instanceColor,supportsVertexTextures:m,outputEncoding:null!==L?y(L.texture):t.outputEncoding,map:!!s.map,mapEncoding:y(s.map),matcap:!!s.matcap,matcapEncoding:y(s.matcap),envMap:!!w,envMapMode:w&&w.mapping,envMapEncoding:y(w),envMapCubeUV:!!w&&(w.mapping===l||w.mapping===c),lightMap:!!s.lightMap,lightMapEncoding:y(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:y(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,clearcoat:C,clearcoatMap:C&&!!s.clearcoatMap,clearcoatRoughnessMap:C&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:C&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,specularColorMapEncoding:y(s.specularColorMap),alphaMap:!!s.alphaMap,alphaTest:R,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenColorMapEncoding:y(s.sheenColorMap),sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!_.geometry&&!!_.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!_.geometry&&!!_.geometry.attributes.color&&4===_.geometry.attributes.color.itemSize,vertexUvs:!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatMap||!!s.clearcoatRoughnessMap||!!s.clearcoatNormalMap||!!s.displacementMap||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularColorMap||!!s.sheenColorMap||s.sheenRoughnessMap,uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||!!s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!M,useFog:s.fog,fogExp2:M&&M.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===_.isSkinnedMesh&&T>0,maxBones:T,useVertexTexture:d,morphTargets:!!_.geometry&&!!_.geometry.morphAttributes.position,morphNormals:!!_.geometry&&!!_.geometry.morphAttributes.normal,morphTargetsCount:_.geometry&&_.geometry.morphAttributes.position?_.geometry.morphAttributes.position.length:0,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:s.format,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&v.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||i.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(St(e.fragmentShader)),n.push(St(e.vertexShader))),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<v.length;t++)n.push(e[v[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=g[t.type];let n;if(e){const t=fi[e];n=Jn.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=o.length;t<e;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new Es(t,n,e,s),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function Ls(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function Rs(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Cs(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Ps(t){const e=[];let n=0;const i=[],r=[],s=[],a={id:-1};function o(i,r,s,o,l,c){let h=e[n];const u=t.get(s);return void 0===h?(h={id:i.id,object:i,geometry:r,material:s,program:u.program||a,groupOrder:o,renderOrder:i.renderOrder,z:l,group:c},e[n]=h):(h.id=i.id,h.object=i,h.geometry=r,h.material=s,h.program=u.program||a,h.groupOrder=o,h.renderOrder=i.renderOrder,h.z=l,h.group=c),n++,h}return{opaque:i,transmissive:r,transparent:s,init:function(){n=0,i.length=0,r.length=0,s.length=0},push:function(t,e,n,a,l,c){const h=o(t,e,n,a,l,c);n.transmission>0?r.push(h):!0===n.transparent?s.push(h):i.push(h)},unshift:function(t,e,n,a,l,c){const h=o(t,e,n,a,l,c);n.transmission>0?r.unshift(h):!0===n.transparent?s.unshift(h):i.unshift(h)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Rs),r.length>1&&r.sort(e||Cs),s.length>1&&s.sort(e||Cs)}}}function Is(t){let e=new WeakMap;return{get:function(n,i){let r;return!1===e.has(n)?(r=new Ps(t),e.set(n,[r])):i>=e.get(n).length?(r=new Ps(t),e.get(n).push(r)):r=e.get(n)[i],r},dispose:function(){e=new WeakMap}}}function Ds(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new zt,color:new rn};break;case"SpotLight":n={position:new zt,direction:new zt,color:new rn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new zt,color:new rn,distance:0,decay:0};break;case"HemisphereLight":n={direction:new zt,skyColor:new rn,groundColor:new rn};break;case"RectAreaLight":n={color:new rn,position:new zt,halfWidth:new zt,halfHeight:new zt}}return t[e.id]=n,n}}}let Ns=0;function zs(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function Bs(t,e){const n=new Ds,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new yt};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new yt,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)r.probe.push(new zt);const s=new zt,a=new de,o=new de;return{setup:function(s,a){let o=0,l=0,c=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let h=0,u=0,d=0,p=0,m=0,f=0,g=0,v=0;s.sort(zs);const y=!0!==a?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],a=e.color,x=e.intensity,_=e.distance,M=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*x*y,l+=a.g*x*y,c+=a.b*x*y;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],x);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[h]=n,r.directionalShadowMap[h]=M,r.directionalShadowMatrix[h]=e.shadow.matrix,f++}r.directional[h]=t,h++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(x*y),t.distance=_,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[d]=n,r.spotShadowMap[d]=M,r.spotShadowMatrix[d]=e.shadow.matrix,v++}r.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(x),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=M,r.pointShadowMatrix[u]=e.shadow.matrix,g++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(x*y),t.groundColor.copy(e.groundColor).multiplyScalar(x*y),r.hemi[m]=t,m++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=mi.LTC_FLOAT_1,r.rectAreaLTC2=mi.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=mi.LTC_HALF_1,r.rectAreaLTC2=mi.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=l,r.ambient[2]=c;const x=r.hash;x.directionalLength===h&&x.pointLength===u&&x.spotLength===d&&x.rectAreaLength===p&&x.hemiLength===m&&x.numDirectionalShadows===f&&x.numPointShadows===g&&x.numSpotShadows===v||(r.directional.length=h,r.spot.length=d,r.rectArea.length=p,r.point.length=u,r.hemi.length=m,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=g,r.spotShadowMatrix.length=v,x.directionalLength=h,x.pointLength=u,x.spotLength=d,x.rectAreaLength=p,x.hemiLength=m,x.numDirectionalShadows=f,x.numPointShadows=g,x.numSpotShadows=v,r.version=Ns++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,h=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),a.copy(d.matrixWorld),a.premultiply(u),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),i++}else if(d.isHemisphereLight){const t=r.hemi[h];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),t.direction.normalize(),h++}}},state:r}}function Fs(t,e){const n=new Bs(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(t){n.setup(i,t)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function Os(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new Fs(t,e),n.set(i,[s])):r>=n.get(i).length?(s=new Fs(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}class Us extends Ze{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Us.prototype.isMeshDepthMaterial=!0;class Hs extends Ze{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new zt,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Hs.prototype.isMeshDistanceMaterial=!0;function Gs(t,e,n){let i=new ci;const r=new yt,s=new yt,a=new Ct,o=new Us({depthPacking:3201}),l=new Hs,c={},h=n.maxTextureSize,u={0:1,1:0,2:2},d=new Zn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new yt},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),m=d.clone();m.defines.HORIZONTAL_PASS=1;const f=new En;f.setAttribute("position",new ln(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new Wn(f,d),y=this;function x(n,i){const r=e.update(v);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,m.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,m.needsUpdate=!0),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,d,v,null),m.uniforms.shadow_pass.value=n.mapPass.texture,m.uniforms.resolution.value=n.mapSize,m.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,m,v,null)}function _(e,n,i,r,s,a,h){let d=null;const p=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(d=void 0!==p?p:!0===r.isPointLight?l:o,t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0){const t=d.uuid,e=i.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let r=n[e];void 0===r&&(r=d.clone(),n[e]=r),d=r}return d.visible=i.visible,d.wireframe=i.wireframe,d.side=3===h?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],d.alphaMap=i.alphaMap,d.alphaTest=i.alphaTest,d.clipShadows=i.clipShadows,d.clippingPlanes=i.clippingPlanes,d.clipIntersection=i.clipIntersection,d.displacementMap=i.displacementMap,d.displacementScale=i.displacementScale,d.displacementBias=i.displacementBias,d.wireframeLinewidth=i.wireframeLinewidth,d.linewidth=i.linewidth,!0===r.isPointLight&&!0===d.isMeshDistanceMaterial&&(d.referencePosition.setFromMatrixPosition(r.matrixWorld),d.nearDistance=s,d.farDistance=a),d}function M(n,r,s,a,o){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],h=r[c.materialIndex];if(h&&h.visible){const e=_(n,0,h,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,c)}}}else if(r.visible){const e=_(n,0,r,a,s.near,s.far,o);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)M(l[t],r,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,n,o){if(!1===y.enabled)return;if(!1===y.autoUpdate&&!1===y.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,c=e.length;l<c;l++){const c=e[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const m=u.getFrameExtents();if(r.multiply(m),s.copy(u.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/m.x),r.x=s.x*m.x,u.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/m.y),r.y=s.y*m.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const t={minFilter:g,magFilter:g,format:E};u.map=new Pt(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.mapPass=new Pt(r.x,r.y,t),u.camera.updateProjectionMatrix()}if(null===u.map){const t={minFilter:p,magFilter:p,format:E};u.map=new Pt(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);a.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(a),u.updateMatrices(c,t),i=u.getFrustum(),M(n,o,u.camera,c,this.type)}u.isPointLightShadow||3!==this.type||x(u,o),u.needsUpdate=!1}y.needsUpdate=!1,t.setRenderTarget(l,c,u)}}function ks(t,e,i){const r=i.isWebGL2;const s=new function(){let e=!1;const n=new Ct;let i=null;const r=new Ct(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,a,o){!0===o&&(e*=a,i*=a,s*=a),n.set(e,i,s,a),!1===r.equals(n)&&(t.clearColor(e,i,s,a),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},a=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(t){t?O(2929):U(2929)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;default:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517)}else t.depthFunc(515);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},o=new function(){let e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,c=null;return{setTest:function(t){e||(t?O(2960):U(2960))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,a){i===e&&r===n&&s===a||(t.stencilFunc(e,n,a),i=e,r=n,s=a)},setOp:function(e,n,i){a===e&&o===n&&l===i||(t.stencilOp(e,n,i),a=e,o=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,a=null,o=null,l=null,c=null}}};let l={},c=null,h={},u=null,d=!1,p=null,m=null,f=null,g=null,v=null,y=null,x=null,_=!1,M=null,b=null,w=null,S=null,T=null;const E=t.getParameter(35661);let A=!1,L=0;const R=t.getParameter(7938);-1!==R.indexOf("WebGL")?(L=parseFloat(/^WebGL (\d)/.exec(R)[1]),A=L>=1):-1!==R.indexOf("OpenGL ES")&&(L=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),A=L>=2);let C=null,P={};const I=t.getParameter(3088),D=t.getParameter(2978),N=(new Ct).fromArray(I),z=(new Ct).fromArray(D);function B(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<i;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,r);return s}const F={};function O(e){!0!==l[e]&&(t.enable(e),l[e]=!0)}function U(e){!1!==l[e]&&(t.disable(e),l[e]=!1)}F[3553]=B(3553,3553,1),F[34067]=B(34067,34069,6),s.setClear(0,0,0,1),a.setClear(1),o.setClear(0),O(2929),a.setFunc(3),V(!1),W(1),O(2884),k(0);const H={[n]:32774,101:32778,102:32779};if(r)H[103]=32775,H[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(H[103]=t.MIN_EXT,H[104]=t.MAX_EXT)}const G={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function k(e,i,r,s,a,o,l,c){if(0!==e){if(!1===d&&(O(3042),d=!0),5===e)a=a||i,o=o||r,l=l||s,i===m&&a===v||(t.blendEquationSeparate(H[i],H[a]),m=i,v=a),r===f&&s===g&&o===y&&l===x||(t.blendFuncSeparate(G[r],G[s],G[o],G[l]),f=r,g=s,y=o,x=l),p=e,_=null;else if(e!==p||c!==_){if(m===n&&v===n||(t.blendEquation(32774),m=n,v=n),c)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}f=null,g=null,y=null,x=null,p=e,_=c}}else!0===d&&(U(3042),d=!1)}function V(e){M!==e&&(e?t.frontFace(2304):t.frontFace(2305),M=e)}function W(e){0!==e?(O(2884),e!==b&&(1===e?t.cullFace(1029):2===e?t.cullFace(1028):t.cullFace(1032))):U(2884),b=e}function j(e,n,i){e?(O(32823),S===n&&T===i||(t.polygonOffset(n,i),S=n,T=i)):U(32823)}function q(e){void 0===e&&(e=33984+E-1),C!==e&&(t.activeTexture(e),C=e)}return{buffers:{color:s,depth:a,stencil:o},enable:O,disable:U,bindFramebuffer:function(e,n){return null===n&&null!==c&&(n=c),h[e]!==n&&(t.bindFramebuffer(e,n),h[e]=n,r&&(36009===e&&(h[36160]=n),36160===e&&(h[36009]=n)),!0)},bindXRFramebuffer:function(e){e!==c&&(t.bindFramebuffer(36160,e),c=e)},useProgram:function(e){return u!==e&&(t.useProgram(e),u=e,!0)},setBlending:k,setMaterial:function(t,e){2===t.side?U(2884):O(2884);let n=1===t.side;e&&(n=!n),V(n),1===t.blending&&!1===t.transparent?k(0):k(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),a.setFunc(t.depthFunc),a.setTest(t.depthTest),a.setMask(t.depthWrite),s.setMask(t.colorWrite);const i=t.stencilWrite;o.setTest(i),i&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),j(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?O(32926):U(32926)},setFlipSided:V,setCullFace:W,setLineWidth:function(e){e!==w&&(A&&t.lineWidth(e),w=e)},setPolygonOffset:j,setScissorTest:function(t){t?O(3089):U(3089)},activeTexture:q,bindTexture:function(e,n){null===C&&q();let i=P[C];void 0===i&&(i={type:void 0,texture:void 0},P[C]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||F[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=P[C];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===N.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),N.copy(e))},viewport:function(e){!1===z.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),z.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===r&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),l={},C=null,P={},c=null,h={},u=null,d=!1,p=null,m=null,f=null,g=null,v=null,y=null,x=null,_=!1,M=null,b=null,w=null,S=null,T=null,N.set(0,0,t.canvas.width,t.canvas.height),z.set(0,0,t.canvas.width,t.canvas.height),s.reset(),a.reset(),o.reset()}}}function Vs(t,e,n,i,r,s,a){const o=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,x=r.maxTextureSize,R=r.maxSamples,C=new WeakMap;let P,I=!1;try{I="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function D(t,e){return I?new OffscreenCanvas(t,e):wt("canvas")}function N(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?gt:Math.floor,s=i(r*t.width),a=i(r*t.height);void 0===P&&(P=D(s,a));const o=n?D(s,a):P;o.width=s,o.height=a;return o.getContext("2d").drawImage(t,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function z(t){return mt(t.width)&&mt(t.height)}function B(t,e){return t.generateMipmaps&&e&&t.minFilter!==p&&t.minFilter!==g}function F(e,n,r,s,a=1){t.generateMipmap(e);i.get(n).__maxMipLevel=Math.log2(Math.max(r,s,a))}function O(n,i,r,s){if(!1===o)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let a=i;return 6403===i&&(5126===r&&(a=33326),5131===r&&(a=33325),5121===r&&(a=33321)),6407===i&&(5126===r&&(a=34837),5131===r&&(a=34843),5121===r&&(a=32849)),6408===i&&(5126===r&&(a=34836),5131===r&&(a=34842),5121===r&&(a=s===Y?35907:32856)),33325!==a&&33326!==a&&34842!==a&&34836!==a||e.get("EXT_color_buffer_float"),a}function U(t){return t===p||t===m||t===f?9728:9729}function H(e){const n=e.target;n.removeEventListener("dispose",H),function(e){const n=i.get(e);if(void 0===n.__webglInit)return;t.deleteTexture(n.__webglTexture),i.remove(e)}(n),n.isVideoTexture&&C.delete(n),a.memory.textures--}function G(e){const n=e.target;n.removeEventListener("dispose",G),function(e){const n=e.texture,r=i.get(e),s=i.get(n);if(!e)return;void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e]);else t.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&t.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);r.__webglTexture&&(t.deleteTexture(r.__webglTexture),a.memory.textures--),i.remove(n[e])}i.remove(n),i.remove(e)}(n)}let k=0;function V(t,e){const r=i.get(t);if(t.isVideoTexture&&function(t){const e=a.render.frame;C.get(t)!==e&&(C.set(t,e),t.update())}(t),t.version>0&&r.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void Z(r,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,r.__webglTexture)}function W(e,r){const a=i.get(e);e.version>0&&a.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;J(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const a=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,h=[];for(let t=0;t<6;t++)h[t]=a||l?l?i.image[t].image:i.image[t]:N(i.image[t],!1,!0,c);const u=h[0],d=z(u)||o,p=s.convert(i.format),m=s.convert(i.type),f=O(i.internalFormat,p,m,i.encoding);let g;if(X(34067,i,d),a){for(let t=0;t<6;t++){g=h[t].mipmaps;for(let e=0;e<g.length;e++){const r=g[e];i.format!==E&&i.format!==T?null!==p?n.compressedTexImage2D(34069+t,e,f,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,f,r.width,r.height,0,p,m,r.data)}}e.__maxMipLevel=g.length-1}else{g=i.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,f,h[t].width,h[t].height,0,p,m,h[t].data);for(let e=0;e<g.length;e++){const i=g[e].image[t].image;n.texImage2D(34069+t,e+1,f,i.width,i.height,0,p,m,i.data)}}else{n.texImage2D(34069+t,0,f,p,m,h[t]);for(let e=0;e<g.length;e++){const i=g[e];n.texImage2D(34069+t,e+1,f,p,m,i.image[t])}}e.__maxMipLevel=g.length}B(i,d)&&F(34067,i,u.width,u.height);e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(a,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,a.__webglTexture))}const j={[h]:10497,[u]:33071,[d]:33648},q={[p]:9728,[m]:9984,[f]:9986,[g]:9729,[v]:9985,[y]:9987};function X(n,s,a){if(a?(t.texParameteri(n,10242,j[s.wrapS]),t.texParameteri(n,10243,j[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,j[s.wrapR]),t.texParameteri(n,10240,q[s.magFilter]),t.texParameteri(n,10241,q[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===u&&s.wrapT===u||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,U(s.magFilter)),t.texParameteri(n,10241,U(s.minFilter)),s.minFilter!==p&&s.minFilter!==g&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(s.type===b&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&s.type===w&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function J(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",H),e.__webglTexture=t.createTexture(),a.memory.textures++)}function Z(e,i,r){let a=3553;i.isDataTexture2DArray&&(a=35866),i.isDataTexture3D&&(a=32879),J(e,i),n.activeTexture(33984+r),n.bindTexture(a,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const l=function(t){return!o&&(t.wrapS!==u||t.wrapT!==u||t.minFilter!==p&&t.minFilter!==g)}(i)&&!1===z(i.image),c=N(i.image,l,!1,x),h=z(c)||o,d=s.convert(i.format);let m,f=s.convert(i.type),v=O(i.internalFormat,d,f,i.encoding);X(a,i,h);const y=i.mipmaps;if(i.isDepthTexture)v=6402,o?v=i.type===b?36012:i.type===M?33190:i.type===S?35056:33189:i.type===b&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===A&&6402===v&&i.type!==_&&i.type!==M&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=_,f=s.convert(i.type)),i.format===L&&6402===v&&(v=34041,i.type!==S&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=S,f=s.convert(i.type))),n.texImage2D(3553,0,v,c.width,c.height,0,d,f,null);else if(i.isDataTexture)if(y.length>0&&h){for(let t=0,e=y.length;t<e;t++)m=y[t],n.texImage2D(3553,t,v,m.width,m.height,0,d,f,m.data);i.generateMipmaps=!1,e.__maxMipLevel=y.length-1}else n.texImage2D(3553,0,v,c.width,c.height,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let t=0,e=y.length;t<e;t++)m=y[t],i.format!==E&&i.format!==T?null!==d?n.compressedTexImage2D(3553,t,v,m.width,m.height,0,m.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,v,m.width,m.height,0,d,f,m.data);e.__maxMipLevel=y.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,v,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,v,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(y.length>0&&h){for(let t=0,e=y.length;t<e;t++)m=y[t],n.texImage2D(3553,t,v,d,f,m);i.generateMipmaps=!1,e.__maxMipLevel=y.length-1}else n.texImage2D(3553,0,v,d,f,c),e.__maxMipLevel=0;B(i,h)&&F(a,i,c.width,c.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function Q(e,r,a,o,l){const c=s.convert(a.format),h=s.convert(a.type),u=O(a.internalFormat,c,h,a.encoding);32879===l||35866===l?n.texImage3D(l,0,u,r.width,r.height,r.depth,0,c,h,null):n.texImage2D(l,0,u,r.width,r.height,0,c,h,null),n.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,l,i.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function K(e,n,i){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let r=33189;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===b?r=36012:e.type===M&&(r=33190));const i=tt(n);t.renderbufferStorageMultisample(36161,i,r,n.width,n.height)}else t.renderbufferStorage(36161,r,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=tt(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture,r=s.convert(e.format),a=s.convert(e.type),o=O(e.internalFormat,r,a,e.encoding);if(i){const e=tt(n);t.renderbufferStorageMultisample(36161,e,o,n.width,n.height)}else t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function $(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),V(r.depthTexture,0);const s=i.get(r.depthTexture).__webglTexture;if(r.depthTexture.format===A)t.framebufferTexture2D(36160,36096,3553,s,0);else{if(r.depthTexture.format!==L)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,s,0)}}(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(36160,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),K(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),K(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}function tt(t){return o&&t.isWebGLMultisampleRenderTarget?Math.min(R,t.samples):0}let et=!1,nt=!1;this.allocateTextureUnit=function(){const t=k;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),k+=1,t},this.resetTextureUnits=function(){k=0},this.setTexture2D=V,this.setTexture2DArray=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?Z(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?Z(r,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,r.__webglTexture))},this.setTextureCube=W,this.setupRenderTarget=function(e){const l=e.texture,c=i.get(e),h=i.get(l);e.addEventListener("dispose",G),!0!==e.isWebGLMultipleRenderTargets&&(h.__webglTexture=t.createTexture(),h.__version=l.version,a.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=!0===e.isWebGLMultisampleRenderTarget,m=l.isDataTexture3D||l.isDataTexture2DArray,f=z(e)||o;if(!o||l.format!==T||l.type!==b&&l.type!==w||(l.format=E,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),u){c.__webglFramebuffer=[];for(let e=0;e<6;e++)c.__webglFramebuffer[e]=t.createFramebuffer()}else if(c.__webglFramebuffer=t.createFramebuffer(),d)if(r.drawBuffers){const n=e.texture;for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);void 0===r.__webglTexture&&(r.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(p)if(o){c.__webglMultisampledFramebuffer=t.createFramebuffer(),c.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,c.__webglColorRenderbuffer);const i=s.convert(l.format),r=s.convert(l.type),a=O(l.internalFormat,i,r,l.encoding),o=tt(e);t.renderbufferStorageMultisample(36161,o,a,e.width,e.height),n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,c.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=t.createRenderbuffer(),K(c.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(u){n.bindTexture(34067,h.__webglTexture),X(34067,l,f);for(let t=0;t<6;t++)Q(c.__webglFramebuffer[t],e,l,36064,34069+t);B(l,f)&&F(34067,l,e.width,e.height),n.unbindTexture()}else if(d){const t=e.texture;for(let r=0,s=t.length;r<s;r++){const s=t[r],a=i.get(s);n.bindTexture(3553,a.__webglTexture),X(3553,s,f),Q(c.__webglFramebuffer,e,s,36064+r,3553),B(s,f)&&F(3553,s,e.width,e.height)}n.unbindTexture()}else{let t=3553;if(m)if(o){t=l.isDataTexture3D?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");n.bindTexture(t,h.__webglTexture),X(t,l,f),Q(c.__webglFramebuffer,e,l,36064,t),B(l,f)&&F(t,l,e.width,e.height,e.depth),n.unbindTexture()}e.depthBuffer&&$(e)},this.updateRenderTargetMipmap=function(t){const e=z(t)||o,r=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let s=0,a=r.length;s<a;s++){const a=r[s];if(B(a,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,r=i.get(a).__webglTexture;n.bindTexture(e,r),F(e,a,t.width,t.height),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(o){const r=e.width,s=e.height;let a=16384;e.depthBuffer&&(a|=256),e.stencilBuffer&&(a|=1024);const o=i.get(e);n.bindFramebuffer(36008,o.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,o.__webglFramebuffer),t.blitFramebuffer(0,0,r,s,0,0,r,s,a,9728),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,o.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===et&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),et=!0),t=t.texture),V(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===nt&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),nt=!0),t=t.texture),W(t,e)}}function Ws(t,e,n){const i=n.isWebGL2;return{convert:function(t){let n;if(t===x)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(t===_)return 5123;if(1013===t)return 5124;if(t===M)return 5125;if(t===b)return 5126;if(t===w)return i?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(t===T)return 6407;if(t===E)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(t===A)return 6402;if(t===L)return 34041;if(1028===t)return 6403;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(t===R||t===C||t===P||t===I){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(t===R)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===C)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===P)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===I)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===D||t===N||t===z||t===B){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(t===D)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===N)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===z)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===B)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((t===F||t===O)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(t===F)return n.COMPRESSED_RGB8_ETC2;if(t===O)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):36492===t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===S?i?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class js extends Kn{constructor(t=[]){super(),this.cameras=t}}js.prototype.isArrayCamera=!0;class qs extends Fe{constructor(){super(),this.type="Group"}}qs.prototype.isGroup=!0;const Xs={type:"move"};class Ys{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new qs,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new qs,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new zt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new zt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new qs,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new zt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new zt),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==a&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Xs))),l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n);if(void 0===l.joints[i.jointName]){const t=new qs;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[i.jointName]=t,l.add(t)}const r=l.joints[i.jointName];null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],a=i.position.distanceTo(r.position),o=.02,c=.005;l.inputState.pinching&&a>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==i),null!==o&&(o.visible=null!==r),null!==l&&(l.visible=null!==s),this}}class Js extends rt{constructor(t,e){super();const n=this,i=t.state;let r=null,s=1,a=null,o="local-floor",l=null,c=null,h=null,u=null,d=null,p=!1,m=null,f=null,g=null,v=null,y=null,x=null;const _=[],M=new Map,b=new Kn;b.layers.enable(1),b.viewport=new Ct;const w=new Kn;w.layers.enable(2),w.viewport=new Ct;const S=[b,w],T=new js;T.layers.enable(1),T.layers.enable(2);let E=null,A=null;function L(t){const e=M.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function R(){M.forEach((function(t,e){t.disconnect(e)})),M.clear(),E=null,A=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),h&&e.deleteFramebuffer(h),m&&e.deleteFramebuffer(m),f&&e.deleteRenderbuffer(f),g&&e.deleteRenderbuffer(g),h=null,m=null,f=null,g=null,d=null,u=null,c=null,r=null,z.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function C(t){const e=r.inputSources;for(let t=0;t<_.length;t++)M.set(e[t],_[t]);for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=M.get(n);i&&(i.dispatchEvent({type:"disconnected",data:n}),M.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],i=M.get(n);i&&i.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=_[t];return void 0===e&&(e=new Ys,_[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=_[t];return void 0===e&&(e=new Ys,_[t]=e),e.getGripSpace()},this.getHand=function(t){let e=_[t];return void 0===e&&(e=new Ys,_[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return c},this.getFrame=function(){return v},this.getSession=function(){return r},this.setSession=async function(t){if(r=t,null!==r){r.addEventListener("select",L),r.addEventListener("selectstart",L),r.addEventListener("selectend",L),r.addEventListener("squeeze",L),r.addEventListener("squeezestart",L),r.addEventListener("squeezeend",L),r.addEventListener("end",R),r.addEventListener("inputsourceschange",C);const t=e.getContextAttributes();if(!0!==t.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers){const n={antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:d})}else if(e instanceof WebGLRenderingContext){const n={antialias:!0,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,e,n),r.updateRenderState({layers:[d]})}else{p=t.antialias;let n=null;t.depth&&(x=256,t.stencil&&(x|=1024),y=t.stencil?33306:36096,n=t.stencil?35056:33190);const a={colorFormat:t.alpha?32856:32849,depthFormat:n,scaleFactor:s};c=new XRWebGLBinding(r,e),u=c.createProjectionLayer(a),h=e.createFramebuffer(),r.updateRenderState({layers:[u]}),p&&(m=e.createFramebuffer(),f=e.createRenderbuffer(),e.bindRenderbuffer(36161,f),e.renderbufferStorageMultisample(36161,4,32856,u.textureWidth,u.textureHeight),i.bindFramebuffer(36160,m),e.framebufferRenderbuffer(36160,36064,36161,f),e.bindRenderbuffer(36161,null),null!==n&&(g=e.createRenderbuffer(),e.bindRenderbuffer(36161,g),e.renderbufferStorageMultisample(36161,4,n,u.textureWidth,u.textureHeight),e.framebufferRenderbuffer(36160,y,36161,g),e.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}a=await r.requestReferenceSpace(o),z.setContext(r),z.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const P=new zt,I=new zt;function D(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;T.near=w.near=b.near=t.near,T.far=w.far=b.far=t.far,E===T.near&&A===T.far||(r.updateRenderState({depthNear:T.near,depthFar:T.far}),E=T.near,A=T.far);const e=t.parent,n=T.cameras;D(T,e);for(let t=0;t<n.length;t++)D(n[t],e);T.matrixWorld.decompose(T.position,T.quaternion,T.scale),t.position.copy(T.position),t.quaternion.copy(T.quaternion),t.scale.copy(T.scale),t.matrix.copy(T.matrix),t.matrixWorld.copy(T.matrixWorld);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){P.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(n.matrixWorld);const i=P.distanceTo(I),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,a=r[14]/(r[10]-1),o=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],h=(r[8]-1)/r[0],u=(s[8]+1)/s[0],d=a*h,p=a*u,m=i/(-h+u),f=m*-h;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(f),t.translateZ(m),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+m,v=o+m,y=d-f,x=p+(i-f),_=l*o/v*g,M=c*o/v*g;t.projectionMatrix.makePerspective(y,x,_,M,g,v)}(T,b,w):T.projectionMatrix.copy(b.projectionMatrix)},this.getCamera=function(){return T},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==d?d.fixedFoveation:void 0},this.setFoveation=function(t){null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};let N=null;const z=new hi;z.setAnimationLoop((function(t,n){if(l=n.getViewerPose(a),v=n,null!==l){const t=l.views;null!==d&&i.bindXRFramebuffer(d.framebuffer);let n=!1;t.length!==T.cameras.length&&(T.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const s=t[r];let a=null;if(null!==d)a=d.getViewport(s);else{const t=c.getViewSubImage(u,s);i.bindXRFramebuffer(h),void 0!==t.depthStencilTexture&&e.framebufferTexture2D(36160,y,3553,t.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,t.colorTexture,0),a=t.viewport}const o=S[r];o.matrix.fromArray(s.transform.matrix),o.projectionMatrix.fromArray(s.projectionMatrix),o.viewport.set(a.x,a.y,a.width,a.height),0===r&&T.matrix.copy(o.matrix),!0===n&&T.cameras.push(o)}p&&(i.bindXRFramebuffer(m),null!==x&&e.clear(x))}const s=r.inputSources;for(let t=0;t<_.length;t++){const e=_[t],i=s[t];e.update(i,n,a)}if(N&&N(t,n),p){const t=u.textureWidth,n=u.textureHeight;i.bindFramebuffer(36008,m),i.bindFramebuffer(36009,h),e.invalidateFramebuffer(36008,[y]),e.invalidateFramebuffer(36009,[y]),e.blitFramebuffer(0,0,t,n,0,0,t,n,16384,9728),e.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,m)}v=null})),this.setAnimationLoop=function(t){N=t},this.dispose=function(){}}}function Zs(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,e.reflectivity.value=n.reflectivity,e.ior.value=n.ior,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap?r=n.clearcoatRoughnessMap:n.specularIntensityMap?r=n.specularIntensityMap:n.specularColorMap?r=n.specularColorMap:n.transmissionMap?r=n.transmissionMap:n.thicknessMap?r=n.thicknessMap:n.sheenColorMap?r=n.sheenColorMap:n.sheenRoughnessMap&&(r=n.sheenRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias);t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s,a){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap);e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e,i){n(t,e),t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap));e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()));e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor));t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap);e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap)}(t,i,a):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias);t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);e.alphaTest>0&&(t.alphaTest.value=e.alphaTest);let n;e.map?n=e.map:e.alphaMap&&(n=e.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Qs(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=wt("canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,o=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",h=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let d=null,m=null;const f=[],g=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=X,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const v=this;let _=!1,M=0,S=0,T=null,A=-1,L=null;const R=new Ct,C=new Ct;let P=null,I=e.width,D=e.height,N=1,z=null,B=null;const F=new Ct(0,0,I,D),O=new Ct(0,0,I,D);let U=!1;const H=[],G=new ci;let k=!1,V=!1,W=null;const j=new de,q=new zt,Y={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function J(){return null===T?N:1}let Z,Q,K,$,tt,et,nt,it,rt,st,at,ot,lt,ct,ht,ut,dt,pt,mt,ft,gt,vt,yt,xt=n;function _t(t,n){for(let i=0;i<t.length;i++){const r=t[i],s=e.getContext(r,n);if(null!==s)return s}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if(e.addEventListener("webglcontextlost",St,!1),e.addEventListener("webglcontextrestored",Tt,!1),null===xt){const e=["webgl2","webgl","experimental-webgl"];if(!0===v.isWebGL1Renderer&&e.shift(),xt=_t(e,t),null===xt)throw _t(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===xt.getShaderPrecisionFormat&&(xt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function Mt(){Z=new Yi(xt),Q=new xi(xt,Z,t),Z.init(Q),vt=new Ws(xt,Z,Q),K=new ks(xt,Z,Q),H[0]=1029,$=new Qi(xt),tt=new Ls,et=new Vs(xt,Z,K,tt,Q,vt,$),nt=new Mi(v),it=new Xi(v),rt=new ui(xt,Q),yt=new vi(xt,Z,rt,Q),st=new Ji(xt,rt,$,yt),at=new ir(xt,st,rt,$),mt=new nr(xt,Q,et),ut=new _i(tt),ot=new As(v,nt,it,Z,Q,yt,ut),lt=new Zs(tt),ct=new Is(tt),ht=new Os(Z,Q),pt=new gi(v,nt,K,at,o),dt=new Gs(v,at,Q),ft=new yi(xt,Z,$,Q),gt=new Zi(xt,Z,$,Q),$.programs=ot.programs,v.capabilities=Q,v.extensions=Z,v.properties=tt,v.renderLists=ct,v.shadowMap=dt,v.state=K,v.info=$}Mt();const bt=new Js(v,xt);function St(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function Tt(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const t=$.autoReset,e=dt.enabled,n=dt.autoUpdate,i=dt.needsUpdate,r=dt.type;Mt(),$.autoReset=t,dt.enabled=e,dt.autoUpdate=n,dt.needsUpdate=i,dt.type=r}function Et(t){const e=t.target;e.removeEventListener("dispose",Et),function(t){(function(t){const e=tt.get(t).programs;void 0!==e&&e.forEach((function(t){ot.releaseProgram(t)}))})(t),tt.remove(t)}(e)}this.xr=bt,this.getContext=function(){return xt},this.getContextAttributes=function(){return xt.getContextAttributes()},this.forceContextLoss=function(){const t=Z.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=Z.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(t){void 0!==t&&(N=t,this.setSize(I,D,!1))},this.getSize=function(t){return t.set(I,D)},this.setSize=function(t,n,i){bt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(I=t,D=n,e.width=Math.floor(t*N),e.height=Math.floor(n*N),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(I*N,D*N).floor()},this.setDrawingBufferSize=function(t,n,i){I=t,D=n,N=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(R)},this.getViewport=function(t){return t.copy(F)},this.setViewport=function(t,e,n,i){t.isVector4?F.set(t.x,t.y,t.z,t.w):F.set(t,e,n,i),K.viewport(R.copy(F).multiplyScalar(N).floor())},this.getScissor=function(t){return t.copy(O)},this.setScissor=function(t,e,n,i){t.isVector4?O.set(t.x,t.y,t.z,t.w):O.set(t,e,n,i),K.scissor(C.copy(O).multiplyScalar(N).floor())},this.getScissorTest=function(){return U},this.setScissorTest=function(t){K.setScissorTest(U=t)},this.setOpaqueSort=function(t){z=t},this.setTransparentSort=function(t){B=t},this.getClearColor=function(t){return t.copy(pt.getClearColor())},this.setClearColor=function(){pt.setClearColor.apply(pt,arguments)},this.getClearAlpha=function(){return pt.getClearAlpha()},this.setClearAlpha=function(){pt.setClearAlpha.apply(pt,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=16384),(void 0===e||e)&&(i|=256),(void 0===n||n)&&(i|=1024),xt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",St,!1),e.removeEventListener("webglcontextrestored",Tt,!1),ct.dispose(),ht.dispose(),tt.dispose(),nt.dispose(),it.dispose(),at.dispose(),yt.dispose(),bt.dispose(),bt.removeEventListener("sessionstart",Lt),bt.removeEventListener("sessionend",Rt),W&&(W.dispose(),W=null),It.stop()},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=Y);const a=r.isMesh&&r.matrixWorld.determinant()<0,o=function(t,e,n,i,r){!0!==e.isScene&&(e=Y);et.resetTextureUnits();const s=e.fog,a=i.isMeshStandardMaterial?e.environment:null,o=null===T?v.outputEncoding:T.texture.encoding,l=(i.isMeshStandardMaterial?it:nt).get(i.envMap||a),c=!0===i.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!i.normalMap&&!!n.attributes.tangent,u=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=n.morphAttributes.position?n.morphAttributes.position.length:0,f=tt.get(i),g=m.state.lights;if(!0===k&&(!0===V||t!==L)){const e=t===L&&i.id===A;ut.setState(i,t,e)}let y=!1;i.version===f.__version?f.needsLights&&f.lightsStateVersion!==g.state.version||f.outputEncoding!==o||r.isInstancedMesh&&!1===f.instancing?y=!0:r.isInstancedMesh||!0!==f.instancing?r.isSkinnedMesh&&!1===f.skinning?y=!0:r.isSkinnedMesh||!0!==f.skinning?f.envMap!==l||i.fog&&f.fog!==s?y=!0:void 0===f.numClippingPlanes||f.numClippingPlanes===ut.numPlanes&&f.numIntersection===ut.numIntersection?(f.vertexAlphas!==c||f.vertexTangents!==h||f.morphTargets!==u||f.morphNormals!==d||!0===Q.isWebGL2&&f.morphTargetsCount!==p)&&(y=!0):y=!0:y=!0:y=!0:(y=!0,f.__version=i.version);let x=f.currentProgram;!0===y&&(x=Ut(i,e,r));let _=!1,M=!1,b=!1;const w=x.getUniforms(),S=f.uniforms;K.useProgram(x.program)&&(_=!0,M=!0,b=!0);i.id!==A&&(A=i.id,M=!0);if(_||L!==t){if(w.setValue(xt,"projectionMatrix",t.projectionMatrix),Q.logarithmicDepthBuffer&&w.setValue(xt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),L!==t&&(L=t,M=!0,b=!0),i.isShaderMaterial||i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshStandardMaterial||i.envMap){const e=w.map.cameraPosition;void 0!==e&&e.setValue(xt,q.setFromMatrixPosition(t.matrixWorld))}(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial)&&w.setValue(xt,"isOrthographic",!0===t.isOrthographicCamera),(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial||i.isShadowMaterial||r.isSkinnedMesh)&&w.setValue(xt,"viewMatrix",t.matrixWorldInverse)}if(r.isSkinnedMesh){w.setOptional(xt,r,"bindMatrix"),w.setOptional(xt,r,"bindMatrixInverse");const t=r.skeleton;t&&(Q.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),w.setValue(xt,"boneTexture",t.boneTexture,et),w.setValue(xt,"boneTextureSize",t.boneTextureSize)):w.setOptional(xt,t,"boneMatrices"))}!n||void 0===n.morphAttributes.position&&void 0===n.morphAttributes.normal||mt.update(r,n,i,x);(M||f.receiveShadow!==r.receiveShadow)&&(f.receiveShadow=r.receiveShadow,w.setValue(xt,"receiveShadow",r.receiveShadow));M&&(w.setValue(xt,"toneMappingExposure",v.toneMappingExposure),f.needsLights&&(R=b,(E=S).ambientLightColor.needsUpdate=R,E.lightProbe.needsUpdate=R,E.directionalLights.needsUpdate=R,E.directionalLightShadows.needsUpdate=R,E.pointLights.needsUpdate=R,E.pointLightShadows.needsUpdate=R,E.spotLights.needsUpdate=R,E.spotLightShadows.needsUpdate=R,E.rectAreaLights.needsUpdate=R,E.hemisphereLights.needsUpdate=R),s&&i.fog&&lt.refreshFogUniforms(S,s),lt.refreshMaterialUniforms(S,i,N,D,W),as.upload(xt,f.uniformsList,S,et));var E,R;i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(as.upload(xt,f.uniformsList,S,et),i.uniformsNeedUpdate=!1);i.isSpriteMaterial&&w.setValue(xt,"center",r.center);return w.setValue(xt,"modelViewMatrix",r.modelViewMatrix),w.setValue(xt,"normalMatrix",r.normalMatrix),w.setValue(xt,"modelMatrix",r.matrixWorld),x}(t,e,n,i,r);K.setMaterial(i,a);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let h,u=1;!0===i.wireframe&&(l=st.getWireframeAttribute(n),u=2),yt.setup(r,i,o,n,l);let d=ft;null!==l&&(h=rt.get(l),d=gt,d.setIndex(h));const p=null!==l?l.count:c.count,f=n.drawRange.start*u,g=n.drawRange.count*u,y=null!==s?s.start*u:0,x=null!==s?s.count*u:1/0,_=Math.max(f,y),M=Math.min(p,f+g,y+x)-1,b=Math.max(0,M-_+1);if(0!==b){if(r.isMesh)!0===i.wireframe?(K.setLineWidth(i.wireframeLinewidth*J()),d.setMode(1)):d.setMode(4);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),K.setLineWidth(t*J()),r.isLineSegments?d.setMode(1):r.isLineLoop?d.setMode(2):d.setMode(3)}else r.isPoints?d.setMode(0):r.isSprite&&d.setMode(4);if(r.isInstancedMesh)d.renderInstances(_,b,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(_,b,t)}else d.render(_,b)}},this.compile=function(t,e){m=ht.get(t),m.init(),g.push(m),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(m.pushLight(t),t.castShadow&&m.pushShadow(t))})),m.setupLights(v.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let i=0;i<n.length;i++){Ut(n[i],t,e)}else Ut(n,t,e)})),g.pop(),m=null};let At=null;function Lt(){It.stop()}function Rt(){It.start()}const It=new hi;function Nt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)m.pushLight(t),t.castShadow&&m.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||G.intersectsSprite(t)){i&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);const e=at.update(t),r=t.material;r.visible&&d.push(t,e,r,n,q.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==$.render.frame&&(t.skeleton.update(),t.skeleton.frame=$.render.frame),!t.frustumCulled||G.intersectsObject(t))){i&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);const e=at.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,a=i.length;s<a;s++){const a=i[s],o=r[a.materialIndex];o&&o.visible&&d.push(t,e,o,n,q.z,a)}}else r.visible&&d.push(t,e,r,n,q.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)Nt(r[t],e,n,i)}function Bt(t,e,n,i){const r=t.opaque,s=t.transmissive,o=t.transparent;m.setupLightsView(n),s.length>0&&function(t,e,n){if(null===W){const t=!0===a&&!0===Q.isWebGL2;W=new(t?Dt:Pt)(1024,1024,{generateMipmaps:!0,type:null!==vt.convert(w)?w:x,minFilter:y,magFilter:p,wrapS:u,wrapT:u})}const i=v.getRenderTarget();v.setRenderTarget(W),v.clear();const r=v.toneMapping;v.toneMapping=0,Ft(t,e,n),v.toneMapping=r,et.updateMultisampleRenderTarget(W),et.updateRenderTargetMipmap(W),v.setRenderTarget(i)}(r,e,n),i&&K.viewport(R.copy(i)),r.length>0&&Ft(r,e,n),s.length>0&&Ft(s,e,n),o.length>0&&Ft(o,e,n)}function Ft(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],a=s.object,o=s.geometry,l=null===i?s.material:i,c=s.group;a.layers.test(n.layers)&&Ot(a,e,n,o,l,c)}}function Ot(t,e,n,i,r,s){t.onBeforeRender(v,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),r.onBeforeRender(v,e,n,i,t,s),!0===r.transparent&&2===r.side?(r.side=1,r.needsUpdate=!0,v.renderBufferDirect(n,e,i,r,t,s),r.side=0,r.needsUpdate=!0,v.renderBufferDirect(n,e,i,r,t,s),r.side=2):v.renderBufferDirect(n,e,i,r,t,s),t.onAfterRender(v,e,n,i,r,s)}function Ut(t,e,n){!0!==e.isScene&&(e=Y);const i=tt.get(t),r=m.state.lights,s=m.state.shadowsArray,a=r.state.version,o=ot.getParameters(t,r.state,s,e,n),l=ot.getProgramCacheKey(o);let c=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?it:nt).get(t.envMap||i.environment),void 0===c&&(t.addEventListener("dispose",Et),c=new Map,i.programs=c);let h=c.get(l);if(void 0!==h){if(i.currentProgram===h&&i.lightsStateVersion===a)return Ht(t,o),h}else o.uniforms=ot.getUniforms(t),t.onBuild(n,o,v),t.onBeforeCompile(o,v),h=ot.acquireProgram(o,l),c.set(l,h),i.uniforms=o.uniforms;const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=ut.uniform),Ht(t,o),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=a,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotShadowMatrix.value=r.state.spotShadowMatrix,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const d=h.getUniforms(),p=as.seqWithValue(d.seq,u);return i.currentProgram=h,i.uniformsList=p,h}function Ht(t,e){const n=tt.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents}It.setAnimationLoop((function(t){At&&At(t)})),"undefined"!=typeof window&&It.setContext(window),this.setAnimationLoop=function(t){At=t,bt.setAnimationLoop(t),null===t?It.stop():It.start()},bt.addEventListener("sessionstart",Lt),bt.addEventListener("sessionend",Rt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===_)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===bt.enabled&&!0===bt.isPresenting&&(!0===bt.cameraAutoUpdate&&bt.updateCamera(e),e=bt.getCamera()),!0===t.isScene&&t.onBeforeRender(v,t,e,T),m=ht.get(t,g.length),m.init(),g.push(m),j.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),G.setFromProjectionMatrix(j),V=this.localClippingEnabled,k=ut.init(this.clippingPlanes,V,e),d=ct.get(t,f.length),d.init(),f.push(d),Nt(t,e,0,v.sortObjects),d.finish(),!0===v.sortObjects&&d.sort(z,B),!0===k&&ut.beginShadows();const n=m.state.shadowsArray;if(dt.render(n,t,e),!0===k&&ut.endShadows(),!0===this.info.autoReset&&this.info.reset(),pt.render(d,t),m.setupLights(v.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,i=n.length;e<i;e++){const i=n[e];Bt(d,t,i,i.viewport)}}else Bt(d,t,e);null!==T&&(et.updateMultisampleRenderTarget(T),et.updateRenderTargetMipmap(T)),!0===t.isScene&&t.onAfterRender(v,t,e),K.buffers.depth.setTest(!0),K.buffers.depth.setMask(!0),K.buffers.color.setMask(!0),K.setPolygonOffset(!1),yt.resetDefaultState(),A=-1,L=null,g.pop(),m=g.length>0?g[g.length-1]:null,f.pop(),d=f.length>0?f[f.length-1]:null},this.getActiveCubeFace=function(){return M},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return T},this.setRenderTarget=function(t,e=0,n=0){T=t,M=e,S=n,t&&void 0===tt.get(t).__webglFramebuffer&&et.setupRenderTarget(t);let i=null,r=!1,s=!1;if(t){const n=t.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(s=!0);const a=tt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=a[e],r=!0):i=t.isWebGLMultisampleRenderTarget?tt.get(t).__webglMultisampledFramebuffer:a,R.copy(t.viewport),C.copy(t.scissor),P=t.scissorTest}else R.copy(F).multiplyScalar(N).floor(),C.copy(O).multiplyScalar(N).floor(),P=U;if(K.bindFramebuffer(36160,i)&&Q.drawBuffers){let e=!1;if(t)if(t.isWebGLMultipleRenderTargets){const n=t.texture;if(H.length!==n.length||36064!==H[0]){for(let t=0,e=n.length;t<e;t++)H[t]=36064+t;H.length=n.length,e=!0}}else 1===H.length&&36064===H[0]||(H[0]=36064,H.length=1,e=!0);else 1===H.length&&1029===H[0]||(H[0]=1029,H.length=1,e=!0);e&&(Q.isWebGL2?xt.drawBuffers(H):Z.get("WEBGL_draw_buffers").drawBuffersWEBGL(H))}if(K.viewport(R),K.scissor(C),K.setScissorTest(P),r){const i=tt.get(t.texture);xt.framebufferTexture2D(36160,36064,34069+e,i.__webglTexture,n)}else if(s){const i=tt.get(t.texture),r=e||0;xt.framebufferTextureLayer(36160,36064,i.__webglTexture,n||0,r)}A=-1},this.readRenderTargetPixels=function(t,e,n,i,r,s,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=tt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){K.bindFramebuffer(36160,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==E&&vt.convert(o)!==xt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===w&&(Z.has("EXT_color_buffer_half_float")||Q.isWebGL2&&Z.has("EXT_color_buffer_float"));if(!(l===x||vt.convert(l)===xt.getParameter(35738)||l===b&&(Q.isWebGL2||Z.has("OES_texture_float")||Z.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===xt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&xt.readPixels(e,n,i,r,vt.convert(o),vt.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==T?tt.get(T).__webglFramebuffer:null;K.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i);let a=vt.convert(e.format);Q.isWebGL2&&(6407===a&&(a=32849),6408===a&&(a=32856)),et.setTexture2D(e,0),xt.copyTexImage2D(3553,n,a,t.x,t.y,r,s,0),K.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,a=vt.convert(n.format),o=vt.convert(n.type);et.setTexture2D(n,0),xt.pixelStorei(37440,n.flipY),xt.pixelStorei(37441,n.premultiplyAlpha),xt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?xt.texSubImage2D(3553,i,t.x,t.y,r,s,a,o,e.image.data):e.isCompressedTexture?xt.compressedTexSubImage2D(3553,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):xt.texSubImage2D(3553,i,t.x,t.y,a,o,e.image),0===i&&n.generateMipmaps&&xt.generateMipmap(3553),K.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(v.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=vt.convert(i.format),c=vt.convert(i.type);let h;if(i.isDataTexture3D)et.setTexture3D(i,0),h=32879;else{if(!i.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");et.setTexture2DArray(i,0),h=35866}xt.pixelStorei(37440,i.flipY),xt.pixelStorei(37441,i.premultiplyAlpha),xt.pixelStorei(3317,i.unpackAlignment);const u=xt.getParameter(3314),d=xt.getParameter(32878),p=xt.getParameter(3316),m=xt.getParameter(3315),f=xt.getParameter(32877),g=n.isCompressedTexture?n.mipmaps[0]:n.image;xt.pixelStorei(3314,g.width),xt.pixelStorei(32878,g.height),xt.pixelStorei(3316,t.min.x),xt.pixelStorei(3315,t.min.y),xt.pixelStorei(32877,t.min.z),n.isDataTexture||n.isDataTexture3D?xt.texSubImage3D(h,r,e.x,e.y,e.z,s,a,o,l,c,g.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),xt.compressedTexSubImage3D(h,r,e.x,e.y,e.z,s,a,o,l,g.data)):xt.texSubImage3D(h,r,e.x,e.y,e.z,s,a,o,l,c,g),xt.pixelStorei(3314,u),xt.pixelStorei(32878,d),xt.pixelStorei(3316,p),xt.pixelStorei(3315,m),xt.pixelStorei(32877,f),0===r&&i.generateMipmaps&&xt.generateMipmap(h),K.unbindTexture()},this.initTexture=function(t){et.setTexture2D(t,0),K.unbindTexture()},this.resetState=function(){M=0,S=0,T=null,K.reset(),yt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Qs.prototype.isWebGLRenderer=!0;class Ks extends Qs{}Ks.prototype.isWebGL1Renderer=!0;class $s{constructor(t,e=25e-5){this.name="",this.color=new rn(t),this.density=e}clone(){return new $s(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}$s.prototype.isFogExp2=!0;class ta{constructor(t,e=1,n=1e3){this.name="",this.color=new rn(t),this.near=e,this.far=n}clone(){return new ta(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}ta.prototype.isFog=!0;class ea extends Fe{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}ea.prototype.isScene=!0;class na{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=et,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=ht()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=ht()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=ht()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}na.prototype.isInterleavedBuffer=!0;const ia=new zt;class ra{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.applyMatrix4(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.applyNormalMatrix(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ia.x=this.getX(e),ia.y=this.getY(e),ia.z=this.getZ(e),ia.transformDirection(t),this.setXYZ(e,ia.x,ia.y,ia.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new ln(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ra(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ra.prototype.isInterleavedBufferAttribute=!0;class sa extends Ze{constructor(t){super(),this.type="SpriteMaterial",this.color=new rn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}let aa;sa.prototype.isSpriteMaterial=!0;const oa=new zt,la=new zt,ca=new zt,ha=new yt,ua=new yt,da=new de,pa=new zt,ma=new zt,fa=new zt,ga=new yt,va=new yt,ya=new yt;class xa extends Fe{constructor(t){if(super(),this.type="Sprite",void 0===aa){aa=new En;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new na(t,5);aa.setIndex([0,1,2,0,2,3]),aa.setAttribute("position",new ra(e,3,0,!1)),aa.setAttribute("uv",new ra(e,2,3,!1))}this.geometry=aa,this.material=void 0!==t?t:new sa,this.center=new yt(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),la.setFromMatrixScale(this.matrixWorld),da.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),ca.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&la.multiplyScalar(-ca.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;_a(pa.set(-.5,-.5,0),ca,s,la,i,r),_a(ma.set(.5,-.5,0),ca,s,la,i,r),_a(fa.set(.5,.5,0),ca,s,la,i,r),ga.set(0,0),va.set(1,0),ya.set(1,1);let a=t.ray.intersectTriangle(pa,ma,fa,!1,oa);if(null===a&&(_a(ma.set(-.5,.5,0),ca,s,la,i,r),va.set(0,1),a=t.ray.intersectTriangle(pa,fa,ma,!1,oa),null===a))return;const o=t.ray.origin.distanceTo(oa);o<t.near||o>t.far||e.push({distance:o,point:oa.clone(),uv:Ye.getUV(oa,pa,ma,fa,ga,va,ya,new yt),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function _a(t,e,n,i,r,s){ha.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(ua.x=s*ha.x-r*ha.y,ua.y=r*ha.x+s*ha.y):ua.copy(ha),t.copy(e),t.x+=ua.x,t.y+=ua.y,t.applyMatrix4(da)}xa.prototype.isSprite=!0;const Ma=new zt,ba=new zt;class wa extends Fe{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const n=this.levels;let i;for(i=0;i<n.length&&!(e<n[i].distance);i++);return n.splice(i,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i&&!(t<e[n].distance);n++);return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Ma.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Ma);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Ma.setFromMatrixPosition(t.matrixWorld),ba.setFromMatrixPosition(this.matrixWorld);const n=Ma.distanceTo(ba)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r&&n>=e[i].distance;i++)e[i-1].object.visible=!1,e[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,i=n.length;t<i;t++){const i=n[t];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}}const Sa=new zt,Ta=new Ct,Ea=new Ct,Aa=new zt,La=new de;class Ra extends Wn{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new de,this.bindMatrixInverse=new de}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Ct,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Ta.fromBufferAttribute(i.attributes.skinIndex,t),Ea.fromBufferAttribute(i.attributes.skinWeight,t),Sa.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=Ea.getComponent(t);if(0!==i){const r=Ta.getComponent(t);La.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Aa.copy(Sa).applyMatrix4(La),i)}}return e.applyMatrix4(this.bindMatrixInverse)}}Ra.prototype.isSkinnedMesh=!0;class Ca extends Fe{constructor(){super(),this.type="Bone"}}Ca.prototype.isBone=!0;class Pa extends Lt{constructor(t=null,e=1,n=1,i,r,s,a,o,l=1003,c=1003,h,u){super(null,s,a,o,l,c,i,r,h,u),this.image={data:t,width:e,height:n},this.magFilter=l,this.minFilter=c,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Pa.prototype.isDataTexture=!0;const Ia=new de,Da=new de;class Na{constructor(t=[],e=[]){this.uuid=ht(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new de)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new de;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,r=t.length;i<r;i++){const r=t[i]?t[i].matrixWorld:Da;Ia.multiplyMatrices(r,e[i]),Ia.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)}clone(){return new Na(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=ft(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new Pa(e,t,t,E,b);return this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new Ca),this.bones.push(r),this.boneInverses.push((new de).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const r=e[i];t.bones.push(r.uuid);const s=n[i];t.boneInverses.push(s.toArray())}return t}}class za extends ln{constructor(t,e,n,i=1){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}za.prototype.isInstancedBufferAttribute=!0;const Ba=new de,Fa=new de,Oa=[],Ua=new Wn;class Ha extends Wn{constructor(t,e,n){super(t,e),this.instanceMatrix=new za(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(Ua.geometry=this.geometry,Ua.material=this.material,void 0!==Ua.material)for(let r=0;r<i;r++){this.getMatrixAt(r,Ba),Fa.multiplyMatrices(n,Ba),Ua.matrixWorld=Fa,Ua.raycast(t,Oa);for(let t=0,n=Oa.length;t<n;t++){const n=Oa[t];n.instanceId=r,n.object=this,e.push(n)}Oa.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new za(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Ha.prototype.isInstancedMesh=!0;class Ga extends Ze{constructor(t){super(),this.type="LineBasicMaterial",this.color=new rn(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}Ga.prototype.isLineBasicMaterial=!0;const ka=new zt,Va=new zt,Wa=new de,ja=new ue,qa=new ie;class Xa extends Fe{constructor(t=new En,e=new Ga){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)ka.fromBufferAttribute(e,t-1),Va.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=ka.distanceTo(Va);t.setAttribute("lineDistance",new vn(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),qa.copy(n.boundingSphere),qa.applyMatrix4(i),qa.radius+=r,!1===t.ray.intersectsSphere(qa))return;Wa.copy(i).invert(),ja.copy(t.ray).applyMatrix4(Wa);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new zt,c=new zt,h=new zt,u=new zt,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,r=n.attributes.position;if(null!==i){for(let n=Math.max(0,s.start),a=Math.min(i.count,s.start+s.count)-1;n<a;n+=d){const s=i.getX(n),a=i.getX(n+1);l.fromBufferAttribute(r,s),c.fromBufferAttribute(r,a);if(ja.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(u);d<t.near||d>t.far||e.push({distance:d,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else{for(let n=Math.max(0,s.start),i=Math.min(r.count,s.start+s.count)-1;n<i;n+=d){l.fromBufferAttribute(r,n),c.fromBufferAttribute(r,n+1);if(ja.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Xa.prototype.isLine=!0;const Ya=new zt,Ja=new zt;class Za extends Xa{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)Ya.fromBufferAttribute(e,t),Ja.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+Ya.distanceTo(Ja);t.setAttribute("lineDistance",new vn(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Za.prototype.isLineSegments=!0;class Qa extends Xa{constructor(t,e){super(t,e),this.type="LineLoop"}}Qa.prototype.isLineLoop=!0;class Ka extends Ze{constructor(t){super(),this.type="PointsMaterial",this.color=new rn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}Ka.prototype.isPointsMaterial=!0;const $a=new de,to=new ue,eo=new ie,no=new zt;class io extends Fe{constructor(t=new En,e=new Ka){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),eo.copy(n.boundingSphere),eo.applyMatrix4(i),eo.radius+=r,!1===t.ray.intersectsSphere(eo))return;$a.copy(i).invert(),to.copy(t.ray).applyMatrix4($a);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){const r=n.index,a=n.attributes.position;if(null!==r){for(let n=Math.max(0,s.start),l=Math.min(r.count,s.start+s.count);n<l;n++){const s=r.getX(n);no.fromBufferAttribute(a,s),ro(no,s,o,i,t,e,this)}}else{for(let n=Math.max(0,s.start),r=Math.min(a.count,s.start+s.count);n<r;n++)no.fromBufferAttribute(a,n),ro(no,n,o,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function ro(t,e,n,i,r,s,a){const o=to.distanceSqToPoint(t);if(o<n){const n=new zt;to.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}io.prototype.isPoints=!0;class so extends Lt{constructor(t,e,n,i,r,s,a,o,l){super(t,e,n,i,r,s,a,o,l),this.format=void 0!==a?a:T,this.minFilter=void 0!==s?s:g,this.magFilter=void 0!==r?r:g,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}so.prototype.isVideoTexture=!0;class ao extends Lt{constructor(t,e,n,i,r,s,a,o,l,c,h,u){super(null,s,a,o,l,c,i,r,h,u),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}ao.prototype.isCompressedTexture=!0;class oo extends Lt{constructor(t,e,n,i,r,s,a,o,l){super(t,e,n,i,r,s,a,o,l),this.needsUpdate=!0}}oo.prototype.isCanvasTexture=!0;class lo extends Lt{constructor(t,e,n,i,r,s,a,o,l,c){if((c=void 0!==c?c:A)!==A&&c!==L)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===A&&(n=_),void 0===n&&c===L&&(n=S),super(null,i,r,s,a,o,c,n,l),this.image={width:t,height:e},this.magFilter=void 0!==a?a:p,this.minFilter=void 0!==o?o:p,this.flipY=!1,this.generateMipmaps=!1}}lo.prototype.isDepthTexture=!0;class co extends En{constructor(t=1,e=8,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],s=[],a=[],o=[],l=new zt,c=new yt;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let r=0,h=3;r<=e;r++,h+=3){const u=n+r/e*i;l.x=t*Math.cos(u),l.y=t*Math.sin(u),s.push(l.x,l.y,l.z),a.push(0,0,1),c.x=(s[h]/t+1)/2,c.y=(s[h+1]/t+1)/2,o.push(c.x,c.y)}for(let t=1;t<=e;t++)r.push(t,t+1,0);this.setIndex(r),this.setAttribute("position",new vn(s,3)),this.setAttribute("normal",new vn(a,3)),this.setAttribute("uv",new vn(o,2))}static fromJSON(t){return new co(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class ho extends En{constructor(t=1,e=1,n=1,i=8,r=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:a,thetaLength:o};const l=this;i=Math.floor(i),r=Math.floor(r);const c=[],h=[],u=[],d=[];let p=0;const m=[],f=n/2;let g=0;function v(n){const r=p,s=new yt,m=new zt;let v=0;const y=!0===n?t:e,x=!0===n?1:-1;for(let t=1;t<=i;t++)h.push(0,f*x,0),u.push(0,x,0),d.push(.5,.5),p++;const _=p;for(let t=0;t<=i;t++){const e=t/i*o+a,n=Math.cos(e),r=Math.sin(e);m.x=y*r,m.y=f*x,m.z=y*n,h.push(m.x,m.y,m.z),u.push(0,x,0),s.x=.5*n+.5,s.y=.5*r*x+.5,d.push(s.x,s.y),p++}for(let t=0;t<i;t++){const e=r+t,i=_+t;!0===n?c.push(i,i+1,e):c.push(i+1,i,e),v+=3}l.addGroup(g,v,!0===n?1:2),g+=v}!function(){const s=new zt,v=new zt;let y=0;const x=(e-t)/n;for(let l=0;l<=r;l++){const c=[],g=l/r,y=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*o+a,l=Math.sin(r),m=Math.cos(r);v.x=y*l,v.y=-g*n+f,v.z=y*m,h.push(v.x,v.y,v.z),s.set(l,x,m).normalize(),u.push(s.x,s.y,s.z),d.push(e,1-g),c.push(p++)}m.push(c)}for(let t=0;t<i;t++)for(let e=0;e<r;e++){const n=m[e][t],i=m[e+1][t],r=m[e+1][t+1],s=m[e][t+1];c.push(n,i,s),c.push(i,r,s),y+=6}l.addGroup(g,y,0),g+=y}(),!1===s&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(c),this.setAttribute("position",new vn(h,3)),this.setAttribute("normal",new vn(u,3)),this.setAttribute("uv",new vn(d,2))}static fromJSON(t){return new ho(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class uo extends ho{constructor(t=1,e=1,n=8,i=1,r=!1,s=0,a=2*Math.PI){super(0,t,e,n,i,r,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:a}}static fromJSON(t){return new uo(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class po extends En{constructor(t=[],e=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],s=[];function a(t,e,n,i){const r=i+1,s=[];for(let i=0;i<=r;i++){s[i]=[];const a=t.clone().lerp(n,i/r),o=e.clone().lerp(n,i/r),l=r-i;for(let t=0;t<=l;t++)s[i][t]=0===t&&i===r?a:a.clone().lerp(o,t/l)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(s[t][n+1]),o(s[t+1][n]),o(s[t][n])):(o(s[t][n+1]),o(s[t+1][n+1]),o(s[t+1][n]))}}function o(t){r.push(t.x,t.y,t.z)}function l(e,n){const i=3*e;n.x=t[i+0],n.y=t[i+1],n.z=t[i+2]}function c(t,e,n,i){i<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=i/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new zt,i=new zt,r=new zt;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],i),l(e[s+2],r),a(n,i,r,t)}(i),function(t){const e=new zt;for(let n=0;n<r.length;n+=3)e.x=r[n+0],e.y=r[n+1],e.z=r[n+2],e.normalize().multiplyScalar(t),r[n+0]=e.x,r[n+1]=e.y,r[n+2]=e.z}(n),function(){const t=new zt;for(let n=0;n<r.length;n+=3){t.x=r[n+0],t.y=r[n+1],t.z=r[n+2];const i=h(t)/2/Math.PI+.5,a=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);s.push(i,1-a)}var e;(function(){const t=new zt,e=new zt,n=new zt,i=new zt,a=new yt,o=new yt,l=new yt;for(let u=0,d=0;u<r.length;u+=9,d+=6){t.set(r[u+0],r[u+1],r[u+2]),e.set(r[u+3],r[u+4],r[u+5]),n.set(r[u+6],r[u+7],r[u+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),i.copy(t).add(e).add(n).divideScalar(3);const p=h(i);c(a,d+0,t,p),c(o,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],i=s[t+4],r=Math.max(e,n,i),a=Math.min(e,n,i);r>.9&&a<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),i<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new vn(r,3)),this.setAttribute("normal",new vn(r.slice(),3)),this.setAttribute("uv",new vn(s,2)),0===i?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new po(t.vertices,t.indices,t.radius,t.details)}}class mo extends po{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new mo(t.radius,t.detail)}}const fo=new zt,go=new zt,vo=new zt,yo=new Ye;class xo extends En{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,i=Math.pow(10,n),r=Math.cos(at*e),s=t.getIndex(),a=t.getAttribute("position"),o=s?s.count:a.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let t=0;t<o;t+=3){s?(l[0]=s.getX(t),l[1]=s.getX(t+1),l[2]=s.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:o}=yo;if(e.fromBufferAttribute(a,l[0]),n.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),yo.getNormal(vo),h[0]=`${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`,h[1]=`${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`,h[2]=`${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=h[t],i=h[e],s=yo[c[t]],a=yo[c[e]],o=`${n}_${i}`,p=`${i}_${n}`;p in u&&u[p]?(vo.dot(u[p].normal)<=r&&(d.push(s.x,s.y,s.z),d.push(a.x,a.y,a.z)),u[p]=null):o in u||(u[o]={index0:l[t],index1:l[e],normal:vo.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];fo.fromBufferAttribute(a,e),go.fromBufferAttribute(a,n),d.push(fo.x,fo.y,fo.z),d.push(go.x,go.y,go.z)}this.setAttribute("position",new vn(d,3))}}}class _o{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let a,o=0,l=r-1;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),a=n[i]-s,a<0)o=i+1;else{if(!(a>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const c=n[i];return(i+(s-c)/(n[i+1]-c))/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),a=this.getPoint(r),o=e||(s.isVector2?new yt:new zt);return o.copy(a).sub(s).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new zt,i=[],r=[],s=[],a=new zt,o=new de;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new zt)}r[0]=new zt,s[0]=new zt;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),h=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],a),s[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),s[e]=s[e-1].clone(),a.crossVectors(i[e-1],i[e]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(ut(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(o.makeRotationAxis(a,t))}s[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos(ut(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(a.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(o.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Mo extends _o{constructor(t=0,e=0,n=1,i=1,r=0,s=2*Math.PI,a=!1,o=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(t,e){const n=e||new yt,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const a=this.aStartAngle+t*r;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,i=l-this.aY;o=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Mo.prototype.isEllipseCurve=!0;class bo extends Mo{constructor(t,e,n,i,r,s){super(t,e,n,n,i,r,s),this.type="ArcCurve"}}function wo(){let t=0,e=0,n=0,i=0;function r(r,s,a,o){t=r,e=a,n=-3*r+3*s-2*a-o,i=2*r-2*s+a+o}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,a,o){let l=(e-t)/s-(n-t)/(s+a)+(n-e)/a,c=(n-e)/a-(i-e)/(a+o)+(i-n)/o;l*=a,c*=a,r(e,n,l,c)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}bo.prototype.isArcCurve=!0;const So=new zt,To=new wo,Eo=new wo,Ao=new wo;class Lo extends _o{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new zt){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let a,o,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?a=i[(l-1)%r]:(So.subVectors(i[0],i[1]).add(i[0]),a=So);const h=i[l%r],u=i[(l+1)%r];if(this.closed||l+2<r?o=i[(l+2)%r]:(So.subVectors(i[r-1],i[r-2]).add(i[r-1]),o=So),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(h),t),n=Math.pow(h.distanceToSquared(u),t),i=Math.pow(u.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),To.initNonuniformCatmullRom(a.x,h.x,u.x,o.x,e,n,i),Eo.initNonuniformCatmullRom(a.y,h.y,u.y,o.y,e,n,i),Ao.initNonuniformCatmullRom(a.z,h.z,u.z,o.z,e,n,i)}else"catmullrom"===this.curveType&&(To.initCatmullRom(a.x,h.x,u.x,o.x,this.tension),Eo.initCatmullRom(a.y,h.y,u.y,o.y,this.tension),Ao.initCatmullRom(a.z,h.z,u.z,o.z,this.tension));return n.set(To.calc(c),Eo.calc(c),Ao.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new zt).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Ro(t,e,n,i,r){const s=.5*(i-e),a=.5*(r-n),o=t*t;return(2*n-2*i+s+a)*(t*o)+(-3*n+3*i-2*s-a)*o+s*t+n}function Co(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function Po(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}Lo.prototype.isCatmullRomCurve3=!0;class Io extends _o{constructor(t=new yt,e=new yt,n=new yt,i=new yt){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new yt){const n=e,i=this.v0,r=this.v1,s=this.v2,a=this.v3;return n.set(Po(t,i.x,r.x,s.x,a.x),Po(t,i.y,r.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Io.prototype.isCubicBezierCurve=!0;class Do extends _o{constructor(t=new zt,e=new zt,n=new zt,i=new zt){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new zt){const n=e,i=this.v0,r=this.v1,s=this.v2,a=this.v3;return n.set(Po(t,i.x,r.x,s.x,a.x),Po(t,i.y,r.y,s.y,a.y),Po(t,i.z,r.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Do.prototype.isCubicBezierCurve3=!0;class No extends _o{constructor(t=new yt,e=new yt){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new yt){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new yt;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}No.prototype.isLineCurve=!0;class zo extends _o{constructor(t=new zt,e=new zt){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new zt){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Bo extends _o{constructor(t=new yt,e=new yt,n=new yt){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new yt){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Co(t,i.x,r.x,s.x),Co(t,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Bo.prototype.isQuadraticBezierCurve=!0;class Fo extends _o{constructor(t=new zt,e=new zt,n=new zt){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new zt){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Co(t,i.x,r.x,s.x),Co(t,i.y,r.y,s.y),Co(t,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Fo.prototype.isQuadraticBezierCurve3=!0;class Oo extends _o{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new yt){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),a=r-s,o=i[0===s?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],h=i[s>i.length-3?i.length-1:s+2];return n.set(Ro(a,o.x,l.x,c.x,h.x),Ro(a,o.y,l.y,c.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new yt).fromArray(n))}return this}}Oo.prototype.isSplineCurve=!0;var Uo=Object.freeze({__proto__:null,ArcCurve:bo,CatmullRomCurve3:Lo,CubicBezierCurve:Io,CubicBezierCurve3:Do,EllipseCurve:Mo,LineCurve:No,LineCurve3:zo,QuadraticBezierCurve:Bo,QuadraticBezierCurve3:Fo,SplineCurve:Oo});class Ho extends _o{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new No(e,t))}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const t=i[r]-n,s=this.curves[r],a=s.getLength(),o=0===a?0:1-t/a;return s.getPointAt(o,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],a=s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,o=s.getPoints(a);for(let t=0;t<o.length;t++){const i=o[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new Uo[n.type]).fromJSON(n))}return this}}class Go extends Ho{constructor(t){super(),this.type="Path",this.currentPoint=new yt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new No(this.currentPoint.clone(),new yt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new Bo(this.currentPoint.clone(),new yt(t,e),new yt(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,s){const a=new Io(this.currentPoint.clone(),new yt(t,e),new yt(n,i),new yt(r,s));return this.curves.push(a),this.currentPoint.set(r,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Oo(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,n,i,r,s),this}absarc(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this}ellipse(t,e,n,i,r,s,a,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,i,r,s,a,o),this}absellipse(t,e,n,i,r,s,a,o){const l=new Mo(t,e,n,i,r,s,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ko extends Go{constructor(t){super(t),this.uuid=ht(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new Go).fromJSON(n))}return this}}const Vo=function(t,e,n=2){const i=e&&e.length,r=i?e[0]*n:t.length;let s=Wo(t,0,r,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,h,u,d,p;if(i&&(s=function(t,e,n,i){const r=[];let s,a,o,l,c;for(s=0,a=e.length;s<a;s++)o=e[s]*i,l=s<a-1?e[s+1]*i:t.length,c=Wo(t,o,l,i,!1),c===c.next&&(c.steiner=!0),r.push(el(c));for(r.sort(Qo),s=0;s<r.length;s++)Ko(r[s],n),n=jo(n,n.next);return n}(t,e,s,n)),t.length>80*n){o=c=t[0],l=h=t[1];for(let e=n;e<r;e+=n)u=t[e],d=t[e+1],u<o&&(o=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-o,h-l),p=0!==p?1/p:0}return qo(s,a,n,o,l,p),a};function Wo(t,e,n,i,r){let s,a;if(r===function(t,e,n,i){let r=0;for(let s=e,a=n-i;s<n;s+=i)r+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return r}(t,e,n,i)>0)for(s=e;s<n;s+=i)a=ul(s,t[s],t[s+1],a);else for(s=n-i;s>=e;s-=i)a=ul(s,t[s],t[s+1],a);return a&&sl(a,a.next)&&(dl(a),a=a.next),a}function jo(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!sl(i,i.next)&&0!==rl(i.prev,i,i.next))i=i.next;else{if(dl(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function qo(t,e,n,i,r,s,a){if(!t)return;!a&&s&&function(t,e,n,i){let r=t;do{null===r.z&&(r.z=tl(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,s,a,o,l,c=1;do{for(n=t,t=null,s=null,a=0;n;){for(a++,i=n,o=0,e=0;e<c&&(o++,i=i.nextZ,i);e++);for(l=c;o>0||l>0&&i;)0!==o&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,o--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;n=i}s.nextZ=null,c*=2}while(a>1)}(r)}(t,i,r,s);let o,l,c=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,s?Yo(t,i,r,s):Xo(t))e.push(o.i/n),e.push(t.i/n),e.push(l.i/n),dl(t),t=l.next,c=l.next;else if((t=l)===c){a?1===a?qo(t=Jo(jo(t),e,n),e,n,i,r,s,2):2===a&&Zo(t,e,n,i,r,s):qo(jo(t),e,n,i,r,s,1);break}}function Xo(t){const e=t.prev,n=t,i=t.next;if(rl(e,n,i)>=0)return!1;let r=t.next.next;for(;r!==t.prev;){if(nl(e.x,e.y,n.x,n.y,i.x,i.y,r.x,r.y)&&rl(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Yo(t,e,n,i){const r=t.prev,s=t,a=t.next;if(rl(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,l=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,c=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,h=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,u=tl(o,l,e,n,i),d=tl(c,h,e,n,i);let p=t.prevZ,m=t.nextZ;for(;p&&p.z>=u&&m&&m.z<=d;){if(p!==t.prev&&p!==t.next&&nl(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&rl(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,m!==t.prev&&m!==t.next&&nl(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&rl(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;p&&p.z>=u;){if(p!==t.prev&&p!==t.next&&nl(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&rl(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;m&&m.z<=d;){if(m!==t.prev&&m!==t.next&&nl(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&rl(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function Jo(t,e,n){let i=t;do{const r=i.prev,s=i.next.next;!sl(r,s)&&al(r,i,i.next,s)&&cl(r,s)&&cl(s,r)&&(e.push(r.i/n),e.push(i.i/n),e.push(s.i/n),dl(i),dl(i.next),i=t=s),i=i.next}while(i!==t);return jo(i)}function Zo(t,e,n,i,r,s){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&il(a,t)){let o=hl(a,t);return a=jo(a,a.next),o=jo(o,o.next),qo(a,e,n,i,r,s),void qo(o,e,n,i,r,s)}t=t.next}a=a.next}while(a!==t)}function Qo(t,e){return t.x-e.x}function Ko(t,e){if(e=function(t,e){let n=e;const i=t.x,r=t.y;let s,a=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const t=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=i&&t>a){if(a=t,t===i){if(r===n.y)return n;if(r===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(i===a)return s;const o=s,l=s.x,c=s.y;let h,u=1/0;n=s;do{i>=n.x&&n.x>=l&&i!==n.x&&nl(r<c?i:a,r,l,c,r<c?a:i,r,n.x,n.y)&&(h=Math.abs(r-n.y)/(i-n.x),cl(n,t)&&(h<u||h===u&&(n.x>s.x||n.x===s.x&&$o(s,n)))&&(s=n,u=h)),n=n.next}while(n!==o);return s}(t,e),e){const n=hl(e,t);jo(e,e.next),jo(n,n.next)}}function $o(t,e){return rl(t.prev,t,e.prev)<0&&rl(e.next,t,t.next)<0}function tl(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function el(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function nl(t,e,n,i,r,s,a,o){return(r-a)*(e-o)-(t-a)*(s-o)>=0&&(t-a)*(i-o)-(n-a)*(e-o)>=0&&(n-a)*(s-o)-(r-a)*(i-o)>=0}function il(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&al(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(cl(t,e)&&cl(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(rl(t.prev,t,e.prev)||rl(t,e.prev,e))||sl(t,e)&&rl(t.prev,t,t.next)>0&&rl(e.prev,e,e.next)>0)}function rl(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function sl(t,e){return t.x===e.x&&t.y===e.y}function al(t,e,n,i){const r=ll(rl(t,e,n)),s=ll(rl(t,e,i)),a=ll(rl(n,i,t)),o=ll(rl(n,i,e));return r!==s&&a!==o||(!(0!==r||!ol(t,n,e))||(!(0!==s||!ol(t,i,e))||(!(0!==a||!ol(n,t,i))||!(0!==o||!ol(n,e,i)))))}function ol(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function ll(t){return t>0?1:t<0?-1:0}function cl(t,e){return rl(t.prev,t,t.next)<0?rl(t,e,t.next)>=0&&rl(t,t.prev,e)>=0:rl(t,e,t.prev)<0||rl(t,t.next,e)<0}function hl(t,e){const n=new pl(t.i,t.x,t.y),i=new pl(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function ul(t,e,n,i){const r=new pl(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function dl(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function pl(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class ml{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n}static isClockWise(t){return ml.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];fl(t),gl(n,t);let s=t.length;e.forEach(fl);for(let t=0;t<e.length;t++)i.push(s),s+=e[t].length,gl(n,e[t]);const a=Vo(n,i);for(let t=0;t<a.length;t+=3)r.push(a.slice(t,t+3));return r}}function fl(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function gl(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class vl extends En{constructor(t=new ko([new yt(.5,.5),new yt(-.5,.5),new yt(-.5,-.5),new yt(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++){s(t[e])}function s(t){const s=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:1,c=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,f=void 0!==e.UVGenerator?e.UVGenerator:yl;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,v,y,x,_,M=!1;m&&(g=m.getSpacedPoints(o),M=!0,c=!1,v=m.computeFrenetFrames(o,!1),y=new zt,x=new zt,_=new zt),c||(p=0,h=0,u=0,d=0);const b=t.extractPoints(a);let w=b.shape;const S=b.holes;if(!ml.isClockWise(w)){w=w.reverse();for(let t=0,e=S.length;t<e;t++){const e=S[t];ml.isClockWise(e)&&(S[t]=e.reverse())}}const T=ml.triangulateShape(w,S),E=w;for(let t=0,e=S.length;t<e;t++){const e=S[t];w=w.concat(e)}function A(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const L=w.length,R=T.length;function C(t,e,n){let i,r,s;const a=t.x-e.x,o=t.y-e.y,l=n.x-t.x,c=n.y-t.y,h=a*a+o*o,u=a*c-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=e.x-o/u,m=e.y+a/u,f=((n.x-c/d-p)*c-(n.y+l/d-m)*l)/(a*c-o*l);i=p+a*f-t.x,r=m+o*f-t.y;const g=i*i+r*r;if(g<=2)return new yt(i,r);s=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(c)&&(t=!0),t?(i=-o,r=a,s=Math.sqrt(h)):(i=a,r=o,s=Math.sqrt(h/2))}return new yt(i/s,r/s)}const P=[];for(let t=0,e=E.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),P[t]=C(E[t],E[n],E[i]);const I=[];let D,N=P.concat();for(let t=0,e=S.length;t<e;t++){const e=S[t];D=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),D[t]=C(e[t],e[i],e[r]);I.push(D),N=N.concat(D)}for(let t=0;t<p;t++){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=A(E[t],P[t],i);F(e.x,e.y,-n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];D=I[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],D[t],i);F(r.x,r.y,-n)}}}const z=u+d;for(let t=0;t<L;t++){const e=c?A(w[t],N[t],z):w[t];M?(x.copy(v.normals[0]).multiplyScalar(e.x),y.copy(v.binormals[0]).multiplyScalar(e.y),_.copy(g[0]).add(x).add(y),F(_.x,_.y,_.z)):F(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<L;e++){const n=c?A(w[e],N[e],z):w[e];M?(x.copy(v.normals[t]).multiplyScalar(n.x),y.copy(v.binormals[t]).multiplyScalar(n.y),_.copy(g[t]).add(x).add(y),F(_.x,_.y,_.z)):F(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=A(E[t],P[t],i);F(e.x,e.y,l+n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];D=I[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],D[t],i);M?F(r.x,r.y+g[o-1].y,g[o-1].x+n):F(r.x,r.y,l+n)}}}function B(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=L*t,s=L*(t+1);U(e+i+n,e+r+n,e+r+s,e+i+s)}}}function F(t,e,n){s.push(t),s.push(e),s.push(n)}function O(t,e,r){H(t),H(e),H(r);const s=i.length/3,a=f.generateTopUV(n,i,s-3,s-2,s-1);G(a[0]),G(a[1]),G(a[2])}function U(t,e,r,s){H(t),H(e),H(s),H(e),H(r),H(s);const a=i.length/3,o=f.generateSideWallUV(n,i,a-6,a-3,a-2,a-1);G(o[0]),G(o[1]),G(o[3]),G(o[1]),G(o[2]),G(o[3])}function H(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function G(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=L*t;for(let t=0;t<R;t++){const n=T[t];O(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=L*t;for(let t=0;t<R;t++){const n=T[t];O(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<R;t++){const e=T[t];O(e[2],e[1],e[0])}for(let t=0;t<R;t++){const e=T[t];O(e[0]+L*o,e[1]+L*o,e[2]+L*o)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;B(E,e),e+=E.length;for(let t=0,n=S.length;t<n;t++){const n=S[t];B(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new vn(i,3)),this.setAttribute("uv",new vn(r,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON());return n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}const i=t.options.extrudePath;return void 0!==i&&(t.options.extrudePath=(new Uo[i.type]).fromJSON(i)),new vl(n,t.options)}}const yl={generateTopUV:function(t,e,n,i,r){const s=e[3*n],a=e[3*n+1],o=e[3*i],l=e[3*i+1],c=e[3*r],h=e[3*r+1];return[new yt(s,a),new yt(o,l),new yt(c,h)]},generateSideWallUV:function(t,e,n,i,r,s){const a=e[3*n],o=e[3*n+1],l=e[3*n+2],c=e[3*i],h=e[3*i+1],u=e[3*i+2],d=e[3*r],p=e[3*r+1],m=e[3*r+2],f=e[3*s],g=e[3*s+1],v=e[3*s+2];return Math.abs(o-h)<Math.abs(a-c)?[new yt(a,1-l),new yt(c,1-u),new yt(d,1-m),new yt(f,1-v)]:[new yt(o,1-l),new yt(h,1-u),new yt(p,1-m),new yt(g,1-v)]}};class xl extends po{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new xl(t.radius,t.detail)}}class _l extends En{constructor(t=[new yt(0,.5),new yt(.5,0),new yt(0,-.5)],e=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=ut(i,0,2*Math.PI);const r=[],s=[],a=[],o=1/e,l=new zt,c=new yt;for(let r=0;r<=e;r++){const h=n+r*o*i,u=Math.sin(h),d=Math.cos(h);for(let n=0;n<=t.length-1;n++)l.x=t[n].x*u,l.y=t[n].y,l.z=t[n].x*d,s.push(l.x,l.y,l.z),c.x=r/e,c.y=n/(t.length-1),a.push(c.x,c.y)}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const i=e+n*t.length,s=i,a=i+t.length,o=i+t.length+1,l=i+1;r.push(s,a,l),r.push(a,o,l)}if(this.setIndex(r),this.setAttribute("position",new vn(s,3)),this.setAttribute("uv",new vn(a,2)),this.computeVertexNormals(),i===2*Math.PI){const n=this.attributes.normal.array,i=new zt,r=new zt,s=new zt,a=e*t.length*3;for(let e=0,o=0;e<t.length;e++,o+=3)i.x=n[o+0],i.y=n[o+1],i.z=n[o+2],r.x=n[a+o+0],r.y=n[a+o+1],r.z=n[a+o+2],s.addVectors(i,r).normalize(),n[o+0]=n[a+o+0]=s.x,n[o+1]=n[a+o+1]=s.y,n[o+2]=n[a+o+2]=s.z}}static fromJSON(t){return new _l(t.points,t.segments,t.phiStart,t.phiLength)}}class Ml extends po{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ml(t.radius,t.detail)}}class bl extends En{constructor(t=.5,e=1,n=8,i=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n);const a=[],o=[],l=[],c=[];let h=t;const u=(e-t)/(i=Math.max(1,i)),d=new zt,p=new yt;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*s;d.x=h*Math.cos(i),d.y=h*Math.sin(i),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}h+=u}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,s=i+n+1,o=i+n+2,l=i+1;a.push(r,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new vn(o,3)),this.setAttribute("normal",new vn(l,3)),this.setAttribute("uv",new vn(c,2))}static fromJSON(t){return new bl(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class wl extends En{constructor(t=new ko([new yt(0,.5),new yt(-.5,-.5),new yt(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){const a=i.length/3,l=t.extractPoints(e);let c=l.shape;const h=l.holes;!1===ml.isClockWise(c)&&(c=c.reverse());for(let t=0,e=h.length;t<e;t++){const e=h[t];!0===ml.isClockWise(e)&&(h[t]=e.reverse())}const u=ml.triangulateShape(c,h);for(let t=0,e=h.length;t<e;t++){const e=h[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];i.push(e.x,e.y,0),r.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],i=e[0]+a,r=e[1]+a,s=e[2]+a;n.push(i,r,s),o+=3}}this.setIndex(n),this.setAttribute("position",new vn(i,3)),this.setAttribute("normal",new vn(r,3)),this.setAttribute("uv",new vn(s,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}return new wl(n,t.curveSegments)}}class Sl extends En{constructor(t=1,e=32,n=16,i=0,r=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const c=[],h=new zt,u=new zt,d=[],p=[],m=[],f=[];for(let d=0;d<=n;d++){const g=[],v=d/n;let y=0;0==d&&0==s?y=.5/e:d==n&&o==Math.PI&&(y=-.5/e);for(let n=0;n<=e;n++){const o=n/e;h.x=-t*Math.cos(i+o*r)*Math.sin(s+v*a),h.y=t*Math.cos(s+v*a),h.z=t*Math.sin(i+o*r)*Math.sin(s+v*a),p.push(h.x,h.y,h.z),u.copy(h).normalize(),m.push(u.x,u.y,u.z),f.push(o+y,1-v),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=c[t][i+1],r=c[t][i],a=c[t+1][i],l=c[t+1][i+1];(0!==t||s>0)&&d.push(e,r,l),(t!==n-1||o<Math.PI)&&d.push(r,a,l)}this.setIndex(d),this.setAttribute("position",new vn(p,3)),this.setAttribute("normal",new vn(m,3)),this.setAttribute("uv",new vn(f,2))}static fromJSON(t){return new Sl(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Tl extends po{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Tl(t.radius,t.detail)}}class El extends En{constructor(t=1,e=.4,n=8,i=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const s=[],a=[],o=[],l=[],c=new zt,h=new zt,u=new zt;for(let s=0;s<=n;s++)for(let d=0;d<=i;d++){const p=d/i*r,m=s/n*Math.PI*2;h.x=(t+e*Math.cos(m))*Math.cos(p),h.y=(t+e*Math.cos(m))*Math.sin(p),h.z=e*Math.sin(m),a.push(h.x,h.y,h.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),u.subVectors(h,c).normalize(),o.push(u.x,u.y,u.z),l.push(d/i),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*t+e-1,r=(i+1)*(t-1)+e-1,a=(i+1)*(t-1)+e,o=(i+1)*t+e;s.push(n,r,o),s.push(r,a,o)}this.setIndex(s),this.setAttribute("position",new vn(a,3)),this.setAttribute("normal",new vn(o,3)),this.setAttribute("uv",new vn(l,2))}static fromJSON(t){return new El(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Al extends En{constructor(t=1,e=.4,n=64,i=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:s},n=Math.floor(n),i=Math.floor(i);const a=[],o=[],l=[],c=[],h=new zt,u=new zt,d=new zt,p=new zt,m=new zt,f=new zt,g=new zt;for(let a=0;a<=n;++a){const y=a/n*r*Math.PI*2;v(y,r,s,t,d),v(y+.01,r,s,t,p),f.subVectors(p,d),g.addVectors(p,d),m.crossVectors(f,g),g.crossVectors(m,f),m.normalize(),g.normalize();for(let t=0;t<=i;++t){const r=t/i*Math.PI*2,s=-e*Math.cos(r),p=e*Math.sin(r);h.x=d.x+(s*g.x+p*m.x),h.y=d.y+(s*g.y+p*m.y),h.z=d.z+(s*g.z+p*m.z),o.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(a/n),c.push(t/i)}}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,o=(i+1)*(t-1)+e;a.push(n,r,o),a.push(r,s,o)}function v(t,e,n,i,r){const s=Math.cos(t),a=Math.sin(t),o=n/e*t,l=Math.cos(o);r.x=i*(2+l)*.5*s,r.y=i*(2+l)*a*.5,r.z=i*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new vn(o,3)),this.setAttribute("normal",new vn(l,3)),this.setAttribute("uv",new vn(c,2))}static fromJSON(t){return new Al(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Ll extends En{constructor(t=new Fo(new zt(-1,-1,0),new zt(-1,1,0),new zt(1,1,0)),e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const s=t.computeFrenetFrames(e,r);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new zt,o=new zt,l=new yt;let c=new zt;const h=[],u=[],d=[],p=[];function m(r){c=t.getPointAt(r/e,c);const l=s.normals[r],d=s.binormals[r];for(let t=0;t<=i;t++){const e=t/i*Math.PI*2,r=Math.sin(e),s=-Math.cos(e);o.x=s*l.x+r*d.x,o.y=s*l.y+r*d.y,o.z=s*l.z+r*d.z,o.normalize(),u.push(o.x,o.y,o.z),a.x=c.x+n*o.x,a.y=c.y+n*o.y,a.z=c.z+n*o.z,h.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<e;t++)m(t);m(!1===r?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=i;n++)l.x=t/e,l.y=n/i,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,a=(i+1)*(t-1)+e;p.push(n,r,a),p.push(r,s,a)}}()}(),this.setIndex(p),this.setAttribute("position",new vn(h,3)),this.setAttribute("normal",new vn(u,3)),this.setAttribute("uv",new vn(d,2))}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Ll((new Uo[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Rl extends En{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,i=new zt,r=new zt;if(null!==t.index){const s=t.attributes.position,a=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],c=l.start;for(let t=c,o=c+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=a.getX(t+o),c=a.getX(t+(o+1)%3);i.fromBufferAttribute(s,l),r.fromBufferAttribute(s,c),!0===Cl(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const s=t.attributes.position;for(let t=0,a=s.count/3;t<a;t++)for(let a=0;a<3;a++){const o=3*t+a,l=3*t+(a+1)%3;i.fromBufferAttribute(s,o),r.fromBufferAttribute(s,l),!0===Cl(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new vn(e,3))}}}function Cl(t,e,n){const i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(i)&&!0!==n.has(r)&&(n.add(i,r),!0)}var Pl=Object.freeze({__proto__:null,BoxGeometry:qn,BoxBufferGeometry:qn,CircleGeometry:co,CircleBufferGeometry:co,ConeGeometry:uo,ConeBufferGeometry:uo,CylinderGeometry:ho,CylinderBufferGeometry:ho,DodecahedronGeometry:mo,DodecahedronBufferGeometry:mo,EdgesGeometry:xo,ExtrudeGeometry:vl,ExtrudeBufferGeometry:vl,IcosahedronGeometry:xl,IcosahedronBufferGeometry:xl,LatheGeometry:_l,LatheBufferGeometry:_l,OctahedronGeometry:Ml,OctahedronBufferGeometry:Ml,PlaneGeometry:di,PlaneBufferGeometry:di,PolyhedronGeometry:po,PolyhedronBufferGeometry:po,RingGeometry:bl,RingBufferGeometry:bl,ShapeGeometry:wl,ShapeBufferGeometry:wl,SphereGeometry:Sl,SphereBufferGeometry:Sl,TetrahedronGeometry:Tl,TetrahedronBufferGeometry:Tl,TorusGeometry:El,TorusBufferGeometry:El,TorusKnotGeometry:Al,TorusKnotBufferGeometry:Al,TubeGeometry:Ll,TubeBufferGeometry:Ll,WireframeGeometry:Rl});class Il extends Ze{constructor(t){super(),this.type="ShadowMaterial",this.color=new rn(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}Il.prototype.isShadowMaterial=!0;class Dl extends Ze{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new rn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Dl.prototype.isMeshStandardMaterial=!0;class Nl extends Dl{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new yt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ut(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new rn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new rn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new rn(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}Nl.prototype.isMeshPhysicalMaterial=!0;class zl extends Ze{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new rn(16777215),this.specular=new rn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}zl.prototype.isMeshPhongMaterial=!0;class Bl extends Ze{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new rn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Bl.prototype.isMeshToonMaterial=!0;class Fl extends Ze{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}Fl.prototype.isMeshNormalMaterial=!0;class Ol extends Ze{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new rn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ol.prototype.isMeshLambertMaterial=!0;class Ul extends Ze{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new rn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new yt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}Ul.prototype.isMeshMatcapMaterial=!0;class Hl extends Ga{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}Hl.prototype.isLineDashedMaterial=!0;var Gl=Object.freeze({__proto__:null,ShadowMaterial:Il,SpriteMaterial:sa,RawShaderMaterial:wi,ShaderMaterial:Zn,PointsMaterial:Ka,MeshPhysicalMaterial:Nl,MeshStandardMaterial:Dl,MeshPhongMaterial:zl,MeshToonMaterial:Bl,MeshNormalMaterial:Fl,MeshLambertMaterial:Ol,MeshDepthMaterial:Us,MeshDistanceMaterial:Hs,MeshBasicMaterial:sn,MeshMatcapMaterial:Ul,LineDashedMaterial:Hl,LineBasicMaterial:Ga,Material:Ze});const kl={arraySlice:function(t,e,n){return kl.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n},sortedArray:function(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,a=0;a!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[a++]=t[i+n]}return r},flattenJSON:function(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let a=s[i];if(void 0!==a)if(Array.isArray(a))do{a=s[i],void 0!==a&&(e.push(s.time),n.push.apply(n,a)),s=t[r++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[i],void 0!==a&&(e.push(s.time),a.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{a=s[i],void 0!==a&&(e.push(s.time),n.push(a)),s=t[r++]}while(void 0!==s)},subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const a=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],o=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*r;if(!(s<n||s>=i)){l.push(e.times[t]);for(let n=0;n<o;++n)c.push(e.values[t*o+n])}}0!==l.length&&(e.times=kl.convertArray(l,e.times.constructor),e.values=kl.convertArray(c,e.values.constructor),a.push(e))}s.tracks=a;let o=1/0;for(let t=0;t<s.tracks.length;++t)o>s.tracks[t].times[0]&&(o=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const a=t.tracks.find((function(t){return t.name===i.name&&t.ValueTypeName===r}));if(void 0===a)continue;let o=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=i.times.length-1;let d;if(s<=i.times[0]){const t=o,e=l-o;d=kl.arraySlice(i.values,t,e)}else if(s>=i.times[u]){const t=u*l+o,e=t+l-o;d=kl.arraySlice(i.values,t,e)}else{const t=i.createInterpolant(),e=o,n=l-o;t.evaluate(s),d=kl.arraySlice(t.resultBuffer,e,n)}if("quaternion"===r){(new Nt).fromArray(d).normalize().conjugate().toArray(d)}const p=a.times.length;for(let t=0;t<p;++t){const e=t*h+c;if("quaternion"===r)Nt.multiplyQuaternionsFlat(a.values,e,d,0,a.values,e);else{const t=h-2*c;for(let n=0;n<t;++n)a.values[e+n]-=d[n]}}}return t.blendMode=q,t}};class Vl{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(t>=r)break t;{const a=e[1];t<a&&(n=2,r=a);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0}}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(void 0===i)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Vl.prototype.beforeStart_=Vl.prototype.copySampleValue_,Vl.prototype.afterEnd_=Vl.prototype.copySampleValue_;class Wl extends Vl{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:k,endingEnd:k}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,a=i[r],o=i[s];if(void 0===a)switch(this.getSettings_().endingStart){case V:r=t,a=2*e-n;break;case W:r=i.length-2,a=e+i[r]-i[r+1];break;default:r=t,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case V:s=t,o=2*n-e;break;case W:s=1,o=n+i[1]-i[0];break;default:s=t-1,o=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-n),this._offsetPrev=r*c,this._offsetNext=s*c}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),m=p*p,f=m*p,g=-u*f+2*u*m-u*p,v=(1+u)*f+(-1.5-2*u)*m+(-.5+u)*p+1,y=(-1-d)*f+(1.5+d)*m+.5*p,x=d*f-d*m;for(let t=0;t!==a;++t)r[t]=g*s[c+t]+v*s[l+t]+y*s[o+t]+x*s[h+t];return r}}class jl extends Vl{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,c=(n-e)/(i-e),h=1-c;for(let t=0;t!==a;++t)r[t]=s[l+t]*h+s[o+t]*c;return r}}class ql extends Vl{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Xl{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=kl.convertArray(e,this.TimeBufferType),this.values=kl.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:kl.convertArray(t.times,Array),values:kl.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new ql(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new jl(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Wl(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case U:e=this.InterpolantFactoryMethodDiscrete;break;case H:e=this.InterpolantFactoryMethodLinear;break;case G:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return U;case this.InterpolantFactoryMethodLinear:return H;case this.InterpolantFactoryMethodSmooth:return G}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=kl.arraySlice(n,r,s),this.values=kl.arraySlice(this.values,r*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==s&&s>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,s),t=!1;break}s=i}if(void 0!==i&&kl.isTypedArray(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=kl.arraySlice(this.times),e=kl.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===G,r=t.length-1;let s=1;for(let a=1;a<r;++a){let r=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(i)r=!0;else{const t=a*n,i=t-n,s=t+n;for(let a=0;a!==n;++a){const n=e[t+a];if(n!==e[i+a]||n!==e[s+a]){r=!0;break}}}if(r){if(a!==s){t[s]=t[a];const i=a*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,a=0;a!==n;++a)e[i+a]=e[t+a];++s}return s!==t.length?(this.times=kl.arraySlice(t,0,s),this.values=kl.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=kl.arraySlice(this.times,0),e=kl.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}Xl.prototype.TimeBufferType=Float32Array,Xl.prototype.ValueBufferType=Float32Array,Xl.prototype.DefaultInterpolation=H;class Yl extends Xl{}Yl.prototype.ValueTypeName="bool",Yl.prototype.ValueBufferType=Array,Yl.prototype.DefaultInterpolation=U,Yl.prototype.InterpolantFactoryMethodLinear=void 0,Yl.prototype.InterpolantFactoryMethodSmooth=void 0;class Jl extends Xl{}Jl.prototype.ValueTypeName="color";class Zl extends Xl{}Zl.prototype.ValueTypeName="number";class Ql extends Vl{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-e)/(i-e);let l=t*a;for(let t=l+a;l!==t;l+=4)Nt.slerpFlat(r,0,s,l-a,s,l,o);return r}}class Kl extends Xl{InterpolantFactoryMethodLinear(t){return new Ql(this.times,this.values,this.getValueSize(),t)}}Kl.prototype.ValueTypeName="quaternion",Kl.prototype.DefaultInterpolation=H,Kl.prototype.InterpolantFactoryMethodSmooth=void 0;class $l extends Xl{}$l.prototype.ValueTypeName="string",$l.prototype.ValueBufferType=Array,$l.prototype.DefaultInterpolation=U,$l.prototype.InterpolantFactoryMethodLinear=void 0,$l.prototype.InterpolantFactoryMethodSmooth=void 0;class tc extends Xl{}tc.prototype.ValueTypeName="vector";class ec{constructor(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=ht(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(nc(n[t]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(Xl.toJSON(n[t]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let t=0;t<r;t++){let a=[],o=[];a.push((t+r-1)%r,t,(t+1)%r),o.push(0,1,0);const l=kl.getKeyframeOrder(a);a=kl.sortedArray(a,1,l),o=kl.sortedArray(o,1,l),i||0!==a[0]||(a.push(r),o.push(o[0])),s.push(new Zl(".morphTargetInfluences["+e[t].name+"]",a,o).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(r);if(s&&s.length>1){const t=s[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const s=[];for(const t in i)s.push(this.CreateFromMorphTargetSequence(t,i[t],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],a=[];kl.flattenJSON(n,s,a,i),0!==s.length&&r.push(new t(e,s,a))}},i=[],r=t.name||"default",s=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new Zl(".morphTargetInfluence["+n+"]",t,s))}o=t.length*(s||1)}else{const s=".bones["+e[t].name+"]";n(tc,s+".position",r,"pos",i),n(Kl,s+".quaternion",r,"rot",i),n(tc,s+".scale",r,"scl",i)}}if(0===i.length)return null;return new this(r,o,i,a)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function nc(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Zl;case"vector":case"vector2":case"vector3":case"vector4":return tc;case"color":return Jl;case"quaternion":return Kl;case"bool":case"boolean":return Yl;case"string":return $l}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];kl.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const ic={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class rc{constructor(t,e,n){const i=this;let r,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===s&&void 0!==i.onStart&&i.onStart(t,a,o),s=!0},this.itemEnd=function(t){a++,void 0!==i.onProgress&&i.onProgress(t,a,o),a===o&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}}const sc=new rc;class ac{constructor(t){this.manager=void 0!==t?t:sc,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const oc={};class lc extends ac{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=ic.get(t);if(void 0!==r)return this.manager.itemStart(t),setTimeout((()=>{e&&e(r),this.manager.itemEnd(t)}),0),r;if(void 0!==oc[t])return void oc[t].push({onLoad:e,onProgress:n,onError:i});oc[t]=[],oc[t].push({onLoad:e,onProgress:n,onError:i});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(s).then((e=>{if(200===e.status||0===e.status){0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const n=oc[t],i=e.body.getReader(),r=e.headers.get("Content-Length"),s=r?parseInt(r):0,a=0!==s;let o=0;return new ReadableStream({start(t){!function e(){i.read().then((({done:i,value:r})=>{if(i)t.close();else{o+=r.byteLength;const i=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(i)}t.enqueue(r),e()}}))}()}})}throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)})).then((t=>{const e=new Response(t);switch(this.responseType){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then((t=>(new DOMParser).parseFromString(t,this.mimeType)));case"json":return e.json();default:return e.text()}})).then((e=>{ic.add(t,e);const n=oc[t];delete oc[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onLoad&&i.onLoad(e)}this.manager.itemEnd(t)})).catch((e=>{const n=oc[t];delete oc[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}this.manager.itemError(t),this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class cc extends ac{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=ic.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const a=wt("img");function o(){c(),ic.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){c(),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class hc extends ac{constructor(t){super(t)}load(t,e,n,i){const r=new ei,s=new cc(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function o(n){s.load(t[n],(function(t){r.images[n]=t,a++,6===a&&(r.needsUpdate=!0,e&&e(r))}),void 0,i)}for(let e=0;e<t.length;++e)o(e);return r}}class uc extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new Pa,a=new lc(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(t,(function(t){const n=r.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:u,s.wrapT=void 0!==n.wrapT?n.wrapT:u,s.magFilter=void 0!==n.magFilter?n.magFilter:g,s.minFilter=void 0!==n.minFilter?n.minFilter:g,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=y),1===n.mipmapCount&&(s.minFilter=g),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n))}),n,i),s}}class dc extends ac{constructor(t){super(t)}load(t,e,n,i){const r=new Lt,s=new cc(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(t){r.image=t,r.needsUpdate=!0,void 0!==e&&e(r)}),n,i),r}}class pc extends Fe{constructor(t,e=1){super(),this.type="Light",this.color=new rn(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}pc.prototype.isLight=!0;class mc extends pc{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(Fe.DefaultUp),this.updateMatrix(),this.groundColor=new rn(e)}copy(t){return pc.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}mc.prototype.isHemisphereLight=!0;const fc=new de,gc=new zt,vc=new zt;class yc{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new yt(512,512),this.map=null,this.mapPass=null,this.matrix=new de,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ci,this._frameExtents=new yt(1,1),this._viewportCount=1,this._viewports=[new Ct(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;gc.setFromMatrixPosition(t.matrixWorld),e.position.copy(gc),vc.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(vc),e.updateMatrixWorld(),fc.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(fc),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class xc extends yc{constructor(){super(new Kn(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=2*ot*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}xc.prototype.isSpotLightShadow=!0;class _c extends pc{constructor(t,e,n=0,i=Math.PI/3,r=0,s=1){super(t,e),this.type="SpotLight",this.position.copy(Fe.DefaultUp),this.updateMatrix(),this.target=new Fe,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.shadow=new xc}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}_c.prototype.isSpotLight=!0;const Mc=new de,bc=new zt,wc=new zt;class Sc extends yc{constructor(){super(new Kn(90,1,.5,500)),this._frameExtents=new yt(4,2),this._viewportCount=6,this._viewports=[new Ct(2,1,1,1),new Ct(0,1,1,1),new Ct(3,1,1,1),new Ct(1,1,1,1),new Ct(3,0,1,1),new Ct(1,0,1,1)],this._cubeDirections=[new zt(1,0,0),new zt(-1,0,0),new zt(0,0,1),new zt(0,0,-1),new zt(0,1,0),new zt(0,-1,0)],this._cubeUps=[new zt(0,1,0),new zt(0,1,0),new zt(0,1,0),new zt(0,1,0),new zt(0,0,1),new zt(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),bc.setFromMatrixPosition(t.matrixWorld),n.position.copy(bc),wc.copy(n.position),wc.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(wc),n.updateMatrixWorld(),i.makeTranslation(-bc.x,-bc.y,-bc.z),Mc.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Mc)}}Sc.prototype.isPointLightShadow=!0;class Tc extends pc{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Sc}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Tc.prototype.isPointLight=!0;class Ec extends yc{constructor(){super(new bi(-5,5,5,-5,.5,500))}}Ec.prototype.isDirectionalLightShadow=!0;class Ac extends pc{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(Fe.DefaultUp),this.updateMatrix(),this.target=new Fe,this.shadow=new Ec}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Ac.prototype.isDirectionalLight=!0;class Lc extends pc{constructor(t,e){super(t,e),this.type="AmbientLight"}}Lc.prototype.isAmbientLight=!0;class Rc extends pc{constructor(t,e,n=10,i=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Rc.prototype.isRectAreaLight=!0;class Cc{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new zt)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}Cc.prototype.isSphericalHarmonics3=!0;class Pc extends pc{constructor(t=new Cc,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Pc.prototype.isLightProbe=!0;class Ic extends ac{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,s=new lc(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=new Gl[t.type];if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=t.sheen),void 0!==t.sheenColor&&(i.sheenColor=(new rn).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(i.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.specularIntensity&&(i.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==i.specularColor&&i.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.thickness&&(i.thickness=t.thickness),void 0!==t.attenuationDistance&&(i.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==i.attenuationColor&&i.attenuationColor.setHex(t.attenuationColor),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.shadowSide&&(i.shadowSide=t.shadowSide),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.format&&(i.format=t.format),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),1!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.alphaToCoverage&&(i.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(i.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const r=t.uniforms[e];switch(i.uniforms[e]={},r.type){case"t":i.uniforms[e].value=n(r.value);break;case"c":i.uniforms[e].value=(new rn).setHex(r.value);break;case"v2":i.uniforms[e].value=(new yt).fromArray(r.value);break;case"v3":i.uniforms[e].value=(new zt).fromArray(r.value);break;case"v4":i.uniforms[e].value=(new Ct).fromArray(r.value);break;case"m3":i.uniforms[e].value=(new xt).fromArray(r.value);break;case"m4":i.uniforms[e].value=(new de).fromArray(r.value);break;default:i.uniforms[e].value=r.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const e in t.extensions)i.extensions[e]=t.extensions[e];if(void 0!==t.shading&&(i.flatShading=1===t.shading),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new yt).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(i.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(i.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new yt).fromArray(t.clearcoatNormalScale)),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(i.thicknessMap=n(t.thicknessMap)),void 0!==t.sheenColorMap&&(i.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(i.sheenRoughnessMap=n(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}}class Dc{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Nc extends En{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Nc.prototype.isInstancedBufferGeometry=!0;class zc extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new lc(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],s=function(t,e){if(void 0!==n[e])return n[e];const i=t.arrayBuffers[e],r=new Uint32Array(i).buffer;return n[e]=r,r}(t,r.buffer),a=bt(r.type,s),o=new na(a,r.stride);return o.uuid=r.uuid,e[i]=o,o}const r=t.isInstancedBufferGeometry?new Nc:new En,s=t.data.index;if(void 0!==s){const t=bt(s.type,s.array);r.setIndex(new ln(t,1))}const a=t.data.attributes;for(const e in a){const n=a[e];let s;if(n.isInterleavedBufferAttribute){const e=i(t.data,n.data);s=new ra(e,n.itemSize,n.offset,n.normalized)}else{const t=bt(n.type,n.array);s=new(n.isInstancedBufferAttribute?za:ln)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),void 0!==n.updateRange&&(s.updateRange.offset=n.updateRange.offset,s.updateRange.count=n.updateRange.count),r.setAttribute(e,s)}const o=t.data.morphAttributes;if(o)for(const e in o){const n=o[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];let a;if(r.isInterleavedBufferAttribute){const e=i(t.data,r.data);a=new ra(e,r.itemSize,r.offset,r.normalized)}else{const t=bt(r.type,r.array);a=new ln(t,r.itemSize,r.normalized)}void 0!==r.name&&(a.name=r.name),s.push(a)}r.morphAttributes[e]=s}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];r.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new zt;void 0!==c.center&&t.fromArray(c.center),r.boundingSphere=new ie(t,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}const Bc={UVMapping:i,CubeReflectionMapping:r,CubeRefractionMapping:s,EquirectangularReflectionMapping:a,EquirectangularRefractionMapping:o,CubeUVReflectionMapping:l,CubeUVRefractionMapping:c},Fc={RepeatWrapping:h,ClampToEdgeWrapping:u,MirroredRepeatWrapping:d},Oc={NearestFilter:p,NearestMipmapNearestFilter:m,NearestMipmapLinearFilter:f,LinearFilter:g,LinearMipmapNearestFilter:v,LinearMipmapLinearFilter:y};class Uc extends ac{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=ic.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))})).then((function(n){ic.add(t,n),e&&e(n),r.manager.itemEnd(t)})).catch((function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)})),r.manager.itemStart(t)}}let Hc;Uc.prototype.isImageBitmapLoader=!0;const Gc={getContext:function(){return void 0===Hc&&(Hc=new(window.AudioContext||window.webkitAudioContext)),Hc},setContext:function(t){Hc=t}};class kc extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new lc(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{const t=n.slice(0);Gc.getContext().decodeAudioData(t,(function(t){e(t)}))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}}class Vc extends Pc{constructor(t,e,n=1){super(void 0,n);const i=(new rn).set(t),r=(new rn).set(e),s=new zt(i.r,i.g,i.b),a=new zt(r.r,r.g,r.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}Vc.prototype.isHemisphereLightProbe=!0;class Wc extends Pc{constructor(t,e=1){super(void 0,e);const n=(new rn).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Wc.prototype.isAmbientLightProbe=!0;const jc=new de,qc=new de;class Xc{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Yc(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Yc();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Yc(){return("undefined"==typeof performance?Date:performance).now()}const Jc=new zt,Zc=new Nt,Qc=new zt,Kc=new zt;class $c extends Fe{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const th=new zt,eh=new Nt,nh=new zt,ih=new zt;class rh{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class sh{constructor(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){a.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}_slerp(t,e,n,i){Nt.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;Nt.multiplyQuaternionsFlat(t,s,t,e,t,n),Nt.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let a=0;a!==r;++a){const r=e+a;t[r]=t[r]*s+t[n+a]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}}const ah="\\[\\]\\.:\\/",oh=new RegExp("[\\[\\]\\.:\\/]","g"),lh="[^\\[\\]\\.:\\/]",ch="[^"+ah.replace("\\.","")+"]",hh=/((?:WC+[\/:])*)/.source.replace("WC",lh),uh=/(WCOD+)?/.source.replace("WCOD",ch),dh=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",lh),ph=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",lh),mh=new RegExp("^"+hh+uh+dh+ph+"$"),fh=["material","materials","bones"];class gh{constructor(t,e,n){this.path=e,this.parsedPath=n||gh.parseTrackName(e),this.node=gh.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new gh.Composite(t,e,n):new gh(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(oh,"")}static parseTrackName(t){const e=mh.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==fh.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=gh.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}gh.Composite=class{constructor(t,e,n){const i=n||gh.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},gh.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},gh.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},gh.prototype.GetterByBindingType=[gh.prototype._getValue_direct,gh.prototype._getValue_array,gh.prototype._getValue_arrayElement,gh.prototype._getValue_toArray],gh.prototype.SetterByBindingTypeAndVersioning=[[gh.prototype._setValue_direct,gh.prototype._setValue_direct_setNeedsUpdate,gh.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[gh.prototype._setValue_array,gh.prototype._setValue_array_setNeedsUpdate,gh.prototype._setValue_array_setMatrixWorldNeedsUpdate],[gh.prototype._setValue_arrayElement,gh.prototype._setValue_arrayElement_setNeedsUpdate,gh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[gh.prototype._setValue_fromArray,gh.prototype._setValue_fromArray_setNeedsUpdate,gh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class vh{constructor(){this.uuid=ht(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let a,o=t.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=e[u];if(void 0===d){d=o++,e[u]=d,t.push(h);for(let t=0,e=s;t!==e;++t)r[t].push(new gh(h,n[t],i[t]))}else if(d<l){a=t[d];const o=--l,c=t[o];e[c.uuid]=d,t[d]=c,e[u]=o,t[o]=h;for(let t=0,e=s;t!==e;++t){const e=r[t],s=e[o];let a=e[d];e[d]=s,void 0===a&&(a=new gh(h,n[t],i[t])),e[o]=a}}else t[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=e[o];if(void 0!==l&&l>=r){const s=r++,c=t[s];e[c.uuid]=l,t[l]=c,e[o]=s,t[s]=a;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[s],r=e[l];e[l]=i,e[s]=r}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=t.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<r){const a=--r,o=t[a],c=--s,h=t[c];e[o.uuid]=l,t[l]=o,e[h.uuid]=a,t[a]=h,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[a],r=e[c];e[l]=i,e[a]=r,e.pop()}}else{const r=--s,a=t[r];r>0&&(e[a.uuid]=l),t[l]=a,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,h=new Array(l);i=r.length,n[t]=i,s.push(t),a.push(e),r.push(h);for(let n=c,i=o.length;n!==i;++n){const i=o[n];h[n]=new gh(i,t,e)}return h}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a];e[t[a]]=n,s[n]=o,s.pop(),r[n]=r[a],r.pop(),i[n]=i[a],i.pop()}}}vh.prototype.isAnimationObjectGroup=!0;class yh{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,a=new Array(s),o={endingStart:k,endingEnd:k};for(let t=0;t!==s;++t){const e=r[t].createInterpolant(null);a[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=i/n,s=n/i;t.warp(1,r,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,o[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;if(i<0||0===n)return;this._startTime=null,e=n*i}e*=this._updateTimeScale(t);const s=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===q)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(a);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=2202===n;if(0===t)return-1===r?i:s&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const a=this.repetitions-r;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=V,i.endingEnd=V):(i.endingStart=t?this.zeroSlopeAtStart?V:k:W,i.endingEnd=e?this.zeroSlopeAtEnd?V:k:W)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=r,o[0]=e,a[1]=r+t,o[1]=n,this}}class xh extends rt{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,a=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let c=l[o];void 0===c&&(c={},l[o]=c);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let h=c[l];if(void 0!==h)s[t]=h;else{if(h=s[t],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,o,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;h=new sh(gh.create(n,l,i),r.ValueTypeName,r.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,o,l),s[t]=h}a[t].resultBuffer=h.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,a=s[r],o=a.knownActions,l=o[o.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,o[c]=l,o.pop(),t._byClipCacheIndex=null;delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,a=s[i],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[r],0===Object.keys(a).length&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new jl(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?ec.findByName(i,t):t;const a=null!==s?s.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:j),void 0!==o){const t=o.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new yh(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,a,r),c}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?ec.findByName(n,t):t,s=r?r.uuid:t,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let a=0;a!==n;++a){e[a]._update(i,t,r,s)}const a=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)a[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}xh.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class _h{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new _h(void 0===this.value.clone?this.value:this.value.clone())}}class Mh extends na{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Mh.prototype.isInstancedInterleavedBuffer=!0;class bh{constructor(t,e,n,i,r){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}bh.prototype.isGLBufferAttribute=!0;function wh(t,e){return t.distance-e.distance}function Sh(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)Sh(i[t],e,n,!0)}}const Th=new yt;class Eh{constructor(t=new yt(1/0,1/0),e=new yt(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Th.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Th.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Eh.prototype.isBox2=!0;const Ah=new zt,Lh=new zt;class Rh{constructor(t=new zt,e=new zt){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Ah.subVectors(t,this.start),Lh.subVectors(this.end,this.start);const n=Lh.dot(Lh);let i=Lh.dot(Ah)/n;return e&&(i=ut(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const Ch=new zt;const Ph=new zt,Ih=new de,Dh=new de;class Nh extends Za{constructor(t){const e=zh(t),n=new En,i=[],r=[],s=new rn(0,0,1),a=new rn(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(a.r,a.g,a.b))}n.setAttribute("position",new vn(i,3)),n.setAttribute("color",new vn(r,3));super(n,new Ga({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Dh.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(Ih.multiplyMatrices(Dh,r.matrixWorld),Ph.setFromMatrixPosition(Ih),i.setXYZ(n,Ph.x,Ph.y,Ph.z),Ih.multiplyMatrices(Dh,r.parent.matrixWorld),Ph.setFromMatrixPosition(Ih),i.setXYZ(n+1,Ph.x,Ph.y,Ph.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function zh(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,zh(t.children[n]));return e}const Bh=new zt,Fh=new rn,Oh=new rn;class Uh extends Za{constructor(t=10,e=10,n=4473924,i=8947848){n=new rn(n),i=new rn(i);const r=e/2,s=t/e,a=t/2,o=[],l=[];for(let t=0,c=0,h=-a;t<=e;t++,h+=s){o.push(-a,0,h,a,0,h),o.push(h,0,-a,h,0,a);const e=t===r?n:i;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new En;c.setAttribute("position",new vn(o,3)),c.setAttribute("color",new vn(l,3));super(c,new Ga({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}const Hh=new zt,Gh=new zt,kh=new zt;const Vh=new zt,Wh=new Qn;function jh(t,e,n,i,r,s,a){Vh.set(r,s,a).unproject(i);const o=e[t];if(void 0!==o){const t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],Vh.x,Vh.y,Vh.z)}}const qh=new Ot;class Xh extends Za{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new En;r.setIndex(new ln(n,1)),r.setAttribute("position",new ln(i,3)),super(r,new Ga({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&qh.setFromObject(this.object),qh.isEmpty())return;const e=qh.min,n=qh.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=e.x,r[4]=n.y,r[5]=n.z,r[6]=e.x,r[7]=e.y,r[8]=n.z,r[9]=n.x,r[10]=e.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=e.z,r[15]=e.x,r[16]=n.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=n.x,r[22]=e.y,r[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return Za.prototype.copy.call(this,t),this.object=t.object,this}}const Yh=new zt;let Jh,Zh;class Qh extends Za{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new En;n.setAttribute("position",new vn(e,3)),n.setAttribute("color",new vn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(n,new Ga({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const i=new rn,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}const Kh=new Float32Array(1),$h=new Int32Array(Kh.buffer);_o.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(_o.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Go.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)},Uh.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},Nh.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},ac.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Dc.extractUrlBase(t)},ac.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Eh.prototype.center=function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},Eh.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Eh.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Eh.prototype.size=function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)},Ot.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Ot.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Ot.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Ot.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Ot.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},ie.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},ci.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Rh.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},xt.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},xt.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},xt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},xt.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},xt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},xt.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},de.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},de.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},de.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new zt).setFromMatrixColumn(this,3)},de.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},de.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},de.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},de.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},de.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},de.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},de.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},de.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},de.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},de.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},de.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},de.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},de.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},de.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},de.prototype.makeFrustum=function(t,e,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,i,n,r,s)},de.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},ai.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},Nt.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},Nt.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},ue.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},ue.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},ue.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Ye.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Ye.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},Ye.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},Ye.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},Ye.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},Ye.barycoordFromPoint=function(t,e,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Ye.getBarycoord(t,e,n,i,r)},Ye.normal=function(t,e,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Ye.getNormal(t,e,n,i)},ko.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},ko.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new vl(this,t)},ko.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new wl(this,t)},yt.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},yt.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},yt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},zt.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},zt.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},zt.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},zt.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},zt.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},zt.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},zt.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},zt.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},zt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Ct.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},Ct.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Fe.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},Fe.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},Fe.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},Fe.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},Fe.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(Fe.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Wn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(Wn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Ra.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Kn.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(pc.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(ln.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===nt},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(nt)}}}),ln.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?nt:et),this},ln.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ln.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},En.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},En.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new ln(arguments[1],arguments[2])))},En.prototype.addDrawCall=function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},En.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},En.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},En.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},En.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(En.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),na.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?nt:et),this},na.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},vl.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},vl.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},vl.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},ea.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},_h.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Ze.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new rn}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(Zn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Qs.prototype.clearTarget=function(t,e,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,i)},Qs.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},Qs.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Qs.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Qs.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Qs.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Qs.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Qs.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Qs.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Qs.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Qs.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Qs.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Qs.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Qs.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Qs.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},Qs.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Qs.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Qs.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Qs.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Qs.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Qs.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Qs.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Qs.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Qs.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Qs.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Qs.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?Y:X}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Gs.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Pt.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),$c.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new kc).load(t,(function(t){e.setBuffer(t)})),this},rh.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},ti.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},ti.prototype.clear=function(t,e,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,i)},Et.crossOrigin=void 0,Et.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new dc;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},Et.loadTextureCube=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new hc;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},Et.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Et.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const tu={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:e}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=e),t.ACESFilmicToneMapping=4,t.AddEquation=n,t.AddOperation=2,t.AdditiveAnimationBlendMode=q,t.AdditiveBlending=2,t.AlphaFormat=1021,t.AlwaysDepth=1,t.AlwaysStencilFunc=519,t.AmbientLight=Lc,t.AmbientLightProbe=Wc,t.AnimationClip=ec,t.AnimationLoader=class extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new lc(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=ec.parse(t[n]);e.push(i)}return e}},t.AnimationMixer=xh,t.AnimationObjectGroup=vh,t.AnimationUtils=kl,t.ArcCurve=bo,t.ArrayCamera=js,t.ArrowHelper=class extends Fe{constructor(t=new zt(0,0,1),e=new zt(0,0,0),n=1,i=16776960,r=.2*n,s=.2*r){super(),this.type="ArrowHelper",void 0===Jh&&(Jh=new En,Jh.setAttribute("position",new vn([0,0,0,0,1,0],3)),Zh=new ho(0,.5,1,5,1),Zh.translate(0,-.5,0)),this.position.copy(e),this.line=new Xa(Jh,new Ga({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Wn(Zh,new sn({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Yh.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Yh,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}},t.Audio=$c,t.AudioAnalyser=rh,t.AudioContext=Gc,t.AudioListener=class extends Fe{constructor(){super(),this.type="AudioListener",this.context=Gc.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Xc}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Jc,Zc,Qc),Kc.set(0,0,-1).applyQuaternion(Zc),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Jc.x,t),e.positionY.linearRampToValueAtTime(Jc.y,t),e.positionZ.linearRampToValueAtTime(Jc.z,t),e.forwardX.linearRampToValueAtTime(Kc.x,t),e.forwardY.linearRampToValueAtTime(Kc.y,t),e.forwardZ.linearRampToValueAtTime(Kc.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(Jc.x,Jc.y,Jc.z),e.setOrientation(Kc.x,Kc.y,Kc.z,n.x,n.y,n.z)}},t.AudioLoader=kc,t.AxesHelper=Qh,t.AxisHelper=function(t){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Qh(t)},t.BackSide=1,t.BasicDepthPacking=3200,t.BasicShadowMap=0,t.BinaryTextureLoader=function(t){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new uc(t)},t.Bone=Ca,t.BooleanKeyframeTrack=Yl,t.BoundingBoxHelper=function(t,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Xh(t,e)},t.Box2=Eh,t.Box3=Ot,t.Box3Helper=class extends Za{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new En;i.setIndex(new ln(n,1)),i.setAttribute("position",new vn([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new Ga({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}},t.BoxBufferGeometry=qn,t.BoxGeometry=qn,t.BoxHelper=Xh,t.BufferAttribute=ln,t.BufferGeometry=En,t.BufferGeometryLoader=zc,t.ByteType=1010,t.Cache=ic,t.Camera=Qn,t.CameraHelper=class extends Za{constructor(t){const e=new En,n=new Ga({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],s={},a=new rn(16755200),o=new rn(16711680),l=new rn(43775),c=new rn(16777215),h=new rn(3355443);function u(t,e,n){d(t,n),d(e,n)}function d(t,e){i.push(0,0,0),r.push(e.r,e.g,e.b),void 0===s[t]&&(s[t]=[]),s[t].push(i.length/3-1)}u("n1","n2",a),u("n2","n4",a),u("n4","n3",a),u("n3","n1",a),u("f1","f2",a),u("f2","f4",a),u("f4","f3",a),u("f3","f1",a),u("n1","f1",a),u("n2","f2",a),u("n3","f3",a),u("n4","f4",a),u("p","n1",o),u("p","n2",o),u("p","n3",o),u("p","n4",o),u("u1","u2",l),u("u2","u3",l),u("u3","u1",l),u("c","t",c),u("p","c",h),u("cn1","cn2",h),u("cn3","cn4",h),u("cf1","cf2",h),u("cf3","cf4",h),e.setAttribute("position",new vn(i,3)),e.setAttribute("color",new vn(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const t=this.geometry,e=this.pointMap;Wh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),jh("c",e,t,Wh,0,0,-1),jh("t",e,t,Wh,0,0,1),jh("n1",e,t,Wh,-1,-1,-1),jh("n2",e,t,Wh,1,-1,-1),jh("n3",e,t,Wh,-1,1,-1),jh("n4",e,t,Wh,1,1,-1),jh("f1",e,t,Wh,-1,-1,1),jh("f2",e,t,Wh,1,-1,1),jh("f3",e,t,Wh,-1,1,1),jh("f4",e,t,Wh,1,1,1),jh("u1",e,t,Wh,.7,1.1,-1),jh("u2",e,t,Wh,-.7,1.1,-1),jh("u3",e,t,Wh,0,2,-1),jh("cf1",e,t,Wh,-1,0,1),jh("cf2",e,t,Wh,1,0,1),jh("cf3",e,t,Wh,0,-1,1),jh("cf4",e,t,Wh,0,1,1),jh("cn1",e,t,Wh,-1,0,-1),jh("cn2",e,t,Wh,1,0,-1),jh("cn3",e,t,Wh,0,-1,-1),jh("cn4",e,t,Wh,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},t.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},t.CanvasTexture=oo,t.CatmullRomCurve3=Lo,t.CineonToneMapping=3,t.CircleBufferGeometry=co,t.CircleGeometry=co,t.ClampToEdgeWrapping=u,t.Clock=Xc,t.Color=rn,t.ColorKeyframeTrack=Jl,t.CompressedTexture=ao,t.CompressedTextureLoader=class extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=[],a=new ao,o=new lc(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(r.withCredentials);let l=0;function c(c){o.load(t[c],(function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=g),a.image=s,a.format=n.format,a.needsUpdate=!0,e&&e(a))}),n,i)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else o.load(t,(function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}a.image=s}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=g),a.format=n.format,a.needsUpdate=!0,e&&e(a)}),n,i);return a}},t.ConeBufferGeometry=uo,t.ConeGeometry=uo,t.CubeCamera=ti,t.CubeReflectionMapping=r,t.CubeRefractionMapping=s,t.CubeTexture=ei,t.CubeTextureLoader=hc,t.CubeUVReflectionMapping=l,t.CubeUVRefractionMapping=c,t.CubicBezierCurve=Io,t.CubicBezierCurve3=Do,t.CubicInterpolant=Wl,t.CullFaceBack=1,t.CullFaceFront=2,t.CullFaceFrontBack=3,t.CullFaceNone=0,t.Curve=_o,t.CurvePath=Ho,t.CustomBlending=5,t.CustomToneMapping=5,t.CylinderBufferGeometry=ho,t.CylinderGeometry=ho,t.Cylindrical=class{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}},t.DataTexture=Pa,t.DataTexture2DArray=Ki,t.DataTexture3D=rr,t.DataTextureLoader=uc,t.DataUtils=class{static toHalfFloat(t){t>65504&&(console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."),t=65504),Kh[0]=t;const e=$h[0];let n=e>>16&32768,i=e>>12&2047;const r=e>>23&255;return r<103?n:r>142?(n|=31744,n|=(255==r?0:1)&&8388607&e,n):r<113?(i|=2048,n|=(i>>114-r)+(i>>113-r&1),n):(n|=r-112<<10|i>>1,n+=1&i,n)}},t.DecrementStencilOp=7683,t.DecrementWrapStencilOp=34056,t.DefaultLoadingManager=sc,t.DepthFormat=A,t.DepthStencilFormat=L,t.DepthTexture=lo,t.DirectionalLight=Ac,t.DirectionalLightHelper=class extends Fe{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===e&&(e=1);let i=new En;i.setAttribute("position",new vn([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new Ga({fog:!1,toneMapped:!1});this.lightPlane=new Xa(i,r),this.add(this.lightPlane),i=new En,i.setAttribute("position",new vn([0,0,0,0,0,1],3)),this.targetLine=new Xa(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Hh.setFromMatrixPosition(this.light.matrixWorld),Gh.setFromMatrixPosition(this.light.target.matrixWorld),kh.subVectors(Gh,Hh),this.lightPlane.lookAt(Gh),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Gh),this.targetLine.scale.z=kh.length()}},t.DiscreteInterpolant=ql,t.DodecahedronBufferGeometry=mo,t.DodecahedronGeometry=mo,t.DoubleSide=2,t.DstAlphaFactor=206,t.DstColorFactor=208,t.DynamicBufferAttribute=function(t,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new ln(t,e).setUsage(nt)},t.DynamicCopyUsage=35050,t.DynamicDrawUsage=nt,t.DynamicReadUsage=35049,t.EdgesGeometry=xo,t.EdgesHelper=function(t,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Za(new xo(t.geometry),new Ga({color:void 0!==e?e:16777215}))},t.EllipseCurve=Mo,t.EqualDepth=4,t.EqualStencilFunc=514,t.EquirectangularReflectionMapping=a,t.EquirectangularRefractionMapping=o,t.Euler=be,t.EventDispatcher=rt,t.ExtrudeBufferGeometry=vl,t.ExtrudeGeometry=vl,t.FaceColors=1,t.FileLoader=lc,t.FlatShading=1,t.Float16BufferAttribute=gn,t.Float32Attribute=function(t,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new vn(t,e)},t.Float32BufferAttribute=vn,t.Float64Attribute=function(t,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new yn(t,e)},t.Float64BufferAttribute=yn,t.FloatType=b,t.Fog=ta,t.FogExp2=$s,t.Font=function(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")},t.FontLoader=function(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")},t.FrontSide=0,t.Frustum=ci,t.GLBufferAttribute=bh,t.GLSL1="100",t.GLSL3=it,t.GammaEncoding=J,t.GreaterDepth=6,t.GreaterEqualDepth=5,t.GreaterEqualStencilFunc=518,t.GreaterStencilFunc=516,t.GridHelper=Uh,t.Group=qs,t.HalfFloatType=w,t.HemisphereLight=mc,t.HemisphereLightHelper=class extends Fe{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const i=new Ml(e);i.rotateY(.5*Math.PI),this.material=new sn({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),s=new Float32Array(3*r.count);i.setAttribute("color",new ln(s,3)),this.add(new Wn(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");Fh.copy(this.light.color),Oh.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?Fh:Oh;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}t.lookAt(Bh.setFromMatrixPosition(this.light.matrixWorld).negate())}},t.HemisphereLightProbe=Vc,t.IcosahedronBufferGeometry=xl,t.IcosahedronGeometry=xl,t.ImageBitmapLoader=Uc,t.ImageLoader=cc,t.ImageUtils=Et,t.ImmediateRenderObject=function(){console.error("THREE.ImmediateRenderObject has been removed.")},t.IncrementStencilOp=7682,t.IncrementWrapStencilOp=34055,t.InstancedBufferAttribute=za,t.InstancedBufferGeometry=Nc,t.InstancedInterleavedBuffer=Mh,t.InstancedMesh=Ha,t.Int16Attribute=function(t,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new dn(t,e)},t.Int16BufferAttribute=dn,t.Int32Attribute=function(t,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new mn(t,e)},t.Int32BufferAttribute=mn,t.Int8Attribute=function(t,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new cn(t,e)},t.Int8BufferAttribute=cn,t.IntType=1013,t.InterleavedBuffer=na,t.InterleavedBufferAttribute=ra,t.Interpolant=Vl,t.InterpolateDiscrete=U,t.InterpolateLinear=H,t.InterpolateSmooth=G,t.InvertStencilOp=5386,t.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},t.KeepStencilOp=tt,t.KeyframeTrack=Xl,t.LOD=wa,t.LatheBufferGeometry=_l,t.LatheGeometry=_l,t.Layers=we,t.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},t.LessDepth=2,t.LessEqualDepth=3,t.LessEqualStencilFunc=515,t.LessStencilFunc=513,t.Light=pc,t.LightProbe=Pc,t.Line=Xa,t.Line3=Rh,t.LineBasicMaterial=Ga,t.LineCurve=No,t.LineCurve3=zo,t.LineDashedMaterial=Hl,t.LineLoop=Qa,t.LinePieces=1,t.LineSegments=Za,t.LineStrip=0,t.LinearEncoding=X,t.LinearFilter=g,t.LinearInterpolant=jl,t.LinearMipMapLinearFilter=1008,t.LinearMipMapNearestFilter=1007,t.LinearMipmapLinearFilter=y,t.LinearMipmapNearestFilter=v,t.LinearToneMapping=1,t.Loader=ac,t.LoaderUtils=Dc,t.LoadingManager=rc,t.LogLuvEncoding=3003,t.LoopOnce=2200,t.LoopPingPong=2202,t.LoopRepeat=2201,t.LuminanceAlphaFormat=1025,t.LuminanceFormat=1024,t.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},t.Material=Ze,t.MaterialLoader=Ic,t.Math=vt,t.MathUtils=vt,t.Matrix3=xt,t.Matrix4=de,t.MaxEquation=104,t.Mesh=Wn,t.MeshBasicMaterial=sn,t.MeshDepthMaterial=Us,t.MeshDistanceMaterial=Hs,t.MeshFaceMaterial=function(t){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),t},t.MeshLambertMaterial=Ol,t.MeshMatcapMaterial=Ul,t.MeshNormalMaterial=Fl,t.MeshPhongMaterial=zl,t.MeshPhysicalMaterial=Nl,t.MeshStandardMaterial=Dl,t.MeshToonMaterial=Bl,t.MinEquation=103,t.MirroredRepeatWrapping=d,t.MixOperation=1,t.MultiMaterial=function(t=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),t.isMultiMaterial=!0,t.materials=t,t.clone=function(){return t.slice()},t},t.MultiplyBlending=4,t.MultiplyOperation=0,t.NearestFilter=p,t.NearestMipMapLinearFilter=1005,t.NearestMipMapNearestFilter=1004,t.NearestMipmapLinearFilter=f,t.NearestMipmapNearestFilter=m,t.NeverDepth=0,t.NeverStencilFunc=512,t.NoBlending=0,t.NoColors=0,t.NoToneMapping=0,t.NormalAnimationBlendMode=j,t.NormalBlending=1,t.NotEqualDepth=7,t.NotEqualStencilFunc=517,t.NumberKeyframeTrack=Zl,t.Object3D=Fe,t.ObjectLoader=class extends ac{constructor(t){super(t)}load(t,e,n,i){const r=this,s=""===this.path?Dc.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const a=new lc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==i&&i(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?r.parse(s,e):console.error("THREE.ObjectLoader: Can't load "+t)}),n,i)}async loadAsync(t,e){const n=""===this.path?Dc.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const i=new lc(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const r=await i.loadAsync(t,e),s=JSON.parse(r),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),s=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),a=this.parseTextures(t.textures,s),o=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,r,o,a,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),void 0!==e){let t=!1;for(const e in s)if(s[e]instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,r),a=this.parseMaterials(t.materials,s),o=this.parseObject(t.object,i,a,s,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(t){const e={};if(void 0!==t)for(let n=0,i=t.length;n<i;n++){const i=(new ko).fromJSON(t[n]);e[i.uuid]=i}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse((function(t){t.isBone&&(i[t.uuid]=t)})),void 0!==t)for(let e=0,r=t.length;e<r;e++){const r=(new Na).fromJSON(t[e],i);n[r.uuid]=r}return n}parseGeometries(t,e){const n={};if(void 0!==t){const i=new zc;for(let r=0,s=t.length;r<s;r++){let s;const a=t[r];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=i.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Pl?s=Pl[a.type].fromJSON(a,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),!0===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData),n[a.uuid]=s}}return n}parseMaterials(t,e){const n={},i={};if(void 0!==t){const r=new Ic;r.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];if("MultiMaterial"===s.type){const t=[];for(let e=0;e<s.materials.length;e++){const i=s.materials[e];void 0===n[i.uuid]&&(n[i.uuid]=r.parse(i)),t.push(n[i.uuid])}i[s.uuid]=t}else void 0===n[s.uuid]&&(n[s.uuid]=r.parse(s)),i[s.uuid]=n[s.uuid]}}return i}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const i=t[n],r=ec.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),r.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:bt(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new rc(e);r=new cc(n),r.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.url;if(Array.isArray(r)){i[n.uuid]=[];for(let t=0,e=r.length;t<e;t++){const e=s(r[t]);null!==e&&(e instanceof HTMLImageElement?i[n.uuid].push(e):i[n.uuid].push(new Pa(e.data,e.width,e.height)))}}else{const t=s(n.url);null!==t&&(i[n.uuid]=t)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(t){if("string"==typeof t){const n=t,r=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await i.loadAsync(r)}return t.data?{data:bt(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){i=new cc(this.manager),i.setCrossOrigin(this.crossOrigin);for(let e=0,i=t.length;e<i;e++){const i=t[e],s=i.url;if(Array.isArray(s)){n[i.uuid]=[];for(let t=0,e=s.length;t<e;t++){const e=s[t],a=await r(e);null!==a&&(a instanceof HTMLImageElement?n[i.uuid].push(a):n[i.uuid].push(new Pa(a.data,a.width,a.height)))}}else{const t=await r(i.url);null!==t&&(n[i.uuid]=t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const i={};if(void 0!==t)for(let r=0,s=t.length;r<s;r++){const s=t[r];let a;void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const o=e[s.image];Array.isArray(o)?(a=new ei(o),6===o.length&&(a.needsUpdate=!0)):(a=o&&o.data?new Pa(o.data,o.width,o.height):new Lt(o),o&&(a.needsUpdate=!0)),a.uuid=s.uuid,void 0!==s.name&&(a.name=s.name),void 0!==s.mapping&&(a.mapping=n(s.mapping,Bc)),void 0!==s.offset&&a.offset.fromArray(s.offset),void 0!==s.repeat&&a.repeat.fromArray(s.repeat),void 0!==s.center&&a.center.fromArray(s.center),void 0!==s.rotation&&(a.rotation=s.rotation),void 0!==s.wrap&&(a.wrapS=n(s.wrap[0],Fc),a.wrapT=n(s.wrap[1],Fc)),void 0!==s.format&&(a.format=s.format),void 0!==s.type&&(a.type=s.type),void 0!==s.encoding&&(a.encoding=s.encoding),void 0!==s.minFilter&&(a.minFilter=n(s.minFilter,Oc)),void 0!==s.magFilter&&(a.magFilter=n(s.magFilter,Oc)),void 0!==s.anisotropy&&(a.anisotropy=s.anisotropy),void 0!==s.flipY&&(a.flipY=s.flipY),void 0!==s.premultiplyAlpha&&(a.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(a.unpackAlignment=s.unpackAlignment),void 0!==s.userData&&(a.userData=s.userData),i[s.uuid]=a}return i}parseObject(t,e,n,i,r){let s,a,o;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function c(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];void 0===n[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(n[r])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function h(t){return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),i[t]}switch(t.type){case"Scene":s=new ea,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new rn(t.background):s.background=h(t.background)),void 0!==t.environment&&(s.environment=h(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new ta(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new $s(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":s=new Kn(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new bi(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new Lc(t.color,t.intensity);break;case"DirectionalLight":s=new Ac(t.color,t.intensity);break;case"PointLight":s=new Tc(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new Rc(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new _c(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":s=new mc(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new Pc).fromJSON(t);break;case"SkinnedMesh":a=l(t.geometry),o=c(t.material),s=new Ra(a,o),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":a=l(t.geometry),o=c(t.material),s=new Wn(a,o);break;case"InstancedMesh":a=l(t.geometry),o=c(t.material);const e=t.count,n=t.instanceMatrix,i=t.instanceColor;s=new Ha(a,o,e),s.instanceMatrix=new za(new Float32Array(n.array),16),void 0!==i&&(s.instanceColor=new za(new Float32Array(i.array),i.itemSize));break;case"LOD":s=new wa;break;case"Line":s=new Xa(l(t.geometry),c(t.material));break;case"LineLoop":s=new Qa(l(t.geometry),c(t.material));break;case"LineSegments":s=new Za(l(t.geometry),c(t.material));break;case"PointCloud":case"Points":s=new io(l(t.geometry),c(t.material));break;case"Sprite":s=new xa(c(t.material));break;case"Group":s=new qs;break;case"Bone":s=new Ca;break;default:s=new Fe}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)s.add(this.parseObject(a[t],e,n,i,r))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];s.animations.push(r[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],i=s.getObjectByProperty("uuid",n.object);void 0!==i&&s.addLevel(i,n.distance)}}return s}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}},t.ObjectSpaceNormalMap=1,t.OctahedronBufferGeometry=Ml,t.OctahedronGeometry=Ml,t.OneFactor=201,t.OneMinusDstAlphaFactor=207,t.OneMinusDstColorFactor=209,t.OneMinusSrcAlphaFactor=205,t.OneMinusSrcColorFactor=203,t.OrthographicCamera=bi,t.PCFShadowMap=1,t.PCFSoftShadowMap=2,t.PMREMGenerator=Oi,t.ParametricGeometry=function(){return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),new En},t.Particle=function(t){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new xa(t)},t.ParticleBasicMaterial=function(t){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Ka(t)},t.ParticleSystem=function(t,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new io(t,e)},t.ParticleSystemMaterial=function(t){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Ka(t)},t.Path=Go,t.PerspectiveCamera=Kn,t.Plane=ai,t.PlaneBufferGeometry=di,t.PlaneGeometry=di,t.PlaneHelper=class extends Xa{constructor(t,e=1,n=16776960){const i=n,r=new En;r.setAttribute("position",new vn([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),r.computeBoundingSphere(),super(r,new Ga({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new En;s.setAttribute("position",new vn([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),s.computeBoundingSphere(),this.add(new Wn(s,new sn({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}},t.PointCloud=function(t,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new io(t,e)},t.PointCloudMaterial=function(t){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Ka(t)},t.PointLight=Tc,t.PointLightHelper=class extends Wn{constructor(t,e,n){super(new Sl(e,4,2),new sn({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},t.Points=io,t.PointsMaterial=Ka,t.PolarGridHelper=class extends Za{constructor(t=10,e=16,n=8,i=64,r=4473924,s=8947848){r=new rn(r),s=new rn(s);const a=[],o=[];for(let n=0;n<=e;n++){const i=n/e*(2*Math.PI),l=Math.sin(i)*t,c=Math.cos(i)*t;a.push(0,0,0),a.push(l,0,c);const h=1&n?r:s;o.push(h.r,h.g,h.b),o.push(h.r,h.g,h.b)}for(let e=0;e<=n;e++){const l=1&e?r:s,c=t-t/n*e;for(let t=0;t<i;t++){let e=t/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c;a.push(n,0,r),o.push(l.r,l.g,l.b),e=(t+1)/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c,a.push(n,0,r),o.push(l.r,l.g,l.b)}}const l=new En;l.setAttribute("position",new vn(a,3)),l.setAttribute("color",new vn(o,3));super(l,new Ga({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},t.PolyhedronBufferGeometry=po,t.PolyhedronGeometry=po,t.PositionalAudio=class extends $c{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(th,eh,nh),ih.set(0,0,1).applyQuaternion(eh);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(th.x,t),e.positionY.linearRampToValueAtTime(th.y,t),e.positionZ.linearRampToValueAtTime(th.z,t),e.orientationX.linearRampToValueAtTime(ih.x,t),e.orientationY.linearRampToValueAtTime(ih.y,t),e.orientationZ.linearRampToValueAtTime(ih.z,t)}else e.setPosition(th.x,th.y,th.z),e.setOrientation(ih.x,ih.y,ih.z)}},t.PropertyBinding=gh,t.PropertyMixer=sh,t.QuadraticBezierCurve=Bo,t.QuadraticBezierCurve3=Fo,t.Quaternion=Nt,t.QuaternionKeyframeTrack=Kl,t.QuaternionLinearInterpolant=Ql,t.REVISION=e,t.RGBADepthPacking=3201,t.RGBAFormat=E,t.RGBAIntegerFormat=1033,t.RGBA_ASTC_10x10_Format=37819,t.RGBA_ASTC_10x5_Format=37816,t.RGBA_ASTC_10x6_Format=37817,t.RGBA_ASTC_10x8_Format=37818,t.RGBA_ASTC_12x10_Format=37820,t.RGBA_ASTC_12x12_Format=37821,t.RGBA_ASTC_4x4_Format=37808,t.RGBA_ASTC_5x4_Format=37809,t.RGBA_ASTC_5x5_Format=37810,t.RGBA_ASTC_6x5_Format=37811,t.RGBA_ASTC_6x6_Format=37812,t.RGBA_ASTC_8x5_Format=37813,t.RGBA_ASTC_8x6_Format=37814,t.RGBA_ASTC_8x8_Format=37815,t.RGBA_BPTC_Format=36492,t.RGBA_ETC2_EAC_Format=O,t.RGBA_PVRTC_2BPPV1_Format=B,t.RGBA_PVRTC_4BPPV1_Format=z,t.RGBA_S3TC_DXT1_Format=C,t.RGBA_S3TC_DXT3_Format=P,t.RGBA_S3TC_DXT5_Format=I,t.RGBDEncoding=$,t.RGBEEncoding=Z,t.RGBEFormat=1023,t.RGBFormat=T,t.RGBIntegerFormat=1032,t.RGBM16Encoding=K,t.RGBM7Encoding=Q,t.RGB_ETC1_Format=36196,t.RGB_ETC2_Format=F,t.RGB_PVRTC_2BPPV1_Format=N,t.RGB_PVRTC_4BPPV1_Format=D,t.RGB_S3TC_DXT1_Format=R,t.RGFormat=1030,t.RGIntegerFormat=1031,t.RawShaderMaterial=wi,t.Ray=ue,t.Raycaster=class{constructor(t,e,n=0,i=1/0){this.ray=new ue(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new we,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return Sh(t,this,n,e),n.sort(wh),n}intersectObjects(t,e=!0,n=[]){for(let i=0,r=t.length;i<r;i++)Sh(t[i],this,n,e);return n.sort(wh),n}},t.RectAreaLight=Rc,t.RedFormat=1028,t.RedIntegerFormat=1029,t.ReinhardToneMapping=2,t.RepeatWrapping=h,t.ReplaceStencilOp=7681,t.ReverseSubtractEquation=102,t.RingBufferGeometry=bl,t.RingGeometry=bl,t.SRGB8_ALPHA8_ASTC_10x10_Format=37851,t.SRGB8_ALPHA8_ASTC_10x5_Format=37848,t.SRGB8_ALPHA8_ASTC_10x6_Format=37849,t.SRGB8_ALPHA8_ASTC_10x8_Format=37850,t.SRGB8_ALPHA8_ASTC_12x10_Format=37852,t.SRGB8_ALPHA8_ASTC_12x12_Format=37853,t.SRGB8_ALPHA8_ASTC_4x4_Format=37840,t.SRGB8_ALPHA8_ASTC_5x4_Format=37841,t.SRGB8_ALPHA8_ASTC_5x5_Format=37842,t.SRGB8_ALPHA8_ASTC_6x5_Format=37843,t.SRGB8_ALPHA8_ASTC_6x6_Format=37844,t.SRGB8_ALPHA8_ASTC_8x5_Format=37845,t.SRGB8_ALPHA8_ASTC_8x6_Format=37846,t.SRGB8_ALPHA8_ASTC_8x8_Format=37847,t.Scene=ea,t.SceneUtils=tu,t.ShaderChunk=pi,t.ShaderLib=fi,t.ShaderMaterial=Zn,t.ShadowMaterial=Il,t.Shape=ko,t.ShapeBufferGeometry=wl,t.ShapeGeometry=wl,t.ShapePath=class{constructor(){this.type="ShapePath",this.color=new rn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new Go,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,s){return this.currentPath.bezierCurveTo(t,e,n,i,r,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new ko;r.curves=i.curves,e.push(r)}return e}function i(t,e){const n=e.length;let i=!1;for(let r=n-1,s=0;s<n;r=s++){let n=e[r],a=e[s],o=a.x-n.x,l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],o=-o,a=e[r],l=-l),t.y<n.y||t.y>a.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-o*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(a.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=a.x)return!0}}return i}const r=ml.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let a,o,l;const c=[];if(1===s.length)return o=s[0],l=new ko,l.curves=o.curves,c.push(l),c;let h=!r(s[0].getPoints());h=t?!h:h;const u=[],d=[];let p,m,f=[],g=0;d[g]=void 0,f[g]=[];for(let e=0,n=s.length;e<n;e++)o=s[e],p=o.getPoints(),a=r(p),a=t?!a:a,a?(!h&&d[g]&&g++,d[g]={s:new ko,p:p},d[g].s.curves=o.curves,h&&g++,f[g]=[]):f[g].push({h:o,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1;const e=[];for(let t=0,e=d.length;t<e;t++)u[t]=[];for(let n=0,r=d.length;n<r;n++){const r=f[n];for(let s=0;s<r.length;s++){const a=r[s];let o=!0;for(let r=0;r<d.length;r++)i(a.p,d[r].p)&&(n!==r&&e.push({froms:n,tos:r,hole:s}),o?(o=!1,u[r].push(a)):t=!0);o&&u[n].push(a)}}e.length>0&&(t||(f=u))}for(let t=0,e=d.length;t<e;t++){l=d[t].s,c.push(l),m=f[t];for(let t=0,e=m.length;t<e;t++)l.holes.push(m[t].h)}return c}},t.ShapeUtils=ml,t.ShortType=1011,t.Skeleton=Na,t.SkeletonHelper=Nh,t.SkinnedMesh=Ra,t.SmoothShading=2,t.Sphere=ie,t.SphereBufferGeometry=Sl,t.SphereGeometry=Sl,t.Spherical=class{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(ut(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}},t.SphericalHarmonics3=Cc,t.SplineCurve=Oo,t.SpotLight=_c,t.SpotLightHelper=class extends Fe{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new En,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const r=t/n*Math.PI*2,s=e/n*Math.PI*2;i.push(Math.cos(r),Math.sin(r),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new vn(i,3));const r=new Ga({fog:!1,toneMapped:!1});this.cone=new Za(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),Ch.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Ch),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},t.Sprite=xa,t.SpriteMaterial=sa,t.SrcAlphaFactor=204,t.SrcAlphaSaturateFactor=210,t.SrcColorFactor=202,t.StaticCopyUsage=35046,t.StaticDrawUsage=et,t.StaticReadUsage=35045,t.StereoCamera=class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Kn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Kn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const n=t.projectionMatrix.clone(),i=e.eyeSep/2,r=i*e.near/e.focus,s=e.near*Math.tan(at*e.fov*.5)/e.zoom;let a,o;qc.elements[12]=-i,jc.elements[12]=i,a=-s*e.aspect+r,o=s*e.aspect+r,n.elements[0]=2*e.near/(o-a),n.elements[8]=(o+a)/(o-a),this.cameraL.projectionMatrix.copy(n),a=-s*e.aspect-r,o=s*e.aspect-r,n.elements[0]=2*e.near/(o-a),n.elements[8]=(o+a)/(o-a),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(qc),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(jc)}},t.StreamCopyUsage=35042,t.StreamDrawUsage=35040,t.StreamReadUsage=35041,t.StringKeyframeTrack=$l,t.SubtractEquation=101,t.SubtractiveBlending=3,t.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},t.TangentSpaceNormalMap=0,t.TetrahedronBufferGeometry=Tl,t.TetrahedronGeometry=Tl,t.TextGeometry=function(){return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),new En},t.Texture=Lt,t.TextureLoader=dc,t.TorusBufferGeometry=El,t.TorusGeometry=El,t.TorusKnotBufferGeometry=Al,t.TorusKnotGeometry=Al,t.Triangle=Ye,t.TriangleFanDrawMode=2,t.TriangleStripDrawMode=1,t.TrianglesDrawMode=0,t.TubeBufferGeometry=Ll,t.TubeGeometry=Ll,t.UVMapping=i,t.Uint16Attribute=function(t,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new pn(t,e)},t.Uint16BufferAttribute=pn,t.Uint32Attribute=function(t,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new fn(t,e)},t.Uint32BufferAttribute=fn,t.Uint8Attribute=function(t,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new hn(t,e)},t.Uint8BufferAttribute=hn,t.Uint8ClampedAttribute=function(t,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new un(t,e)},t.Uint8ClampedBufferAttribute=un,t.Uniform=_h,t.UniformsLib=mi,t.UniformsUtils=Jn,t.UnsignedByteType=x,t.UnsignedInt248Type=S,t.UnsignedIntType=M,t.UnsignedShort4444Type=1017,t.UnsignedShort5551Type=1018,t.UnsignedShort565Type=1019,t.UnsignedShortType=_,t.VSMShadowMap=3,t.Vector2=yt,t.Vector3=zt,t.Vector4=Ct,t.VectorKeyframeTrack=tc,t.Vertex=function(t,e,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new zt(t,e,n)},t.VertexColors=2,t.VideoTexture=so,t.WebGL1Renderer=Ks,t.WebGLCubeRenderTarget=ni,t.WebGLMultipleRenderTargets=It,t.WebGLMultisampleRenderTarget=Dt,t.WebGLRenderTarget=Pt,t.WebGLRenderTargetCube=function(t,e,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new ni(t,n)},t.WebGLRenderer=Qs,t.WebGLUtils=Ws,t.WireframeGeometry=Rl,t.WireframeHelper=function(t,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Za(new Rl(t.geometry),new Ga({color:void 0!==e?e:16777215}))},t.WrapAroundEnding=W,t.XHRLoader=function(t){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new lc(t)},t.ZeroCurvatureEnding=k,t.ZeroFactor=200,t.ZeroSlopeEnding=V,t.ZeroStencilOp=0,t.sRGBEncoding=Y,Object.defineProperty(t,"__esModule",{value:!0})}));

var d3=d3||{};
(function(){function di(a){return function(){return this.matches(a)}}function Mb(a,b){return a<b?-1:a>b?1:a>=b?0:NaN}function Bf(a){1===a.length&&(a=Bn(a));return{left:function(b,c,d,e){null==d&&(d=0);null==e&&(e=b.length);for(;d<e;){var g=d+e>>>1;0>a(b[g],c)?d=g+1:e=g}return d},right:function(b,c,d,e){null==d&&(d=0);null==e&&(e=b.length);for(;d<e;){var g=d+e>>>1;0<a(b[g],c)?e=g:d=g+1}return d}}}function Bn(a){return function(b,c){return Mb(a(b),c)}}function ei(a,b){return[a,b]}function Ab(a){return null===a?
NaN:+a}function fi(a,b){var c=a.length,d=0,e=-1,g=0,k,m=0;if(null==b)for(;++e<c;){if(!isNaN(k=Ab(a[e]))){var p=k-g;g+=p/++d;m+=p*(k-g)}}else for(;++e<c;)isNaN(k=Ab(b(a[e],e,a)))||(p=k-g,g+=p/++d,m+=p*(k-g));if(1<d)return m/(d-1)}function gi(a,b){return(a=fi(a,b))?Math.sqrt(a):a}function Cf(a,b){var c=a.length,d=-1,e,g,k;if(null==b)for(;++d<c;){if(null!=(e=a[d])&&e>=e)for(g=k=e;++d<c;)null!=(e=a[d])&&(g>e&&(g=e),k<e&&(k=e))}else for(;++d<c;)if(null!=(e=b(a[d],d,a))&&e>=e)for(g=k=e;++d<c;)null!=(e=
b(a[d],d,a))&&(g>e&&(g=e),k<e&&(k=e));return[g,k]}function Od(a){return function(){return a}}function Cn(a){return a}function Ta(a,b,c){a=+a;b=+b;c=2>(e=arguments.length)?(b=a,a=0,1):3>e?1:+c;for(var d=-1,e=Math.max(0,Math.ceil((b-a)/c))|0,g=Array(e);++d<e;)g[d]=a+d*c;return g}function Df(a,b,c){var d,e=-1,g;b=+b;a=+a;c=+c;if(a===b&&0<c)return[a];if(d=b<a){var k=a;a=b;b=k}if(0===(g=Nc(a,b,c))||!isFinite(g))return[];if(0<g)for(a=Math.ceil(a/g),b=Math.floor(b/g),b=Array(k=Math.ceil(b-a+1));++e<k;)b[e]=
(a+e)*g;else for(a=Math.floor(a*g),b=Math.ceil(b*g),b=Array(k=Math.ceil(a-b+1));++e<k;)b[e]=(a-e)/g;d&&b.reverse();return b}function Nc(a,b,c){b=(b-a)/Math.max(0,c);a=Math.floor(Math.log(b)/Math.LN10);b/=Math.pow(10,a);return 0<=a?(b>=Ef?10:b>=Ff?5:b>=Gf?2:1)*Math.pow(10,a):-Math.pow(10,-a)/(b>=Ef?10:b>=Ff?5:b>=Gf?2:1)}function Nb(a,b,c){var d=Math.abs(b-a)/Math.max(0,c);c=Math.pow(10,Math.floor(Math.log(d)/Math.LN10));d/=c;d>=Ef?c*=10:d>=Ff?c*=5:d>=Gf&&(c*=2);return b<a?-c:c}function Hf(a){return Math.ceil(Math.log(a.length)/
Math.LN2)+1}function Oc(a,b,c){null==c&&(c=Ab);if(d=a.length){if(0>=(b=+b)||2>d)return+c(a[0],0,a);if(1<=b)return+c(a[d-1],d-1,a);var d;b*=d-1;d=Math.floor(b);var e=+c(a[d],d,a);a=+c(a[d+1],d+1,a);return e+(a-e)*(b-d)}}function hi(a,b){var c=a.length,d=-1,e,g;if(null==b)for(;++d<c;){if(null!=(e=a[d])&&e>=e)for(g=e;++d<c;)null!=(e=a[d])&&e>g&&(g=e)}else for(;++d<c;)if(null!=(e=b(a[d],d,a))&&e>=e)for(g=e;++d<c;)null!=(e=b(a[d],d,a))&&e>g&&(g=e);return g}function If(a){var b=a.length;var c=-1;for(var d=
0,e,g;++c<b;)d+=a[c].length;for(e=Array(d);0<=--b;)for(g=a[b],c=g.length;0<=--c;)e[--d]=g[c];return e}function ii(a,b){var c=a.length,d=-1,e,g;if(null==b)for(;++d<c;){if(null!=(e=a[d])&&e>=e)for(g=e;++d<c;)null!=(e=a[d])&&g>e&&(g=e)}else for(;++d<c;)if(null!=(e=b(a[d],d,a))&&e>=e)for(g=e;++d<c;)null!=(e=b(a[d],d,a))&&g>e&&(g=e);return g}function ji(a){if(!(g=a.length))return[];for(var b=-1,c=ii(a,Dn),d=Array(c);++b<c;)for(var e=-1,g,k=d[b]=Array(g);++e<g;)k[e]=a[e][b];return d}function Dn(a){return a.length}
function En(a){return a}function Fn(a){return"translate("+(a+.5)+",0)"}function Gn(a){return"translate(0,"+(a+.5)+")"}function Hn(a){return function(b){return+a(b)}}function In(a){var b=Math.max(0,a.bandwidth()-1)/2;a.round()&&(b=Math.round(b));return function(c){return+a(c)+b}}function Jn(){return!this.__axis}function Pd(a,b){function c(q){var w=null==e?b.ticks?b.ticks.apply(b,d):b.domain():e,B=null==g?b.tickFormat?b.tickFormat.apply(b,d):En:g,F=Math.max(k,0)+p,J=b.range(),P=+J[0]+.5;J=+J[J.length-
1]+.5;var x=(b.bandwidth?In:Hn)(b.copy()),y=q.selection?q.selection():q,I=y.selectAll(".domain").data([null]);w=y.selectAll(".tick").data(w,b).order();var Q=w.exit(),V=w.enter().append("g").attr("class","tick"),N=w.select("line"),T=w.select("text");I=I.merge(I.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor"));w=w.merge(V);N=N.merge(V.append("line").attr("stroke","currentColor").attr(h+"2",v*k));T=T.merge(V.append("text").attr("fill","currentColor").attr(h,v*F).attr("dy",
1===a?"0em":3===a?"0.71em":"0.32em"));q!==y&&(I=I.transition(q),w=w.transition(q),N=N.transition(q),T=T.transition(q),Q=Q.transition(q).attr("opacity",1E-6).attr("transform",function(f){return isFinite(f=x(f))?l(f):this.getAttribute("transform")}),V.attr("opacity",1E-6).attr("transform",function(f){var n=this.parentNode.__axis;return l(n&&isFinite(n=n(f))?n:x(f))}));Q.remove();I.attr("d",4===a||2==a?m?"M"+v*m+","+P+"H0.5V"+J+"H"+v*m:"M0.5,"+P+"V"+J:m?"M"+P+","+v*m+"V0.5H"+J+"V"+v*m:"M"+P+",0.5H"+
J);w.attr("opacity",1).attr("transform",function(f){return l(x(f))});N.attr(h+"2",v*k);T.attr(h,v*F).text(B);y.filter(Jn).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",2===a?"start":4===a?"end":"middle");y.each(function(){this.__axis=x})}var d=[],e=null,g=null,k=6,m=6,p=3,v=1===a||4===a?-1:1,h=4===a||2===a?"x":"y",l=1===a||3===a?Fn:Gn;c.scale=function(q){return arguments.length?(b=q,c):b};c.ticks=function(){return d=Jf.call(arguments),c};c.tickArguments=
function(q){return arguments.length?(d=null==q?[]:Jf.call(q),c):d.slice()};c.tickValues=function(q){return arguments.length?(e=null==q?null:Jf.call(q),c):e&&e.slice()};c.tickFormat=function(q){return arguments.length?(g=q,c):g};c.tickSize=function(q){return arguments.length?(k=m=+q,c):k};c.tickSizeInner=function(q){return arguments.length?(k=+q,c):k};c.tickSizeOuter=function(q){return arguments.length?(m=+q,c):m};c.tickPadding=function(q){return arguments.length?(p=+q,c):p};return c}function Ob(){for(var a=
0,b=arguments.length,c={},d;a<b;++a){if(!(d=arguments[a]+"")||d in c)throw Error("illegal type: "+d);c[d]=[]}return new Qd(c)}function Qd(a){this._=a}function Kn(a,b){return a.trim().split(/^|\s+/).map(function(c){var d="",e=c.indexOf(".");0<=e&&(d=c.slice(e+1),c=c.slice(0,e));if(c&&!b.hasOwnProperty(c))throw Error("unknown type: "+c);return{type:c,name:d}})}function ki(a,b,c){for(var d=0,e=a.length;d<e;++d)if(a[d].name===b){a[d]=Ln;a=a.slice(0,d).concat(a.slice(d+1));break}null!=c&&a.push({name:b,
value:c});return a}function Pc(a){var b=a+="",c=b.indexOf(":");0<=c&&"xmlns"!==(b=a.slice(0,c))&&(a=a.slice(c+1));return Ua.hasOwnProperty(b)?{space:Ua[b],local:a}:a}function Mn(a){return function(){var b=this.ownerDocument,c=this.namespaceURI;return"http://www.w3.org/1999/xhtml"===c&&"http://www.w3.org/1999/xhtml"===b.documentElement.namespaceURI?b.createElement(a):b.createElementNS(c,a)}}function Nn(a){return function(){return this.ownerDocument.createElementNS(a.space,a.local)}}function Rd(a){a=
Pc(a);return(a.local?Nn:Mn)(a)}function On(){}function Sd(a){return null==a?On:function(){return this.querySelector(a)}}function Pn(){return[]}function Kf(a){return null==a?Pn:function(){return this.querySelectorAll(a)}}function li(a){return Array(a.length)}function Td(a,b){this.ownerDocument=a.ownerDocument;this.namespaceURI=a.namespaceURI;this._next=null;this._parent=a;this.__data__=b}function Qn(a){return function(){return a}}function Rn(a,b,c,d,e,g){for(var k=0,m,p=b.length,v=g.length;k<v;++k)(m=
b[k])?(m.__data__=g[k],d[k]=m):c[k]=new Td(a,g[k]);for(;k<p;++k)if(m=b[k])e[k]=m}function Sn(a,b,c,d,e,g,k){var m,p,v={},h=b.length,l=g.length,q=Array(h),w;for(m=0;m<h;++m)if(p=b[m])q[m]=w="$"+k.call(p,p.__data__,m,b),w in v?e[m]=p:v[w]=p;for(m=0;m<l;++m)w="$"+k.call(a,g[m],m,g),(p=v[w])?(d[m]=p,p.__data__=g[m],v[w]=null):c[m]=new Td(a,g[m]);for(m=0;m<h;++m)(p=b[m])&&v[q[m]]===p&&(e[m]=p)}function Tn(a,b){return a<b?-1:a>b?1:a>=b?0:NaN}function Un(a){return function(){this.removeAttribute(a)}}function Vn(a){return function(){this.removeAttributeNS(a.space,
a.local)}}function Wn(a,b){return function(){this.setAttribute(a,b)}}function Xn(a,b){return function(){this.setAttributeNS(a.space,a.local,b)}}function Yn(a,b){return function(){var c=b.apply(this,arguments);null==c?this.removeAttribute(a):this.setAttribute(a,c)}}function Zn(a,b){return function(){var c=b.apply(this,arguments);null==c?this.removeAttributeNS(a.space,a.local):this.setAttributeNS(a.space,a.local,c)}}function Lf(a){return a.ownerDocument&&a.ownerDocument.defaultView||a.document&&a||
a.defaultView}function $n(a){return function(){this.style.removeProperty(a)}}function ao(a,b,c){return function(){this.style.setProperty(a,b,c)}}function bo(a,b,c){return function(){var d=b.apply(this,arguments);null==d?this.style.removeProperty(a):this.style.setProperty(a,d,c)}}function Pb(a,b){return a.style.getPropertyValue(b)||Lf(a).getComputedStyle(a,null).getPropertyValue(b)}function co(a){return function(){delete this[a]}}function eo(a,b){return function(){this[a]=b}}function fo(a,b){return function(){var c=
b.apply(this,arguments);null==c?delete this[a]:this[a]=c}}function Mf(a){return a.classList||new mi(a)}function mi(a){this._node=a;this._names=(a.getAttribute("class")||"").trim().split(/^|\s+/)}function ni(a,b){a=Mf(a);for(var c=-1,d=b.length;++c<d;)a.add(b[c])}function oi(a,b){a=Mf(a);for(var c=-1,d=b.length;++c<d;)a.remove(b[c])}function go(a){return function(){ni(this,a)}}function ho(a){return function(){oi(this,a)}}function io(a,b){return function(){(b.apply(this,arguments)?ni:oi)(this,a)}}function jo(){this.textContent=
""}function ko(a){return function(){this.textContent=a}}function lo(a){return function(){var b=a.apply(this,arguments);this.textContent=null==b?"":b}}function mo(){this.innerHTML=""}function no(a){return function(){this.innerHTML=a}}function oo(a){return function(){var b=a.apply(this,arguments);this.innerHTML=null==b?"":b}}function po(){this.nextSibling&&this.parentNode.appendChild(this)}function qo(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function ro(){return null}
function so(){var a=this.parentNode;a&&a.removeChild(this)}function to(){return this.parentNode.insertBefore(this.cloneNode(!1),this.nextSibling)}function uo(){return this.parentNode.insertBefore(this.cloneNode(!0),this.nextSibling)}function vo(a,b,c){a=pi(a,b,c);return function(d){var e=d.relatedTarget;e&&(e===this||e.compareDocumentPosition(this)&8)||a.call(this,d)}}function pi(a,b,c){return function(d){var e=d3.event;d3.event=d;try{a.call(this,this.__data__,b,c)}finally{d3.event=e}}}function wo(a){return a.trim().split(/^|\s+/).map(function(b){var c=
"",d=b.indexOf(".");0<=d&&(c=b.slice(d+1),b=b.slice(0,d));return{type:b,name:c}})}function xo(a){return function(){var b=this.__on;if(b){for(var c=0,d=-1,e=b.length,g;c<e;++c)(g=b[c],a.type&&g.type!==a.type||g.name!==a.name)?b[++d]=g:this.removeEventListener(g.type,g.listener,g.capture);++d?b.length=d:delete this.__on}}}function yo(a,b,c){var d=qi.hasOwnProperty(a.type)?vo:pi;return function(e,g,k){e=this.__on;var m;g=d(b,g,k);if(e){k=0;for(var p=e.length;k<p;++k)if((m=e[k]).type===a.type&&m.name===
a.name){this.removeEventListener(m.type,m.listener,m.capture);this.addEventListener(m.type,m.listener=g,m.capture=c);m.value=b;return}}this.addEventListener(a.type,g,c);m={type:a.type,name:a.name,value:b,listener:g,capture:c};e?e.push(m):this.__on=[m]}}function Qc(a,b,c,d){var e=d3.event;a.sourceEvent=d3.event;d3.event=a;try{return b.apply(c,d)}finally{d3.event=e}}function ri(a,b,c){var d=Lf(a),e=d.CustomEvent;"function"===typeof e?e=new e(b,c):(e=d.document.createEvent("Event"),c?(e.initEvent(b,
c.bubbles,c.cancelable),e.detail=c.detail):e.initEvent(b,!1,!1));a.dispatchEvent(e)}function zo(a,b){return function(){return ri(this,a,b)}}function Ao(a,b){return function(){return ri(this,a,b.apply(this,arguments))}}function Ja(a,b){this._groups=a;this._parents=b}function Qb(){return new Ja([[document.documentElement]],Nf)}function Ra(a){return"string"===typeof a?new Ja([[document.querySelector(a)]],[document.documentElement]):new Ja([[a]],Nf)}function si(){return new Of}function Of(){this._="@"+
(++Bo).toString(36)}function Pf(){for(var a=d3.event,b;b=a.sourceEvent;)a=b;return a}function Ud(a,b){var c=a.ownerSVGElement||a;if(c.createSVGPoint)return c=c.createSVGPoint(),c.x=b.clientX,c.y=b.clientY,c=c.matrixTransform(a.getScreenCTM().inverse()),[c.x,c.y];c=a.getBoundingClientRect();return[b.clientX-c.left-a.clientLeft,b.clientY-c.top-a.clientTop]}function Bb(a){var b=Pf();b.changedTouches&&(b=b.changedTouches[0]);return Ud(a,b)}function Vd(a,b,c){3>arguments.length&&(c=b,b=Pf().changedTouches);
for(var d=0,e=b?b.length:0,g;d<e;++d)if((g=b[d]).identifier===c)return Ud(a,g);return null}function fc(){d3.event.preventDefault();d3.event.stopImmediatePropagation()}function Wd(a){var b=a.document.documentElement;a=Ra(a).on("dragstart.drag",fc,!0);if("onselectstart"in b)a.on("selectstart.drag",fc,!0);else b.__noselect=b.style.MozUserSelect,b.style.MozUserSelect="none"}function Xd(a,b){var c=a.document.documentElement,d=Ra(a).on("dragstart.drag",null);b&&(d.on("click.drag",fc,!0),setTimeout(function(){d.on("click.drag",
null)},0));if("onselectstart"in c)d.on("selectstart.drag",null);else c.style.MozUserSelect=c.__noselect,delete c.__noselect}function Yd(a){return function(){return a}}function Qf(a,b,c,d,e,g,k,m,p,v){this.target=a;this.type=b;this.subject=c;this.identifier=d;this.active=e;this.x=g;this.y=k;this.dx=m;this.dy=p;this._=v}function Co(){return!d3.event.button}function Do(){return this.parentNode}function Eo(a){return null==a?{x:d3.event.x,y:d3.event.y}:a}function Fo(){return"ontouchstart"in this}function gc(a,
b,c){a.prototype=b.prototype=c;c.constructor=a}function Rc(a,b){a=Object.create(a.prototype);for(var c in b)a[c]=b[c];return a}function Cb(){}function Db(a){var b;a=(a+"").trim().toLowerCase();return(b=Go.exec(a))?(b=parseInt(b[1],16),new Fa(b>>8&15|b>>4&240,b>>4&15|b&240,(b&15)<<4|b&15,1)):(b=Ho.exec(a))?ti(parseInt(b[1],16)):(b=Io.exec(a))?new Fa(b[1],b[2],b[3],1):(b=Jo.exec(a))?new Fa(255*b[1]/100,255*b[2]/100,255*b[3]/100,1):(b=Ko.exec(a))?ui(b[1],b[2],b[3],b[4]):(b=Lo.exec(a))?ui(255*b[1]/100,
255*b[2]/100,255*b[3]/100,b[4]):(b=Mo.exec(a))?vi(b[1],b[2]/100,b[3]/100,1):(b=No.exec(a))?vi(b[1],b[2]/100,b[3]/100,b[4]):wi.hasOwnProperty(a)?ti(wi[a]):"transparent"===a?new Fa(NaN,NaN,NaN,0):null}function ti(a){return new Fa(a>>16&255,a>>8&255,a&255,1)}function ui(a,b,c,d){0>=d&&(a=b=c=NaN);return new Fa(a,b,c,d)}function Rf(a){a instanceof Cb||(a=Db(a));if(!a)return new Fa;a=a.rgb();return new Fa(a.r,a.g,a.b,a.opacity)}function hc(a,b,c,d){return 1===arguments.length?Rf(a):new Fa(a,b,c,null==
d?1:d)}function Fa(a,b,c,d){this.r=+a;this.g=+b;this.b=+c;this.opacity=+d}function Sf(a){a=Math.max(0,Math.min(255,Math.round(a)||0));return(16>a?"0":"")+a.toString(16)}function vi(a,b,c,d){0>=d?a=b=c=NaN:0>=c||1<=c?a=b=NaN:0>=b&&(a=NaN);return new ib(a,b,c,d)}function Oo(a){if(a instanceof ib)return new ib(a.h,a.s,a.l,a.opacity);a instanceof Cb||(a=Db(a));if(!a)return new ib;if(a instanceof ib)return a;a=a.rgb();var b=a.r/255,c=a.g/255,d=a.b/255,e=Math.min(b,c,d),g=Math.max(b,c,d),k=NaN,m=g-e,p=
(g+e)/2;m?(k=b===g?(c-d)/m+6*(c<d):c===g?(d-b)/m+2:(b-c)/m+4,m/=.5>p?g+e:2-g-e,k*=60):m=0<p&&1>p?0:k;return new ib(k,m,p,a.opacity)}function Zd(a,b,c,d){return 1===arguments.length?Oo(a):new ib(a,b,c,null==d?1:d)}function ib(a,b,c,d){this.h=+a;this.s=+b;this.l=+c;this.opacity=+d}function Tf(a,b,c){return 255*(60>a?b+(c-b)*a/60:180>a?c:240>a?b+(c-b)*(240-a)/60:b)}function Uf(a){if(a instanceof cb)return new cb(a.l,a.a,a.b,a.opacity);if(a instanceof jb){if(isNaN(a.h))return new cb(a.l,0,0,a.opacity);
var b=a.h*xi;return new cb(a.l,Math.cos(b)*a.c,Math.sin(b)*a.c,a.opacity)}a instanceof Fa||(a=Rf(a));var c=Vf(a.r),d=Vf(a.g),e=Vf(a.b);b=Wf(.2225045*c+.7168786*d+.0606169*e);if(c===d&&d===e)var g=c=b;else g=Wf((.4360747*c+.3850649*d+.1430804*e)/.96422),c=Wf((.0139322*c+.0971045*d+.7141733*e)/.82521);return new cb(116*b-16,500*(g-b),200*(b-c),a.opacity)}function $d(a,b,c,d){return 1===arguments.length?Uf(a):new cb(a,b,c,null==d?1:d)}function cb(a,b,c,d){this.l=+a;this.a=+b;this.b=+c;this.opacity=+d}
function Wf(a){return a>Po?Math.pow(a,1/3):a/yi+zi}function Xf(a){return a>ic?a*a*a:yi*(a-zi)}function Yf(a){return 255*(.0031308>=a?12.92*a:1.055*Math.pow(a,1/2.4)-.055)}function Vf(a){return.04045>=(a/=255)?a/12.92:Math.pow((a+.055)/1.055,2.4)}function Ai(a){if(a instanceof jb)return new jb(a.h,a.c,a.l,a.opacity);a instanceof cb||(a=Uf(a));if(0===a.a&&0===a.b)return new jb(NaN,0,a.l,a.opacity);var b=Math.atan2(a.b,a.a)*Bi;return new jb(0>b?b+360:b,Math.sqrt(a.a*a.a+a.b*a.b),a.l,a.opacity)}function ae(a,
b,c,d){return 1===arguments.length?Ai(a):new jb(a,b,c,null==d?1:d)}function jb(a,b,c,d){this.h=+a;this.c=+b;this.l=+c;this.opacity=+d}function db(a,b,c,d){if(1===arguments.length){var e=a;if(e instanceof Rb)e=new Rb(e.h,e.s,e.l,e.opacity);else{e instanceof Fa||(e=Rf(e));var g=e.g/255,k=e.b/255,m=(Ci*k+e.r/255*-1.7884503806-3.5172982438*g)/(Ci+-1.7884503806-3.5172982438);k-=m;var p=(1.97294*(g-m)- -.29227*k)/-.90649;k=(g=Math.sqrt(p*p+k*k)/(1.97294*m*(1-m)))?Math.atan2(p,k)*Bi-120:NaN;e=new Rb(0>k?
k+360:k,g,m,e.opacity)}}else e=new Rb(a,b,c,null==d?1:d);return e}function Rb(a,b,c,d){this.h=+a;this.s=+b;this.l=+c;this.opacity=+d}function Di(a,b,c,d,e){var g=a*a,k=g*a;return((1-3*a+3*g-k)*b+(4-6*g+3*k)*c+(1+3*a+3*g-3*k)*d+k*e)/6}function Ei(a){var b=a.length-1;return function(c){var d=0>=c?c=0:1<=c?(c=1,b-1):Math.floor(c*b),e=a[d],g=a[d+1];return Di((c-d/b)*b,0<d?a[d-1]:2*e-g,e,g,d<b-1?a[d+2]:2*g-e)}}function Fi(a){var b=a.length;return function(c){var d=Math.floor((0>(c%=1)?++c:c)*b);return Di((c-
d/b)*b,a[(d+b-1)%b],a[d%b],a[(d+1)%b],a[(d+2)%b])}}function be(a){return function(){return a}}function Gi(a,b){return function(c){return a+c*b}}function Qo(a,b,c){return a=Math.pow(a,c),b=Math.pow(b,c)-a,c=1/c,function(d){return Math.pow(a+d*b,c)}}function ce(a,b){var c=b-a;return c?Gi(a,180<c||-180>c?c-360*Math.round(c/360):c):be(isNaN(a)?b:a)}function Ro(a){return 1===(a=+a)?Ea:function(b,c){return c-b?Qo(b,c,a):be(isNaN(b)?c:b)}}function Ea(a,b){var c=b-a;return c?Gi(a,c):be(isNaN(a)?b:a)}function Hi(a){return function(b){var c=
b.length,d=Array(c),e=Array(c),g=Array(c),k;for(k=0;k<c;++k){var m=hc(b[k]);d[k]=m.r||0;e[k]=m.g||0;g[k]=m.b||0}d=a(d);e=a(e);g=a(g);m.opacity=1;return function(p){m.r=d(p);m.g=e(p);m.b=g(p);return m+""}}}function Ii(a,b){var c=b?b.length:0,d=a?Math.min(c,a.length):0,e=Array(d),g=Array(c),k;for(k=0;k<d;++k)e[k]=Sc(a[k],b[k]);for(;k<c;++k)g[k]=b[k];return function(m){for(k=0;k<d;++k)g[k]=e[k](m);return g}}function Ji(a,b){var c=new Date;return a=+a,b-=a,function(d){return c.setTime(a+b*d),c}}function Va(a,
b){return a=+a,b-=a,function(c){return a+b*c}}function Ki(a,b){var c={},d={},e;if(null===a||"object"!==typeof a)a={};if(null===b||"object"!==typeof b)b={};for(e in b)e in a?c[e]=Sc(a[e],b[e]):d[e]=b[e];return function(g){for(e in c)d[e]=c[e](g);return d}}function So(a){return function(){return a}}function To(a){return function(b){return a(b)+""}}function Zf(a,b){var c=$f.lastIndex=ag.lastIndex=0,d,e,g,k=-1,m=[],p=[];a+="";for(b+="";(d=$f.exec(a))&&(e=ag.exec(b));)(g=e.index)>c&&(g=b.slice(c,g),m[k]?
m[k]+=g:m[++k]=g),(d=d[0])===(e=e[0])?m[k]?m[k]+=e:m[++k]=e:(m[++k]=null,p.push({i:k,x:Va(d,e)})),c=ag.lastIndex;c<b.length&&(g=b.slice(c),m[k]?m[k]+=g:m[++k]=g);return 2>m.length?p[0]?To(p[0].x):So(b):(b=p.length,function(v){for(var h=0,l;h<b;++h)m[(l=p[h]).i]=l.x(v);return m.join("")})}function Sc(a,b){var c=typeof b,d;return null==b||"boolean"===c?be(b):("number"===c?Va:"string"===c?(d=Db(b))?(b=d,Tc):Zf:b instanceof Db?Tc:b instanceof Date?Ji:Array.isArray(b)?Ii:"function"!==typeof b.valueOf&&
"function"!==typeof b.toString||isNaN(b)?Ki:Va)(a,b)}function Li(a,b){return a=+a,b-=a,function(c){return Math.round(a+b*c)}}function Mi(a,b,c,d,e,g){var k,m,p;if(k=Math.sqrt(a*a+b*b))a/=k,b/=k;if(p=a*c+b*d)c-=a*p,d-=b*p;if(m=Math.sqrt(c*c+d*d))c/=m,d/=m,p/=m;a*d<b*c&&(a=-a,b=-b,p=-p,k=-k);return{translateX:e,translateY:g,rotate:Math.atan2(b,a)*Ni,skewX:Math.atan(p)*Ni,scaleX:k,scaleY:m}}function Oi(a,b,c,d){function e(v){return v.length?v.pop()+" ":""}function g(v,h,l,q,w,B){v!==l||h!==q?(w=w.push("translate(",
null,b,null,c),B.push({i:w-4,x:Va(v,l)},{i:w-2,x:Va(h,q)})):(l||q)&&w.push("translate("+l+b+q+c)}function k(v,h,l,q){v!==h?(180<v-h?h+=360:180<h-v&&(v+=360),q.push({i:l.push(e(l)+"rotate(",null,d)-2,x:Va(v,h)})):h&&l.push(e(l)+"rotate("+h+d)}function m(v,h,l,q){v!==h?q.push({i:l.push(e(l)+"skewX(",null,d)-2,x:Va(v,h)}):h&&l.push(e(l)+"skewX("+h+d)}function p(v,h,l,q,w,B){v!==l||h!==q?(w=w.push(e(w)+"scale(",null,",",null,")"),B.push({i:w-4,x:Va(v,l)},{i:w-2,x:Va(h,q)})):1===l&&1===q||w.push(e(w)+
"scale("+l+","+q+")")}return function(v,h){var l=[],q=[];v=a(v);h=a(h);g(v.translateX,v.translateY,h.translateX,h.translateY,l,q);k(v.rotate,h.rotate,l,q);m(v.skewX,h.skewX,l,q);p(v.scaleX,v.scaleY,h.scaleX,h.scaleY,l,q);v=h=null;return function(w){for(var B=-1,F=q.length,J;++B<F;)l[(J=q[B]).i]=J.x(w);return l.join("")}}}function Pi(a){return((a=Math.exp(a))+1/a)/2}function Qi(a,b){var c=a[0],d=a[1],e=a[2];a=b[2];var g=b[0]-c,k=b[1]-d,m=g*g+k*k;if(1E-12>m){var p=Math.log(a/e)/Uc;a=function(l){return[c+
l*g,d+l*k,e*Math.exp(Uc*l*p)]}}else{var v=Math.sqrt(m);b=(a*a-e*e+4*m)/(4*e*v);a=(a*a-e*e-4*m)/(4*a*v);var h=Math.log(Math.sqrt(b*b+1)-b);p=(Math.log(Math.sqrt(a*a+1)-a)-h)/Uc;a=function(l){l*=p;var q=Pi(h),w=Uc*l+h;var B=((w=Math.exp(2*w))-1)/(w+1);var F=h;w=((F=Math.exp(F))-1/F)/2;B=e/(2*v)*(q*B-w);return[c+B*g,d+B*k,e*q/Pi(Uc*l+h)]}}a.duration=1E3*p;return a}function Ri(a){return function(b,c){var d=a((b=Zd(b)).h,(c=Zd(c)).h),e=Ea(b.s,c.s),g=Ea(b.l,c.l),k=Ea(b.opacity,c.opacity);return function(m){b.h=
d(m);b.s=e(m);b.l=g(m);b.opacity=k(m);return b+""}}}function Si(a){return function(b,c){var d=a((b=ae(b)).h,(c=ae(c)).h),e=Ea(b.c,c.c),g=Ea(b.l,c.l),k=Ea(b.opacity,c.opacity);return function(m){b.h=d(m);b.c=e(m);b.l=g(m);b.opacity=k(m);return b+""}}}function Ti(a){return function d(c){function e(g,k){var m=a((g=db(g)).h,(k=db(k)).h),p=Ea(g.s,k.s),v=Ea(g.l,k.l),h=Ea(g.opacity,k.opacity);return function(l){g.h=m(l);g.s=p(l);g.l=v(Math.pow(l,c));g.opacity=h(l);return g+""}}c=+c;e.gamma=d;return e}(1)}
function jc(){return Sb||(Ui(Uo),Sb=Vc.now()+de)}function Uo(){Sb=0}function Wc(){this._call=this._time=this._next=null}function ee(a,b,c){var d=new Wc;d.restart(a,b,c);return d}function Vi(){jc();++kc;for(var a=fe,b;a;)0<=(b=Sb-a._time)&&a._call.call(null,b),a=a._next;--kc}function Wi(){Sb=(ge=Vc.now())+de;kc=Xc=0;try{Vi()}finally{kc=0;for(var a,b=fe,c,d=Infinity;b;)b._call?(d>b._time&&(d=b._time),a=b,b=b._next):(c=b._next,b._next=null,b=a?a._next=c:fe=c);Yc=a;bg(d);Sb=0}}function Vo(){var a=Vc.now(),
b=a-ge;1E3<b&&(de-=b,ge=a)}function bg(a){kc||(Xc&&(Xc=clearTimeout(Xc)),24<a-Sb?(Infinity>a&&(Xc=setTimeout(Wi,a-Vc.now()-de)),Zc&&(Zc=clearInterval(Zc))):(Zc||(ge=Vc.now(),Zc=setInterval(Vo,1E3)),kc=1,Ui(Wi)))}function cg(a,b,c){var d=new Wc;b=null==b?0:+b;d.restart(function(e){d.stop();a(e+b)},b,c);return d}function he(a,b,c,d,e,g){var k=a.__transition;if(!k)a.__transition={};else if(c in k)return;Wo(a,c,{name:b,index:d,group:e,on:Xo,tween:Yo,time:g.time,delay:g.delay,duration:g.duration,ease:g.ease,
timer:null,state:0})}function dg(a,b){a=eb(a,b);if(0<a.state)throw Error("too late; already scheduled");return a}function Tb(a,b){a=eb(a,b);if(2<a.state)throw Error("too late; already started");return a}function eb(a,b){a=a.__transition;if(!a||!(a=a[b]))throw Error("transition not found");return a}function Wo(a,b,c){function d(p){var v,h;if(1!==c.state)return g();for(q in k){var l=k[q];if(l.name===c.name){if(3===l.state)return cg(d);4===l.state?(l.state=6,l.timer.stop(),l.on.call("interrupt",a,a.__data__,
l.index,l.group),delete k[q]):+q<b&&(l.state=6,l.timer.stop(),delete k[q])}}cg(function(){3===c.state&&(c.state=4,c.timer.restart(e,c.delay,c.time),e(p))});c.state=2;c.on.call("start",a,a.__data__,c.index,c.group);if(2===c.state){c.state=3;m=Array(h=c.tween.length);var q=0;for(v=-1;q<h;++q)if(l=c.tween[q].value.call(a,a.__data__,c.index,c.group))m[++v]=l;m.length=v+1}}function e(p){p=p<c.duration?c.ease.call(null,p/c.duration):(c.timer.restart(g),c.state=5,1);for(var v=-1,h=m.length;++v<h;)m[v].call(null,
p);5===c.state&&(c.on.call("end",a,a.__data__,c.index,c.group),g())}function g(){c.state=6;c.timer.stop();delete k[b];for(var p in k)return;delete a.__transition}var k=a.__transition,m;k[b]=c;c.timer=ee(function(p){c.state=1;c.timer.restart(d,c.delay,c.time);c.delay<=p&&d(p-c.delay)},0,c.time)}function Ub(a,b){var c=a.__transition,d,e=!0,g;if(c){b=null==b?null:b+"";for(g in c)if((d=c[g]).name!==b)e=!1;else{var k=2<d.state&&5>d.state;d.state=6;d.timer.stop();k&&d.on.call("interrupt",a,a.__data__,d.index,
d.group);delete c[g]}e&&delete a.__transition}}function Zo(a,b){var c,d;return function(){var e=Tb(this,a),g=e.tween;if(g!==c){d=c=g;g=0;for(var k=d.length;g<k;++g)if(d[g].name===b){d=d.slice();d.splice(g,1);break}}e.tween=d}}function $o(a,b,c){var d,e;if("function"!==typeof c)throw Error();return function(){var g=Tb(this,a),k=g.tween;if(k!==d){e=(d=k).slice();k={name:b,value:c};for(var m=0,p=e.length;m<p;++m)if(e[m].name===b){e[m]=k;break}m===p&&e.push(k)}g.tween=e}}function eg(a,b,c){var d=a._id;
a.each(function(){var e=Tb(this,d);(e.value||(e.value={}))[b]=c.apply(this,arguments)});return function(e){return eb(e,d).value[b]}}function Xi(a,b){var c;return("number"===typeof b?Va:b instanceof Db?Tc:(c=Db(b))?(b=c,Tc):Zf)(a,b)}function ap(a){return function(){this.removeAttribute(a)}}function bp(a){return function(){this.removeAttributeNS(a.space,a.local)}}function cp(a,b,c){var d,e;return function(){var g=this.getAttribute(a);return g===c?null:g===d?e:e=b(d=g,c)}}function dp(a,b,c){var d,e;
return function(){var g=this.getAttributeNS(a.space,a.local);return g===c?null:g===d?e:e=b(d=g,c)}}function ep(a,b,c){var d,e,g;return function(){var k=c(this);if(null==k)return void this.removeAttribute(a);var m=this.getAttribute(a);return m===k?null:m===d&&k===e?g:g=b(d=m,e=k)}}function fp(a,b,c){var d,e,g;return function(){var k=c(this);if(null==k)return void this.removeAttributeNS(a.space,a.local);var m=this.getAttributeNS(a.space,a.local);return m===k?null:m===d&&k===e?g:g=b(d=m,e=k)}}function gp(a,
b){function c(){var d=this,e=b.apply(d,arguments);return e&&function(g){d.setAttributeNS(a.space,a.local,e(g))}}c._value=b;return c}function hp(a,b){function c(){var d=this,e=b.apply(d,arguments);return e&&function(g){d.setAttribute(a,e(g))}}c._value=b;return c}function ip(a,b){return function(){dg(this,a).delay=+b.apply(this,arguments)}}function jp(a,b){return b=+b,function(){dg(this,a).delay=b}}function kp(a,b){return function(){Tb(this,a).duration=+b.apply(this,arguments)}}function lp(a,b){return b=
+b,function(){Tb(this,a).duration=b}}function mp(a,b){if("function"!==typeof b)throw Error();return function(){Tb(this,a).ease=b}}function np(a){return(a+"").trim().split(/^|\s+/).every(function(b){var c=b.indexOf(".");0<=c&&(b=b.slice(0,c));return!b||"start"===b})}function op(a,b,c){var d,e,g=np(b)?dg:Tb;return function(){var k=g(this,a),m=k.on;if(m!==d)(e=(d=m).copy()).on(b,c);k.on=e}}function pp(a){return function(){var b=this.parentNode,c;for(c in this.__transition)if(+c!==a)return;b&&b.removeChild(this)}}
function qp(a,b){var c,d,e;return function(){var g=Pb(this,a),k=(this.style.removeProperty(a),Pb(this,a));return g===k?null:g===c&&k===d?e:e=b(c=g,d=k)}}function rp(a){return function(){this.style.removeProperty(a)}}function sp(a,b,c){var d,e;return function(){var g=Pb(this,a);return g===c?null:g===d?e:e=b(d=g,c)}}function tp(a,b,c){var d,e,g;return function(){var k=Pb(this,a),m=c(this);null==m&&(m=(this.style.removeProperty(a),Pb(this,a)));return k===m?null:k===d&&m===e?g:g=b(d=k,e=m)}}function up(a,
b,c){function d(){var e=this,g=b.apply(e,arguments);return g&&function(k){e.style.setProperty(a,g(k),c)}}d._value=b;return d}function vp(a){return function(){this.textContent=a}}function wp(a){return function(){var b=a(this);this.textContent=null==b?"":b}}function kb(a,b,c,d){this._groups=a;this._parents=b;this._name=c;this._id=d}function Yi(a){return Qb().transition(a)}function Zi(a){return(1>=(a*=2)?a*a:--a*(2-a)+1)/2}function fg(a){return(1>=(a*=2)?a*a*a:(a-=2)*a*a+2)/2}function $i(a){return(1-
Math.cos(aj*a))/2}function bj(a){return(1>=(a*=2)?Math.pow(2,10*a-10):2-Math.pow(2,10-10*a))/2}function cj(a){return(1>=(a*=2)?1-Math.sqrt(1-a*a):Math.sqrt(1-(a-=2)*a)+1)/2}function $c(a){return(a=+a)<gg?ie*a*a:a<xp?ie*(a-=yp)*a+.75:a<zp?ie*(a-=Ap)*a+.9375:ie*(a-=Bp)*a+.984375}function dj(a){return function(){return a}}function Cp(a,b,c){this.target=a;this.type=b;this.selection=c}function je(){d3.event.preventDefault();d3.event.stopImmediatePropagation()}function ad(a){return{type:a}}function Dp(){return!d3.event.button}
function Ep(){var a=this.ownerSVGElement||this;return[[0,0],[a.width.baseVal.value,a.height.baseVal.value]]}function hg(a){for(;!a.__brush;)if(!(a=a.parentNode))return;return a.__brush}function ig(a){return a[0][0]===a[1][0]||a[0][1]===a[1][1]}function jg(a){function b(q){var w=q.property("__brush",k).selectAll(".overlay").data([ad("overlay")]);w.enter().append("rect").attr("class","overlay").attr("pointer-events","all").attr("cursor",qb.overlay).merge(w).each(function(){var B=hg(this).extent;Ra(this).attr("x",
B[0][0]).attr("y",B[0][1]).attr("width",B[1][0]-B[0][0]).attr("height",B[1][1]-B[0][1])});q.selectAll(".selection").data([ad("selection")]).enter().append("rect").attr("class","selection").attr("cursor",qb.selection).attr("fill","#777").attr("fill-opacity",.3).attr("stroke","#fff").attr("shape-rendering","crispEdges");w=q.selectAll(".handle").data(a.handles,function(B){return B.type});w.exit().remove();w.enter().append("rect").attr("class",function(B){return"handle handle--"+B.type}).attr("cursor",
function(B){return qb[B.type]});q.each(c).attr("fill","none").attr("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush touchstart.brush",g)}function c(){var q=Ra(this),w=hg(this).selection;w?(q.selectAll(".selection").style("display",null).attr("x",w[0][0]).attr("y",w[0][1]).attr("width",w[1][0]-w[0][0]).attr("height",w[1][1]-w[0][1]),q.selectAll(".handle").style("display",null).attr("x",function(B){return"e"===B.type[B.type.length-1]?w[1][0]-h/2:w[0][0]-
h/2}).attr("y",function(B){return"s"===B.type[0]?w[1][1]-h/2:w[0][1]-h/2}).attr("width",function(B){return"n"===B.type||"s"===B.type?w[1][0]-w[0][0]+h:h}).attr("height",function(B){return"e"===B.type||"w"===B.type?w[1][1]-w[0][1]+h:h})):q.selectAll(".selection,.handle").style("display","none").attr("x",null).attr("y",null).attr("width",null).attr("height",null)}function d(q,w){return q.__brush.emitter||new e(q,w)}function e(q,w){this.that=q;this.args=w;this.state=q.__brush;this.active=0}function g(){function q(){var ea=
Bb(P);!S||E||K||(Math.abs(ea[0]-L[0])>Math.abs(ea[1]-L[1])?K=!0:E=!0);L=ea;O=!0;je();w()}function w(){C=L[0]-H[0];G=L[1]-H[1];switch(y){case kg:case ej:I&&(C=Math.max(f-n,Math.min(t-z,C)),M=n+C,Y=z+C);Q&&(G=Math.max(u-r,Math.min(D-A,G)),X=r+G,W=A+G);break;case lc:0>I?(C=Math.max(f-n,Math.min(t-n,C)),M=n+C,Y=z):0<I&&(C=Math.max(f-z,Math.min(t-z,C)),M=n,Y=z+C);0>Q?(G=Math.max(u-r,Math.min(D-r,G)),X=r+G,W=A):0<Q&&(G=Math.max(u-A,Math.min(D-A,G)),X=r,W=A+G);break;case mc:I&&(M=Math.max(f,Math.min(t,n-
C*I)),Y=Math.max(f,Math.min(t,z+C*I))),Q&&(X=Math.max(u,Math.min(D,r-G*Q)),W=Math.max(u,Math.min(D,A+G*Q)))}if(Y<M){I*=-1;var ea=n;n=z;z=ea;ea=M;M=Y;Y=ea;x in fj&&aa.attr("cursor",qb[x=fj[x]])}W<X&&(Q*=-1,ea=r,r=A,A=ea,ea=X,X=W,W=ea,x in gj&&aa.attr("cursor",qb[x=gj[x]]));V.selection&&(T=V.selection);E&&(M=T[0][0],Y=T[1][0]);K&&(X=T[0][1],W=T[1][1]);if(T[0][0]!==M||T[0][1]!==X||T[1][0]!==Y||T[1][1]!==W)V.selection=[[M,X],[Y,W]],c.call(P),U.brush()}function B(){d3.event.stopImmediatePropagation();
if(d3.event.touches){if(d3.event.touches.length)return;l&&clearTimeout(l);l=setTimeout(function(){l=null},500);ba.on("touchmove.brush touchend.brush touchcancel.brush",null)}else Xd(d3.event.view,O),ha.on("keydown.brush keyup.brush mousemove.brush mouseup.brush",null);ba.attr("pointer-events","all");aa.attr("cursor",qb.overlay);V.selection&&(T=V.selection);ig(T)&&(V.selection=null,c.call(P));U.end()}function F(){switch(d3.event.keyCode){case 16:S=I&&Q;break;case 18:y===lc&&(I&&(z=Y-C*I,n=M+C*I),Q&&
(A=W-G*Q,r=X+G*Q),y=mc,w());break;case 32:if(y===lc||y===mc)0>I?z=Y-C:0<I&&(n=M-C),0>Q?A=W-G:0<Q&&(r=X-G),y=kg,aa.attr("cursor",qb.selection),w();break;default:return}je()}function J(){switch(d3.event.keyCode){case 16:S&&(E=K=S=!1,w());break;case 18:y===mc&&(0>I?z=Y:0<I&&(n=M),0>Q?A=W:0<Q&&(r=X),y=lc,w());break;case 32:y===kg&&(d3.event.altKey?(I&&(z=Y-C*I,n=M+C*I),Q&&(A=W-G*Q,r=X+G*Q),y=mc):(0>I?z=Y:0<I&&(n=M),0>Q?A=W:0<Q&&(r=X),y=lc),aa.attr("cursor",qb[x]),w());break;default:return}je()}if(d3.event.touches){if(d3.event.changedTouches.length<
d3.event.touches.length)return je()}else if(l)return;if(p.apply(this,arguments)){var P=this,x=d3.event.target.__data__.type,y="selection"===(d3.event.metaKey?x="overlay":x)?ej:d3.event.altKey?mc:lc,I=a===ke?null:Fp[x],Q=a===le?null:Gp[x],V=hg(P),N=V.extent,T=V.selection,f=N[0][0],n,u=N[0][1],r,t=N[1][0],z,D=N[1][1],A,C,G,O,S=I&&Q&&d3.event.shiftKey,E,K,H=Bb(P),L=H,U=d(P,arguments).beforestart();"overlay"===x?V.selection=T=[[n=a===ke?f:H[0],r=a===le?u:H[1]],[z=a===ke?t:n,A=a===le?D:r]]:(n=T[0][0],
r=T[0][1],z=T[1][0],A=T[1][1]);var M=n;var X=r;var Y=z;var W=A;var ba=Ra(P).attr("pointer-events","none"),aa=ba.selectAll(".overlay").attr("cursor",qb[x]);if(d3.event.touches)ba.on("touchmove.brush",q,!0).on("touchend.brush touchcancel.brush",B,!0);else{var ha=Ra(d3.event.view).on("keydown.brush",F,!0).on("keyup.brush",J,!0).on("mousemove.brush",q,!0).on("mouseup.brush",B,!0);Wd(d3.event.view)}d3.event.stopImmediatePropagation();Ub(P);c.call(P);U.start()}}function k(){var q=this.__brush||{selection:null};
q.extent=m.apply(this,arguments);q.dim=a;return q}var m=Ep,p=Dp,v=Ob(b,"start","brush","end"),h=6,l;b.move=function(q,w){q.selection?q.on("start.brush",function(){d(this,arguments).beforestart().start()}).on("interrupt.brush end.brush",function(){d(this,arguments).end()}).tween("brush",function(){function B(Q){J.selection=1===Q&&ig(y)?null:I(Q);c.call(F);P.brush()}var F=this,J=F.__brush,P=d(F,arguments),x=J.selection,y=a.input("function"===typeof w?w.apply(this,arguments):w,J.extent),I=Sc(x,y);return x&&
y?B:B(1)}):q.each(function(){var B=arguments,F=this.__brush,J=a.input("function"===typeof w?w.apply(this,B):w,F.extent);B=d(this,B).beforestart();Ub(this);F.selection=null==J||ig(J)?null:J;c.call(this);B.start().brush().end()})};e.prototype={beforestart:function(){1===++this.active&&(this.state.emitter=this,this.starting=!0);return this},start:function(){this.starting&&(this.starting=!1,this.emit("start"));return this},brush:function(){this.emit("brush");return this},end:function(){0===--this.active&&
(delete this.state.emitter,this.emit("end"));return this},emit:function(q){Qc(new Cp(b,q,a.output(this.state.selection)),v.apply,v,[q,this.that,this.args])}};b.extent=function(q){return arguments.length?(m="function"===typeof q?q:dj([[+q[0][0],+q[0][1]],[+q[1][0],+q[1][1]]]),b):m};b.filter=function(q){return arguments.length?(p="function"===typeof q?q:dj(!!q),b):p};b.handleSize=function(q){return arguments.length?(h=+q,b):h};b.on=function(){var q=v.on.apply(v,arguments);return q===v?b:q};return b}
function Hp(a){return function(b,c){return a(b.source.value+b.target.value,c.source.value+c.target.value)}}function lg(a){return function(){return a}}function mg(){this._x0=this._y0=this._x1=this._y1=null;this._=""}function Eb(){return new mg}function Ip(a){return a.source}function Jp(a){return a.target}function Kp(a){return a.radius}function Lp(a){return a.startAngle}function Mp(a){return a.endAngle}function me(){}function rb(a,b){var c=new me;if(a instanceof me)a.each(function(k,m){c.set(m,k)});
else if(Array.isArray(a)){var d=-1,e=a.length,g;if(null==b)for(;++d<e;)c.set(d,a[d]);else for(;++d<e;)c.set(b(g=a[d],d,a),g)}else if(a)for(d in a)c.set(d,a[d]);return c}function Np(){return{}}function Op(a,b,c){a[b]=c}function hj(){return rb()}function ij(a,b,c){a.set(b,c)}function ne(){}function jj(a,b){var c=new ne;if(a instanceof ne)a.each(function(g){c.add(g)});else if(a){var d=-1,e=a.length;if(null==b)for(;++d<e;)c.add(a[d]);else for(;++d<e;)c.add(b(a[d],d,a))}return c}function Pp(a,b){return a-
b}function Fb(a){return function(){return a}}function Qp(){}function kj(){function a(p){var v=k(p);if(Array.isArray(v))v=v.slice().sort(Pp);else{var h=Cf(p),l=h[0];h=h[1];v=Nb(l,h,v);v=Ta(Math.floor(l/v)*v,Math.floor(h/v)*v,v)}return v.map(function(q){return b(p,q)})}function b(p,v){var h=[],l=[];c(p,v,function(q){m(q,p,v);for(var w=0,B=q.length,F=q[B-1][1]*q[0][0]-q[B-1][0]*q[0][1];++w<B;)F+=q[w-1][1]*q[w][0]-q[w-1][0]*q[w][1];0<F?h.push([q]):l.push(q)});l.forEach(function(q){for(var w=0,B=h.length,
F;w<B;++w){a:{var J=(F=h[w])[0];for(var P=q,x=-1,y=P.length;++x<y;){b:{var I=J;for(var Q=P[x],V=Q[0],N=Q[1],T=-1,f=0,n=I.length,u=n-1;f<n;u=f++){var r=I[f],t=r[0],z=r[1],D=I[u];u=D[0];var A=D[1],C,G=r;r=D;D=Q;if(C=(r[0]-G[0])*(D[1]-G[1])===(D[0]-G[0])*(r[1]-G[1]))G=G[C=+(G[0]===r[0])],D=D[C],r=r[C],C=G<=D&&D<=r||r<=D&&D<=G;if(C){I=0;break b}z>N!==A>N&&V<(u-t)*(N-z)/(A-z)+t&&(T=-T)}I=T}if(I){J=I;break a}}J=0}if(-1!==J){F.push(q);break}}});return{type:"MultiPolygon",value:v,coordinates:h}}function c(p,
v,h){function l(I){var Q=[I[0][0]+F,I[0][1]+B];I=[I[1][0]+F,I[1][1]+B];var V=2*Q[0]+Q[1]*(e+1)*4,N=2*I[0]+I[1]*(e+1)*4,T,f;(T=w[V])?(f=q[N])?(delete w[T.end],delete q[f.start],T===f?(T.ring.push(I),h(T.ring)):q[T.start]=w[f.end]={start:T.start,end:f.end,ring:T.ring.concat(f.ring)}):(delete w[T.end],T.ring.push(I),w[T.end=N]=T):(T=q[N])?(f=w[V])?(delete q[T.start],delete w[f.end],T===f?(T.ring.push(I),h(T.ring)):q[f.start]=w[T.end]={start:f.start,end:T.end,ring:f.ring.concat(T.ring)}):(delete q[T.start],
T.ring.unshift(Q),q[T.start=V]=T):q[V]=w[N]={start:V,end:N,ring:[Q,I]}}var q=[],w=[],B;var F=B=-1;var J=p[0]>=v;for(sb[J<<1].forEach(l);++F<e-1;){var P=J;J=p[F+1]>=v;sb[P|J<<1].forEach(l)}for(sb[J<<0].forEach(l);++B<g-1;){F=-1;J=p[B*e+e]>=v;var x=p[B*e]>=v;for(sb[J<<1|x<<2].forEach(l);++F<e-1;){P=J;J=p[B*e+e+F+1]>=v;var y=x;x=p[B*e+F+1]>=v;sb[P|J<<1|x<<2|y<<3].forEach(l)}sb[J|x<<3].forEach(l)}F=-1;x=p[B*e]>=v;for(sb[x<<2].forEach(l);++F<e-1;)y=x,x=p[B*e+F+1]>=v,sb[x<<2|y<<3].forEach(l);sb[x<<3].forEach(l)}
function d(p,v,h){p.forEach(function(l){var q=l[0],w=l[1],B=q|0,F=w|0,J=v[F*e+B];if(0<q&&q<e&&B===q){var P=v[F*e+B-1];l[0]=q+(h-P)/(J-P)-.5}0<w&&w<g&&F===w&&(P=v[(F-1)*e+B],l[1]=w+(h-P)/(J-P)-.5)})}var e=1,g=1,k=Hf,m=d;a.contour=b;a.size=function(p){if(!arguments.length)return[e,g];var v=Math.ceil(p[0]),h=Math.ceil(p[1]);if(!(0<v&&0<h))throw Error("invalid size");return e=v,g=h,a};a.thresholds=function(p){return arguments.length?(k="function"===typeof p?p:Array.isArray(p)?Fb(lj.call(p)):Fb(p),a):
k};a.smooth=function(p){return arguments.length?(m=p?d:Qp,a):m===d};return a}function ng(a,b,c){for(var d=a.width,e=a.height,g=(c<<1)+1,k=0;k<e;++k)for(var m=0,p=0;m<d+c;++m)m<d&&(p+=a.data[m+k*d]),m>=c&&(m>=g&&(p-=a.data[m-g+k*d]),b.data[m-c+k*d]=p/Math.min(m+1,d-1+g-m,g))}function og(a,b,c){for(var d=a.width,e=a.height,g=(c<<1)+1,k=0;k<d;++k)for(var m=0,p=0;m<e+c;++m)m<e&&(p+=a.data[k+m*d]),m>=c&&(m>=g&&(p-=a.data[k+(m-g)*d]),b.data[k+(m-c)*d]=p/Math.min(m+1,e-1+g-m,g))}function Rp(a){return a[0]}
function Sp(a){return a[1]}function Tp(){return 1}function mj(a){return function(b){for(var c={},d=0;d<a.length;d++)c[a[d]]=b[d]||"";return c}}function Up(a,b){var c=mj(a);return function(d,e){return b(c(d),e,a)}}function Vp(a){var b=Object.create(null),c=[];a.forEach(function(d){for(var e in d)e in b||c.push(b[e]=e)});return c}function oe(a){function b(k,m){function p(){if(B)return pg;if(F)return F=!1,nj;var P,x=l,y;if(34===k.charCodeAt(x)){for(;l++<h&&34!==k.charCodeAt(l)||34===k.charCodeAt(++l););
(P=l)>=h?B=!0:10===(y=k.charCodeAt(l++))?F=!0:13===y&&(F=!0,10===k.charCodeAt(l)&&++l);return k.slice(x+1,P-1).replace(/""/g,'"')}for(;l<h;){if(10===(y=k.charCodeAt(P=l++)))F=!0;else if(13===y)F=!0,10===k.charCodeAt(l)&&++l;else if(y!==g)continue;return k.slice(x,P)}return B=!0,k.slice(x,h)}var v=[],h=k.length,l=0,q=0,w,B=0>=h,F=!1;10===k.charCodeAt(h-1)&&--h;for(13===k.charCodeAt(h-1)&&--h;(w=p())!==pg;){for(var J=[];w!==nj&&w!==pg;)J.push(w),w=p();m&&null==(J=m(J,q++))||v.push(J)}return v}function c(k){return k.map(d).join(a)}
function d(k){return null==k?"":e.test(k+="")?'"'+k.replace(/"/g,'""')+'"':k}var e=new RegExp('["'+a+"\n\r]"),g=a.charCodeAt(0);return{parse:function(k,m){var p,v;k=b(k,function(h,l){if(p)return p(h,l-1);v=h;p=m?Up(h,m):mj(h)});k.columns=v||[];return k},parseRows:b,format:function(k,m){null==m&&(m=Vp(k));return[m.map(d).join(a)].concat(k.map(function(p){return m.map(function(v){return d(p[v])}).join(a)})).join("\n")},formatRows:function(k){return k.map(c).join("\n")}}}function Wp(a){if(!a.ok)throw Error(a.status+
" "+a.statusText);return a.blob()}function Xp(a){if(!a.ok)throw Error(a.status+" "+a.statusText);return a.arrayBuffer()}function Yp(a){if(!a.ok)throw Error(a.status+" "+a.statusText);return a.text()}function qg(a,b){return fetch(a,b).then(Yp)}function oj(a){return function(b,c,d){2===arguments.length&&"function"===typeof c&&(d=c,c=void 0);return qg(b,c).then(function(e){return a(e,d)})}}function Zp(a){if(!a.ok)throw Error(a.status+" "+a.statusText);return a.json()}function Ca(a){return function(){return a}}
function Gb(){return 1E-6*(Math.random()-.5)}function pj(a,b,c,d){if(isNaN(b)||isNaN(c))return a;var e,g=a._root;d={data:d};var k=a._x0,m=a._y0,p=a._x1,v=a._y1,h,l,q,w,B;if(!g)return a._root=d,a;for(;g.length;)if((q=b>=(h=(k+p)/2))?k=h:p=h,(w=c>=(l=(m+v)/2))?m=l:v=l,e=g,!(g=g[B=w<<1|q]))return e[B]=d,a;var F=+a._x.call(null,g.data);var J=+a._y.call(null,g.data);if(b===F&&c===J)return d.next=g,e?e[B]=d:a._root=d,a;do e=e?e[B]=Array(4):a._root=Array(4),(q=b>=(h=(k+p)/2))?k=h:p=h,(w=c>=(l=(m+v)/2))?
m=l:v=l;while((B=w<<1|q)===(q=(J>=l)<<1|F>=h));return e[q]=g,e[B]=d,a}function Ka(a,b,c,d,e){this.node=a;this.x0=b;this.y0=c;this.x1=d;this.y1=e}function $p(a){return a[0]}function aq(a){return a[1]}function pe(a,b,c){b=new rg(null==b?$p:b,null==c?aq:c,NaN,NaN,NaN,NaN);return null==a?b:b.addAll(a)}function rg(a,b,c,d,e,g){this._x=a;this._y=b;this._x0=c;this._y0=d;this._x1=e;this._y1=g;this._root=void 0}function qj(a){for(var b={data:a.data},c=b;a=a.next;)c=c.next={data:a.data};return b}function bq(a){return a.x+
a.vx}function cq(a){return a.y+a.vy}function dq(a){return a.index}function rj(a,b){a=a.get(b);if(!a)throw Error("missing: "+b);return a}function eq(a){return a.x}function fq(a){return a.y}function qe(a,b){if(0>(b=(a=b?a.toExponential(b-1):a.toExponential()).indexOf("e")))return null;var c=a.slice(0,b);return[1<c.length?c[0]+c.slice(2):c,+a.slice(b+1)]}function nc(a){return a=qe(Math.abs(a)),a?a[1]:NaN}function gq(a,b){return function(c,d){for(var e=c.length,g=[],k=0,m=a[0],p=0;0<e&&0<m;){p+m+1>d&&
(m=Math.max(1,d-p));g.push(c.substring(e-=m,e+m));if((p+=m+1)>d)break;m=a[k=(k+1)%a.length]}return g.reverse().join(b)}}function hq(a){return function(b){return b.replace(/[0-9]/g,function(c){return a[+c]})}}function bd(a){return new sg(a)}function sg(a){if(!(b=iq.exec(a)))throw Error("invalid format: "+a);var b;this.fill=b[1]||" ";this.align=b[2]||">";this.sign=b[3]||"-";this.symbol=b[4]||"";this.zero=!!b[5];this.width=b[6]&&+b[6];this.comma=!!b[7];this.precision=b[8]&&+b[8].slice(1);this.trim=!!b[9];
this.type=b[10]||""}function sj(a,b){b=qe(a,b);if(!b)return a+"";a=b[0];b=b[1];return 0>b?"0."+Array(-b).join("0")+a:a.length>b+1?a.slice(0,b+1)+"."+a.slice(b+1):a+Array(b-a.length+2).join("0")}function tj(a){return a}function uj(a){function b(m){function p(N){var T=y,f=I,n,u;if("c"===x)f=Q(N)+f,N="";else{N=+N;var r=0>N;N=Q(Math.abs(N),J);if(P){var t=N.length,z=1,D=-1;a:for(;z<t;++z)switch(N[z]){case ".":D=n=z;break;case "0":0===D&&(D=z);n=z;break;default:if(!+N[z])break a;0<D&&(D=0)}N=0<D?N.slice(0,
D)+N.slice(n+1):N}r&&0===+N&&(r=!1);T=(r?"("===l?l:"-":"-"===l||"("===l?"":l)+T;f=("s"===x?vj[8+wj/3]:"")+f+(r&&"("===l?")":"");if(V)for(r=-1,n=N.length;++r<n;)if(u=N.charCodeAt(r),48>u||57<u){f=(46===u?e+N.slice(r+1):N.slice(r))+f;N=N.slice(0,r);break}}F&&!w&&(N=c(N,Infinity));u=T.length+N.length+f.length;r=u<B?Array(B-u+1).join(v):"";F&&w&&(N=c(r+N,r.length?B-f.length:Infinity),r="");switch(h){case "<":N=T+N+f+r;break;case "=":N=T+r+N+f;break;case "^":N=r.slice(0,u=r.length>>1)+T+N+f+r.slice(u);
break;default:N=r+T+N+f}return g(N)}m=bd(m);var v=m.fill,h=m.align,l=m.sign,q=m.symbol,w=m.zero,B=m.width,F=m.comma,J=m.precision,P=m.trim,x=m.type;"n"===x?(F=!0,x="g"):xj[x]||(null==J&&(J=12),P=!0,x="g");if(w||"0"===v&&"="===h)w=!0,v="0",h="=";var y="$"===q?d[0]:"#"===q&&/[boxX]/.test(x)?"0"+x.toLowerCase():"",I="$"===q?d[1]:/[%p]/.test(x)?k:"",Q=xj[x],V=/[defgprs%]/.test(x);J=null==J?6:/[gprs]/.test(x)?Math.max(1,Math.min(21,J)):Math.max(0,Math.min(20,J));p.toString=function(){return m+""};return p}
var c=a.grouping&&a.thousands?gq(a.grouping,a.thousands):tj,d=a.currency,e=a.decimal,g=a.numerals?hq(a.numerals):tj,k=a.percent||"%";return{format:b,formatPrefix:function(m,p){var v=b((m=bd(m),m.type="f",m));m=3*Math.max(-8,Math.min(8,Math.floor(nc(p)/3)));var h=Math.pow(10,-m),l=vj[8+m/3];return function(q){return v(h*q)+l}}}}function yj(a){re=uj(a);d3.format=re.format;d3.formatPrefix=re.formatPrefix;return re}function zj(a){return Math.max(0,-nc(Math.abs(a)))}function Aj(a,b){return Math.max(0,
3*Math.max(-8,Math.min(8,Math.floor(nc(b)/3)))-nc(Math.abs(a)))}function Bj(a,b){a=Math.abs(a);b=Math.abs(b)-a;return Math.max(0,nc(b)-nc(a))+1}function fb(){this.reset()}function Cj(a,b,c){var d=a.s=b+c,e=d-b;a.t=b-(d-e)+(c-e)}function Dj(a){return 1<a?0:-1>a?oa:Math.acos(a)}function La(a){return 1<a?wa:-1>a?-wa:Math.asin(a)}function Ej(a){return(a=ca(a/2))*a}function xa(){}function se(a,b){if(a&&Fj.hasOwnProperty(a.type))Fj[a.type](a,b)}function tg(a,b,c){var d=-1;c=a.length-c;for(b.lineStart();++d<
c;){var e=a[d];b.point(e[0],e[1],e[2])}b.lineEnd()}function Gj(a,b){var c=-1,d=a.length;for(b.polygonStart();++c<d;)tg(a[c],b,1);b.polygonEnd()}function gb(a,b){if(a&&Hj.hasOwnProperty(a.type))Hj[a.type](a,b);else se(a,b)}function jq(){lb.point=kq}function lq(){Ij(Jj,Kj)}function kq(a,b){lb.point=Ij;Jj=a;Kj=b;a*=ia;b*=ia;ug=a;vg=da(b=b/2+te);wg=ca(b)}function Ij(a,b){a*=ia;b*=ia;b=b/2+te;var c=a-ug,d=0<=c?1:-1,e=d*c;c=da(b);b=ca(b);var g=wg*b,k=vg*c+g*da(e);d=g*d*ca(e);ue.add(Ma(d,k));ug=a;vg=c;wg=
b}function ve(a){return[Ma(a[1],a[0]),La(a[2])]}function Vb(a){var b=a[0];a=a[1];var c=da(a);return[c*da(b),c*ca(b),ca(a)]}function we(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}function oc(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function xg(a,b){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2]}function xe(a,b){return[a[0]*b,a[1]*b,a[2]*b]}function ye(a){var b=Ba(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);a[0]/=b;a[1]/=b;a[2]/=b}function yg(a,b){Hb.push(tb=[za=a,Aa=a]);b<Wa&&(Wa=b);b>Za&&(Za=
b)}function Lj(a,b){var c=Vb([a*ia,b*ia]);if(pc){var d=oc(pc,c);d=oc([d[1],-d[0],0],d);ye(d);d=ve(d);var e=a-Wb,g=0<e?1:-1,k=d[0]*va*g;e=180<ra(e);e^(g*Wb<k&&k<g*a)?(d=d[1]*va,d>Za&&(Za=d)):(k=(k+360)%360-180,e^(g*Wb<k&&k<g*a))?(d=-d[1]*va,d<Wa&&(Wa=d)):(b<Wa&&(Wa=b),b>Za&&(Za=b));e?a<Wb?Xa(za,a)>Xa(za,Aa)&&(Aa=a):Xa(a,Aa)>Xa(za,Aa)&&(za=a):Aa>=za?(a<za&&(za=a),a>Aa&&(Aa=a)):a>Wb?Xa(za,a)>Xa(za,Aa)&&(Aa=a):Xa(a,Aa)>Xa(za,Aa)&&(za=a)}else Hb.push(tb=[za=a,Aa=a]);b<Wa&&(Wa=b);b>Za&&(Za=b);pc=c;Wb=a}
function Mj(){ub.point=Lj}function Nj(){tb[0]=za;tb[1]=Aa;ub.point=yg;pc=null}function Oj(a,b){if(pc){var c=a-Wb;cd.add(180<ra(c)?c+(0<c?360:-360):c)}else Pj=a,Qj=b;lb.point(a,b);Lj(a,b)}function mq(){lb.lineStart()}function nq(){Oj(Pj,Qj);lb.lineEnd();1E-6<ra(cd)&&(za=-(Aa=180));tb[0]=za;tb[1]=Aa;pc=null}function Xa(a,b){return 0>(b-=a)?b+360:b}function oq(a,b){return a[0]-b[0]}function Rj(a,b){return a[0]<=a[1]?a[0]<=b&&b<=a[1]:b<a[0]||a[1]<b}function zg(a,b){a*=ia;b*=ia;var c=da(b);dd(c*da(a),
c*ca(a),ca(b))}function dd(a,b,c){++ed;ze+=(a-ze)/ed;Ae+=(b-Ae)/ed;Be+=(c-Be)/ed}function Sj(){hb.point=pq}function pq(a,b){a*=ia;b*=ia;var c=da(b);Na=c*da(a);Oa=c*ca(a);Pa=ca(b);hb.point=qq;dd(Na,Oa,Pa)}function qq(a,b){a*=ia;b*=ia;var c=da(b),d=c*da(a);a=c*ca(a);b=ca(b);var e=Ma(Ba((e=Oa*b-Pa*a)*e+(e=Pa*d-Na*b)*e+(e=Na*a-Oa*d)*e),Na*d+Oa*a+Pa*b);Ce+=e;De+=e*(Na+(Na=d));Ee+=e*(Oa+(Oa=a));Fe+=e*(Pa+(Pa=b));dd(Na,Oa,Pa)}function Tj(){hb.point=zg}function rq(){hb.point=sq}function tq(){Uj(Vj,Wj);hb.point=
zg}function sq(a,b){Vj=a;Wj=b;a*=ia;b*=ia;hb.point=Uj;var c=da(b);Na=c*da(a);Oa=c*ca(a);Pa=ca(b);dd(Na,Oa,Pa)}function Uj(a,b){a*=ia;b*=ia;var c=da(b),d=c*da(a);a=c*ca(a);b=ca(b);c=Oa*b-Pa*a;var e=Pa*d-Na*b,g=Na*a-Oa*d,k=Ba(c*c+e*e+g*g),m=La(k);k=k&&-m/k;Ag+=k*c;Bg+=k*e;Cg+=k*g;Ce+=m;De+=m*(Na+(Na=d));Ee+=m*(Oa+(Oa=a));Fe+=m*(Pa+(Pa=b));dd(Na,Oa,Pa)}function qc(a){return function(){return a}}function Dg(a,b){function c(d,e){return d=a(d,e),b(d[0],d[1])}a.invert&&b.invert&&(c.invert=function(d,e){return d=
b.invert(d,e),d&&a.invert(d[0],d[1])});return c}function Eg(a,b){return[a>oa?a-Sa:a<-oa?a+Sa:a,b]}function Fg(a,b,c){return(a%=Sa)?b||c?Dg(Xj(a),Yj(b,c)):Xj(a):b||c?Yj(b,c):Eg}function Zj(a){return function(b,c){return b+=a,[b>oa?b-Sa:b<-oa?b+Sa:b,c]}}function Xj(a){var b=Zj(a);b.invert=Zj(-a);return b}function Yj(a,b){function c(m,p){var v=da(p),h=da(m)*v;m=ca(m)*v;p=ca(p);v=p*d+h*e;return[Ma(m*g-v*k,h*d-p*e),La(v*g+m*k)]}var d=da(a),e=ca(a),g=da(b),k=ca(b);c.invert=function(m,p){var v=da(p),h=da(m)*
v;m=ca(m)*v;p=ca(p);v=p*g-m*k;return[Ma(m*g+p*k,h*d+v*e),La(v*d-h*e)]};return c}function ak(a){function b(c){c=a(c[0]*ia,c[1]*ia);return c[0]*=va,c[1]*=va,c}a=Fg(a[0]*ia,a[1]*ia,2<a.length?a[2]*ia:0);b.invert=function(c){c=a.invert(c[0]*ia,c[1]*ia);return c[0]*=va,c[1]*=va,c};return b}function bk(a,b,c,d,e,g){if(c){var k=da(b),m=ca(b);c*=d;if(null==e)e=b+d*Sa,g=b-c/2;else if(e=ck(k,e),g=ck(k,g),0<d?e<g:e>g)e+=d*Sa;for(;0<d?e>g:e<g;e-=c)b=ve([k,-m*da(e),-m*ca(e)]),a.point(b[0],b[1])}}function ck(a,
b){b=Vb(b);b[0]-=a;ye(b);a=Dj(-b[1]);return((0>-b[2]?-a:a)+Sa-1E-6)%Sa}function dk(){var a=[],b;return{point:function(c,d){b.push([c,d])},lineStart:function(){a.push(b=[])},lineEnd:xa,rejoin:function(){1<a.length&&a.push(a.pop().concat(a.shift()))},result:function(){var c=a;a=[];b=null;return c}}}function Ge(a,b){return 1E-6>ra(a[0]-b[0])&&1E-6>ra(a[1]-b[1])}function He(a,b,c,d){this.x=a;this.z=b;this.o=c;this.e=d;this.v=!1;this.n=this.p=null}function ek(a,b,c,d,e){var g=[],k=[];a.forEach(function(l){if(!(0>=
(q=l.length-1))){var q,w=l[0],B=l[q];if(Ge(w,B)){e.lineStart();for(m=0;m<q;++m)e.point((w=l[m])[0],w[1]);e.lineEnd()}else g.push(q=new He(w,l,null,!0)),k.push(q.o=new He(w,null,q,!1)),g.push(q=new He(B,l,null,!1)),k.push(q.o=new He(B,null,q,!0))}});if(g.length){k.sort(b);fk(g);fk(k);var m=0;for(a=k.length;m<a;++m)k[m].e=c=!c;c=g[0];for(var p;;){for(var v=c,h=!0;v.v;)if((v=v.n)===c)return;b=v.z;e.lineStart();do{v.v=v.o.v=!0;if(v.e){if(h)for(m=0,a=b.length;m<a;++m)e.point((p=b[m])[0],p[1]);else d(v.x,
v.n.x,1,e);v=v.n}else{if(h)for(b=v.p.z,m=b.length-1;0<=m;--m)e.point((p=b[m])[0],p[1]);else d(v.x,v.p.x,-1,e);v=v.p}v=v.o;b=v.z;h=!h}while(!v.v);e.lineEnd()}}}function fk(a){if(b=a.length){for(var b,c=0,d=a[0],e;++c<b;)d.n=e=a[c],e.p=d,d=e;d.n=e=a[0];e.p=d}}function gk(a,b){var c=b[0];b=b[1];var d=ca(b),e=[ca(c),-da(c),0],g=0,k=0;Gg.reset();1===d?b=wa+1E-6:-1===d&&(b=-wa-1E-6);d=0;for(var m=a.length;d<m;++d)if(v=(p=a[d]).length){var p,v,h=p[v-1],l=h[0],q=h[1]/2+te,w=ca(q),B=da(q);for(q=0;q<v;++q,
l=J,w=P,B=x,h=F){var F=p[q],J=F[0];x=F[1]/2+te;var P=ca(x),x=da(x),y=J-l,I=0<=y?1:-1,Q=I*y,V=Q>oa;w*=P;Gg.add(Ma(w*I*ca(Q),B*x+w*da(Q)));g+=V?y+I*Sa:y;V^l>=c^J>=c&&(h=oc(Vb(h),Vb(F)),ye(h),l=oc(e,h),ye(l),l=(V^0<=y?-1:1)*La(l[2]),b>l||b===l&&(h[0]||h[1]))&&(k+=V^0<=y?1:-1)}}return(-1E-6>g||1E-6>g&&-1E-6>Gg)^k&1}function hk(a,b,c,d){return function(e){function g(I,Q){a(I,Q)&&e.point(I,Q)}function k(I,Q){q.point(I,Q)}function m(){y.point=k;q.lineStart()}function p(){y.point=g;q.lineEnd()}function v(I,
Q){x.push([I,Q]);B.point(I,Q)}function h(){B.lineStart();x=[]}function l(){v(x[0][0],x[0][1]);B.lineEnd();var I=B.clean(),Q=w.result(),V=Q.length,N;x.pop();J.push(x);x=null;if(V)if(I&1){if(V=Q[0],0<(Q=V.length-1)){F||(e.polygonStart(),F=!0);e.lineStart();for(I=0;I<Q;++I)e.point((N=V[I])[0],N[1]);e.lineEnd()}}else 1<V&&I&2&&Q.push(Q.pop().concat(Q.shift())),P.push(Q.filter(uq))}var q=b(e),w=dk(),B=b(w),F=!1,J,P,x,y={point:g,lineStart:m,lineEnd:p,polygonStart:function(){y.point=v;y.lineStart=h;y.lineEnd=
l;P=[];J=[]},polygonEnd:function(){y.point=g;y.lineStart=m;y.lineEnd=p;P=If(P);var I=gk(J,d);P.length?(F||(e.polygonStart(),F=!0),ek(P,vq,I,c,e)):I&&(F||(e.polygonStart(),F=!0),e.lineStart(),c(null,null,1,e),e.lineEnd());F&&(e.polygonEnd(),F=!1);P=J=null},sphere:function(){e.polygonStart();e.lineStart();c(null,null,1,e);e.lineEnd();e.polygonEnd()}};return y}}function uq(a){return 1<a.length}function vq(a,b){return(0>(a=a.x)[0]?a[1]-wa-1E-6:wa-a[1])-(0>(b=b.x)[0]?b[1]-wa-1E-6:wa-b[1])}function ik(a){function b(p,
v){return da(p)*da(v)>e}function c(p,v,h){var l=Vb(p),q=Vb(v),w=[1,0,0];q=oc(l,q);var B=we(q,q);l=q[0];var F=B-l*l;if(!F)return!h&&p;B=e*B/F;F=-e*l/F;l=oc(w,q);w=xe(w,B);q=xe(q,F);xg(w,q);q=we(w,l);B=we(l,l);F=q*q-B*(we(w,w)-1);if(!(0>F)){var J=Ba(F);F=xe(l,(-q-J)/B);xg(F,w);F=ve(F);if(!h)return F;h=p[0];var P=v[0];p=p[1];v=v[1];if(P<h){var x=h;h=P;P=x}var y=P-h,I=1E-6>ra(y-oa);!I&&v<p&&(x=p,p=v,v=x);if(I||1E-6>y?I?0<p+v^F[1]<(1E-6>ra(F[0]-h)?p:v):p<=F[1]&&F[1]<=v:y>oa^(h<=F[0]&&F[0]<=P))return v=
xe(l,(-q+J)/B),xg(v,w),[F,ve(v)]}}function d(p,v){var h=k?a:oa-a,l=0;p<-h?l|=1:p>h&&(l|=2);v<-h?l|=4:v>h&&(l|=8);return l}var e=da(a),g=6*ia,k=0<e,m=1E-6<ra(e);return hk(b,function(p){var v,h,l,q,w;return{lineStart:function(){q=l=!1;w=1},point:function(B,F){var J=[B,F],P=b(B,F);F=k?P?0:d(B,F):P?d(B+(0>B?oa:-oa),F):0;!v&&(q=l=P)&&p.lineStart();P!==l&&(B=c(v,J),!B||Ge(v,B)||Ge(J,B))&&(J[0]+=1E-6,J[1]+=1E-6,P=b(J[0],J[1]));if(P!==l)w=0,P?(p.lineStart(),B=c(J,v),p.point(B[0],B[1])):(B=c(v,J),p.point(B[0],
B[1]),p.lineEnd()),v=B;else if(m&&v&&k^P){var x;F&h||!(x=c(J,v,!0))||(w=0,k?(p.lineStart(),p.point(x[0][0],x[0][1]),p.point(x[1][0],x[1][1]),p.lineEnd()):(p.point(x[1][0],x[1][1]),p.lineEnd(),p.lineStart(),p.point(x[0][0],x[0][1])))}!P||v&&Ge(v,J)||p.point(J[0],J[1]);v=J;l=P;h=F},lineEnd:function(){l&&p.lineEnd();v=null},clean:function(){return w|(q&&l)<<1}}},function(p,v,h,l){bk(l,a,g,h,p,v)},k?[0,-a]:[-oa,a-oa])}function wq(a,b,c,d,e,g){var k=a[0],m=a[1],p=0,v=1,h=b[0]-k,l=b[1]-m;c-=k;if(h||!(0<
c)){c/=h;if(0>h){if(c<p)return;c<v&&(v=c)}else if(0<h){if(c>v)return;c>p&&(p=c)}c=e-k;if(h||!(0>c)){c/=h;if(0>h){if(c>v)return;c>p&&(p=c)}else if(0<h){if(c<p)return;c<v&&(v=c)}c=d-m;if(l||!(0<c)){c/=l;if(0>l){if(c<p)return;c<v&&(v=c)}else if(0<l){if(c>v)return;c>p&&(p=c)}c=g-m;if(l||!(0>c)){c/=l;if(0>l){if(c>v)return;c>p&&(p=c)}else if(0<l){if(c<p)return;c<v&&(v=c)}0<p&&(a[0]=k+p*h,a[1]=m+p*l);1>v&&(b[0]=k+v*h,b[1]=m+v*l);return!0}}}}}function Ie(a,b,c,d){function e(p,v,h,l){var q=0,w=0;if(null==
p||(q=g(p,h))!==(w=g(v,h))||0>m(p,v)^0<h){do l.point(0===q||3===q?a:c,1<q?d:b);while((q=(q+h+4)%4)!==w)}else l.point(v[0],v[1])}function g(p,v){return 1E-6>ra(p[0]-a)?0<v?0:3:1E-6>ra(p[0]-c)?0<v?2:1:1E-6>ra(p[1]-b)?0<v?1:0:0<v?3:2}function k(p,v){return m(p.x,v.x)}function m(p,v){var h=g(p,1),l=g(v,1);return h!==l?h-l:0===h?v[1]-p[1]:1===h?p[0]-v[0]:2===h?p[1]-v[1]:v[0]-p[0]}return function(p){function v(f,n){a<=f&&f<=c&&b<=n&&n<=d&&l.point(f,n)}function h(f,n){var u=a<=f&&f<=c&&b<=n&&n<=d;B&&F.push([f,
n]);if(V)J=f,P=n,x=u,V=!1,u&&(l.lineStart(),l.point(f,n));else if(u&&Q)l.point(f,n);else{var r=[y=Math.max(-1E9,Math.min(1E9,y)),I=Math.max(-1E9,Math.min(1E9,I))],t=[f=Math.max(-1E9,Math.min(1E9,f)),n=Math.max(-1E9,Math.min(1E9,n))];wq(r,t,a,b,c,d)?(Q||(l.lineStart(),l.point(r[0],r[1])),l.point(t[0],t[1]),u||l.lineEnd(),N=!1):u&&(l.lineStart(),l.point(f,n),N=!1)}y=f;I=n;Q=u}var l=p,q=dk(),w,B,F,J,P,x,y,I,Q,V,N,T={point:v,lineStart:function(){T.point=h;B&&B.push(F=[]);V=!0;Q=!1;y=I=NaN},lineEnd:function(){w&&
(h(J,P),x&&Q&&q.rejoin(),w.push(q.result()));T.point=v;Q&&l.lineEnd()},polygonStart:function(){l=q;w=[];B=[];N=!0},polygonEnd:function(){for(var f,n=f=0,u=B.length;n<u;++n){var r=B[n],t=1,z=r.length,D=r[0],A=D[0];for(D=D[1];t<z;++t){var C=A;var G=D;D=r[t];A=D[0];D=D[1];G<=d?D>d&&(A-C)*(d-G)>(D-G)*(a-C)&&++f:D<=d&&(A-C)*(d-G)<(D-G)*(a-C)&&--f}}n=N&&f;u=(w=If(w)).length;if(n||u)p.polygonStart(),n&&(p.lineStart(),e(null,null,1,p),p.lineEnd()),u&&ek(w,k,f,e,p),p.polygonEnd();l=p;w=B=F=null}};return T}}
function xq(){rc.point=rc.lineEnd=xa}function yq(a,b){a*=ia;b*=ia;Hg=a;Je=ca(b);Ke=da(b);rc.point=zq}function zq(a,b){a*=ia;b*=ia;var c=ca(b);b=da(b);var d=ra(a-Hg),e=da(d);d=ca(d);d*=b;var g=Ke*c-Je*b*e;e=Je*c+Ke*b*e;Ig.add(Ma(Ba(d*d+g*g),e));Hg=a;Je=c;Ke=b}function jk(a){Ig.reset();gb(a,rc);return+Ig}function sc(a,b){Jg[0]=a;Jg[1]=b;return jk(Aq)}function Le(a,b){return a&&kk.hasOwnProperty(a.type)?kk[a.type](a,b):!1}function lk(a,b){var c=sc(a[0],a[1]),d=sc(a[0],b);a=sc(b,a[1]);return d+a<=c+1E-6}
function mk(a,b){return!!gk(a.map(Bq),nk(b))}function Bq(a){return a=a.map(nk),a.pop(),a}function nk(a){return[a[0]*ia,a[1]*ia]}function ok(a,b,c){var d=Ta(a,b-1E-6,c).concat(b);return function(e){return d.map(function(g){return[e,g]})}}function pk(a,b,c){var d=Ta(a,b-1E-6,c).concat(b);return function(e){return d.map(function(g){return[g,e]})}}function qk(){function a(){return{type:"MultiLineString",coordinates:b()}}function b(){return Ta(Me(g/q)*q,e,q).map(J).concat(Ta(Me(v/w)*w,p,w).map(P)).concat(Ta(Me(d/
h)*h,c,h).filter(function(y){return 1E-6<ra(y%q)}).map(B)).concat(Ta(Me(m/l)*l,k,l).filter(function(y){return 1E-6<ra(y%w)}).map(F))}var c,d,e,g,k,m,p,v,h=10,l=h,q=90,w=360,B,F,J,P,x=2.5;a.lines=function(){return b().map(function(y){return{type:"LineString",coordinates:y}})};a.outline=function(){return{type:"Polygon",coordinates:[J(g).concat(P(p).slice(1),J(e).reverse().slice(1),P(v).reverse().slice(1))]}};a.extent=function(y){return arguments.length?a.extentMajor(y).extentMinor(y):a.extentMinor()};
a.extentMajor=function(y){if(!arguments.length)return[[g,v],[e,p]];g=+y[0][0];e=+y[1][0];v=+y[0][1];p=+y[1][1];g>e&&(y=g,g=e,e=y);v>p&&(y=v,v=p,p=y);return a.precision(x)};a.extentMinor=function(y){if(!arguments.length)return[[d,m],[c,k]];d=+y[0][0];c=+y[1][0];m=+y[0][1];k=+y[1][1];d>c&&(y=d,d=c,c=y);m>k&&(y=m,m=k,k=y);return a.precision(x)};a.step=function(y){return arguments.length?a.stepMajor(y).stepMinor(y):a.stepMinor()};a.stepMajor=function(y){if(!arguments.length)return[q,w];q=+y[0];w=+y[1];
return a};a.stepMinor=function(y){if(!arguments.length)return[h,l];h=+y[0];l=+y[1];return a};a.precision=function(y){if(!arguments.length)return x;x=+y;B=ok(m,k,90);F=pk(d,c,x);J=ok(v,p,90);P=pk(g,e,x);return a};return a.extentMajor([[-180,-89.999999],[180,89.999999]]).extentMinor([[-180,-80.000001],[180,80.000001]])}function Xb(a){return a}function Cq(){vb.point=Dq}function Dq(a,b){vb.point=rk;sk=Kg=a;tk=Lg=b}function rk(a,b){Mg.add(Lg*a-Kg*b);Kg=a;Lg=b}function Eq(){rk(sk,tk)}function Yb(a,b){Ng+=
a;Og+=b;++fd}function uk(){$a.point=Fq}function Fq(a,b){$a.point=Gq;Yb(mb=a,nb=b)}function Gq(a,b){var c=a-mb,d=b-nb;c=Ba(c*c+d*d);Ne+=c*(mb+a)/2;Oe+=c*(nb+b)/2;tc+=c;Yb(mb=a,nb=b)}function vk(){$a.point=Yb}function Hq(){$a.point=Iq}function Jq(){wk(xk,yk)}function Iq(a,b){$a.point=wk;Yb(xk=mb=a,yk=nb=b)}function wk(a,b){var c=a-mb,d=b-nb;c=Ba(c*c+d*d);Ne+=c*(mb+a)/2;Oe+=c*(nb+b)/2;tc+=c;c=nb*a-mb*b;Pg+=c*(mb+a);Qg+=c*(nb+b);gd+=3*c;Yb(mb=a,nb=b)}function zk(a){this._context=a}function Kq(a,b){hd.point=
Ak;Bk=id=a;Ck=jd=b}function Ak(a,b){id-=a;jd-=b;Rg.add(Ba(id*id+jd*jd));id=a;jd=b}function Dk(){this._string=[]}function Ek(a){return"m0,"+a+"a"+a+","+a+" 0 1,1 0,"+-2*a+"a"+a+","+a+" 0 1,1 0,"+2*a+"z"}function kd(a){return function(b){var c=new Sg,d;for(d in a)c[d]=a[d];c.stream=b;return c}}function Sg(){}function Tg(a,b,c){var d=a.clipExtent&&a.clipExtent();a.scale(150).translate([0,0]);null!=d&&a.clipExtent(null);gb(c,a.stream(Pe));b(Pe.result());null!=d&&a.clipExtent(d);return a}function uc(a,
b,c){return Tg(a,function(d){var e=b[1][0]-b[0][0],g=b[1][1]-b[0][1],k=Math.min(e/(d[1][0]-d[0][0]),g/(d[1][1]-d[0][1]));e=+b[0][0]+(e-k*(d[1][0]+d[0][0]))/2;d=+b[0][1]+(g-k*(d[1][1]+d[0][1]))/2;a.scale(150*k).translate([e,d])},c)}function Ug(a,b,c){return Tg(a,function(d){var e=+b,g=e/(d[1][0]-d[0][0]);e=(e-g*(d[1][0]+d[0][0]))/2;d=-g*d[0][1];a.scale(150*g).translate([e,d])},c)}function Vg(a,b,c){return Tg(a,function(d){var e=+b,g=e/(d[1][1]-d[0][1]),k=-g*d[0][0];d=(e-g*(d[1][1]+d[0][1]))/2;a.scale(150*
g).translate([k,d])},c)}function Fk(a){return kd({point:function(b,c){b=a(b,c);this.stream.point(b[0],b[1])}})}function Gk(a,b){function c(d,e,g,k,m,p,v,h,l,q,w,B,F,J){var P=v-d,x=h-e,y=P*P+x*x;if(y>4*b&&F--){var I=k+q,Q=m+w,V=p+B,N=Ba(I*I+Q*Q+V*V),T=La(V/=N),f=1E-6>ra(ra(V)-1)||1E-6>ra(g-l)?(g+l)/2:Ma(Q,I),n=a(f,T);T=n[0];n=n[1];var u=T-d,r=n-e,t=x*u-P*r;if(t*t/y>b||.3<ra((P*u+x*r)/y-.5)||k*q+m*w+p*B<Lq)c(d,e,g,k,m,p,T,n,f,I/=N,Q/=N,V,F,J),J.point(T,n),c(T,n,f,I,Q,V,v,h,l,q,w,B,F,J)}}return function(d){function e(T,
f){T=a(T,f);d.point(T[0],T[1])}function g(){x=NaN;N.point=k;d.lineStart()}function k(T,f){var n=Vb([T,f]);f=a(T,f);c(x,y,P,I,Q,V,x=f[0],y=f[1],P=T,I=n[0],Q=n[1],V=n[2],16,d);d.point(x,y)}function m(){N.point=e;d.lineEnd()}function p(){g();N.point=v;N.lineEnd=h}function v(T,f){k(l=T,f);q=x;w=y;B=I;F=Q;J=V;N.point=k}function h(){c(x,y,P,I,Q,V,q,w,l,B,F,J,16,d);N.lineEnd=m;m()}var l,q,w,B,F,J,P,x,y,I,Q,V,N={point:e,lineStart:g,lineEnd:m,polygonStart:function(){d.polygonStart();N.lineStart=p},polygonEnd:function(){d.polygonEnd();
N.lineStart=g}};return N}}function Mq(a){return kd({point:function(b,c){b=a(b,c);return this.stream.point(b[0],b[1])}})}function Nq(a,b,c){function d(e,g){return[b+a*e,c-a*g]}d.invert=function(e,g){return[(e-b)/a,(c-g)/a]};return d}function Hk(a,b,c,d){function e(q,w){return[k*q-m*w+b,c-m*q-k*w]}var g=da(d);d=ca(d);var k=g*a,m=d*a,p=g/a,v=d/a,h=(d*c-g*b)/a,l=(d*b+g*c)/a;e.invert=function(q,w){return[p*q-v*w+h,l-v*q-p*w]};return e}function ob(a){return Wg(function(){return a})()}function Wg(a){function b(t){return n(t[0]*
ia,t[1]*ia)}function c(t){return(t=n.invert(t[0],t[1]))&&[t[0]*va,t[1]*va]}function d(){var t=Hk(k,0,0,F).apply(null,g(v,h));t=(F?Hk:Nq)(k,m-t[0],p-t[1],F);B=Fg(l,q,w);f=Dg(g,t);n=Dg(B,f);t=f;T=+N?Gk(t,N):Fk(t);return e()}function e(){u=r=null;return b}var g,k=150,m=480,p=250,v=0,h=0,l=0,q=0,w=0,B,F=0,J=null,P=Xg,x=null,y,I,Q,V=Xb,N=.5,T,f,n,u,r;b.stream=function(t){return u&&r===t?u:u=Oq(Mq(B)(P(T(V(r=t)))))};b.preclip=function(t){return arguments.length?(P=t,J=void 0,e()):P};b.postclip=function(t){return arguments.length?
(V=t,x=y=I=Q=null,e()):V};b.clipAngle=function(t){return arguments.length?(P=+t?ik(J=t*ia):(J=null,Xg),e()):J*va};b.clipExtent=function(t){return arguments.length?(V=null==t?(x=y=I=Q=null,Xb):Ie(x=+t[0][0],y=+t[0][1],I=+t[1][0],Q=+t[1][1]),e()):null==x?null:[[x,y],[I,Q]]};b.scale=function(t){return arguments.length?(k=+t,d()):k};b.translate=function(t){return arguments.length?(m=+t[0],p=+t[1],d()):[m,p]};b.center=function(t){return arguments.length?(v=t[0]%360*ia,h=t[1]%360*ia,d()):[v*va,h*va]};b.rotate=
function(t){return arguments.length?(l=t[0]%360*ia,q=t[1]%360*ia,w=2<t.length?t[2]%360*ia:0,d()):[l*va,q*va,w*va]};b.angle=function(t){return arguments.length?(F=t%360*ia,d()):F*va};b.precision=function(t){if(arguments.length){var z=f;var D=N=t*t;z=(T=+D?Gk(z,D):Fk(z),e())}else z=Ba(N);return z};b.fitExtent=function(t,z){return uc(b,t,z)};b.fitSize=function(t,z){return uc(b,[[0,0],t],z)};b.fitWidth=function(t,z){return Ug(b,t,z)};b.fitHeight=function(t,z){return Vg(b,t,z)};return function(){g=a.apply(this,
arguments);b.invert=g.invert&&c;return d()}}function Yg(a){var b=0,c=oa/3,d=Wg(a);a=d(b,c);a.parallels=function(e){return arguments.length?d(b=e[0]*ia,c=e[1]*ia):[b*va,c*va]};return a}function Pq(a){function b(d,e){return[d*c,ca(e)/c]}var c=da(a);b.invert=function(d,e){return[d/c,La(e*c)]};return b}function Ik(a,b){function c(m,p){p=Ba(g-2*e*ca(p))/e;return[p*ca(m*=e),k-p*da(m)]}var d=ca(a),e=(d+ca(b))/2;if(1E-6>ra(e))return Pq(a);var g=1+d*(2*e-d),k=Ba(g)/e;c.invert=function(m,p){p=k-p;return[Ma(m,
ra(p))/e*ld(p),La((g-(m*m+p*p)*e*e)/(2*e))]};return c}function Qe(){return Yg(Ik).scale(155.424).center([0,33.6442])}function Jk(){return Qe().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])}function Qq(a){var b=a.length;return{point:function(c,d){for(var e=-1;++e<b;)a[e].point(c,d)},sphere:function(){for(var c=-1;++c<b;)a[c].sphere()},lineStart:function(){for(var c=-1;++c<b;)a[c].lineStart()},lineEnd:function(){for(var c=-1;++c<b;)a[c].lineEnd()},polygonStart:function(){for(var c=
-1;++c<b;)a[c].polygonStart()},polygonEnd:function(){for(var c=-1;++c<b;)a[c].polygonEnd()}}}function Kk(a){return function(b,c){var d=da(b),e=da(c);d=a(d*e);return[d*e*ca(b),d*ca(c)]}}function md(a){return function(b,c){var d=Ba(b*b+c*c),e=a(d),g=ca(e);e=da(e);return[Ma(b*g,d*e),La(d&&c*g/d)]}}function nd(a,b){return[a,Re(vc((wa+b)/2))]}function Lk(a){function b(){var l=oa*e(),q=c(ak(c.rotate()).invert([0,0]));return k(null==m?[[q[0]-l,q[1]-l],[q[0]+l,q[1]+l]]:a===nd?[[Math.max(q[0]-l,m),p],[Math.min(q[0]+
l,v),h]]:[[m,Math.max(q[1]-l,p)],[v,Math.min(q[1]+l,h)]])}var c=ob(a),d=c.center,e=c.scale,g=c.translate,k=c.clipExtent,m=null,p,v,h;c.scale=function(l){return arguments.length?(e(l),b()):e()};c.translate=function(l){return arguments.length?(g(l),b()):g()};c.center=function(l){return arguments.length?(d(l),b()):d()};c.clipExtent=function(l){return arguments.length?(null==l?m=p=v=h=null:(m=+l[0][0],p=+l[0][1],v=+l[1][0],h=+l[1][1]),b()):null==m?null:[[m,p],[v,h]]};return b()}function Mk(a,b){function c(k,
m){0<g?m<-wa+1E-6&&(m=-wa+1E-6):m>wa-1E-6&&(m=wa-1E-6);m=g/Zg(vc((wa+m)/2),e);return[m*ca(e*k),g-m*da(e*k)]}var d=da(a),e=a===b?ca(a):Re(d/da(b))/Re(vc((wa+b)/2)/vc((wa+a)/2)),g=d*Zg(vc((wa+a)/2),e)/e;if(!e)return nd;c.invert=function(k,m){m=g-m;var p=ld(e)*Ba(k*k+m*m);return[Ma(k,ra(m))/e*ld(m),2*wc(Zg(g/p,1/e))-wa]};return c}function od(a,b){return[a,b]}function Nk(a,b){function c(k,m){m=g-m;k*=e;return[m*ca(k),g-m*da(k)]}var d=da(a),e=a===b?ca(a):(d-da(b))/(b-a),g=d/e+a;if(1E-6>ra(e))return od;
c.invert=function(k,m){m=g-m;return[Ma(k,ra(m))/e*ld(m),g-ld(e)*Ba(k*k+m*m)]};return c}function $g(a,b){b=La(Se*ca(b));var c=b*b,d=c*c*c;return[a*da(b)/(Se*(1.340264+3*-.081106*c+d*(7*8.93E-4+.034164*c))),b*(1.340264+-.081106*c+d*(8.93E-4+.003796*c))]}function ah(a,b){var c=da(b),d=da(a)*c;return[c*ca(a)/d,ca(b)/d]}function Te(a,b,c,d){return 1===a&&1===b&&0===c&&0===d?Xb:kd({point:function(e,g){this.stream.point(e*a+c,g*b+d)}})}function bh(a,b){var c=b*b,d=c*c;return[a*(.8707-.131979*c+d*(-.013791+
d*(.003971*c-.001529*d))),b*(1.007226+c*(.015085+d*(-.044475+.028874*c-.005916*d)))]}function ch(a,b){return[da(b)*ca(a),ca(b)]}function dh(a,b){var c=da(b),d=1+da(a)*c;return[c*ca(a)/d,ca(b)/d]}function eh(a,b){return[Re(vc((wa+b)/2)),-a]}function Rq(a,b){return a.parent===b.parent?1:2}function Sq(a,b){return a+b.x}function Tq(a,b){return Math.max(a,b.y)}function Uq(a){for(var b;b=a.children;)a=b[0];return a}function Vq(a){for(var b;b=a.children;)a=b[b.length-1];return a}function Wq(a){var b=0,c=
a.children,d=c&&c.length;if(d)for(;0<=--d;)b+=c[d].value;else b=1;a.value=b}function fh(a,b){var c=new xc(a);a=+a.value&&(c.value=a.value);var d,e=[c],g,k,m,p;for(null==b&&(b=Xq);d=e.pop();)if(a&&(d.value=+d.data.value),(k=b(d.data))&&(p=k.length))for(d.children=Array(p),m=p-1;0<=m;--m)e.push(g=d.children[m]=new xc(k[m])),g.parent=d,g.depth=d.depth+1;return c.eachBefore(Ok)}function Xq(a){return a.children}function Yq(a){a.data=a.data.data}function Ok(a){var b=0;do a.height=b;while((a=a.parent)&&
a.height<++b)}function xc(a){this.data=a;this.depth=this.height=0;this.parent=null}function Pk(a){var b=0;a=Zq.call(a);for(var c=a.length,d,e;c;)e=Math.random()*c--|0,d=a[c],a[c]=a[e],a[e]=d;c=a.length;d=[];for(var g;b<c;)if(e=a[b],g&&Qk(g,e))++b;else{a:if(b=d,gh(e,b))b=[e];else{for(d=0;d<b.length;++d)if(Ue(e,b[d])&&gh(pd(b[d],e),b)){b=[b[d],e];break a}for(d=0;d<b.length-1;++d)for(g=d+1;g<b.length;++g)if(Ue(pd(b[d],b[g]),e)&&Ue(pd(b[d],e),b[g])&&Ue(pd(b[g],e),b[d])&&gh(Rk(b[d],b[g],e),b)){b=[b[d],
b[g],e];break a}throw Error();}a:{b=d=b;switch(b.length){case 1:b=b[0];b={x:b.x,y:b.y,r:b.r};break a;case 2:b=pd(b[0],b[1]);break a;case 3:b=Rk(b[0],b[1],b[2]);break a}b=void 0}g=b;b=0}return g}function Ue(a,b){var c=a.r-b.r,d=b.x-a.x;a=b.y-a.y;return 0>c||c*c<d*d+a*a}function Qk(a,b){var c=a.r-b.r+1E-6,d=b.x-a.x;a=b.y-a.y;return 0<c&&c*c>d*d+a*a}function gh(a,b){for(var c=0;c<b.length;++c)if(!Qk(a,b[c]))return!1;return!0}function pd(a,b){var c=a.x,d=a.y;a=a.r;var e=b.x,g=b.y;b=b.r;var k=e-c,m=g-
d,p=b-a,v=Math.sqrt(k*k+m*m);return{x:(c+e+k/v*p)/2,y:(d+g+m/v*p)/2,r:(v+a+b)/2}}function Rk(a,b,c){var d=a.x,e=a.y;a=a.r;var g=b.x,k=b.y,m=b.r,p=c.x,v=c.y,h=c.r;c=d-g;b=d-p;var l=e-k,q=e-v,w=m-a,B=h-a,F=d*d+e*e-a*a;k=F-g*g-k*k+m*m;v=F-p*p-v*v+h*h;p=b*l-c*q;g=(l*v-q*k)/(2*p)-d;l=(q*w-l*B)/p;q=(b*k-c*v)/(2*p)-e;c=(c*B-b*w)/p;b=l*l+c*c-1;w=2*(a+g*l+q*c);a=g*g+q*q-a*a;a=-(b?(w+Math.sqrt(w*w-4*b*a))/(2*b):a/w);return{x:d+g+l*a,y:e+q+c*a,r:a}}function Sk(a,b,c){var d=a.x-b.x,e=a.y-b.y,g=d*d+e*e;if(g){var k=
b.r+c.r;k*=k;var m=a.r+c.r;m*=m;if(k>m){var p=(g+m-k)/(2*g);k=Math.sqrt(Math.max(0,m/g-p*p));c.x=a.x-p*d-k*e;c.y=a.y-p*e+k*d}else p=(g+k-m)/(2*g),k=Math.sqrt(Math.max(0,k/g-p*p)),c.x=b.x+p*d-k*e,c.y=b.y+p*e+k*d}else c.x=b.x+c.r,c.y=b.y}function Tk(a,b){var c=a.r+b.r-1E-6,d=b.x-a.x;a=b.y-a.y;return 0<c&&c*c>d*d+a*a}function Uk(a){var b=a._,c=a.next._,d=b.r+c.r;a=(b.x*c.r+c.x*b.r)/d;b=(b.y*c.r+c.y*b.r)/d;return a*a+b*b}function Ve(a){this._=a;this.previous=this.next=null}function Vk(a){if(!(c=a.length))return 0;
var b,c;var d=a[0];d.x=0;d.y=0;if(!(1<c))return d.r;var e=a[1];d.x=-e.r;e.x=d.r;e.y=0;if(!(2<c))return d.r+e.r;Sk(e,d,b=a[2]);d=new Ve(d);e=new Ve(e);b=new Ve(b);d.next=b.previous=e;e.next=d.previous=b;b.next=e.previous=d;var g=3;a:for(;g<c;++g){Sk(d._,e._,b=a[g]);b=new Ve(b);var k=e.next;var m=d.previous;var p=e._.r;var v=d._.r;do if(p<=v){if(Tk(k._,b._)){e=k;d.next=e;e.previous=d;--g;continue a}p+=k._.r;k=k.next}else{if(Tk(m._,b._)){d=m;d.next=e;e.previous=d;--g;continue a}v+=m._.r;m=m.previous}while(k!==
m.next);b.previous=d;b.next=e;d.next=e.previous=e=b;for(k=Uk(d);(b=b.next)!==e;)(m=Uk(b))<k&&(d=b,k=m);e=d.next}d=[e._];for(b=e;(b=b.next)!==e;)d.push(b._);b=Pk(d);for(g=0;g<c;++g)d=a[g],d.x-=b.x,d.y-=b.y;return b.r}function We(a){if("function"!==typeof a)throw Error();return a}function Zb(){return 0}function yc(a){return function(){return a}}function $q(a){return Math.sqrt(a.value)}function Wk(a){return function(b){b.children||(b.r=Math.max(0,+a(b)||0))}}function hh(a,b){return function(c){if(d=
c.children){var d,e,g=d.length,k=a(c)*b||0;if(k)for(e=0;e<g;++e)d[e].r+=k;var m=Vk(d);if(k)for(e=0;e<g;++e)d[e].r-=k;c.r=m+k}}}function Xk(a){return function(b){var c=b.parent;b.r*=a;c&&(b.x=c.x+a*b.x,b.y=c.y+a*b.y)}}function Yk(a){a.x0=Math.round(a.x0);a.y0=Math.round(a.y0);a.x1=Math.round(a.x1);a.y1=Math.round(a.y1)}function qd(a,b,c,d,e){var g=a.children,k=-1,m=g.length;for(d=a.value&&(d-b)/a.value;++k<m;)a=g[k],a.y0=c,a.y1=e,a.x0=b,a.x1=b+=a.value*d}function ar(a){return a.id}function br(a){return a.parentId}
function cr(a,b){return a.parent===b.parent?1:2}function ih(a){var b=a.children;return b?b[0]:a.t}function jh(a){var b=a.children;return b?b[b.length-1]:a.t}function Xe(a,b){this._=a;this.A=this.children=this.parent=null;this.a=this;this.s=this.c=this.m=this.z=0;this.t=null;this.i=b}function dr(a){a=new Xe(a,0);for(var b,c=[a],d,e,g;b=c.pop();)if(e=b._.children)for(b.children=Array(d=e.length),g=d-1;0<=g;--g)c.push(d=b.children[g]=new Xe(e[g],g)),d.parent=b;(a.parent=new Xe(null,0)).children=[a];
return a}function Ye(a,b,c,d,e){var g=a.children,k=-1,m=g.length;for(e=a.value&&(e-c)/a.value;++k<m;)a=g[k],a.x0=b,a.x1=d,a.y0=c,a.y1=c+=a.value*e}function Zk(a,b,c,d,e,g){for(var k=[],m=b.children,p,v,h=p=0,l=m.length,q,w=b.value,B,F,J,P,x,y;p<l;){b=e-c;q=g-d;do B=m[h++].value;while(!B&&h<l);F=J=B;y=Math.max(q/b,b/q)/(w*a);P=B*B*y;for(x=Math.max(J/P,P/F);h<l;++h){B+=v=m[h].value;v<F&&(F=v);v>J&&(J=v);P=B*B*y;P=Math.max(J/P,P/F);if(P>x){B-=v;break}x=P}k.push(p={value:B,dice:b<q,children:m.slice(p,
h)});p.dice?qd(p,c,d,e,w?d+=q*B/w:g):Ye(p,c,d,w?c+=b*B/w:e,g);w-=B;p=h}return k}function er(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])}function fr(a,b){return a[0]-b[0]||a[1]-b[1]}function $k(a){for(var b=a.length,c=[0,1],d=2,e=2;e<b;++e){for(;1<d&&0>=er(a[c[d-2]],a[c[d-1]],a[e]);)--d;c[d++]=e}return c.slice(0,d)}function zc(){return Math.random()}function kh(a){function b(g){var k=g+"",m=c.get(k);if(!m){if(e!==lh)return e;c.set(k,m=d.push(g))}return a[(m-1)%a.length]}var c=rb(),
d=[],e=lh;a=null==a?[]:Ib.call(a);b.domain=function(g){if(!arguments.length)return d.slice();d=[];c=rb();for(var k=-1,m=g.length,p,v;++k<m;)c.has(v=(p=g[k])+"")||c.set(v,d.push(p));return b};b.range=function(g){return arguments.length?(a=Ib.call(g),b):a.slice()};b.unknown=function(g){return arguments.length?(e=g,b):e};b.copy=function(){return kh().domain(d).range(a).unknown(e)};return b}function mh(){function a(){var l=c().length,q=e[1]<e[0],w=e[q-0],B=e[1-q];g=(B-w)/Math.max(1,l-p+2*v);m&&(g=Math.floor(g));
w+=(B-w-g*(l-p))*h;k=g*(1-p);m&&(w=Math.round(w),k=Math.round(k));l=Ta(l).map(function(F){return w+g*F});return d(q?l.reverse():l)}var b=kh().unknown(void 0),c=b.domain,d=b.range,e=[0,1],g,k,m=!1,p=0,v=0,h=.5;delete b.unknown;b.domain=function(l){return arguments.length?(c(l),a()):c()};b.range=function(l){return arguments.length?(e=[+l[0],+l[1]],a()):e.slice()};b.rangeRound=function(l){return e=[+l[0],+l[1]],m=!0,a()};b.bandwidth=function(){return k};b.step=function(){return g};b.round=function(l){return arguments.length?
(m=!!l,a()):m};b.padding=function(l){return arguments.length?(p=v=Math.max(0,Math.min(1,l)),a()):p};b.paddingInner=function(l){return arguments.length?(p=Math.max(0,Math.min(1,l)),a()):p};b.paddingOuter=function(l){return arguments.length?(v=Math.max(0,Math.min(1,l)),a()):v};b.align=function(l){return arguments.length?(h=Math.max(0,Math.min(1,l)),a()):h};b.copy=function(){return mh().domain(c()).range(e).round(m).paddingInner(p).paddingOuter(v).align(h)};return a()}function al(a){var b=a.copy;a.padding=
a.paddingOuter;delete a.paddingInner;delete a.paddingOuter;a.copy=function(){return al(b())};return a}function nh(a){return function(){return a}}function bl(a){return+a}function oh(a,b){return(b-=a=+a)?function(c){return(c-a)/b}:nh(b)}function gr(a){return function(b,c){var d=a(b=+b,c=+c);return function(e){return e<=b?0:e>=c?1:d(e)}}}function hr(a){return function(b,c){var d=a(b=+b,c=+c);return function(e){return 0>=e?b:1<=e?c:d(e)}}}function ir(a,b,c,d){var e=a[0];a=a[1];var g=b[0];b=b[1];a<e?(e=
c(a,e),g=d(b,g)):(e=c(e,a),g=d(g,b));return function(k){return g(e(k))}}function jr(a,b,c,d){var e=Math.min(a.length,b.length)-1,g=Array(e),k=Array(e),m=-1;a[e]<a[0]&&(a=a.slice().reverse(),b=b.slice().reverse());for(;++m<e;)g[m]=c(a[m],a[m+1]),k[m]=d(b[m],b[m+1]);return function(p){var v=$b(a,p,1,e)-1;return k[v](g[v](p))}}function Ze(a,b){return b.domain(a.domain()).range(a.range()).interpolate(a.interpolate()).clamp(a.clamp())}function $e(a,b){function c(){p=2<Math.min(e.length,g.length)?jr:ir;
v=h=null;return d}function d(l){return(v||(v=p(e,g,m?gr(a):a,k)))(+l)}var e=cl,g=cl,k=Sc,m=!1,p,v,h;d.invert=function(l){return(h||(h=p(g,e,oh,m?hr(b):b)))(+l)};d.domain=function(l){return arguments.length?(e=ph.call(l,bl),c()):e.slice()};d.range=function(l){return arguments.length?(g=Ib.call(l),c()):g.slice()};d.rangeRound=function(l){return g=Ib.call(l),k=Li,c()};d.clamp=function(l){return arguments.length?(m=!!l,c()):m};d.interpolate=function(l){return arguments.length?(k=l,c()):k};return c()}
function Ac(a){var b=a.domain;a.ticks=function(c){var d=b();return Df(d[0],d[d.length-1],null==c?10:c)};a.tickFormat=function(c,d){var e;a:{var g=b(),k=g[0];g=g[g.length-1];c=Nb(k,g,null==c?10:c);d=bd(null==d?",f":d);switch(d.type){case "s":k=Math.max(Math.abs(k),Math.abs(g));null!=d.precision||isNaN(e=Aj(c,k))||(d.precision=e);e=d3.formatPrefix(d,k);break a;case "":case "e":case "g":case "p":case "r":null!=d.precision||isNaN(e=Bj(c,Math.max(Math.abs(k),Math.abs(g))))||(d.precision=e-("e"===d.type));
break;case "f":case "%":null!=d.precision||isNaN(e=zj(c))||(d.precision=e-2*("%"===d.type))}e=d3.format(d)}return e};a.nice=function(c){null==c&&(c=10);var d=b(),e=0,g=d.length-1,k=d[e],m=d[g];if(m<k){var p=k;k=m;m=p;p=e;e=g;g=p}p=Nc(k,m,c);0<p?(k=Math.floor(k/p)*p,m=Math.ceil(m/p)*p,p=Nc(k,m,c)):0>p&&(k=Math.ceil(k*p)/p,m=Math.floor(m*p)/p,p=Nc(k,m,c));0<p?(d[e]=Math.floor(k/p)*p,d[g]=Math.ceil(m/p)*p,b(d)):0>p&&(d[e]=Math.ceil(k*p)/p,d[g]=Math.floor(m*p)/p,b(d));return a};return a}function dl(){var a=
$e(oh,Va);a.copy=function(){return Ze(a,dl())};return Ac(a)}function el(){function a(c){return+c}var b=[0,1];a.invert=a;a.domain=a.range=function(c){return arguments.length?(b=ph.call(c,bl),a):b.slice()};a.copy=function(){return el().domain(b)};return Ac(a)}function fl(a,b){a=a.slice();var c=0,d=a.length-1,e=a[c],g=a[d];if(g<e){var k=c;c=d;d=k;k=e;e=g;g=k}a[c]=b.floor(e);a[d]=b.ceil(g);return a}function kr(a,b){return(b=Math.log(b/a))?function(c){return Math.log(c/a)/b}:nh(b)}function lr(a,b){return 0>
a?function(c){return-Math.pow(-b,c)*Math.pow(-a,1-c)}:function(c){return Math.pow(b,c)*Math.pow(a,1-c)}}function mr(a){return isFinite(a)?+("1e"+a):0>a?0:a}function gl(a){return 10===a?mr:a===Math.E?Math.exp:function(b){return Math.pow(a,b)}}function hl(a){return a===Math.E?Math.log:10===a&&Math.log10||2===a&&Math.log2||(a=Math.log(a),function(b){return Math.log(b)/a})}function il(a){return function(b){return-a(-b)}}function jl(){function a(){e=hl(d);g=gl(d);0>c()[0]&&(e=il(e),g=il(g));return b}var b=
$e(kr,lr).domain([1,10]),c=b.domain,d=10,e=hl(10),g=gl(10);b.base=function(k){return arguments.length?(d=+k,a()):d};b.domain=function(k){return arguments.length?(c(k),a()):c()};b.ticks=function(k){var m=c(),p=m[0];m=m[m.length-1];var v;if(v=m<p)h=p,p=m,m=h;var h=e(p),l=e(m);var q=null==k?10:+k;k=[];if(!(d%1)&&l-h<q)if(h=Math.round(h)-1,l=Math.round(l)+1,0<p)for(;h<l;++h){var w=1;for(q=g(h);w<d;++w){var B=q*w;if(!(B<p)){if(B>m)break;k.push(B)}}}else for(;h<l;++h)for(w=d-1,q=g(h);1<=w;--w){if(B=q*w,
!(B<p)){if(B>m)break;k.push(B)}}else k=Df(h,l,Math.min(l-h,q)).map(g);return v?k.reverse():k};b.tickFormat=function(k,m){null==m&&(m=10===d?".0e":",");"function"!==typeof m&&(m=d3.format(m));if(Infinity===k)return m;null==k&&(k=10);var p=Math.max(1,d*k/b.ticks().length);return function(v){var h=v/g(Math.round(e(v)));h*d<d-.5&&(h*=d);return h<=p?m(v):""}};b.nice=function(){return c(fl(c(),{floor:function(k){return g(Math.floor(e(k)))},ceil:function(k){return g(Math.ceil(e(k)))}}))};b.copy=function(){return Ze(b,
jl().base(d))};return b}function Bc(a,b){return 0>a?-Math.pow(-a,b):Math.pow(a,b)}function qh(){var a=1,b=$e(function(d,e){return(e=Bc(e,a)-(d=Bc(d,a)))?function(g){return(Bc(g,a)-d)/e}:nh(e)},function(d,e){e=Bc(e,a)-(d=Bc(d,a));return function(g){return Bc(d+e*g,1/a)}}),c=b.domain;b.exponent=function(d){return arguments.length?(a=+d,c(c())):a};b.copy=function(){return Ze(b,qh().exponent(a))};return Ac(b)}function kl(){function a(){var g=0,k=Math.max(1,d.length);for(e=Array(k-1);++g<k;)e[g-1]=Oc(c,
g/k);return b}function b(g){if(!isNaN(g=+g))return d[$b(e,g)]}var c=[],d=[],e=[];b.invertExtent=function(g){g=d.indexOf(g);return 0>g?[NaN,NaN]:[0<g?e[g-1]:c[0],g<e.length?e[g]:c[c.length-1]]};b.domain=function(g){if(!arguments.length)return c.slice();c=[];for(var k=0,m=g.length,p;k<m;++k)(p=g[k],null==p||isNaN(p=+p))||c.push(p);c.sort(Mb);return a()};b.range=function(g){return arguments.length?(d=Ib.call(g),a()):d.slice()};b.quantiles=function(){return e.slice()};b.copy=function(){return kl().domain(c).range(d)};
return b}function ll(){function a(m){if(m<=m)return k[$b(g,m,0,e)]}function b(){var m=-1;for(g=Array(e);++m<e;)g[m]=((m+1)*d-(m-e)*c)/(e+1);return a}var c=0,d=1,e=1,g=[.5],k=[0,1];a.domain=function(m){return arguments.length?(c=+m[0],d=+m[1],b()):[c,d]};a.range=function(m){return arguments.length?(e=(k=Ib.call(m)).length-1,b()):k.slice()};a.invertExtent=function(m){m=k.indexOf(m);return 0>m?[NaN,NaN]:1>m?[c,g[0]]:m>=e?[g[e-1],d]:[g[m-1],g[m]]};a.copy=function(){return ll().domain([c,d]).range(k)};
return Ac(a)}function ml(){function a(e){if(e<=e)return c[$b(b,e,0,d)]}var b=[.5],c=[0,1],d=1;a.domain=function(e){return arguments.length?(b=Ib.call(e),d=Math.min(b.length,c.length-1),a):b.slice()};a.range=function(e){return arguments.length?(c=Ib.call(e),d=Math.min(b.length,c.length-1),a):c.slice()};a.invertExtent=function(e){e=c.indexOf(e);return[b[e-1],b[e]]};a.copy=function(){return ml().domain(b).range(c)};return a}function Da(a,b,c,d){function e(g){return a(g=new Date(+g)),g}e.floor=e;e.ceil=
function(g){return a(g=new Date(g-1)),b(g,1),a(g),g};e.round=function(g){var k=e(g),m=e.ceil(g);return g-k<m-g?k:m};e.offset=function(g,k){return b(g=new Date(+g),null==k?1:Math.floor(k)),g};e.range=function(g,k,m){var p=[],v;g=e.ceil(g);m=null==m?1:Math.floor(m);if(!(g<k&&0<m))return p;do p.push(v=new Date(+g)),b(g,m),a(g);while(v<g&&g<k);return p};e.filter=function(g){return Da(function(k){if(k>=k)for(;a(k),!g(k);)k.setTime(k-1)},function(k,m){if(k>=k)if(0>m)for(;0>=++m;)for(;b(k,-1),!g(k););else for(;0<=
--m;)for(;b(k,1),!g(k););})};c&&(e.count=function(g,k){rh.setTime(+g);sh.setTime(+k);a(rh);a(sh);return Math.floor(c(rh,sh))},e.every=function(g){g=Math.floor(g);return isFinite(g)&&0<g?1<g?e.filter(d?function(k){return 0===d(k)%g}:function(k){return 0===e.count(0,k)%g}):e:null});return e}function ac(a){return Da(function(b){b.setDate(b.getDate()-(b.getDay()+7-a)%7);b.setHours(0,0,0,0)},function(b,c){b.setDate(b.getDate()+7*c)},function(b,c){return(c-b-6E4*(c.getTimezoneOffset()-b.getTimezoneOffset()))/
6048E5})}function bc(a){return Da(function(b){b.setUTCDate(b.getUTCDate()-(b.getUTCDay()+7-a)%7);b.setUTCHours(0,0,0,0)},function(b,c){b.setUTCDate(b.getUTCDate()+7*c)},function(b,c){return(c-b)/6048E5})}function nr(a){if(0<=a.y&&100>a.y){var b=new Date(-1,a.m,a.d,a.H,a.M,a.S,a.L);b.setFullYear(a.y);return b}return new Date(a.y,a.m,a.d,a.H,a.M,a.S,a.L)}function af(a){if(0<=a.y&&100>a.y){var b=new Date(Date.UTC(-1,a.m,a.d,a.H,a.M,a.S,a.L));b.setUTCFullYear(a.y);return b}return new Date(Date.UTC(a.y,
a.m,a.d,a.H,a.M,a.S,a.L))}function rd(a){return{y:a,m:0,d:1,H:0,M:0,S:0,L:0}}function nl(a){function b(f,n){return function(u){var r=[],t=-1,z=0,D=f.length,A,C;for(u instanceof Date||(u=new Date(+u));++t<D;)if(37===f.charCodeAt(t)){r.push(f.slice(z,t));null!=(z=ol[A=f.charAt(++t)])?A=f.charAt(++t):z="e"===A?" ":"0";if(C=n[A])A=C(u,z);r.push(A);z=t+1}r.push(f.slice(z,t));return r.join("")}}function c(f,n){return function(u){var r=rd(1900);if(d(r,f,u+="",0)!=u.length)return null;if("Q"in r)return new Date(r.Q);
"p"in r&&(r.H=r.H%12+12*r.p);if("V"in r){if(1>r.V||53<r.V)return null;"w"in r||(r.w=1);if("Z"in r){u=af(rd(r.y));var t=u.getUTCDay();u=4<t||0===t?sd.ceil(u):sd(u);u=td.offset(u,7*(r.V-1));r.y=u.getUTCFullYear();r.m=u.getUTCMonth();r.d=u.getUTCDate()+(r.w+6)%7}else u=n(rd(r.y)),t=u.getDay(),u=4<t||0===t?ud.ceil(u):ud(u),u=vd.offset(u,7*(r.V-1)),r.y=u.getFullYear(),r.m=u.getMonth(),r.d=u.getDate()+(r.w+6)%7}else if("W"in r||"U"in r)"w"in r||(r.w="u"in r?r.u%7:"W"in r?1:0),t="Z"in r?af(rd(r.y)).getUTCDay():
n(rd(r.y)).getDay(),r.m=0,r.d="W"in r?(r.w+6)%7+7*r.W-(t+5)%7:r.w+7*r.U-(t+6)%7;return"Z"in r?(r.H+=r.Z/100|0,r.M+=r.Z%100,af(r)):n(r)}}function d(f,n,u,r){for(var t=0,z=n.length,D=u.length,A;t<z;){if(r>=D)return-1;A=n.charCodeAt(t++);if(37===A){if(A=n.charAt(t++),A=T[A in ol?n.charAt(t++):A],!A||0>(r=A(f,u,r)))return-1}else if(A!=u.charCodeAt(r++))return-1}return r}var e=a.dateTime,g=a.date,k=a.time,m=a.periods,p=a.days,v=a.shortDays,h=a.months,l=a.shortMonths,q=wd(m),w=xd(m),B=wd(p),F=xd(p),J=wd(v),
P=xd(v),x=wd(h),y=xd(h),I=wd(l),Q=xd(l),V={a:function(f){return v[f.getDay()]},A:function(f){return p[f.getDay()]},b:function(f){return l[f.getMonth()]},B:function(f){return h[f.getMonth()]},c:null,d:pl,e:pl,f:or,H:pr,I:qr,j:rr,L:ql,m:sr,M:tr,p:function(f){return m[+(12<=f.getHours())]},Q:rl,s:sl,S:ur,u:vr,U:wr,V:xr,w:yr,W:zr,x:null,X:null,y:Ar,Y:Br,Z:Cr,"%":tl},N={a:function(f){return v[f.getUTCDay()]},A:function(f){return p[f.getUTCDay()]},b:function(f){return l[f.getUTCMonth()]},B:function(f){return h[f.getUTCMonth()]},
c:null,d:ul,e:ul,f:Dr,H:Er,I:Fr,j:Gr,L:vl,m:Hr,M:Ir,p:function(f){return m[+(12<=f.getUTCHours())]},Q:rl,s:sl,S:Jr,u:Kr,U:Lr,V:Mr,w:Nr,W:Or,x:null,X:null,y:Pr,Y:Qr,Z:Rr,"%":tl},T={a:function(f,n,u){return(n=J.exec(n.slice(u)))?(f.w=P[n[0].toLowerCase()],u+n[0].length):-1},A:function(f,n,u){return(n=B.exec(n.slice(u)))?(f.w=F[n[0].toLowerCase()],u+n[0].length):-1},b:function(f,n,u){return(n=I.exec(n.slice(u)))?(f.m=Q[n[0].toLowerCase()],u+n[0].length):-1},B:function(f,n,u){return(n=x.exec(n.slice(u)))?
(f.m=y[n[0].toLowerCase()],u+n[0].length):-1},c:function(f,n,u){return d(f,e,n,u)},d:wl,e:wl,f:Sr,H:xl,I:xl,j:Tr,L:Ur,m:Vr,M:Wr,p:function(f,n,u){return(n=q.exec(n.slice(u)))?(f.p=w[n[0].toLowerCase()],u+n[0].length):-1},Q:Xr,s:Yr,S:Zr,u:$r,U:as,V:bs,w:cs,W:ds,x:function(f,n,u){return d(f,g,n,u)},X:function(f,n,u){return d(f,k,n,u)},y:es,Y:fs,Z:gs,"%":hs};V.x=b(g,V);V.X=b(k,V);V.c=b(e,V);N.x=b(g,N);N.X=b(k,N);N.c=b(e,N);return{format:function(f){var n=b(f+="",V);n.toString=function(){return f};return n},
parse:function(f){var n=c(f+="",nr);n.toString=function(){return f};return n},utcFormat:function(f){var n=b(f+="",N);n.toString=function(){return f};return n},utcParse:function(f){var n=c(f,af);n.toString=function(){return f};return n}}}function sa(a,b,c){var d=0>a?"-":"";a=(d?-a:a)+"";var e=a.length;return d+(e<c?Array(c-e+1).join(b)+a:a)}function is(a){return a.replace(js,"\\$&")}function wd(a){return new RegExp("^(?:"+a.map(is).join("|")+")","i")}function xd(a){for(var b={},c=-1,d=a.length;++c<
d;)b[a[c].toLowerCase()]=c;return b}function cs(a,b,c){return(b=Ga.exec(b.slice(c,c+1)))?(a.w=+b[0],c+b[0].length):-1}function $r(a,b,c){return(b=Ga.exec(b.slice(c,c+1)))?(a.u=+b[0],c+b[0].length):-1}function as(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.U=+b[0],c+b[0].length):-1}function bs(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.V=+b[0],c+b[0].length):-1}function ds(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.W=+b[0],c+b[0].length):-1}function fs(a,b,c){return(b=Ga.exec(b.slice(c,c+4)))?(a.y=
+b[0],c+b[0].length):-1}function es(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.y=+b[0]+(68<+b[0]?1900:2E3),c+b[0].length):-1}function gs(a,b,c){return(b=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(b.slice(c,c+6)))?(a.Z=b[1]?0:-(b[2]+(b[3]||"00")),c+b[0].length):-1}function Vr(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.m=b[0]-1,c+b[0].length):-1}function wl(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.d=+b[0],c+b[0].length):-1}function Tr(a,b,c){return(b=Ga.exec(b.slice(c,c+3)))?(a.m=0,a.d=+b[0],c+b[0].length):
-1}function xl(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.H=+b[0],c+b[0].length):-1}function Wr(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.M=+b[0],c+b[0].length):-1}function Zr(a,b,c){return(b=Ga.exec(b.slice(c,c+2)))?(a.S=+b[0],c+b[0].length):-1}function Ur(a,b,c){return(b=Ga.exec(b.slice(c,c+3)))?(a.L=+b[0],c+b[0].length):-1}function Sr(a,b,c){return(b=Ga.exec(b.slice(c,c+6)))?(a.L=Math.floor(b[0]/1E3),c+b[0].length):-1}function hs(a,b,c){return(a=ks.exec(b.slice(c,c+1)))?c+a[0].length:-1}function Xr(a,
b,c){return(b=Ga.exec(b.slice(c)))?(a.Q=+b[0],c+b[0].length):-1}function Yr(a,b,c){return(b=Ga.exec(b.slice(c)))?(a.Q=1E3*+b[0],c+b[0].length):-1}function pl(a,b){return sa(a.getDate(),b,2)}function pr(a,b){return sa(a.getHours(),b,2)}function qr(a,b){return sa(a.getHours()%12||12,b,2)}function rr(a,b){return sa(1+vd.count(wb(a),a),b,3)}function ql(a,b){return sa(a.getMilliseconds(),b,3)}function or(a,b){return ql(a,b)+"000"}function sr(a,b){return sa(a.getMonth()+1,b,2)}function tr(a,b){return sa(a.getMinutes(),
b,2)}function ur(a,b){return sa(a.getSeconds(),b,2)}function vr(a){a=a.getDay();return 0===a?7:a}function wr(a,b){return sa(yd.count(wb(a),a),b,2)}function xr(a,b){var c=a.getDay();a=4<=c||0===c?zd(a):zd.ceil(a);return sa(zd.count(wb(a),a)+(4===wb(a).getDay()),b,2)}function yr(a){return a.getDay()}function zr(a,b){return sa(ud.count(wb(a),a),b,2)}function Ar(a,b){return sa(a.getFullYear()%100,b,2)}function Br(a,b){return sa(a.getFullYear()%1E4,b,4)}function Cr(a){a=a.getTimezoneOffset();return(0<
a?"-":(a*=-1,"+"))+sa(a/60|0,"0",2)+sa(a%60,"0",2)}function ul(a,b){return sa(a.getUTCDate(),b,2)}function Er(a,b){return sa(a.getUTCHours(),b,2)}function Fr(a,b){return sa(a.getUTCHours()%12||12,b,2)}function Gr(a,b){return sa(1+td.count(xb(a),a),b,3)}function vl(a,b){return sa(a.getUTCMilliseconds(),b,3)}function Dr(a,b){return vl(a,b)+"000"}function Hr(a,b){return sa(a.getUTCMonth()+1,b,2)}function Ir(a,b){return sa(a.getUTCMinutes(),b,2)}function Jr(a,b){return sa(a.getUTCSeconds(),b,2)}function Kr(a){a=
a.getUTCDay();return 0===a?7:a}function Lr(a,b){return sa(Ad.count(xb(a),a),b,2)}function Mr(a,b){var c=a.getUTCDay();a=4<=c||0===c?Bd(a):Bd.ceil(a);return sa(Bd.count(xb(a),a)+(4===xb(a).getUTCDay()),b,2)}function Nr(a){return a.getUTCDay()}function Or(a,b){return sa(sd.count(xb(a),a),b,2)}function Pr(a,b){return sa(a.getUTCFullYear()%100,b,2)}function Qr(a,b){return sa(a.getUTCFullYear()%1E4,b,4)}function Rr(){return"+0000"}function tl(){return"%"}function rl(a){return+a}function sl(a){return Math.floor(+a/
1E3)}function yl(a){Cc=nl(a);d3.timeFormat=Cc.format;d3.timeParse=Cc.parse;d3.utcFormat=Cc.utcFormat;d3.utcParse=Cc.utcParse;return Cc}function ls(a){return a.toISOString()}function ms(a){a=new Date(a);return isNaN(a)?null:a}function ns(a){return new Date(a)}function os(a){return a instanceof Date?+a:+new Date(+a)}function th(a,b,c,d,e,g,k,m,p){function v(N){return(k(N)<N?B:g(N)<N?F:e(N)<N?J:d(N)<N?P:b(N)<N?c(N)<N?x:y:a(N)<N?I:Q)(N)}function h(N,T,f,n){null==N&&(N=10);if("number"===typeof N){n=Math.abs(f-
T)/N;var u=Bf(function(r){return r[2]}).right(V,n);u===V.length?(n=Nb(T/31536E6,f/31536E6,N),N=a):u?(u=V[n/V[u-1][2]<V[u][2]/n?u-1:u],n=u[1],N=u[0]):(n=Math.max(Nb(T,f,N),1),N=m)}return null==n?N:N.every(n)}var l=$e(oh,Va),q=l.invert,w=l.domain,B=p(".%L"),F=p(":%S"),J=p("%I:%M"),P=p("%I %p"),x=p("%a %d"),y=p("%b %d"),I=p("%B"),Q=p("%Y"),V=[[k,1,1E3],[k,5,5E3],[k,15,15E3],[k,30,3E4],[g,1,6E4],[g,5,3E5],[g,15,9E5],[g,30,18E5],[e,1,36E5],[e,3,108E5],[e,6,216E5],[e,12,432E5],[d,1,864E5],[d,2,1728E5],
[c,1,6048E5],[b,1,2592E6],[b,3,7776E6],[a,1,31536E6]];l.invert=function(N){return new Date(q(N))};l.domain=function(N){return arguments.length?w(ph.call(N,os)):w().map(ns)};l.ticks=function(N,T){var f=w(),n=f[0];f=f[f.length-1];var u=f<n;if(u){var r=n;n=f;f=r}r=(r=h(N,n,f,T))?r.range(n,f+1):[];return u?r.reverse():r};l.tickFormat=function(N,T){return null==T?v:p(T)};l.nice=function(N,T){var f=w();return(N=h(N,f[0],f[f.length-1],T))?w(fl(f,N)):l};l.copy=function(){return Ze(l,th(a,b,c,d,e,g,k,m,p))};
return l}function zl(a){function b(k){k=(k-c)*e;return a(g?Math.max(0,Math.min(1,k)):k)}var c=0,d=1,e=1,g=!1;b.domain=function(k){return arguments.length?(c=+k[0],d=+k[1],e=c===d?0:1/(d-c),b):[c,d]};b.clamp=function(k){return arguments.length?(g=!!k,b):g};b.interpolator=function(k){return arguments.length?(a=k,b):a};b.copy=function(){return zl(a).domain([c,d]).clamp(g)};return Ac(b)}function Al(a){function b(p){var v=.5+((p=+p)-d)*(p<d?g:k);return a(m?Math.max(0,Math.min(1,v)):v)}var c=0,d=.5,e=1,
g=1,k=1,m=!1;b.domain=function(p){return arguments.length?(c=+p[0],d=+p[1],e=+p[2],g=c===d?0:.5/(d-c),k=d===e?0:.5/(e-d),b):[c,d,e]};b.clamp=function(p){return arguments.length?(m=!!p,b):m};b.interpolator=function(p){return arguments.length?(a=p,b):a};b.copy=function(){return Al(a).domain([c,d,e]).clamp(m)};return Ac(b)}function ka(a){for(var b=a.length/6|0,c=Array(b),d=0;d<b;)c[d]="#"+a.slice(6*d,6*++d);return c}function ua(a){return Bl(a[a.length-1])}function bf(a){var b=a.length;return function(c){return a[Math.max(0,
Math.min(b-1,Math.floor(c*b)))]}}function na(a){return function(){return a}}function Cl(a){return 1<=a?cf:-1>=a?-cf:Math.asin(a)}function ps(a){return a.innerRadius}function qs(a){return a.outerRadius}function rs(a){return a.startAngle}function ss(a){return a.endAngle}function ts(a){return a&&a.padAngle}function df(a,b,c,d,e,g,k){var m=a-c,p=b-d;k=(k?g:-g)/Dc(m*m+p*p);p*=k;m*=-k;var v=a+p,h=b+m,l=c+p,q=d+m;c=(v+l)/2;d=(h+q)/2;b=l-v;a=q-h;k=b*b+a*a;g=e-g;q=v*q-l*h;var w=(0>a?-1:1)*Dc(us(0,g*g*k-q*
q));v=(q*a-b*w)/k;h=(-q*b-a*w)/k;l=(q*a+b*w)/k;b=(-q*b+a*w)/k;a=v-c;k=h-d;c=l-c;d=b-d;a*a+k*k>c*c+d*d&&(v=l,h=b);return{cx:v,cy:h,x01:-p,y01:-m,x11:v*(e/g-1),y11:h*(e/g-1)}}function Dl(a){this._context=a}function ef(a){return new Dl(a)}function uh(a){return a[0]}function vh(a){return a[1]}function wh(){function a(m){var p,v=m.length,h,l=!1,q;null==e&&(k=g(q=Eb()));for(p=0;p<=v;++p)!(p<v&&d(h=m[p],p,m))===l&&((l=!l)?k.lineStart():k.lineEnd()),l&&k.point(+b(h,p,m),+c(h,p,m));if(q)return k=null,q+""||
null}var b=uh,c=vh,d=na(!0),e=null,g=ef,k=null;a.x=function(m){return arguments.length?(b="function"===typeof m?m:na(+m),a):b};a.y=function(m){return arguments.length?(c="function"===typeof m?m:na(+m),a):c};a.defined=function(m){return arguments.length?(d="function"===typeof m?m:na(!!m),a):d};a.curve=function(m){return arguments.length?(g=m,null!=e&&(k=g(e)),a):g};a.context=function(m){return arguments.length?(null==m?e=k=null:k=g(e=m),a):e};return a}function El(){function a(h){var l,q,w=h.length,
B,F=!1,J,P=Array(w),x=Array(w);null==m&&(v=p(J=Eb()));for(l=0;l<=w;++l){if(!(l<w&&k(B=h[l],l,h))===F)if(F=!F){var y=l;v.areaStart();v.lineStart()}else{v.lineEnd();v.lineStart();for(q=l-1;q>=y;--q)v.point(P[q],x[q]);v.lineEnd();v.areaEnd()}F&&(P[l]=+c(B,l,h),x[l]=+e(B,l,h),v.point(d?+d(B,l,h):P[l],g?+g(B,l,h):x[l]))}if(J)return v=null,J+""||null}function b(){return wh().defined(k).curve(p).context(m)}var c=uh,d=null,e=na(0),g=vh,k=na(!0),m=null,p=ef,v=null;a.x=function(h){return arguments.length?(c=
"function"===typeof h?h:na(+h),d=null,a):c};a.x0=function(h){return arguments.length?(c="function"===typeof h?h:na(+h),a):c};a.x1=function(h){return arguments.length?(d=null==h?null:"function"===typeof h?h:na(+h),a):d};a.y=function(h){return arguments.length?(e="function"===typeof h?h:na(+h),g=null,a):e};a.y0=function(h){return arguments.length?(e="function"===typeof h?h:na(+h),a):e};a.y1=function(h){return arguments.length?(g=null==h?null:"function"===typeof h?h:na(+h),a):g};a.lineX0=a.lineY0=function(){return b().x(c).y(e)};
a.lineY1=function(){return b().x(c).y(g)};a.lineX1=function(){return b().x(d).y(e)};a.defined=function(h){return arguments.length?(k="function"===typeof h?h:na(!!h),a):k};a.curve=function(h){return arguments.length?(p=h,null!=m&&(v=p(m)),a):p};a.context=function(h){return arguments.length?(null==h?m=v=null:v=p(m=h),a):m};return a}function vs(a,b){return b<a?-1:b>a?1:b>=a?0:NaN}function ws(a){return a}function Fl(a){this._curve=a}function xh(a){function b(c){return new Fl(a(c))}b._curve=a;return b}
function Cd(a){var b=a.curve;a.angle=a.x;delete a.x;a.radius=a.y;delete a.y;a.curve=function(c){return arguments.length?b(xh(c)):b()._curve};return a}function Gl(){return Cd(wh().curve(Hl))}function Il(){var a=El().curve(Hl),b=a.curve,c=a.lineX0,d=a.lineX1,e=a.lineY0,g=a.lineY1;a.angle=a.x;delete a.x;a.startAngle=a.x0;delete a.x0;a.endAngle=a.x1;delete a.x1;a.radius=a.y;delete a.y;a.innerRadius=a.y0;delete a.y0;a.outerRadius=a.y1;delete a.y1;a.lineStartAngle=function(){return Cd(c())};delete a.lineX0;
a.lineEndAngle=function(){return Cd(d())};delete a.lineX1;a.lineInnerRadius=function(){return Cd(e())};delete a.lineY0;a.lineOuterRadius=function(){return Cd(g())};delete a.lineY1;a.curve=function(k){return arguments.length?b(xh(k)):b()._curve};return a}function Dd(a,b){return[(b=+b)*Math.cos(a-=Math.PI/2),b*Math.sin(a)]}function xs(a){return a.source}function ys(a){return a.target}function yh(a){function b(){var m,p=zh.call(arguments),v=c.apply(this,p),h=d.apply(this,p);k||(k=m=Eb());a(k,+e.apply(this,
(p[0]=v,p)),+g.apply(this,p),+e.apply(this,(p[0]=h,p)),+g.apply(this,p));if(m)return k=null,m+""||null}var c=xs,d=ys,e=uh,g=vh,k=null;b.source=function(m){return arguments.length?(c=m,b):c};b.target=function(m){return arguments.length?(d=m,b):d};b.x=function(m){return arguments.length?(e="function"===typeof m?m:na(+m),b):e};b.y=function(m){return arguments.length?(g="function"===typeof m?m:na(+m),b):g};b.context=function(m){return arguments.length?(k=null==m?null:m,b):k};return b}function zs(a,b,
c,d,e){a.moveTo(b,c);a.bezierCurveTo(b=(b+d)/2,c,b,e,d,e)}function As(a,b,c,d,e){a.moveTo(b,c);a.bezierCurveTo(b,c=(c+e)/2,d,c,d,e)}function Bs(a,b,c,d,e){var g=Dd(b,c);b=Dd(b,c=(c+e)/2);c=Dd(d,c);d=Dd(d,e);a.moveTo(g[0],g[1]);a.bezierCurveTo(b[0],b[1],c[0],c[1],d[0],d[1])}function Jb(){}function ff(a,b,c){a._context.bezierCurveTo((2*a._x0+a._x1)/3,(2*a._y0+a._y1)/3,(a._x0+2*a._x1)/3,(a._y0+2*a._y1)/3,(a._x0+4*a._x1+b)/6,(a._y0+4*a._y1+c)/6)}function gf(a){this._context=a}function Jl(a){this._context=
a}function Kl(a){this._context=a}function Ll(a,b){this._basis=new gf(a);this._beta=b}function hf(a,b,c){a._context.bezierCurveTo(a._x1+a._k*(a._x2-a._x0),a._y1+a._k*(a._y2-a._y0),a._x2+a._k*(a._x1-b),a._y2+a._k*(a._y1-c),a._x2,a._y2)}function Ah(a,b){this._context=a;this._k=(1-b)/6}function Bh(a,b){this._context=a;this._k=(1-b)/6}function Ch(a,b){this._context=a;this._k=(1-b)/6}function Dh(a,b,c){var d=a._x1,e=a._y1,g=a._x2,k=a._y2;if(1E-12<a._l01_a){var m=2*a._l01_2a+3*a._l01_a*a._l12_a+a._l12_2a,
p=3*a._l01_a*(a._l01_a+a._l12_a);d=(d*m-a._x0*a._l12_2a+a._x2*a._l01_2a)/p;e=(e*m-a._y0*a._l12_2a+a._y2*a._l01_2a)/p}1E-12<a._l23_a&&(m=2*a._l23_2a+3*a._l23_a*a._l12_a+a._l12_2a,p=3*a._l23_a*(a._l23_a+a._l12_a),g=(g*m+a._x1*a._l23_2a-b*a._l12_2a)/p,k=(k*m+a._y1*a._l23_2a-c*a._l12_2a)/p);a._context.bezierCurveTo(d,e,g,k,a._x2,a._y2)}function Ml(a,b){this._context=a;this._alpha=b}function Nl(a,b){this._context=a;this._alpha=b}function Ol(a,b){this._context=a;this._alpha=b}function Pl(a){this._context=
a}function Ql(a,b,c){var d=a._x1-a._x0;b-=a._x1;var e=(a._y1-a._y0)/(d||0>b&&-0);a=(c-a._y1)/(b||0>d&&-0);return((0>e?-1:1)+(0>a?-1:1))*Math.min(Math.abs(e),Math.abs(a),.5*Math.abs((e*b+a*d)/(d+b)))||0}function Rl(a,b){var c=a._x1-a._x0;return c?(3*(a._y1-a._y0)/c-b)/2:b}function Eh(a,b,c){var d=a._x0,e=a._x1,g=a._y1,k=(e-d)/3;a._context.bezierCurveTo(d+k,a._y0+k*b,e-k,g-k*c,e,g)}function jf(a){this._context=a}function Sl(a){this._context=new Tl(a)}function Tl(a){this._context=a}function Ul(a){this._context=
a}function Vl(a){var b,c=a.length-1,d=Array(c),e=Array(c),g=Array(c);d[0]=0;e[0]=2;g[0]=a[0]+2*a[1];for(b=1;b<c-1;++b)d[b]=1,e[b]=4,g[b]=4*a[b]+2*a[b+1];d[c-1]=2;e[c-1]=7;g[c-1]=8*a[c-1]+a[c];for(b=1;b<c;++b){var k=d[b]/e[b-1];e[b]-=k;g[b]-=k*g[b-1]}d[c-1]=g[c-1]/e[c-1];for(b=c-2;0<=b;--b)d[b]=(g[b]-d[b+1])/e[b];e[c-1]=(a[c]+d[c-1])/2;for(b=0;b<c-1;++b)e[b]=2*a[b+1]-d[b+1];return[d,e]}function kf(a,b){this._context=a;this._t=b}function Ec(a,b){if(1<(k=a.length))for(var c=1,d,e,g=a[b[0]],k,m=g.length;c<
k;++c)for(e=g,g=a[b[c]],d=0;d<m;++d)g[d][1]+=g[d][0]=isNaN(e[d][1])?e[d][0]:e[d][1]}function Fc(a){a=a.length;for(var b=Array(a);0<=--a;)b[a]=a;return b}function Cs(a,b){return a[b]}function Wl(a){var b=a.map(Xl);return Fc(a).sort(function(c,d){return b[c]-b[d]})}function Xl(a){for(var b=0,c=-1,d=a.length,e;++c<d;)if(e=+a[c][1])b+=e;return b}function Yl(a){return function(){return a}}function Ds(a){return a[0]}function Es(a){return a[1]}function lf(){this._=null}function mf(a){a.U=a.C=a.L=a.R=a.P=
a.N=null}function Ed(a,b){var c=b.R,d=b.U;d?d.L===b?d.L=c:d.R=c:a._=c;c.U=d;b.U=c;b.R=c.L;b.R&&(b.R.U=b);c.L=b}function Fd(a,b){var c=b.L,d=b.U;d?d.L===b?d.L=c:d.R=c:a._=c;c.U=d;b.U=c;b.L=c.R;b.L&&(b.L.U=b);c.R=b}function Zl(a){for(;a.L;)a=a.L;return a}function Gd(a,b,c,d){var e=[null,null],g=Ha.push(e)-1;e.left=a;e.right=b;c&&nf(e,a,b,c);d&&nf(e,b,a,d);Ya[a.index].halfedges.push(g);Ya[b.index].halfedges.push(g);return e}function Hd(a,b,c){b=[b,c];b.left=a;return b}function nf(a,b,c,d){a[0]||a[1]?
a.left===c?a[1]=d:a[0]=d:(a[0]=d,a.left=b,a.right=c)}function Fs(a,b,c,d,e){var g=a[0],k=a[1],m=g[0];g=g[1];var p=0,v=1,h=k[0]-m;k=k[1]-g;b-=m;if(h||!(0<b)){b/=h;if(0>h){if(b<p)return;b<v&&(v=b)}else if(0<h){if(b>v)return;b>p&&(p=b)}b=d-m;if(h||!(0>b)){b/=h;if(0>h){if(b>v)return;b>p&&(p=b)}else if(0<h){if(b<p)return;b<v&&(v=b)}b=c-g;if(k||!(0<b)){b/=k;if(0>k){if(b<p)return;b<v&&(v=b)}else if(0<k){if(b>v)return;b>p&&(p=b)}b=e-g;if(k||!(0>b)){b/=k;if(0>k){if(b>v)return;b>p&&(p=b)}else if(0<k){if(b<
p)return;b<v&&(v=b)}if(!(0<p||1>v))return!0;0<p&&(a[0]=[m+p*h,g+p*k]);1>v&&(a[1]=[m+v*h,g+v*k]);return!0}}}}}function Gs(a,b,c,d,e){var g=a[1];if(g)return!0;var k=a[0],m=a.left,p=a.right;g=m[0];m=m[1];var v=p[0];p=p[1];var h=(g+v)/2;if(p===m){if(h<b||h>=d)return;if(g>v){if(!k)k=[h,c];else if(k[1]>=e)return;g=[h,e]}else{if(!k)k=[h,e];else if(k[1]<c)return;g=[h,c]}}else{var l=(g-v)/(p-m);h=(m+p)/2-l*h;if(-1>l||1<l)if(g>v){if(!k)k=[(c-h)/l,c];else if(k[1]>=e)return;g=[(e-h)/l,e]}else{if(!k)k=[(e-h)/
l,e];else if(k[1]<c)return;g=[(c-h)/l,c]}else if(m<p){if(!k)k=[b,l*b+h];else if(k[0]>=d)return;g=[d,l*d+h]}else{if(!k)k=[d,l*d+h];else if(k[0]<b)return;g=[b,l*b+h]}}a[0]=k;a[1]=g;return!0}function Hs(a,b){a=a.site;var c=b.left,d=b.right;a===d&&(d=c,c=a);if(d)return Math.atan2(d[1]-c[1],d[0]-c[0]);a===c?(c=b[1],d=b[0]):(c=b[0],d=b[1]);return Math.atan2(c[0]-d[0],d[1]-c[1])}function $l(a,b){return b[+(b.left!==a.site)]}function Is(){for(var a=0,b=Ya.length,c,d,e,g;a<b;++a)if((c=Ya[a])&&(g=(d=c.halfedges).length)){var k=
Array(g),m=Array(g);for(e=0;e<g;++e)k[e]=e,m[e]=Hs(c,Ha[d[e]]);k.sort(function(p,v){return m[v]-m[p]});for(e=0;e<g;++e)m[e]=d[k[e]];for(e=0;e<g;++e)d[e]=m[e]}}function Js(){mf(this);this.x=this.y=this.arc=this.site=this.cy=null}function Gc(a){var b=a.P,c=a.N;if(b&&c){var d=b.site;b=a.site;var e=c.site;if(d!==e){c=b[0];var g=b[1],k=d[0]-c,m=d[1]-g;d=e[0]-c;var p=e[1]-g;e=2*(k*p-m*d);if(!(e>=-Ks)){var v=k*k+m*m,h=d*d+p*p;m=(p*v-m*h)/e;d=(k*h-d*v)/e;k=am.pop()||new Js;k.arc=a;k.site=b;k.x=m+c;k.y=(k.cy=
d+g)+Math.sqrt(m*m+d*d);a.circle=k;a=null;for(b=Id._;b;)if(k.y<b.y||k.y===b.y&&k.x<=b.x)if(b.L)b=b.L;else{a=b.P;break}else if(b.R)b=b.R;else{a=b;break}Id.insert(a,k);a||(Fh=k)}}}}function Hc(a){var b=a.circle;b&&(b.P||(Fh=b.N),Id.remove(b),am.push(b),mf(b),a.circle=null)}function Ls(){mf(this);this.edge=this.site=this.circle=null}function bm(a){var b=cm.pop()||new Ls;b.site=a;return b}function Gh(a){Hc(a);Ic.remove(a);cm.push(a);mf(a)}function dm(a,b){var c=a.site,d=c[0],e=c[1],g=e-b;if(!g)return d;
a=a.P;if(!a)return-Infinity;c=a.site;a=c[0];c=c[1];b=c-b;if(!b)return a;var k=a-d,m=1/g-1/b,p=k/b;return m?(-p+Math.sqrt(p*p-2*m*(k*k/(-2*b)-c+b/2+e-g/2)))/m+d:(d+a)/2}function Ms(a,b){return b[1]-a[1]||b[0]-a[0]}function Hh(a,b){var c=a.sort(Ms).pop(),d;Ha=[];Ya=Array(a.length);Ic=new lf;for(Id=new lf;;){var e=Fh;if(c&&(!e||c[1]<e.y||c[1]===e.y&&c[0]<e.x)){if(c[0]!==d||c[1]!==g){var g=d=void 0;e=c;for(var k=e[0],m=e[1],p=Ic._;p;){var v=dm(p,m)-k;if(v>ta)p=p.L;else{var h=p;var l=m;var q=h.N;q?l=dm(q,
l):(h=h.site,l=h[1]===l?h[0]:Infinity);l=k-l;if(l>ta){if(!p.R){g=p;break}p=p.R}else{v>-ta?(g=p.P,d=p):l>-ta?(g=p,d=p.N):g=d=p;break}}}Ya[e.index]={site:e,halfedges:[]};v=bm(e);Ic.insert(g,v);if(g||d)if(g===d)Hc(g),d=bm(g.site),Ic.insert(v,d),v.edge=d.edge=Gd(g.site,v.site),Gc(g),Gc(d);else if(d){Hc(g);Hc(d);k=g.site;p=k[0];l=k[1];h=e[0]-p;q=e[1]-l;m=d.site;var w=m[0]-p,B=m[1]-l,F=2*(h*B-q*w),J=h*h+q*q,P=w*w+B*B;p=[(B*J-q*P)/F+p,(h*P-w*J)/F+l];nf(d.edge,k,m,p);v.edge=Gd(k,e,null,p);d.edge=Gd(e,m,null,
p);Gc(g);Gc(d)}else v.edge=Gd(g.site,v.site);d=c[0];g=c[1]}c=a.pop()}else if(e){m=e.arc;e=m.circle;k=e.x;p=e.cy;e=[k,p];h=m.P;l=m.N;v=[m];Gh(m);for(m=h;m.circle&&Math.abs(k-m.circle.x)<ta&&Math.abs(p-m.circle.cy)<ta;)h=m.P,v.unshift(m),Gh(m),m=h;v.unshift(m);Hc(m);for(h=l;h.circle&&Math.abs(k-h.circle.x)<ta&&Math.abs(p-h.circle.cy)<ta;)l=h.N,v.push(h),Gh(h),h=l;v.push(h);Hc(h);p=v.length;for(k=1;k<p;++k)h=v[k],m=v[k-1],nf(h.edge,m.site,h.site,e);m=v[0];h=v[p-1];h.edge=Gd(m.site,h.site,null,e);Gc(m);
Gc(h)}else break}Is();if(b){d=+b[0][0];a=+b[0][1];c=+b[1][0];b=+b[1][1];g=Ha.length;for(var x;g--;)Gs(x=Ha[g],d,a,c,b)&&Fs(x,d,a,c,b)&&(Math.abs(x[0][0]-x[1][0])>ta||Math.abs(x[0][1]-x[1][1])>ta)||delete Ha[g];x=Ya.length;g=!0;for(e=0;e<x;++e)if(v=Ya[e]){var y=v.site;m=v.halfedges;for(k=m.length;k--;)Ha[m[k]]||m.splice(k,1);k=0;for(p=m.length;k<p;)if(l=Ha[m[k]],h=l[+(l.left===v.site)],q=h[0],w=h[1],B=$l(v,Ha[m[++k%p]]),l=B[0],B=B[1],Math.abs(q-l)>ta||Math.abs(w-B)>ta)m.splice(k,0,Ha.push(Hd(y,h,Math.abs(q-
d)<ta&&b-w>ta?[d,Math.abs(l-d)<ta?B:b]:Math.abs(w-b)<ta&&c-q>ta?[Math.abs(B-b)<ta?l:c,b]:Math.abs(q-c)<ta&&w-a>ta?[c,Math.abs(l-c)<ta?B:a]:Math.abs(w-a)<ta&&q-d>ta?[Math.abs(B-a)<ta?l:d,a]:null))-1),++p;p&&(g=!1)}if(g){k=Infinity;e=0;for(g=null;e<x;++e)if(v=Ya[e])y=v.site,m=y[0]-d,p=y[1]-a,m=m*m+p*p,m<k&&(k=m,g=v);g&&(e=[d,a],d=[d,b],b=[c,b],a=[c,a],g.halfedges.push(Ha.push(Hd(y=g.site,e,d))-1,Ha.push(Hd(y,d,b))-1,Ha.push(Hd(y,b,a))-1,Ha.push(Hd(y,a,e))-1))}for(e=0;e<x;++e)if(v=Ya[e])v.halfedges.length||
delete Ya[e]}this.edges=Ha;this.cells=Ya;Ic=Id=Ha=Ya=null}function of(a){return function(){return a}}function Ns(a,b,c){this.target=a;this.type=b;this.transform=c}function yb(a,b,c){this.k=a;this.x=b;this.y=c}function em(a){return a.__zoom||pf}function Jd(){d3.event.preventDefault();d3.event.stopImmediatePropagation()}function Os(){return!d3.event.button}function Ps(){var a=this;if(a instanceof SVGElement){a=a.ownerSVGElement||a;var b=a.width.baseVal.value;a=a.height.baseVal.value}else b=a.clientWidth,
a=a.clientHeight;return[[0,0],[b,a]]}function fm(){return this.__zoom||pf}function Qs(){return-d3.event.deltaY*(d3.event.deltaMode?120:1)/500}function Rs(){return"ontouchstart"in this}function Ss(a,b,c){var d=a.invertX(b[0][0])-c[0][0],e=a.invertX(b[1][0])-c[1][0],g=a.invertY(b[0][1])-c[0][1];b=a.invertY(b[1][1])-c[1][1];return a.translate(e>d?(d+e)/2:Math.min(0,d)||Math.max(0,e),b>g?(g+b)/2:Math.min(0,g)||Math.max(0,b))}var gm=Bf(Mb),$b=gm.right,Ts=gm.left,hm=Array.prototype,Us=hm.slice,Vs=hm.map,
Ef=Math.sqrt(50),Ff=Math.sqrt(10),Gf=Math.sqrt(2),Jf=Array.prototype.slice,Ln={value:function(){}};Qd.prototype=Ob.prototype={constructor:Qd,on:function(a,b){var c=this._,d=Kn(a+"",c),e,g=-1,k=d.length;if(2>arguments.length)for(;++g<k;){var m;if(m=e=(a=d[g]).type){a:{m=c[e];for(var p=0,v=m.length;p<v;++p)if((e=m[p]).name===a.name){e=e.value;break a}e=void 0}m=e}if(m)return e}else{if(null!=b&&"function"!==typeof b)throw Error("invalid callback: "+b);for(;++g<k;)if(e=(a=d[g]).type)c[e]=ki(c[e],a.name,
b);else if(null==b)for(e in c)c[e]=ki(c[e],a.name,null);return this}},copy:function(){var a={},b=this._,c;for(c in b)a[c]=b[c].slice();return new Qd(a)},call:function(a,b){if(0<(e=arguments.length-2))for(var c=Array(e),d=0,e,g;d<e;++d)c[d]=arguments[d+2];if(!this._.hasOwnProperty(a))throw Error("unknown type: "+a);g=this._[a];d=0;for(e=g.length;d<e;++d)g[d].value.apply(b,c)},apply:function(a,b,c){if(!this._.hasOwnProperty(a))throw Error("unknown type: "+a);a=this._[a];for(var d=0,e=a.length;d<e;++d)a[d].value.apply(b,
c)}};var Ua={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};if("undefined"!==typeof document){var Kd=document.documentElement;if(!Kd.matches){var Ws=Kd.webkitMatchesSelector||Kd.msMatchesSelector||Kd.mozMatchesSelector||Kd.oMatchesSelector;di=function(a){return function(){return Ws.call(this,a)}}}}var Ih=di;Td.prototype={constructor:Td,appendChild:function(a){return this._parent.insertBefore(a,
this._next)},insertBefore:function(a,b){return this._parent.insertBefore(a,b)},querySelector:function(a){return this._parent.querySelector(a)},querySelectorAll:function(a){return this._parent.querySelectorAll(a)}};mi.prototype={add:function(a){0>this._names.indexOf(a)&&(this._names.push(a),this._node.setAttribute("class",this._names.join(" ")))},remove:function(a){a=this._names.indexOf(a);0<=a&&(this._names.splice(a,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(a){return 0<=
this._names.indexOf(a)}};var qi={};d3.event=null;"undefined"!==typeof document&&("onmouseenter"in document.documentElement||(qi={mouseenter:"mouseover",mouseleave:"mouseout"}));var Nf=[null];Ja.prototype=Qb.prototype={constructor:Ja,select:function(a){"function"!==typeof a&&(a=Sd(a));for(var b=this._groups,c=b.length,d=Array(c),e=0;e<c;++e)for(var g=b[e],k=g.length,m=d[e]=Array(k),p,v,h=0;h<k;++h)(p=g[h])&&(v=a.call(p,p.__data__,h,g))&&("__data__"in p&&(v.__data__=p.__data__),m[h]=v);return new Ja(d,
this._parents)},selectAll:function(a){"function"!==typeof a&&(a=Kf(a));for(var b=this._groups,c=b.length,d=[],e=[],g=0;g<c;++g)for(var k=b[g],m=k.length,p,v=0;v<m;++v)if(p=k[v])d.push(a.call(p,p.__data__,v,k)),e.push(p);return new Ja(d,e)},filter:function(a){"function"!==typeof a&&(a=Ih(a));for(var b=this._groups,c=b.length,d=Array(c),e=0;e<c;++e)for(var g=b[e],k=g.length,m=d[e]=[],p,v=0;v<k;++v)(p=g[v])&&a.call(p,p.__data__,v,g)&&m.push(p);return new Ja(d,this._parents)},data:function(a,b){if(!a)return w=
Array(this.size()),v=-1,this.each(function(x){w[++v]=x}),w;var c=b?Sn:Rn,d=this._parents,e=this._groups;"function"!==typeof a&&(a=Qn(a));for(var g=e.length,k=Array(g),m=Array(g),p=Array(g),v=0;v<g;++v){var h=d[v],l=e[v],q=l.length,w=a.call(h,h&&h.__data__,v,d),B=w.length,F=m[v]=Array(B),J=k[v]=Array(B);q=p[v]=Array(q);c(h,l,F,J,q,w,b);l=h=0;for(var P;h<B;++h)if(q=F[h]){for(h>=l&&(l=h+1);!(P=J[l])&&++l<B;);q._next=P||null}}k=new Ja(k,d);k._enter=m;k._exit=p;return k},enter:function(){return new Ja(this._enter||
this._groups.map(li),this._parents)},exit:function(){return new Ja(this._exit||this._groups.map(li),this._parents)},merge:function(a){var b=this._groups;a=a._groups;for(var c=b.length,d=Math.min(c,a.length),e=Array(c),g=0;g<d;++g)for(var k=b[g],m=a[g],p=k.length,v=e[g]=Array(p),h,l=0;l<p;++l)if(h=k[l]||m[l])v[l]=h;for(;g<c;++g)e[g]=b[g];return new Ja(e,this._parents)},order:function(){for(var a=this._groups,b=-1,c=a.length;++b<c;)for(var d=a[b],e=d.length-1,g=d[e],k;0<=--e;)if(k=d[e])g&&g!==k.nextSibling&&
g.parentNode.insertBefore(k,g),g=k;return this},sort:function(a){function b(l,q){return l&&q?a(l.__data__,q.__data__):!l-!q}a||(a=Tn);for(var c=this._groups,d=c.length,e=Array(d),g=0;g<d;++g){for(var k=c[g],m=k.length,p=e[g]=Array(m),v,h=0;h<m;++h)if(v=k[h])p[h]=v;p.sort(b)}return(new Ja(e,this._parents)).order()},call:function(){var a=arguments[0];arguments[0]=this;a.apply(null,arguments);return this},nodes:function(){var a=Array(this.size()),b=-1;this.each(function(){a[++b]=this});return a},node:function(){for(var a=
this._groups,b=0,c=a.length;b<c;++b)for(var d=a[b],e=0,g=d.length;e<g;++e){var k=d[e];if(k)return k}return null},size:function(){var a=0;this.each(function(){++a});return a},empty:function(){return!this.node()},each:function(a){for(var b=this._groups,c=0,d=b.length;c<d;++c)for(var e=b[c],g=0,k=e.length,m;g<k;++g)(m=e[g])&&a.call(m,m.__data__,g,e);return this},attr:function(a,b){var c=Pc(a);if(2>arguments.length){var d=this.node();return c.local?d.getAttributeNS(c.space,c.local):d.getAttribute(c)}return this.each((null==
b?c.local?Vn:Un:"function"===typeof b?c.local?Zn:Yn:c.local?Xn:Wn)(c,b))},style:function(a,b,c){return 1<arguments.length?this.each((null==b?$n:"function"===typeof b?bo:ao)(a,b,null==c?"":c)):Pb(this.node(),a)},property:function(a,b){return 1<arguments.length?this.each((null==b?co:"function"===typeof b?fo:eo)(a,b)):this.node()[a]},classed:function(a,b){var c=(a+"").trim().split(/^|\s+/);if(2>arguments.length){for(var d=Mf(this.node()),e=-1,g=c.length;++e<g;)if(!d.contains(c[e]))return!1;return!0}return this.each(("function"===
typeof b?io:b?go:ho)(c,b))},text:function(a){return arguments.length?this.each(null==a?jo:("function"===typeof a?lo:ko)(a)):this.node().textContent},html:function(a){return arguments.length?this.each(null==a?mo:("function"===typeof a?oo:no)(a)):this.node().innerHTML},raise:function(){return this.each(po)},lower:function(){return this.each(qo)},append:function(a){var b="function"===typeof a?a:Rd(a);return this.select(function(){return this.appendChild(b.apply(this,arguments))})},insert:function(a,
b){var c="function"===typeof a?a:Rd(a),d=null==b?ro:"function"===typeof b?b:Sd(b);return this.select(function(){return this.insertBefore(c.apply(this,arguments),d.apply(this,arguments)||null)})},remove:function(){return this.each(so)},clone:function(a){return this.select(a?uo:to)},datum:function(a){return arguments.length?this.property("__data__",a):this.node().__data__},on:function(a,b,c){var d=wo(a+""),e=d.length,g;if(2>arguments.length){var k=this.node().__on;if(k)for(var m=0,p=k.length,v;m<p;++m){var h=
0;for(v=k[m];h<e;++h)if((g=d[h]).type===v.type&&g.name===v.name)return v.value}}else{k=b?yo:xo;null==c&&(c=!1);for(h=0;h<e;++h)this.each(k(d[h],b,c));return this}},dispatch:function(a,b){return this.each(("function"===typeof b?Ao:zo)(a,b))}};var Bo=0;Of.prototype=si.prototype={constructor:Of,get:function(a){for(var b=this._;!(b in a);)if(!(a=a.parentNode))return;return a[b]},set:function(a,b){return a[this._]=b},remove:function(a){return this._ in a&&delete a[this._]},toString:function(){return this._}};
Qf.prototype.on=function(){var a=this._.on.apply(this._,arguments);return a===this._?this:a};var Jc=1/.7,Go=/^#([0-9a-f]{3})$/,Ho=/^#([0-9a-f]{6})$/,Io=RegExp("^rgb\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*\\)$"),Jo=RegExp("^rgb\\(\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"),Ko=RegExp("^rgba\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"),
Lo=RegExp("^rgba\\(\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"),Mo=RegExp("^hsl\\(\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"),No=RegExp("^hsla\\(\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"),
wi={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,
darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,
hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,
linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,
palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,
turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};gc(Cb,Db,{displayable:function(){return this.rgb().displayable()},hex:function(){return this.rgb().hex()},toString:function(){return this.rgb()+""}});gc(Fa,hc,Rc(Cb,{brighter:function(a){a=null==a?Jc:Math.pow(Jc,a);return new Fa(this.r*a,this.g*a,this.b*a,this.opacity)},darker:function(a){a=null==a?.7:Math.pow(.7,a);return new Fa(this.r*a,this.g*a,this.b*a,this.opacity)},rgb:function(){return this},
displayable:function(){return 0<=this.r&&255>=this.r&&0<=this.g&&255>=this.g&&0<=this.b&&255>=this.b&&0<=this.opacity&&1>=this.opacity},hex:function(){return"#"+Sf(this.r)+Sf(this.g)+Sf(this.b)},toString:function(){var a=this.opacity;a=isNaN(a)?1:Math.max(0,Math.min(1,a));return(1===a?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===a?")":", "+a+")")}}));gc(ib,Zd,Rc(Cb,{brighter:function(a){a=
null==a?Jc:Math.pow(Jc,a);return new ib(this.h,this.s,this.l*a,this.opacity)},darker:function(a){a=null==a?.7:Math.pow(.7,a);return new ib(this.h,this.s,this.l*a,this.opacity)},rgb:function(){var a=this.h%360+360*(0>this.h),b=isNaN(a)||isNaN(this.s)?0:this.s,c=this.l;b=c+(.5>c?c:1-c)*b;c=2*c-b;return new Fa(Tf(240<=a?a-240:a+120,c,b),Tf(a,c,b),Tf(120>a?a+240:a-120,c,b),this.opacity)},displayable:function(){return(0<=this.s&&1>=this.s||isNaN(this.s))&&0<=this.l&&1>=this.l&&0<=this.opacity&&1>=this.opacity}}));
var xi=Math.PI/180,Bi=180/Math.PI,zi=4/29,ic=6/29,yi=3*ic*ic,Po=ic*ic*ic;gc(cb,$d,Rc(Cb,{brighter:function(a){return new cb(this.l+18*(null==a?1:a),this.a,this.b,this.opacity)},darker:function(a){return new cb(this.l-18*(null==a?1:a),this.a,this.b,this.opacity)},rgb:function(){var a=(this.l+16)/116,b=isNaN(this.a)?a:a+this.a/500,c=isNaN(this.b)?a:a-this.b/200;b=.96422*Xf(b);a=1*Xf(a);c=.82521*Xf(c);return new Fa(Yf(3.1338561*b-1.6168667*a-.4906146*c),Yf(-.9787684*b+1.9161415*a+.033454*c),Yf(.0719453*
b-.2289914*a+1.4052427*c),this.opacity)}}));gc(jb,ae,Rc(Cb,{brighter:function(a){return new jb(this.h,this.c,this.l+18*(null==a?1:a),this.opacity)},darker:function(a){return new jb(this.h,this.c,this.l-18*(null==a?1:a),this.opacity)},rgb:function(){return Uf(this).rgb()}}));var Ci=1.78277*-.29227-.1347134789;gc(Rb,db,Rc(Cb,{brighter:function(a){a=null==a?Jc:Math.pow(Jc,a);return new Rb(this.h,this.s,this.l*a,this.opacity)},darker:function(a){a=null==a?.7:Math.pow(.7,a);return new Rb(this.h,this.s,
this.l*a,this.opacity)},rgb:function(){var a=isNaN(this.h)?0:(this.h+120)*xi,b=+this.l,c=isNaN(this.s)?0:this.s*b*(1-b),d=Math.cos(a);a=Math.sin(a);return new Fa(255*(b+c*(-.14861*d+1.78277*a)),255*(b+c*(-.29227*d+-.90649*a)),255*(b+1.97294*c*d),this.opacity)}}));var Tc=function c(b){function d(g,k){var m=e((g=hc(g)).r,(k=hc(k)).r),p=e(g.g,k.g),v=e(g.b,k.b),h=Ea(g.opacity,k.opacity);return function(l){g.r=m(l);g.g=p(l);g.b=v(l);g.opacity=h(l);return g+""}}var e=Ro(b);d.gamma=c;return d}(1),Bl=Hi(Ei),
Xs=Hi(Fi),$f=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,ag=new RegExp($f.source,"g"),Ni=180/Math.PI,Jh={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1},Ld,Kh,im,qf,jm=Oi(function(b){if("none"===b)return Jh;Ld||(Ld=document.createElement("DIV"),Kh=document.documentElement,im=document.defaultView);Ld.style.transform=b;b=im.getComputedStyle(Kh.appendChild(Ld),null).getPropertyValue("transform");Kh.removeChild(Ld);b=b.slice(7,-1).split(",");return Mi(+b[0],+b[1],+b[2],+b[3],+b[4],+b[5])},
"px, ","px)","deg)"),km=Oi(function(b){if(null==b)return Jh;qf||(qf=document.createElementNS("http://www.w3.org/2000/svg","g"));qf.setAttribute("transform",b);if(!(b=qf.transform.baseVal.consolidate()))return Jh;b=b.matrix;return Mi(b.a,b.b,b.c,b.d,b.e,b.f)},", ",")",")"),Uc=Math.SQRT2,Ys=Ri(ce),Zs=Ri(Ea),$s=Si(ce),at=Si(Ea),bt=Ti(ce),rf=Ti(Ea),kc=0,Xc=0,Zc=0,fe,Yc,ge=0,Sb=0,de=0,Vc="object"===typeof performance&&performance.now?performance:Date,Ui="object"===typeof window&&window.requestAnimationFrame?
window.requestAnimationFrame.bind(window):function(b){setTimeout(b,17)};Wc.prototype=ee.prototype={constructor:Wc,restart:function(b,c,d){if("function"!==typeof b)throw new TypeError("callback is not a function");d=(null==d?jc():+d)+(null==c?0:+c);this._next||Yc===this||(Yc?Yc._next=this:fe=this,Yc=this);this._call=b;this._time=d;bg()},stop:function(){this._call&&(this._call=null,this._time=Infinity,bg())}};var Xo=Ob("start","end","interrupt"),Yo=[],ct=Qb.prototype.constructor,lm=0,Kc=Qb.prototype;
kb.prototype=Yi.prototype={constructor:kb,select:function(b){var c=this._name,d=this._id;"function"!==typeof b&&(b=Sd(b));for(var e=this._groups,g=e.length,k=Array(g),m=0;m<g;++m)for(var p=e[m],v=p.length,h=k[m]=Array(v),l,q,w=0;w<v;++w)(l=p[w])&&(q=b.call(l,l.__data__,w,p))&&("__data__"in l&&(q.__data__=l.__data__),h[w]=q,he(h[w],c,d,w,h,eb(l,d)));return new kb(k,this._parents,c,d)},selectAll:function(b){var c=this._name,d=this._id;"function"!==typeof b&&(b=Kf(b));for(var e=this._groups,g=e.length,
k=[],m=[],p=0;p<g;++p)for(var v=e[p],h=v.length,l,q=0;q<h;++q)if(l=v[q]){for(var w=b.call(l,l.__data__,q,v),B,F=eb(l,d),J=0,P=w.length;J<P;++J)(B=w[J])&&he(B,c,d,J,w,F);k.push(w);m.push(l)}return new kb(k,m,c,d)},filter:function(b){"function"!==typeof b&&(b=Ih(b));for(var c=this._groups,d=c.length,e=Array(d),g=0;g<d;++g)for(var k=c[g],m=k.length,p=e[g]=[],v,h=0;h<m;++h)(v=k[h])&&b.call(v,v.__data__,h,k)&&p.push(v);return new kb(e,this._parents,this._name,this._id)},merge:function(b){if(b._id!==this._id)throw Error();
var c=this._groups;b=b._groups;for(var d=c.length,e=Math.min(d,b.length),g=Array(d),k=0;k<e;++k)for(var m=c[k],p=b[k],v=m.length,h=g[k]=Array(v),l,q=0;q<v;++q)if(l=m[q]||p[q])h[q]=l;for(;k<d;++k)g[k]=c[k];return new kb(g,this._parents,this._name,this._id)},selection:function(){return new ct(this._groups,this._parents)},transition:function(){for(var b=this._name,c=this._id,d=++lm,e=this._groups,g=e.length,k=0;k<g;++k)for(var m=e[k],p=m.length,v,h=0;h<p;++h)if(v=m[h]){var l=eb(v,c);he(v,b,d,h,m,{time:l.time+
l.delay+l.duration,delay:0,duration:l.duration,ease:l.ease})}return new kb(e,this._parents,b,d)},call:Kc.call,nodes:Kc.nodes,node:Kc.node,size:Kc.size,empty:Kc.empty,each:Kc.each,on:function(b,c){var d=this._id;return 2>arguments.length?eb(this.node(),d).on.on(b):this.each(op(d,b,c))},attr:function(b,c){var d=Pc(b),e="transform"===d?km:Xi;return this.attrTween(b,"function"===typeof c?(d.local?fp:ep)(d,e,eg(this,"attr."+b,c)):null==c?(d.local?bp:ap)(d):(d.local?dp:cp)(d,e,c+""))},attrTween:function(b,
c){var d="attr."+b;if(2>arguments.length)return(d=this.tween(d))&&d._value;if(null==c)return this.tween(d,null);if("function"!==typeof c)throw Error();var e=Pc(b);return this.tween(d,(e.local?gp:hp)(e,c))},style:function(b,c,d){var e="transform"===(b+="")?jm:Xi;return null==c?this.styleTween(b,qp(b,e)).on("end.style."+b,rp(b)):this.styleTween(b,"function"===typeof c?tp(b,e,eg(this,"style."+b,c)):sp(b,e,c+""),d)},styleTween:function(b,c,d){var e="style."+(b+="");if(2>arguments.length)return(e=this.tween(e))&&
e._value;if(null==c)return this.tween(e,null);if("function"!==typeof c)throw Error();return this.tween(e,up(b,c,null==d?"":d))},text:function(b){return this.tween("text","function"===typeof b?wp(eg(this,"text",b)):vp(null==b?"":b+""))},remove:function(){return this.on("end.remove",pp(this._id))},tween:function(b,c){var d=this._id;b+="";if(2>arguments.length){d=eb(this.node(),d).tween;for(var e=0,g=d.length,k;e<g;++e)if((k=d[e]).name===b)return k.value;return null}return this.each((null==c?Zo:$o)(d,
b,c))},delay:function(b){var c=this._id;return arguments.length?this.each(("function"===typeof b?ip:jp)(c,b)):eb(this.node(),c).delay},duration:function(b){var c=this._id;return arguments.length?this.each(("function"===typeof b?kp:lp)(c,b)):eb(this.node(),c).duration},ease:function(b){var c=this._id;return arguments.length?this.each(mp(c,b)):eb(this.node(),c).ease}};var dt=function d(c){function e(g){return Math.pow(g,c)}c=+c;e.exponent=d;return e}(3),et=function e(d){function g(k){return 1-Math.pow(1-
k,d)}d=+d;g.exponent=e;return g}(3),mm=function g(e){function k(m){return(1>=(m*=2)?Math.pow(m,e):2-Math.pow(2-m,e))/2}e=+e;k.exponent=g;return k}(3),aj=Math.PI,nm=aj/2,gg=4/11,yp=6/11,xp=8/11,Ap=9/11,zp=10/11,Bp=21/22,ie=1/gg/gg,ft=function k(g){function m(p){return p*p*((g+1)*p-g)}g=+g;m.overshoot=k;return m}(1.70158),gt=function m(k){function p(v){return--v*v*((k+1)*v+k)+1}k=+k;p.overshoot=m;return p}(1.70158),om=function p(m){function v(h){return(1>(h*=2)?h*h*((m+1)*h-m):(h-=2)*h*((m+1)*h+m)+
2)/2}m=+m;v.overshoot=p;return v}(1.70158),Lc=2*Math.PI,ht=function h(p,v){function l(w){return p*Math.pow(2,10*--w)*Math.sin((q-w)/v)}var q=Math.asin(1/(p=Math.max(1,p)))*(v/=Lc);l.amplitude=function(w){return h(w,v*Lc)};l.period=function(w){return h(p,w)};return l}(1,.3),pm=function l(v,h){function q(B){return 1-v*Math.pow(2,-10*(B=+B))*Math.sin((B+w)/h)}var w=Math.asin(1/(v=Math.max(1,v)))*(h/=Lc);q.amplitude=function(B){return l(B,h*Lc)};q.period=function(B){return l(v,B)};return q}(1,.3),it=
function q(h,l){function w(F){return(0>(F=2*F-1)?h*Math.pow(2,10*F)*Math.sin((B-F)/l):2-h*Math.pow(2,-10*F)*Math.sin((B+F)/l))/2}var B=Math.asin(1/(h=Math.max(1,h)))*(l/=Lc);w.amplitude=function(F){return q(F,l*Lc)};w.period=function(F){return q(h,F)};return w}(1,.3),Lh={time:null,delay:0,duration:250,ease:fg};Qb.prototype.interrupt=function(h){return this.each(function(){Ub(this,h)})};Qb.prototype.transition=function(h){var l;if(h instanceof kb){var q=h._id;h=h._name}else q=++lm,(l=Lh).time=jc(),
h=null==h?null:h+"";for(var w=this._groups,B=w.length,F=0;F<B;++F)for(var J=w[F],P=J.length,x,y=0;y<P;++y)if(x=J[y]){var I=x,Q=h,V=q,N=y,T=J,f;if(!(f=l))a:{f=void 0;for(var n=q;!(f=x.__transition)||!(f=f[n]);)if(!(x=x.parentNode)){f=(Lh.time=jc(),Lh);break a}}he(I,Q,V,N,T,f)}return new kb(w,this._parents,h,q)};var jt=[null],ej={name:"drag"},kg={name:"space"},lc={name:"handle"},mc={name:"center"},le={name:"x",handles:["e","w"].map(ad),input:function(h,l){return h&&[[h[0],l[0][1]],[h[1],l[1][1]]]},
output:function(h){return h&&[h[0][0],h[1][0]]}},ke={name:"y",handles:["n","s"].map(ad),input:function(h,l){return h&&[[l[0][0],h[0]],[l[1][0],h[1]]]},output:function(h){return h&&[h[0][1],h[1][1]]}},kt={name:"xy",handles:"n e s w nw ne se sw".split(" ").map(ad),input:function(h){return h},output:function(h){return h}},qb={overlay:"crosshair",selection:"move",n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},fj={e:"w",w:"e",
nw:"ne",ne:"nw",se:"sw",sw:"se"},gj={n:"s",s:"n",nw:"sw",ne:"se",se:"ne",sw:"nw"},Fp={overlay:1,selection:1,n:null,e:1,s:null,w:-1,nw:-1,ne:1,se:1,sw:-1},Gp={overlay:1,selection:1,n:-1,e:null,s:1,w:null,nw:-1,ne:-1,se:1,sw:1},qm=Math.cos,rm=Math.sin,sm=Math.PI,sf=sm/2,tm=2*sm,um=Math.max,lt=Array.prototype.slice,Mh=Math.PI,Nh=2*Mh,mt=Nh-1E-6;mg.prototype=Eb.prototype={constructor:mg,moveTo:function(h,l){this._+="M"+(this._x0=this._x1=+h)+","+(this._y0=this._y1=+l)},closePath:function(){null!==this._x1&&
(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(h,l){this._+="L"+(this._x1=+h)+","+(this._y1=+l)},quadraticCurveTo:function(h,l,q,w){this._+="Q"+ +h+","+ +l+","+(this._x1=+q)+","+(this._y1=+w)},bezierCurveTo:function(h,l,q,w,B,F){this._+="C"+ +h+","+ +l+","+ +q+","+ +w+","+(this._x1=+B)+","+(this._y1=+F)},arcTo:function(h,l,q,w,B){h=+h;l=+l;q=+q;w=+w;B=+B;var F=this._x1,J=this._y1,P=q-h,x=w-l,y=F-h,I=J-l,Q=y*y+I*I;if(0>B)throw Error("negative radius: "+B);if(null===this._x1)this._+=
"M"+(this._x1=h)+","+(this._y1=l);else if(1E-6<Q)if(1E-6<Math.abs(I*P-x*y)&&B){q-=F;w-=J;var V=P*P+x*x;J=Math.sqrt(V);F=Math.sqrt(Q);Q=B*Math.tan((Mh-Math.acos((V+Q-(q*q+w*w))/(2*J*F)))/2);F=Q/F;Q/=J;1E-6<Math.abs(F-1)&&(this._+="L"+(h+F*y)+","+(l+F*I));this._+="A"+B+","+B+",0,0,"+ +(I*q>y*w)+","+(this._x1=h+Q*P)+","+(this._y1=l+Q*x)}else this._+="L"+(this._x1=h)+","+(this._y1=l)},arc:function(h,l,q,w,B,F){h=+h;l=+l;q=+q;var J=q*Math.cos(w),P=q*Math.sin(w),x=h+J,y=l+P,I=1^F;w=F?w-B:B-w;if(0>q)throw Error("negative radius: "+
q);if(null===this._x1)this._+="M"+x+","+y;else if(1E-6<Math.abs(this._x1-x)||1E-6<Math.abs(this._y1-y))this._+="L"+x+","+y;q&&(0>w&&(w=w%Nh+Nh),w>mt?this._+="A"+q+","+q+",0,1,"+I+","+(h-J)+","+(l-P)+"A"+q+","+q+",0,1,"+I+","+(this._x1=x)+","+(this._y1=y):1E-6<w&&(this._+="A"+q+","+q+",0,"+ +(w>=Mh)+","+I+","+(this._x1=h+q*Math.cos(B))+","+(this._y1=l+q*Math.sin(B))))},rect:function(h,l,q,w){this._+="M"+(this._x0=this._x1=+h)+","+(this._y0=this._y1=+l)+"h"+ +q+"v"+ +w+"h"+-q+"Z"},toString:function(){return this._}};
me.prototype=rb.prototype={constructor:me,has:function(h){return" "+h in this},get:function(h){return this[" "+h]},set:function(h,l){this[" "+h]=l;return this},remove:function(h){h=" "+h;return h in this&&delete this[h]},clear:function(){for(var h in this)" "===h[0]&&delete this[h]},keys:function(){var h=[],l;for(l in this)" "===l[0]&&h.push(l.slice(1));return h},values:function(){var h=[],l;for(l in this)" "===l[0]&&h.push(this[l]);return h},entries:function(){var h=[],l;for(l in this)" "===l[0]&&
h.push({key:l.slice(1),value:this[l]});return h},size:function(){var h=0,l;for(l in this)" "===l[0]&&++h;return h},empty:function(){for(var h in this)if(" "===h[0])return!1;return!0},each:function(h){for(var l in this)" "===l[0]&&h(this[l],l.slice(1),this)}};var cc=rb.prototype;ne.prototype=jj.prototype={constructor:ne,has:cc.has,add:function(h){h+="";this[" "+h]=h;return this},remove:cc.remove,clear:cc.clear,values:cc.keys,size:cc.size,empty:cc.empty,each:cc.each};var lj=Array.prototype.slice,sb=
[[],[[[1,1.5],[.5,1]]],[[[1.5,1],[1,1.5]]],[[[1.5,1],[.5,1]]],[[[1,.5],[1.5,1]]],[[[1,1.5],[.5,1]],[[1,.5],[1.5,1]]],[[[1,.5],[1,1.5]]],[[[1,.5],[.5,1]]],[[[.5,1],[1,.5]]],[[[1,1.5],[1,.5]]],[[[.5,1],[1,.5]],[[1.5,1],[1,1.5]]],[[[1.5,1],[1,.5]]],[[[.5,1],[1.5,1]]],[[[1,1.5],[1.5,1]]],[[[.5,1],[1,1.5]]],[]],nj={},pg={},tf=oe(","),vm=tf.parse,nt=tf.parseRows,ot=tf.format,pt=tf.formatRows,uf=oe("\t"),wm=uf.parse,qt=uf.parseRows,rt=uf.format,st=uf.formatRows,tt=oj(vm),ut=oj(wm),Qa=pe.prototype=rg.prototype;
Qa.copy=function(){var h=new rg(this._x,this._y,this._x0,this._y0,this._x1,this._y1),l=this._root,q,w;if(!l)return h;if(!l.length)return h._root=qj(l),h;for(q=[{source:l,target:h._root=Array(4)}];l=q.pop();)for(var B=0;4>B;++B)if(w=l.source[B])w.length?q.push({source:w,target:l.target[B]=Array(4)}):l.target[B]=qj(w);return h};Qa.add=function(h){var l=+this._x.call(null,h),q=+this._y.call(null,h);return pj(this.cover(l,q),l,q,h)};Qa.addAll=function(h){var l,q,w=h.length,B,F,J=Array(w),P=Array(w),x=
Infinity,y=Infinity,I=-Infinity,Q=-Infinity;for(q=0;q<w;++q)isNaN(B=+this._x.call(null,l=h[q]))||isNaN(F=+this._y.call(null,l))||(J[q]=B,P[q]=F,B<x&&(x=B),B>I&&(I=B),F<y&&(y=F),F>Q&&(Q=F));I<x&&(x=this._x0,I=this._x1);Q<y&&(y=this._y0,Q=this._y1);this.cover(x,y).cover(I,Q);for(q=0;q<w;++q)pj(this,J[q],P[q],h[q]);return this};Qa.cover=function(h,l){if(isNaN(h=+h)||isNaN(l=+l))return this;var q=this._x0,w=this._y0,B=this._x1,F=this._y1;if(isNaN(q))B=(q=Math.floor(h))+1,F=(w=Math.floor(l))+1;else if(q>
h||h>B||w>l||l>F){var J=B-q,P=this._root,x;switch(x=(l<(w+F)/2)<<1|h<(q+B)/2){case 0:do{var y=Array(4);y[x]=P;P=y}while(J*=2,B=q+J,F=w+J,h>B||l>F);break;case 1:do y=Array(4),y[x]=P,P=y;while(J*=2,q=B-J,F=w+J,q>h||l>F);break;case 2:do y=Array(4),y[x]=P,P=y;while(J*=2,B=q+J,w=F-J,h>B||w>l);break;case 3:do y=Array(4),y[x]=P,P=y;while(J*=2,q=B-J,w=F-J,q>h||w>l)}this._root&&this._root.length&&(this._root=P)}else return this;this._x0=q;this._y0=w;this._x1=B;this._y1=F;return this};Qa.data=function(){var h=
[];this.visit(function(l){if(!l.length){do h.push(l.data);while(l=l.next)}});return h};Qa.extent=function(h){return arguments.length?this.cover(+h[0][0],+h[0][1]).cover(+h[1][0],+h[1][1]):isNaN(this._x0)?void 0:[[this._x0,this._y0],[this._x1,this._y1]]};Qa.find=function(h,l,q){var w=this._x0,B=this._y0,F,J,P,x,y=this._x1,I=this._y1,Q=[],V=this._root,N;V&&Q.push(new Ka(V,w,B,y,I));null==q?q=Infinity:(w=h-q,B=l-q,y=h+q,I=l+q,q*=q);for(;N=Q.pop();)if(!(!(V=N.node)||(F=N.x0)>y||(J=N.y0)>I||(P=N.x1)<w||
(x=N.y1)<B))if(V.length){N=(F+P)/2;var T=(J+x)/2;Q.push(new Ka(V[3],N,T,P,x),new Ka(V[2],F,T,N,x),new Ka(V[1],N,J,P,T),new Ka(V[0],F,J,N,T));if(V=(l>=T)<<1|h>=N)N=Q[Q.length-1],Q[Q.length-1]=Q[Q.length-1-V],Q[Q.length-1-V]=N}else if(N=h-+this._x.call(null,V.data),T=l-+this._y.call(null,V.data),N=N*N+T*T,N<q){var f=Math.sqrt(q=N);w=h-f;B=l-f;y=h+f;I=l+f;f=V.data}return f};Qa.remove=function(h){if(isNaN(x=+this._x.call(null,h))||isNaN(y=+this._y.call(null,h)))return this;var l,q=this._root,w,B=this._x0,
F=this._y0,J=this._x1,P=this._y1,x,y,I,Q,V,N,T;if(!q)return this;if(q.length)for(;;){(V=x>=(I=(B+J)/2))?B=I:J=I;(N=y>=(Q=(F+P)/2))?F=Q:P=Q;if(!(l=q,q=q[T=N<<1|V]))return this;if(!q.length)break;if(l[T+1&3]||l[T+2&3]||l[T+3&3]){var f=l;var n=T}}for(;q.data!==h;)if(!(w=q,q=q.next))return this;(h=q.next)&&delete q.next;if(w)return h?w.next=h:delete w.next,this;if(!l)return this._root=h,this;h?l[T]=h:delete l[T];(q=l[0]||l[1]||l[2]||l[3])&&q===(l[3]||l[2]||l[1]||l[0])&&!q.length&&(f?f[n]=q:this._root=
q);return this};Qa.removeAll=function(h){for(var l=0,q=h.length;l<q;++l)this.remove(h[l]);return this};Qa.root=function(){return this._root};Qa.size=function(){var h=0;this.visit(function(l){if(!l.length){do++h;while(l=l.next)}});return h};Qa.visit=function(h){var l=[],q,w=this._root,B,F,J,P,x;for(w&&l.push(new Ka(w,this._x0,this._y0,this._x1,this._y1));q=l.pop();)if(!h(w=q.node,F=q.x0,J=q.y0,P=q.x1,x=q.y1)&&w.length){q=(F+P)/2;var y=(J+x)/2;(B=w[3])&&l.push(new Ka(B,q,y,P,x));(B=w[2])&&l.push(new Ka(B,
F,y,q,x));(B=w[1])&&l.push(new Ka(B,q,J,P,y));(B=w[0])&&l.push(new Ka(B,F,J,q,y))}return this};Qa.visitAfter=function(h){var l=[],q=[],w;for(this._root&&l.push(new Ka(this._root,this._x0,this._y0,this._x1,this._y1));w=l.pop();){var B=w.node;if(B.length){var F,J=w.x0,P=w.y0,x=w.x1,y=w.y1,I=(J+x)/2,Q=(P+y)/2;(F=B[0])&&l.push(new Ka(F,J,P,I,Q));(F=B[1])&&l.push(new Ka(F,I,P,x,Q));(F=B[2])&&l.push(new Ka(F,J,Q,I,y));(F=B[3])&&l.push(new Ka(F,I,Q,x,y))}q.push(w)}for(;w=q.pop();)h(w.node,w.x0,w.y0,w.x1,
w.y1);return this};Qa.x=function(h){return arguments.length?(this._x=h,this):this._x};Qa.y=function(h){return arguments.length?(this._y=h,this):this._y};var vt=Math.PI*(3-Math.sqrt(5)),iq=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;bd.prototype=sg.prototype;sg.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(null==this.width?"":Math.max(1,this.width|0))+(this.comma?",":"")+(null==this.precision?"":"."+Math.max(0,this.precision|
0))+(this.trim?"~":"")+this.type};var wj,xj={"%":function(h,l){return(100*h).toFixed(l)},b:function(h){return Math.round(h).toString(2)},c:function(h){return h+""},d:function(h){return Math.round(h).toString(10)},e:function(h,l){return h.toExponential(l)},f:function(h,l){return h.toFixed(l)},g:function(h,l){return h.toPrecision(l)},o:function(h){return Math.round(h).toString(8)},p:function(h,l){return sj(100*h,l)},r:sj,s:function(h,l){var q=qe(h,l);if(!q)return h+"";var w=q[0];q=q[1];q=q-(wj=3*Math.max(-8,
Math.min(8,Math.floor(q/3))))+1;var B=w.length;return q===B?w:q>B?w+Array(q-B+1).join("0"):0<q?w.slice(0,q)+"."+w.slice(q):"0."+Array(1-q).join("0")+qe(h,Math.max(0,l+q-1))[0]},X:function(h){return Math.round(h).toString(16).toUpperCase()},x:function(h){return Math.round(h).toString(16)}},vj="y z a f p n \u00b5 m  k M G T P E Z Y".split(" "),re;yj({decimal:".",thousands:",",grouping:[3],currency:["$",""]});fb.prototype={constructor:fb,reset:function(){this.s=this.t=0},add:function(h){Cj(vf,h,this.t);
Cj(this,vf.s,this.s);this.s?this.t+=vf.t:this.s=vf.t},valueOf:function(){return this.s}};var vf=new fb,oa=Math.PI,wa=oa/2,te=oa/4,Sa=2*oa,va=180/oa,ia=oa/180,ra=Math.abs,wc=Math.atan,Ma=Math.atan2,da=Math.cos,Me=Math.ceil,xm=Math.exp,Re=Math.log,Zg=Math.pow,ca=Math.sin,ld=Math.sign||function(h){return 0<h?1:0>h?-1:0},Ba=Math.sqrt,vc=Math.tan,Hj={Feature:function(h,l){se(h.geometry,l)},FeatureCollection:function(h,l){h=h.features;for(var q=-1,w=h.length;++q<w;)se(h[q].geometry,l)}},Fj={Sphere:function(h,
l){l.sphere()},Point:function(h,l){h=h.coordinates;l.point(h[0],h[1],h[2])},MultiPoint:function(h,l){for(var q=h.coordinates,w=-1,B=q.length;++w<B;)h=q[w],l.point(h[0],h[1],h[2])},LineString:function(h,l){tg(h.coordinates,l,0)},MultiLineString:function(h,l){h=h.coordinates;for(var q=-1,w=h.length;++q<w;)tg(h[q],l,0)},Polygon:function(h,l){Gj(h.coordinates,l)},MultiPolygon:function(h,l){h=h.coordinates;for(var q=-1,w=h.length;++q<w;)Gj(h[q],l)},GeometryCollection:function(h,l){h=h.geometries;for(var q=
-1,w=h.length;++q<w;)se(h[q],l)}},ue=new fb,wf=new fb,Jj,Kj,ug,vg,wg,lb={point:xa,lineStart:xa,lineEnd:xa,polygonStart:function(){ue.reset();lb.lineStart=jq;lb.lineEnd=lq},polygonEnd:function(){var h=+ue;wf.add(0>h?Sa+h:h);this.lineStart=this.lineEnd=this.point=xa},sphere:function(){wf.add(Sa)}},za,Wa,Aa,Za,Wb,Pj,Qj,pc,cd=new fb,Hb,tb,ub={point:yg,lineStart:Mj,lineEnd:Nj,polygonStart:function(){ub.point=Oj;ub.lineStart=mq;ub.lineEnd=nq;cd.reset();lb.polygonStart()},polygonEnd:function(){lb.polygonEnd();
ub.point=yg;ub.lineStart=Mj;ub.lineEnd=Nj;0>ue?(za=-(Aa=180),Wa=-(Za=90)):1E-6<cd?Za=90:-1E-6>cd&&(Wa=-90);tb[0]=za;tb[1]=Aa}},ed,Ce,ze,Ae,Be,De,Ee,Fe,Ag,Bg,Cg,Vj,Wj,Na,Oa,Pa,hb={sphere:xa,point:zg,lineStart:Sj,lineEnd:Tj,polygonStart:function(){hb.lineStart=rq;hb.lineEnd=tq},polygonEnd:function(){hb.lineStart=Sj;hb.lineEnd=Tj}};Eg.invert=Eg;var Gg=new fb,Xg=hk(function(){return!0},function(h){var l=NaN,q=NaN,w=NaN,B;return{lineStart:function(){h.lineStart();B=1},point:function(F,J){var P=0<F?oa:
-oa,x=ra(F-l);if(1E-6>ra(x-oa))h.point(l,q=0<(q+J)/2?wa:-wa),h.point(w,q),h.lineEnd(),h.lineStart(),h.point(P,q),h.point(F,q),B=0;else if(w!==P&&x>=oa){1E-6>ra(l-w)&&(l-=1E-6*w);1E-6>ra(F-P)&&(F-=1E-6*P);x=l;var y=q,I=F,Q,V,N=ca(x-I);q=1E-6<ra(N)?wc((ca(y)*(V=da(J))*ca(I)-ca(J)*(Q=da(y))*ca(x))/(Q*V*N)):(y+J)/2;h.point(w,q);h.lineEnd();h.lineStart();h.point(P,q);B=0}h.point(l=F,q=J);w=P},lineEnd:function(){h.lineEnd();l=q=NaN},clean:function(){return 2-B}}},function(h,l,q,w){null==h?(q*=wa,w.point(-oa,
q),w.point(0,q),w.point(oa,q),w.point(oa,0),w.point(oa,-q),w.point(0,-q),w.point(-oa,-q),w.point(-oa,0),w.point(-oa,q)):1E-6<ra(h[0]-l[0])?(h=h[0]<l[0]?oa:-oa,q=q*h/2,w.point(-h,q),w.point(0,q),w.point(h,q)):w.point(l[0],l[1])},[-oa,-wa]),Ig=new fb,Hg,Je,Ke,rc={sphere:xa,point:xa,lineStart:function(){rc.point=yq;rc.lineEnd=xq},lineEnd:xa,polygonStart:xa,polygonEnd:xa},Jg=[null,null],Aq={type:"LineString",coordinates:Jg},ym={Feature:function(h,l){return Le(h.geometry,l)},FeatureCollection:function(h,
l){h=h.features;for(var q=-1,w=h.length;++q<w;)if(Le(h[q].geometry,l))return!0;return!1}},kk={Sphere:function(){return!0},Point:function(h,l){return 0===sc(h.coordinates,l)},MultiPoint:function(h,l){h=h.coordinates;for(var q=-1,w=h.length;++q<w;)if(0===sc(h[q],l))return!0;return!1},LineString:function(h,l){return lk(h.coordinates,l)},MultiLineString:function(h,l){h=h.coordinates;for(var q=-1,w=h.length;++q<w;)if(lk(h[q],l))return!0;return!1},Polygon:function(h,l){return mk(h.coordinates,l)},MultiPolygon:function(h,
l){h=h.coordinates;for(var q=-1,w=h.length;++q<w;)if(mk(h[q],l))return!0;return!1},GeometryCollection:function(h,l){h=h.geometries;for(var q=-1,w=h.length;++q<w;)if(Le(h[q],l))return!0;return!1}},Oh=new fb,Mg=new fb,sk,tk,Kg,Lg,vb={point:xa,lineStart:xa,lineEnd:xa,polygonStart:function(){vb.lineStart=Cq;vb.lineEnd=Eq},polygonEnd:function(){vb.lineStart=vb.lineEnd=vb.point=xa;Oh.add(ra(Mg));Mg.reset()},result:function(){var h=Oh/2;Oh.reset();return h}},Mc=Infinity,xf=Mc,Md=-Mc,yf=Md,Pe={point:function(h,
l){h<Mc&&(Mc=h);h>Md&&(Md=h);l<xf&&(xf=l);l>yf&&(yf=l)},lineStart:xa,lineEnd:xa,polygonStart:xa,polygonEnd:xa,result:function(){var h=[[Mc,xf],[Md,yf]];Md=yf=-(xf=Mc=Infinity);return h}},Ng=0,Og=0,fd=0,Ne=0,Oe=0,tc=0,Pg=0,Qg=0,gd=0,xk,yk,mb,nb,$a={point:Yb,lineStart:uk,lineEnd:vk,polygonStart:function(){$a.lineStart=Hq;$a.lineEnd=Jq},polygonEnd:function(){$a.point=Yb;$a.lineStart=uk;$a.lineEnd=vk},result:function(){var h=gd?[Pg/gd,Qg/gd]:tc?[Ne/tc,Oe/tc]:fd?[Ng/fd,Og/fd]:[NaN,NaN];Ng=Og=fd=Ne=Oe=
tc=Pg=Qg=gd=0;return h}};zk.prototype={_radius:4.5,pointRadius:function(h){return this._radius=h,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._context.closePath();this._point=NaN},point:function(h,l){switch(this._point){case 0:this._context.moveTo(h,l);this._point=1;break;case 1:this._context.lineTo(h,l);break;default:this._context.moveTo(h+this._radius,l),this._context.arc(h,l,this._radius,
0,Sa)}},result:xa};var Rg=new fb,Ph,Bk,Ck,id,jd,hd={point:xa,lineStart:function(){hd.point=Kq},lineEnd:function(){Ph&&Ak(Bk,Ck);hd.point=xa},polygonStart:function(){Ph=!0},polygonEnd:function(){Ph=null},result:function(){var h=+Rg;Rg.reset();return h}};Dk.prototype={_radius:4.5,_circle:Ek(4.5),pointRadius:function(h){(h=+h)!==this._radius&&(this._radius=h,this._circle=null);return this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},
lineEnd:function(){0===this._line&&this._string.push("Z");this._point=NaN},point:function(h,l){switch(this._point){case 0:this._string.push("M",h,",",l);this._point=1;break;case 1:this._string.push("L",h,",",l);break;default:null==this._circle&&(this._circle=Ek(this._radius)),this._string.push("M",h,",",l,this._circle)}},result:function(){if(this._string.length){var h=this._string.join("");this._string=[];return h}return null}};Sg.prototype={constructor:Sg,point:function(h,l){this.stream.point(h,
l)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var Lq=da(30*ia),Oq=kd({point:function(h,l){this.stream.point(h*ia,l*ia)}}),Qh=Kk(function(h){return Ba(2/(1+h))});Qh.invert=md(function(h){return 2*La(h/2)});var Rh=Kk(function(h){return(h=Dj(h))&&h/ca(h)});Rh.invert=md(function(h){return h});nd.invert=function(h,l){return[h,
2*wc(xm(l))-wa]};od.invert=od;var Se=Ba(3)/2;$g.invert=function(h,l){for(var q=l,w=q*q,B=w*w*w,F=0,J;12>F&&!(J=q*(1.340264+-.081106*w+B*(8.93E-4+.003796*w))-l,w=1.340264+3*-.081106*w+B*(7*8.93E-4+.034164*w),q-=J/=w,w=q*q,B=w*w*w,1E-12>ra(J));++F);return[Se*h*(1.340264+3*-.081106*w+B*(7*8.93E-4+.034164*w))/da(q),La(ca(q)/Se)]};ah.invert=md(wc);bh.invert=function(h,l){var q=l,w=25;do{var B=q*q;var F=B*B;q-=F=(q*(1.007226+B*(.015085+F*(-.044475+.028874*B-.005916*F)))-l)/(1.007226+B*(.045255+F*(-.311325+
.259866*B-.005916*11*F)))}while(1E-6<ra(F)&&0<--w);return[h/(.8707+(B=q*q)*(-.131979+B*(-.013791+B*B*B*(.003971-.001529*B)))),q]};ch.invert=md(La);dh.invert=md(function(h){return 2*wc(h)});eh.invert=function(h,l){return[-l,2*wc(xm(h))-wa]};xc.prototype=fh.prototype={constructor:xc,count:function(){return this.eachAfter(Wq)},each:function(h){var l,q=[this],w;do{var B=q.reverse();for(q=[];l=B.pop();)if(h(l),l=l.children){var F=0;for(w=l.length;F<w;++F)q.push(l[F])}}while(q.length);return this},eachAfter:function(h){for(var l,
q=[this],w=[],B,F;l=q.pop();)if(w.push(l),l=l.children)for(B=0,F=l.length;B<F;++B)q.push(l[B]);for(;l=w.pop();)h(l);return this},eachBefore:function(h){for(var l,q=[this],w;l=q.pop();)if(h(l),l=l.children)for(w=l.length-1;0<=w;--w)q.push(l[w]);return this},sum:function(h){return this.eachAfter(function(l){for(var q=+h(l.data)||0,w=l.children,B=w&&w.length;0<=--B;)q+=w[B].value;l.value=q})},sort:function(h){return this.eachBefore(function(l){l.children&&l.children.sort(h)})},path:function(h){var l=
this;var q=l;var w=h;if(q!==w){var B=q.ancestors(),F=w.ancestors(),J=null;q=B.pop();for(w=F.pop();q===w;)J=q,q=B.pop(),w=F.pop();q=J}for(w=[l];l!==q;)l=l.parent,w.push(l);for(l=w.length;h!==q;)w.splice(l,0,h),h=h.parent;return w},ancestors:function(){for(var h=this,l=[h];h=h.parent;)l.push(h);return l},descendants:function(){var h=[];this.each(function(l){h.push(l)});return h},leaves:function(){var h=[];this.eachBefore(function(l){l.children||h.push(l)});return h},links:function(){var h=this,l=[];
h.each(function(q){q!==h&&l.push({source:q.parent,target:q})});return l},copy:function(){return fh(this).eachBefore(Yq)}};var Zq=Array.prototype.slice,wt={depth:-1},zm={};Xe.prototype=Object.create(xc.prototype);var Am=(1+Math.sqrt(5))/2,Bm=function q(l){function w(B,F,J,P,x){Zk(l,B,F,J,P,x)}w.ratio=function(B){return q(1<(B=+B)?B:1)};return w}(Am),xt=function w(q){function B(F,J,P,x,y){if((I=F._squarify)&&I.ratio===q)for(var I,Q,V,N=-1,T,f=I.length,n=F.value;++N<f;){F=I[N];Q=F.children;V=F.value=
0;for(T=Q.length;V<T;++V)F.value+=Q[V].value;F.dice?qd(F,J,P,x,P+=(y-P)*F.value/n):Ye(F,J,P,J+=(x-J)*F.value/n,y);n-=F.value}else F._squarify=I=Zk(q,F,J,P,x,y),I.ratio=q}B.ratio=function(F){return w(1<(F=+F)?F:1)};return B}(Am),yt=function B(w){function F(J,P){J=null==J?0:+J;P=null==P?1:+P;1===arguments.length?(P=J,J=0):P-=J;return function(){return w()*P+J}}F.source=B;return F}(zc),Cm=function F(B){function J(P,x){var y,I;P=null==P?0:+P;x=null==x?1:+x;return function(){if(null!=y){var Q=y;y=null}else{do y=
2*B()-1,Q=2*B()-1,I=y*y+Q*Q;while(!I||1<I)}return P+x*Q*Math.sqrt(-2*Math.log(I)/I)}}J.source=F;return J}(zc),zt=function J(F){function P(){var x=Cm.source(F).apply(this,arguments);return function(){return Math.exp(x())}}P.source=J;return P}(zc),Dm=function P(J){function x(y){return function(){for(var I=0,Q=0;Q<y;++Q)I+=J();return I}}x.source=P;return x}(zc),At=function x(P){function y(I){var Q=Dm.source(P)(I);return function(){return Q()/I}}y.source=x;return y}(zc),Bt=function y(x){function I(Q){return function(){return-Math.log(1-
x())/Q}}I.source=y;return I}(zc),Em=Array.prototype,ph=Em.map,Ib=Em.slice,lh={name:"implicit"},cl=[0,1],rh=new Date,sh=new Date,dc=Da(function(){},function(x,y){x.setTime(+x+y)},function(x,y){return y-x});dc.every=function(x){x=Math.floor(x);return isFinite(x)&&0<x?1<x?Da(function(y){y.setTime(Math.floor(y/x)*x)},function(y,I){y.setTime(+y+I*x)},function(y,I){return(I-y)/x}):dc:null};var Fm=dc.range,Nd=Da(function(x){x.setTime(1E3*Math.floor(x/1E3))},function(x,y){x.setTime(+x+1E3*y)},function(x,
y){return(y-x)/1E3},function(x){return x.getUTCSeconds()}),Gm=Nd.range,Sh=Da(function(x){x.setTime(6E4*Math.floor(x/6E4))},function(x,y){x.setTime(+x+6E4*y)},function(x,y){return(y-x)/6E4},function(x){return x.getMinutes()}),Ct=Sh.range,Th=Da(function(x){var y=6E4*x.getTimezoneOffset()%36E5;0>y&&(y+=36E5);x.setTime(36E5*Math.floor((+x-y)/36E5)+y)},function(x,y){x.setTime(+x+36E5*y)},function(x,y){return(y-x)/36E5},function(x){return x.getHours()}),Dt=Th.range,vd=Da(function(x){x.setHours(0,0,0,0)},
function(x,y){x.setDate(x.getDate()+y)},function(x,y){return(y-x-6E4*(y.getTimezoneOffset()-x.getTimezoneOffset()))/864E5},function(x){return x.getDate()-1}),Et=vd.range,yd=ac(0),ud=ac(1),Hm=ac(2),Im=ac(3),zd=ac(4),Jm=ac(5),Km=ac(6),Lm=yd.range,Ft=ud.range,Gt=Hm.range,Ht=Im.range,It=zd.range,Jt=Jm.range,Kt=Km.range,Uh=Da(function(x){x.setDate(1);x.setHours(0,0,0,0)},function(x,y){x.setMonth(x.getMonth()+y)},function(x,y){return y.getMonth()-x.getMonth()+12*(y.getFullYear()-x.getFullYear())},function(x){return x.getMonth()}),
Lt=Uh.range,wb=Da(function(x){x.setMonth(0,1);x.setHours(0,0,0,0)},function(x,y){x.setFullYear(x.getFullYear()+y)},function(x,y){return y.getFullYear()-x.getFullYear()},function(x){return x.getFullYear()});wb.every=function(x){return isFinite(x=Math.floor(x))&&0<x?Da(function(y){y.setFullYear(Math.floor(y.getFullYear()/x)*x);y.setMonth(0,1);y.setHours(0,0,0,0)},function(y,I){y.setFullYear(y.getFullYear()+I*x)}):null};var Mt=wb.range,Vh=Da(function(x){x.setUTCSeconds(0,0)},function(x,y){x.setTime(+x+
6E4*y)},function(x,y){return(y-x)/6E4},function(x){return x.getUTCMinutes()}),Nt=Vh.range,Wh=Da(function(x){x.setUTCMinutes(0,0,0)},function(x,y){x.setTime(+x+36E5*y)},function(x,y){return(y-x)/36E5},function(x){return x.getUTCHours()}),Ot=Wh.range,td=Da(function(x){x.setUTCHours(0,0,0,0)},function(x,y){x.setUTCDate(x.getUTCDate()+y)},function(x,y){return(y-x)/864E5},function(x){return x.getUTCDate()-1}),Pt=td.range,Ad=bc(0),sd=bc(1),Mm=bc(2),Nm=bc(3),Bd=bc(4),Om=bc(5),Pm=bc(6),Qm=Ad.range,Qt=sd.range,
Rt=Mm.range,St=Nm.range,Tt=Bd.range,Ut=Om.range,Vt=Pm.range,Xh=Da(function(x){x.setUTCDate(1);x.setUTCHours(0,0,0,0)},function(x,y){x.setUTCMonth(x.getUTCMonth()+y)},function(x,y){return y.getUTCMonth()-x.getUTCMonth()+12*(y.getUTCFullYear()-x.getUTCFullYear())},function(x){return x.getUTCMonth()}),Wt=Xh.range,xb=Da(function(x){x.setUTCMonth(0,1);x.setUTCHours(0,0,0,0)},function(x,y){x.setUTCFullYear(x.getUTCFullYear()+y)},function(x,y){return y.getUTCFullYear()-x.getUTCFullYear()},function(x){return x.getUTCFullYear()});
xb.every=function(x){return isFinite(x=Math.floor(x))&&0<x?Da(function(y){y.setUTCFullYear(Math.floor(y.getUTCFullYear()/x)*x);y.setUTCMonth(0,1);y.setUTCHours(0,0,0,0)},function(y,I){y.setUTCFullYear(y.getUTCFullYear()+I*x)}):null};var Xt=xb.range,ol={"-":"",_:" ",0:"0"},Ga=/^\s*\d+/,ks=/^%/,js=/[\\^$*+?|[\]().{}]/g,Cc;yl({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),
months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")});var Yt=Date.prototype.toISOString?ls:d3.utcFormat("%Y-%m-%dT%H:%M:%S.%LZ"),Zt=+new Date("2000-01-01T00:00:00.000Z")?ms:d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ"),$t=ka("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),au=ka("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"),
bu=ka("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"),cu=ka("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"),du=ka("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),eu=ka("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),fu=ka("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),gu=ka("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),
hu=ka("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),iu=ka("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),ju=ka("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),ku=ka("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),Rm=Array(3).concat("d8b365f5f5f55ab4ac","a6611adfc27d80cdc1018571","a6611adfc27df5f5f580cdc1018571","8c510ad8b365f6e8c3c7eae55ab4ac01665e","8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e","8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e","8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30","5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(ka),lu=ua(Rm),Sm=Array(3).concat("af8dc3f7f7f77fbf7b","7b3294c2a5cfa6dba0008837","7b3294c2a5cff7f7f7a6dba0008837","762a83af8dc3e7d4e8d9f0d37fbf7b1b7837","762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837","762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837","762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837","40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(ka),mu=ua(Sm),Tm=Array(3).concat("e9a3c9f7f7f7a1d76a","d01c8bf1b6dab8e1864dac26","d01c8bf1b6daf7f7f7b8e1864dac26","c51b7de9a3c9fde0efe6f5d0a1d76a4d9221","c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221","c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221","c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221","8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419","8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(ka),
nu=ua(Tm),Um=Array(3).concat("998ec3f7f7f7f1a340","5e3c99b2abd2fdb863e66101","5e3c99b2abd2f7f7f7fdb863e66101","542788998ec3d8daebfee0b6f1a340b35806","542788998ec3d8daebf7f7f7fee0b6f1a340b35806","5427888073acb2abd2d8daebfee0b6fdb863e08214b35806","5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806","2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08","2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(ka),ou=ua(Um),Vm=Array(3).concat("ef8a62f7f7f767a9cf","ca0020f4a58292c5de0571b0",
"ca0020f4a582f7f7f792c5de0571b0","b2182bef8a62fddbc7d1e5f067a9cf2166ac","b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac","b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac","b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac","67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061","67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(ka),pu=ua(Vm),Wm=Array(3).concat("ef8a62ffffff999999","ca0020f4a582bababa404040","ca0020f4a582ffffffbababa404040","b2182bef8a62fddbc7e0e0e09999994d4d4d",
"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d","b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d","b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d","67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a","67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(ka),qu=ua(Wm),Xm=Array(3).concat("fc8d59ffffbf91bfdb","d7191cfdae61abd9e92c7bb6","d7191cfdae61ffffbfabd9e92c7bb6","d73027fc8d59fee090e0f3f891bfdb4575b4","d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4","d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4","a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695","a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(ka),ru=ua(Xm),Ym=Array(3).concat("fc8d59ffffbf91cf60","d7191cfdae61a6d96a1a9641","d7191cfdae61ffffbfa6d96a1a9641","d73027fc8d59fee08bd9ef8b91cf601a9850","d73027fc8d59fee08bffffbfd9ef8b91cf601a9850","d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850","d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850","a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(ka),su=ua(Ym),Zm=Array(3).concat("fc8d59ffffbf99d594","d7191cfdae61abdda42b83ba","d7191cfdae61ffffbfabdda42b83ba","d53e4ffc8d59fee08be6f59899d5943288bd","d53e4ffc8d59fee08bffffbfe6f59899d5943288bd","d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd","d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd","9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2","9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(ka),
tu=ua(Zm),$m=Array(3).concat("e5f5f999d8c92ca25f","edf8fbb2e2e266c2a4238b45","edf8fbb2e2e266c2a42ca25f006d2c","edf8fbccece699d8c966c2a42ca25f006d2c","edf8fbccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(ka),uu=ua($m),an=Array(3).concat("e0ecf49ebcda8856a7","edf8fbb3cde38c96c688419d","edf8fbb3cde38c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b","f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(ka),vu=ua(an),bn=Array(3).concat("e0f3dba8ddb543a2ca","f0f9e8bae4bc7bccc42b8cbe","f0f9e8bae4bc7bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(ka),wu=ua(bn),cn=Array(3).concat("fee8c8fdbb84e34a33","fef0d9fdcc8afc8d59d7301f",
"fef0d9fdcc8afc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(ka),xu=ua(cn),dn=Array(3).concat("ece2f0a6bddb1c9099","f6eff7bdc9e167a9cf02818a","f6eff7bdc9e167a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(ka),
yu=ua(dn),en=Array(3).concat("ece7f2a6bddb2b8cbe","f1eef6bdc9e174a9cf0570b0","f1eef6bdc9e174a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(ka),zu=ua(en),fn=Array(3).concat("e7e1efc994c7dd1c77","f1eef6d7b5d8df65b0ce1256","f1eef6d7b5d8df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0e7298ace125691003f",
"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f","f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(ka),Au=ua(fn),gn=Array(3).concat("fde0ddfa9fb5c51b8a","feebe2fbb4b9f768a1ae017e","feebe2fbb4b9f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(ka),Bu=ua(gn),hn=Array(3).concat("edf8b17fcdbb2c7fb8","ffffcca1dab441b6c4225ea8",
"ffffcca1dab441b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(ka),Cu=ua(hn),jn=Array(3).concat("f7fcb9addd8e31a354","ffffccc2e69978c679238443","ffffccc2e69978c67931a354006837","ffffccd9f0a3addd8e78c67931a354006837","ffffccd9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(ka),
Du=ua(jn),kn=Array(3).concat("fff7bcfec44fd95f0e","ffffd4fed98efe9929cc4c02","ffffd4fed98efe9929d95f0e993404","ffffd4fee391fec44ffe9929d95f0e993404","ffffd4fee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(ka),Eu=ua(kn),ln=Array(3).concat("ffeda0feb24cf03b20","ffffb2fecc5cfd8d3ce31a1c","ffffb2fecc5cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026","ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(ka),Fu=ua(ln),mn=Array(3).concat("deebf79ecae13182bd","eff3ffbdd7e76baed62171b5","eff3ffbdd7e76baed63182bd08519c","eff3ffc6dbef9ecae16baed63182bd08519c","eff3ffc6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(ka),Gu=ua(mn),nn=Array(3).concat("e5f5e0a1d99b31a354","edf8e9bae4b374c476238b45",
"edf8e9bae4b374c47631a354006d2c","edf8e9c7e9c0a1d99b74c47631a354006d2c","edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(ka),Hu=ua(nn),on=Array(3).concat("f0f0f0bdbdbd636363","f7f7f7cccccc969696525252","f7f7f7cccccc969696636363252525","f7f7f7d9d9d9bdbdbd969696636363252525","f7f7f7d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(ka),
Iu=ua(on),pn=Array(3).concat("efedf5bcbddc756bb1","f2f0f7cbc9e29e9ac86a51a3","f2f0f7cbc9e29e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(ka),Ju=ua(pn),qn=Array(3).concat("fee0d2fc9272de2d26","fee5d9fcae91fb6a4acb181d","fee5d9fcae91fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d","fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(ka),Ku=ua(qn),rn=Array(3).concat("fee6cefdae6be6550d","feeddefdbe85fd8d3cd94701","feeddefdbe85fd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(ka),Lu=ua(rn),Mu=rf(db(300,.5,0),db(-240,.5,1)),Nu=rf(db(-100,.75,.35),db(80,
1.5,.8)),Ou=rf(db(260,.75,.35),db(80,1.5,.8)),zf=db(),Af=hc(),Pu=Math.PI/3,Qu=2*Math.PI/3,Ru=bf(ka("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),
Su=bf(ka("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
Tu=bf(ka("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
Uu=bf(ka("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")),
sn=Math.abs,Ia=Math.atan2,ec=Math.cos,us=Math.max,Yh=Math.min,pb=Math.sin,Dc=Math.sqrt,Kb=Math.PI,cf=Kb/2,Lb=2*Kb;Dl.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x;y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=
2;default:this._context.lineTo(x,y)}}};var Hl=xh(ef);Fl.prototype={areaStart:function(){this._curve.areaStart()},areaEnd:function(){this._curve.areaEnd()},lineStart:function(){this._curve.lineStart()},lineEnd:function(){this._curve.lineEnd()},point:function(x,y){this._curve.point(y*Math.sin(x),y*-Math.cos(x))}};var zh=Array.prototype.slice,Zh={draw:function(x,y){y=Math.sqrt(y/Kb);x.moveTo(y,0);x.arc(0,0,y,0,Lb)}},tn={draw:function(x,y){y=Math.sqrt(y/5)/2;x.moveTo(-3*y,-y);x.lineTo(-y,-y);x.lineTo(-y,
-3*y);x.lineTo(y,-3*y);x.lineTo(y,-y);x.lineTo(3*y,-y);x.lineTo(3*y,y);x.lineTo(y,y);x.lineTo(y,3*y);x.lineTo(-y,3*y);x.lineTo(-y,y);x.lineTo(-3*y,y);x.closePath()}},un=Math.sqrt(1/3),Vu=2*un,vn={draw:function(x,y){y=Math.sqrt(y/Vu);var I=y*un;x.moveTo(0,-y);x.lineTo(I,0);x.lineTo(0,y);x.lineTo(-I,0);x.closePath()}},wn=Math.sin(Kb/10)/Math.sin(7*Kb/10),Wu=Math.sin(Lb/10)*wn,Xu=-Math.cos(Lb/10)*wn,xn={draw:function(x,y){y=Math.sqrt(.8908130915292852*y);var I=Wu*y,Q=Xu*y;x.moveTo(0,-y);x.lineTo(I,Q);
for(var V=1;5>V;++V){var N=Lb*V/5,T=Math.cos(N);N=Math.sin(N);x.lineTo(N*y,-T*y);x.lineTo(T*I-N*Q,N*I+T*Q)}x.closePath()}},yn={draw:function(x,y){y=Math.sqrt(y);var I=-y/2;x.rect(I,I,y,y)}},$h=Math.sqrt(3),zn={draw:function(x,y){y=-Math.sqrt(y/(3*$h));x.moveTo(0,2*y);x.lineTo(-$h*y,-y);x.lineTo($h*y,-y);x.closePath()}},ab=Math.sqrt(3)/2,ai=1/Math.sqrt(12),Yu=3*(ai/2+1),An={draw:function(x,y){var I=Math.sqrt(y/Yu);y=I/2;var Q=I*ai;I=I*ai+I;var V=-y;x.moveTo(y,Q);x.lineTo(y,I);x.lineTo(V,I);x.lineTo(-.5*
y-ab*Q,ab*y+-.5*Q);x.lineTo(-.5*y-ab*I,ab*y+-.5*I);x.lineTo(-.5*V-ab*I,ab*V+-.5*I);x.lineTo(-.5*y+ab*Q,-.5*Q-ab*y);x.lineTo(-.5*y+ab*I,-.5*I-ab*y);x.lineTo(-.5*V+ab*I,-.5*I-ab*V);x.closePath()}},Zu=[Zh,tn,vn,yn,xn,zn,An];gf.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0},lineEnd:function(){switch(this._point){case 3:ff(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||
0!==this._line&&1===this._point)&&this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x;y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:ff(this,x,y)}this._x0=this._x1;this._x1=x;this._y0=this._y1;this._y1=y}};Jl.prototype={areaStart:Jb,areaEnd:Jb,lineStart:function(){this._x0=this._x1=
this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN;this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2);this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3);this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3);this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(x,
y){x=+x;y=+y;switch(this._point){case 0:this._point=1;this._x2=x;this._y2=y;break;case 1:this._point=2;this._x3=x;this._y3=y;break;case 2:this._point=3;this._x4=x;this._y4=y;this._context.moveTo((this._x0+4*this._x1+x)/6,(this._y0+4*this._y1+y)/6);break;default:ff(this,x,y)}this._x0=this._x1;this._x1=x;this._y0=this._y1;this._y1=y}};Kl.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0},lineEnd:function(){(this._line||
0!==this._line&&3===this._point)&&this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x;y=+y;switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var I=(this._x0+4*this._x1+x)/6,Q=(this._y0+4*this._y1+y)/6;this._line?this._context.lineTo(I,Q):this._context.moveTo(I,Q);break;case 3:this._point=4;default:ff(this,x,y)}this._x0=this._x1;this._x1=x;this._y0=this._y1;this._y1=y}};Ll.prototype={lineStart:function(){this._x=[];this._y=[];this._basis.lineStart()},
lineEnd:function(){var x=this._x,y=this._y,I=x.length-1;if(0<I)for(var Q=x[0],V=y[0],N=x[I]-Q,T=y[I]-V,f=-1,n;++f<=I;)n=f/I,this._basis.point(this._beta*x[f]+(1-this._beta)*(Q+n*N),this._beta*y[f]+(1-this._beta)*(V+n*T));this._x=this._y=null;this._basis.lineEnd()},point:function(x,y){this._x.push(+x);this._y.push(+y)}};var $u=function I(y){function Q(V){return 1===y?new gf(V):new Ll(V,y)}Q.beta=function(V){return I(+V)};return Q}(.85);Ah.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=
NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:hf(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath();this._line=1-this._line},point:function(y,I){y=+y;I=+I;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(y,I):this._context.moveTo(y,I);break;case 1:this._point=2;this._x1=y;this._y1=
I;break;case 2:this._point=3;default:hf(this,y,I)}this._x0=this._x1;this._x1=this._x2;this._x2=y;this._y0=this._y1;this._y1=this._y2;this._y2=I}};var av=function Q(I){function V(N){return new Ah(N,I)}V.tension=function(N){return Q(+N)};return V}(0);Bh.prototype={areaStart:Jb,areaEnd:Jb,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,
this._y3);this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3);this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(I,Q){I=+I;Q=+Q;switch(this._point){case 0:this._point=1;this._x3=I;this._y3=Q;break;case 1:this._point=2;this._context.moveTo(this._x4=I,this._y4=Q);break;case 2:this._point=3;this._x5=I;this._y5=Q;break;default:hf(this,I,Q)}this._x0=this._x1;this._x1=this._x2;this._x2=
I;this._y0=this._y1;this._y1=this._y2;this._y2=Q}};var bv=function V(Q){function N(T){return new Bh(T,Q)}N.tension=function(T){return V(+T)};return N}(0);Ch.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath();this._line=1-this._line},point:function(Q,V){Q=+Q;V=+V;switch(this._point){case 0:this._point=
1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:hf(this,Q,V)}this._x0=this._x1;this._x1=this._x2;this._x2=Q;this._y0=this._y1;this._y1=this._y2;this._y2=V}};var cv=function N(V){function T(f){return new Ch(f,V)}T.tension=function(f){return N(+f)};return T}(0);Ml.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=
this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath();this._line=1-this._line},point:function(V,N){V=+V;N=+N;if(this._point){var T=this._x2-V,f=this._y2-N;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(T*T+f*f,this._alpha))}switch(this._point){case 0:this._point=
1;this._line?this._context.lineTo(V,N):this._context.moveTo(V,N);break;case 1:this._point=2;break;case 2:this._point=3;default:Dh(this,V,N)}this._l01_a=this._l12_a;this._l12_a=this._l23_a;this._l01_2a=this._l12_2a;this._l12_2a=this._l23_2a;this._x0=this._x1;this._x1=this._x2;this._x2=V;this._y0=this._y1;this._y1=this._y2;this._y2=N}};var dv=function T(N){function f(n){return N?new Ml(n,N):new Ah(n,0)}f.alpha=function(n){return T(+n)};return f}(.5);Nl.prototype={areaStart:Jb,areaEnd:Jb,lineStart:function(){this._x0=
this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3);this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3);this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(N,
T){N=+N;T=+T;if(this._point){var f=this._x2-N,n=this._y2-T;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(f*f+n*n,this._alpha))}switch(this._point){case 0:this._point=1;this._x3=N;this._y3=T;break;case 1:this._point=2;this._context.moveTo(this._x4=N,this._y4=T);break;case 2:this._point=3;this._x5=N;this._y5=T;break;default:Dh(this,N,T)}this._l01_a=this._l12_a;this._l12_a=this._l23_a;this._l01_2a=this._l12_2a;this._l12_2a=this._l23_2a;this._x0=this._x1;this._x1=this._x2;this._x2=N;this._y0=this._y1;this._y1=
this._y2;this._y2=T}};var ev=function f(T){function n(u){return T?new Nl(u,T):new Bh(u,0)}n.alpha=function(u){return f(+u)};return n}(.5);Ol.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath();this._line=1-this._line},
point:function(T,f){T=+T;f=+f;if(this._point){var n=this._x2-T,u=this._y2-f;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+u*u,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:Dh(this,T,f)}this._l01_a=this._l12_a;this._l12_a=this._l23_a;this._l01_2a=this._l12_2a;this._l12_2a=this._l23_2a;this._x0=this._x1;this._x1=
this._x2;this._x2=T;this._y0=this._y1;this._y1=this._y2;this._y2=f}};var fv=function n(f){function u(r){return f?new Ol(r,f):new Ch(r,0)}u.alpha=function(r){return n(+r)};return u}(.5);Pl.prototype={areaStart:Jb,areaEnd:Jb,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(f,n){f=+f;n=+n;this._point?this._context.lineTo(f,n):(this._point=1,this._context.moveTo(f,n))}};jf.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=
NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN;this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:Eh(this,this._t0,Rl(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath();this._line=1-this._line},point:function(f,n){var u=NaN;f=+f;n=+n;if(f!==this._x1||n!==this._y1){switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(f,n):this._context.moveTo(f,n);break;
case 1:this._point=2;break;case 2:this._point=3;Eh(this,Rl(this,u=Ql(this,f,n)),u);break;default:Eh(this,this._t0,u=Ql(this,f,n))}this._x0=this._x1;this._x1=f;this._y0=this._y1;this._y1=n;this._t0=u}}};(Sl.prototype=Object.create(jf.prototype)).point=function(f,n){jf.prototype.point.call(this,n,f)};Tl.prototype={moveTo:function(f,n){this._context.moveTo(n,f)},closePath:function(){this._context.closePath()},lineTo:function(f,n){this._context.lineTo(n,f)},bezierCurveTo:function(f,n,u,r,t,z){this._context.bezierCurveTo(n,
f,r,u,z,t)}};Ul.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[];this._y=[]},lineEnd:function(){var f=this._x,n=this._y,u=f.length;if(u)if(this._line?this._context.lineTo(f[0],n[0]):this._context.moveTo(f[0],n[0]),2===u)this._context.lineTo(f[1],n[1]);else for(var r=Vl(f),t=Vl(n),z=0,D=1;D<u;++z,++D)this._context.bezierCurveTo(r[0][z],t[0][z],r[1][z],t[1][z],f[D],n[D]);(this._line||0!==this._line&&1===u)&&this._context.closePath();this._line=
1-this._line;this._x=this._y=null},point:function(f,n){this._x.push(+f);this._y.push(+n)}};kf.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN;this._point=0},lineEnd:function(){0<this._t&&1>this._t&&2===this._point&&this._context.lineTo(this._x,this._y);(this._line||0!==this._line&&1===this._point)&&this._context.closePath();0<=this._line&&(this._t=1-this._t,this._line=1-this._line)},point:function(f,n){f=+f;n=+n;switch(this._point){case 0:this._point=
1;this._line?this._context.lineTo(f,n):this._context.moveTo(f,n);break;case 1:this._point=2;default:if(0>=this._t)this._context.lineTo(this._x,n),this._context.lineTo(f,n);else{var u=this._x*(1-this._t)+f*this._t;this._context.lineTo(u,this._y);this._context.lineTo(u,n)}}this._x=f;this._y=n}};lf.prototype={constructor:lf,insert:function(f,n){var u;if(f){n.P=f;if(n.N=f.N)f.N.P=n;f.N=n;if(f.R){for(f=f.R;f.L;)f=f.L;f.L=n}else f.R=n;var r=f}else this._?(f=Zl(this._),n.P=null,n.N=f,f.P=f.L=n,r=f):(n.P=
n.N=null,this._=n,r=null);n.L=n.R=null;n.U=r;n.C=!0;for(f=n;r&&r.C;)n=r.U,r===n.L?(u=n.R)&&u.C?(r.C=u.C=!1,n.C=!0,f=n):(f===r.R&&(Ed(this,r),f=r,r=f.U),r.C=!1,n.C=!0,Fd(this,n)):(u=n.L)&&u.C?(r.C=u.C=!1,n.C=!0,f=n):(f===r.L&&(Fd(this,r),f=r,r=f.U),r.C=!1,n.C=!0,Ed(this,n)),r=f.U;this._.C=!1},remove:function(f){f.N&&(f.N.P=f.P);f.P&&(f.P.N=f.N);f.N=f.P=null;var n=f.U,u=f.L,r=f.R;var t=u?r?Zl(r):u:r;n?n.L===f?n.L=t:n.R=t:this._=t;if(u&&r){var z=t.C;t.C=f.C;t.L=u;u.U=t;t!==r?(n=t.U,t.U=f.U,f=t.R,n.L=
f,t.R=r,r.U=t):(t.U=n,n=t,f=t.R)}else z=f.C,f=t;f&&(f.U=n);if(!z)if(f&&f.C)f.C=!1;else{do{if(f===this._)break;if(f===n.L){if(f=n.R,f.C&&(f.C=!1,n.C=!0,Ed(this,n),f=n.R),f.L&&f.L.C||f.R&&f.R.C){f.R&&f.R.C||(f.L.C=!1,f.C=!0,Fd(this,f),f=n.R);f.C=n.C;n.C=f.R.C=!1;Ed(this,n);f=this._;break}}else if(f=n.L,f.C&&(f.C=!1,n.C=!0,Fd(this,n),f=n.L),f.L&&f.L.C||f.R&&f.R.C){f.L&&f.L.C||(f.R.C=!1,f.C=!0,Ed(this,f),f=n.L);f.C=n.C;n.C=f.L.C=!1;Fd(this,n);f=this._;break}f.C=!0;f=n;n=n.U}while(!f.C);f&&(f.C=!1)}}};
var am=[],Fh,cm=[],ta=1E-6,Ks=1E-12,Ic,Ya,Id,Ha;Hh.prototype={constructor:Hh,polygons:function(){var f=this.edges;return this.cells.map(function(n){var u=n.halfedges.map(function(r){return $l(n,f[r])});u.data=n.site.data;return u})},triangles:function(){var f=[],n=this.edges;this.cells.forEach(function(u,r){if(D=(t=u.halfedges).length){u=u.site;var t,z=-1,D,A=n[t[D-1]];for(A=A.left===u?A.right:A.left;++z<D;){var C=A;A=n[t[z]];A=A.left===u?A.right:A.left;C&&A&&r<C.index&&r<A.index&&0>(u[0]-A[0])*(C[1]-
u[1])-(u[0]-C[0])*(A[1]-u[1])&&f.push([u.data,C.data,A.data])}}});return f},links:function(){return this.edges.filter(function(f){return f.right}).map(function(f){return{source:f.left.data,target:f.right.data}})},find:function(f,n,u){var r=this,t=r._found||0;var z=r.cells.length;for(var D;!(D=r.cells[t]);)if(++t>=z)return null;z=f-D.site[0];var A=n-D.site[1],C=z*z+A*A;do D=r.cells[z=t],t=null,D.halfedges.forEach(function(G){var O=r.edges[G];G=O.left;if(G!==D.site&&G||(G=O.right)){O=f-G[0];var S=n-
G[1];O=O*O+S*S;O<C&&(C=O,t=G.index)}});while(null!==t);r._found=z;return null==u||C<=u*u?D.site:null}};yb.prototype={constructor:yb,scale:function(f){return 1===f?this:new yb(this.k*f,this.x,this.y)},translate:function(f,n){return 0===f&0===n?this:new yb(this.k,this.x+this.k*f,this.y+this.k*n)},apply:function(f){return[f[0]*this.k+this.x,f[1]*this.k+this.y]},applyX:function(f){return f*this.k+this.x},applyY:function(f){return f*this.k+this.y},invert:function(f){return[(f[0]-this.x)/this.k,(f[1]-this.y)/
this.k]},invertX:function(f){return(f-this.x)/this.k},invertY:function(f){return(f-this.y)/this.k},rescaleX:function(f){return f.copy().domain(f.range().map(this.invertX,this).map(f.invert,f))},rescaleY:function(f){return f.copy().domain(f.range().map(this.invertY,this).map(f.invert,f))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};var pf=new yb(1,0,0);em.prototype=yb.prototype;d3.version="5.7.0";d3.bisect=$b;d3.bisectRight=$b;d3.bisectLeft=Ts;d3.ascending=Mb;d3.bisector=
Bf;d3.cross=function(f,n,u){var r=f.length,t=n.length,z=Array(r*t),D,A,C;null==u&&(u=ei);for(D=C=0;D<r;++D){var G=f[D];for(A=0;A<t;++A,++C)z[C]=u(G,n[A])}return z};d3.descending=function(f,n){return n<f?-1:n>f?1:n>=f?0:NaN};d3.deviation=gi;d3.extent=Cf;d3.histogram=function(){function f(t){var z,D=t.length,A=Array(D);for(z=0;z<D;++z)A[z]=n(t[z],z,t);z=u(A);var C=z[0],G=z[1],O=r(A,C,G);Array.isArray(O)||(O=Nb(C,G,O),O=Ta(Math.ceil(C/O)*O,G,O));for(var S=O.length;O[0]<=C;)O.shift(),--S;for(;O[S-1]>
G;)O.pop(),--S;var E=Array(S+1);for(z=0;z<=S;++z){var K=E[z]=[];K.x0=0<z?O[z-1]:C;K.x1=z<S?O[z]:G}for(z=0;z<D;++z)K=A[z],C<=K&&K<=G&&E[$b(O,K,0,S)].push(t[z]);return E}var n=Cn,u=Cf,r=Hf;f.value=function(t){return arguments.length?(n="function"===typeof t?t:Od(t),f):n};f.domain=function(t){return arguments.length?(u="function"===typeof t?t:Od([t[0],t[1]]),f):u};f.thresholds=function(t){return arguments.length?(r="function"===typeof t?t:Array.isArray(t)?Od(Us.call(t)):Od(t),f):r};return f};d3.thresholdFreedmanDiaconis=
function(f,n,u){f=Vs.call(f,Ab).sort(Mb);return Math.ceil((u-n)/(2*(Oc(f,.75)-Oc(f,.25))*Math.pow(f.length,-1/3)))};d3.thresholdScott=function(f,n,u){return Math.ceil((u-n)/(3.5*gi(f)*Math.pow(f.length,-1/3)))};d3.thresholdSturges=Hf;d3.max=hi;d3.mean=function(f,n){var u=f.length,r=u,t=-1,z,D=0;if(null==n)for(;++t<u;)isNaN(z=Ab(f[t]))?--r:D+=z;else for(;++t<u;)isNaN(z=Ab(n(f[t],t,f)))?--r:D+=z;if(r)return D/r};d3.median=function(f,n){var u=f.length,r=-1,t,z=[];if(null==n)for(;++r<u;)isNaN(t=Ab(f[r]))||
z.push(t);else for(;++r<u;)isNaN(t=Ab(n(f[r],r,f)))||z.push(t);return Oc(z.sort(Mb),.5)};d3.merge=If;d3.min=ii;d3.pairs=function(f,n){null==n&&(n=ei);for(var u=0,r=f.length-1,t=f[0],z=Array(0>r?0:r);u<r;)z[u]=n(t,t=f[++u]);return z};d3.permute=function(f,n){for(var u=n.length,r=Array(u);u--;)r[u]=f[n[u]];return r};d3.quantile=Oc;d3.range=Ta;d3.scan=function(f,n){if(u=f.length){var u,r=0,t=0,z,D=f[t];for(null==n&&(n=Mb);++r<u;)if(0>n(z=f[r],D)||0!==n(D,D))D=z,t=r;if(0===n(D,D))return t}};d3.shuffle=
function(f,n,u){u=(null==u?f.length:u)-(n=null==n?0:+n);for(var r,t;u;)t=Math.random()*u--|0,r=f[u+n],f[u+n]=f[t+n],f[t+n]=r;return f};d3.sum=function(f,n){var u=f.length,r=-1,t,z=0;if(null==n)for(;++r<u;){if(t=+f[r])z+=t}else for(;++r<u;)if(t=+n(f[r],r,f))z+=t;return z};d3.ticks=Df;d3.tickIncrement=Nc;d3.tickStep=Nb;d3.transpose=ji;d3.variance=fi;d3.zip=function(){return ji(arguments)};d3.axisTop=function(f){return Pd(1,f)};d3.axisRight=function(f){return Pd(2,f)};d3.axisBottom=function(f){return Pd(3,
f)};d3.axisLeft=function(f){return Pd(4,f)};d3.brush=function(){return jg(kt)};d3.brushX=function(){return jg(le)};d3.brushY=function(){return jg(ke)};d3.brushSelection=function(f){return(f=f.__brush)?f.dim.output(f.selection):null};d3.chord=function(){function f(z){var D=z.length,A=[],C=Ta(D),G=[],O=[],S=O.groups=Array(D),E=Array(D*D),K,H;var L=0;for(K=-1;++K<D;){var U=0;for(H=-1;++H<D;)U+=z[K][H];A.push(U);G.push(Ta(D));L+=U}u&&C.sort(function(ea,la){return u(A[ea],A[la])});r&&G.forEach(function(ea,
la){ea.sort(function(pa,R){return r(z[la][pa],z[la][R])})});var M=(L=um(0,tm-n*D)/L)?n:tm/D;U=0;for(K=-1;++K<D;){var X=U;for(H=-1;++H<D;){var Y=C[K],W=G[Y][H],ba=z[Y][W],aa=U,ha=U+=ba*L;E[W*D+Y]={index:Y,subindex:W,startAngle:aa,endAngle:ha,value:ba}}S[Y]={index:Y,startAngle:X,endAngle:U,value:A[Y]};U+=M}for(K=-1;++K<D;)for(H=K-1;++H<D;)C=E[H*D+K],G=E[K*D+H],(C.value||G.value)&&O.push(C.value<G.value?{source:G,target:C}:{source:C,target:G});return t?O.sort(t):O}var n=0,u=null,r=null,t=null;f.padAngle=
function(z){return arguments.length?(n=um(0,z),f):n};f.sortGroups=function(z){return arguments.length?(u=z,f):u};f.sortSubgroups=function(z){return arguments.length?(r=z,f):r};f.sortChords=function(z){return arguments.length?(null==z?t=null:(t=Hp(z))._=z,f):t&&t._};return f};d3.ribbon=function(){function f(){var A,C=lt.call(arguments),G=n.apply(this,C),O=u.apply(this,C);G=+r.apply(this,(C[0]=G,C));var S=t.apply(this,C)-sf,E=z.apply(this,C)-sf,K=G*qm(S),H=G*rm(S);O=+r.apply(this,(C[0]=O,C));var L=
t.apply(this,C)-sf;C=z.apply(this,C)-sf;D||(D=A=Eb());D.moveTo(K,H);D.arc(0,0,G,S,E);if(S!==L||E!==C)D.quadraticCurveTo(0,0,O*qm(L),O*rm(L)),D.arc(0,0,O,L,C);D.quadraticCurveTo(0,0,K,H);D.closePath();if(A)return D=null,A+""||null}var n=Ip,u=Jp,r=Kp,t=Lp,z=Mp,D=null;f.radius=function(A){return arguments.length?(r="function"===typeof A?A:lg(+A),f):r};f.startAngle=function(A){return arguments.length?(t="function"===typeof A?A:lg(+A),f):t};f.endAngle=function(A){return arguments.length?(z="function"===
typeof A?A:lg(+A),f):z};f.source=function(A){return arguments.length?(n=A,f):n};f.target=function(A){return arguments.length?(u=A,f):u};f.context=function(A){return arguments.length?(D=null==A?null:A,f):D};return f};d3.nest=function(){function f(A,C,G,O){if(C>=u.length)return null!=t&&A.sort(t),null!=z?z(A):A;for(var S=-1,E=A.length,K=u[C++],H,L,U=rb(),M,X=G();++S<E;)(M=U.get(H=K(L=A[S])+""))?M.push(L):U.set(H,[L]);U.each(function(Y,W){O(X,W,f(Y,C,G,O))});return X}function n(A,C){if(++C>u.length)return A;
var G=r[C-1];if(null!=z&&C>=u.length)var O=A.entries();else O=[],A.each(function(S,E){O.push({key:E,values:n(S,C)})});return null!=G?O.sort(function(S,E){return G(S.key,E.key)}):O}var u=[],r=[],t,z,D;return D={object:function(A){return f(A,0,Np,Op)},map:function(A){return f(A,0,hj,ij)},entries:function(A){return n(f(A,0,hj,ij),0)},key:function(A){u.push(A);return D},sortKeys:function(A){r[u.length-1]=A;return D},sortValues:function(A){t=A;return D},rollup:function(A){z=A;return D}}};d3.set=jj;d3.map=
rb;d3.keys=function(f){var n=[],u;for(u in f)n.push(u);return n};d3.values=function(f){var n=[],u;for(u in f)n.push(f[u]);return n};d3.entries=function(f){var n=[],u;for(u in f)n.push({key:u,value:f[u]});return n};d3.color=Db;d3.rgb=hc;d3.hsl=Zd;d3.lab=$d;d3.hcl=ae;d3.lch=function(f,n,u,r){return 1===arguments.length?Ai(f):new jb(u,n,f,null==r?1:r)};d3.gray=function(f,n){return new cb(f,0,0,null==n?1:n)};d3.cubehelix=db;d3.contours=kj;d3.contourDensity=function(){function f(M){var X=new Float32Array(H*
L),Y=new Float32Array(H*L);M.forEach(function(W,ba,aa){var ha=+D(W,ba,aa)+K>>E,ea=+A(W,ba,aa)+K>>E;W=+C(W,ba,aa);0<=ha&&ha<H&&0<=ea&&ea<L&&(X[ha+ea*H]+=W)});ng({width:H,height:L,data:X},{width:H,height:L,data:Y},S>>E);og({width:H,height:L,data:Y},{width:H,height:L,data:X},S>>E);ng({width:H,height:L,data:X},{width:H,height:L,data:Y},S>>E);og({width:H,height:L,data:Y},{width:H,height:L,data:X},S>>E);ng({width:H,height:L,data:X},{width:H,height:L,data:Y},S>>E);og({width:H,height:L,data:Y},{width:H,height:L,
data:X},S>>E);M=U(X);Array.isArray(M)||(Y=hi(X),M=Nb(0,Y,M),M=Ta(0,Math.floor(Y/M)*M,M),M.shift());return kj().thresholds(M).size([H,L])(X).map(n)}function n(M){M.value*=Math.pow(2,-2*E);M.coordinates.forEach(u);return M}function u(M){M.forEach(r)}function r(M){M.forEach(t)}function t(M){M[0]=M[0]*Math.pow(2,E)-K;M[1]=M[1]*Math.pow(2,E)-K}function z(){K=3*S;H=G+2*K>>E;L=O+2*K>>E;return f}var D=Rp,A=Sp,C=Tp,G=960,O=500,S=20,E=2,K=3*S,H=G+2*K>>E,L=O+2*K>>E,U=Fb(20);f.x=function(M){return arguments.length?
(D="function"===typeof M?M:Fb(+M),f):D};f.y=function(M){return arguments.length?(A="function"===typeof M?M:Fb(+M),f):A};f.weight=function(M){return arguments.length?(C="function"===typeof M?M:Fb(+M),f):C};f.size=function(M){if(!arguments.length)return[G,O];var X=Math.ceil(M[0]),Y=Math.ceil(M[1]);if(!(0<=X||0<=X))throw Error("invalid size");return G=X,O=Y,z()};f.cellSize=function(M){if(!arguments.length)return 1<<E;if(!(1<=(M=+M)))throw Error("invalid cell size");return E=Math.floor(Math.log(M)/Math.LN2),
z()};f.thresholds=function(M){return arguments.length?(U="function"===typeof M?M:Array.isArray(M)?Fb(lj.call(M)):Fb(M),f):U};f.bandwidth=function(M){if(!arguments.length)return Math.sqrt(S*(S+1));if(!(0<=(M=+M)))throw Error("invalid bandwidth");return S=Math.round((Math.sqrt(4*M*M+1)-1)/2),z()};return f};d3.dispatch=Ob;d3.drag=function(){function f(W){W.on("mousedown.drag",n).filter(S).on("touchstart.drag",t).on("touchmove.drag",z).on("touchend.drag touchcancel.drag",D).style("touch-action","none").style("-webkit-tap-highlight-color",
"rgba(0,0,0,0)")}function n(){if(!X&&C.apply(this,arguments)){var W=A("mouse",G.apply(this,arguments),Bb,this,arguments);W&&(Ra(d3.event.view).on("mousemove.drag",u,!0).on("mouseup.drag",r,!0),Wd(d3.event.view),d3.event.stopImmediatePropagation(),M=!1,L=d3.event.clientX,U=d3.event.clientY,W("start"))}}function u(){fc();if(!M){var W=d3.event.clientX-L,ba=d3.event.clientY-U;M=W*W+ba*ba>Y}E.mouse("drag")}function r(){Ra(d3.event.view).on("mousemove.drag mouseup.drag",null);Xd(d3.event.view,M);fc();E.mouse("end")}
function t(){if(C.apply(this,arguments)){var W=d3.event.changedTouches,ba=G.apply(this,arguments),aa=W.length,ha,ea;for(ha=0;ha<aa;++ha)if(ea=A(W[ha].identifier,ba,Vd,this,arguments))d3.event.stopImmediatePropagation(),ea("start")}}function z(){var W=d3.event.changedTouches,ba=W.length,aa,ha;for(aa=0;aa<ba;++aa)if(ha=E[W[aa].identifier])fc(),ha("drag")}function D(){var W=d3.event.changedTouches,ba=W.length,aa,ha;X&&clearTimeout(X);X=setTimeout(function(){X=null},500);for(aa=0;aa<ba;++aa)if(ha=E[W[aa].identifier])d3.event.stopImmediatePropagation(),
ha("end")}function A(W,ba,aa,ha,ea){var la=aa(ba,W),pa,R,Z,fa=K.copy();if(Qc(new Qf(f,"beforestart",pa,W,H,la[0],la[1],0,0,fa),function(){if(null==(d3.event.subject=pa=O.apply(ha,ea)))return!1;R=pa.x-la[0]||0;Z=pa.y-la[1]||0;return!0}))return function ma(qa){var ya=la;switch(qa){case "start":E[W]=ma;var bb=H++;break;case "end":delete E[W],--H;case "drag":la=aa(ba,W),bb=H}Qc(new Qf(f,qa,pa,W,bb,la[0]+R,la[1]+Z,la[0]-ya[0],la[1]-ya[1],fa),fa.apply,fa,[qa,ha,ea])}}var C=Co,G=Do,O=Eo,S=Fo,E={},K=Ob("start",
"drag","end"),H=0,L,U,M,X,Y=0;f.filter=function(W){return arguments.length?(C="function"===typeof W?W:Yd(!!W),f):C};f.container=function(W){return arguments.length?(G="function"===typeof W?W:Yd(W),f):G};f.subject=function(W){return arguments.length?(O="function"===typeof W?W:Yd(W),f):O};f.touchable=function(W){return arguments.length?(S="function"===typeof W?W:Yd(!!W),f):S};f.on=function(){var W=K.on.apply(K,arguments);return W===K?f:W};f.clickDistance=function(W){return arguments.length?(Y=(W=+W)*
W,f):Math.sqrt(Y)};return f};d3.dragDisable=Wd;d3.dragEnable=Xd;d3.dsvFormat=oe;d3.csvParse=vm;d3.csvParseRows=nt;d3.csvFormat=ot;d3.csvFormatRows=pt;d3.tsvParse=wm;d3.tsvParseRows=qt;d3.tsvFormat=rt;d3.tsvFormatRows=st;d3.easeLinear=function(f){return+f};d3.easeQuad=Zi;d3.easeQuadIn=function(f){return f*f};d3.easeQuadOut=function(f){return f*(2-f)};d3.easeQuadInOut=Zi;d3.easeCubic=fg;d3.easeCubicIn=function(f){return f*f*f};d3.easeCubicOut=function(f){return--f*f*f+1};d3.easeCubicInOut=fg;d3.easePoly=
mm;d3.easePolyIn=dt;d3.easePolyOut=et;d3.easePolyInOut=mm;d3.easeSin=$i;d3.easeSinIn=function(f){return 1-Math.cos(f*nm)};d3.easeSinOut=function(f){return Math.sin(f*nm)};d3.easeSinInOut=$i;d3.easeExp=bj;d3.easeExpIn=function(f){return Math.pow(2,10*f-10)};d3.easeExpOut=function(f){return 1-Math.pow(2,-10*f)};d3.easeExpInOut=bj;d3.easeCircle=cj;d3.easeCircleIn=function(f){return 1-Math.sqrt(1-f*f)};d3.easeCircleOut=function(f){return Math.sqrt(1- --f*f)};d3.easeCircleInOut=cj;d3.easeBounce=$c;d3.easeBounceIn=
function(f){return 1-$c(1-f)};d3.easeBounceOut=$c;d3.easeBounceInOut=function(f){return(1>=(f*=2)?1-$c(1-f):$c(f-1)+1)/2};d3.easeBack=om;d3.easeBackIn=ft;d3.easeBackOut=gt;d3.easeBackInOut=om;d3.easeElastic=pm;d3.easeElasticIn=ht;d3.easeElasticOut=pm;d3.easeElasticInOut=it;d3.blob=function(f,n){return fetch(f,n).then(Wp)};d3.buffer=function(f,n){return fetch(f,n).then(Xp)};d3.dsv=function(f,n,u,r){3===arguments.length&&"function"===typeof u&&(r=u,u=void 0);var t=oe(f);return qg(n,u).then(function(z){return t.parse(z,
r)})};d3.csv=tt;d3.tsv=ut;d3.json=function(f,n){return fetch(f,n).then(Zp)};d3.text=qg;d3.forceCenter=function(f,n){function u(){var t,z=r.length,D=0,A=0;for(t=0;t<z;++t){var C=r[t];D+=C.x;A+=C.y}D=D/z-f;A=A/z-n;for(t=0;t<z;++t)C=r[t],C.x-=D,C.y-=A}var r;null==f&&(f=0);null==n&&(n=0);u.initialize=function(t){r=t};u.x=function(t){return arguments.length?(f=+t,u):f};u.y=function(t){return arguments.length?(n=+t,u):n};return u};d3.forceCollide=function(f){function n(){function C(X,Y,W,ba,aa){var ha=
X.data;X=X.r;var ea=L+X;if(ha)ha.index>E.index&&(Y=K-ha.x-ha.vx,W=H-ha.y-ha.vy,ba=Y*Y+W*W,ba<ea*ea&&(0===Y&&(Y=Gb(),ba+=Y*Y),0===W&&(W=Gb(),ba+=W*W),ba=(ea-(ba=Math.sqrt(ba)))/ba*D,E.vx+=(Y*=ba)*(ea=(X*=X)/(U+X)),E.vy+=(W*=ba)*ea,ha.vx-=Y*(ea=1-ea),ha.vy-=W*ea));else return Y>K+ea||ba<K-ea||W>H+ea||aa<H-ea}for(var G,O=t.length,S,E,K,H,L,U,M=0;M<A;++M)for(S=pe(t,bq,cq).visitAfter(u),G=0;G<O;++G)E=t[G],L=z[E.index],U=L*L,K=E.x+E.vx,H=E.y+E.vy,S.visit(C)}function u(C){if(C.data)return C.r=z[C.data.index];
for(var G=C.r=0;4>G;++G)C[G]&&C[G].r>C.r&&(C.r=C[G].r)}function r(){if(t){var C,G=t.length;z=Array(G);for(C=0;C<G;++C){var O=t[C];z[O.index]=+f(O,C,t)}}}var t,z,D=1,A=1;"function"!==typeof f&&(f=Ca(null==f?1:+f));n.initialize=function(C){t=C;r()};n.iterations=function(C){return arguments.length?(A=+C,n):A};n.strength=function(C){return arguments.length?(D=+C,n):D};n.radius=function(C){return arguments.length?(f="function"===typeof C?C:Ca(+C),r(),n):f};return n};d3.forceLink=function(f){function n(H){return 1/
Math.min(S[H.source.index],S[H.target.index])}function u(H){for(var L=0,U=f.length;L<K;++L)for(var M=0,X,Y,W,ba,aa;M<U;++M)X=f[M],Y=X.source,X=X.target,W=X.x+X.vx-Y.x-Y.vx||Gb(),ba=X.y+X.vy-Y.y-Y.vy||Gb(),aa=Math.sqrt(W*W+ba*ba),aa=(aa-G[M])/aa*H*A[M],W*=aa,ba*=aa,X.vx-=W*(aa=E[M]),X.vy-=ba*aa,Y.vx+=W*(aa=1-aa),Y.vy+=ba*aa}function r(){if(O){var H=O.length,L=f.length,U=rb(O,D);var M=0;for(S=Array(H);M<L;++M)H=f[M],H.index=M,"object"!==typeof H.source&&(H.source=rj(U,H.source)),"object"!==typeof H.target&&
(H.target=rj(U,H.target)),S[H.source.index]=(S[H.source.index]||0)+1,S[H.target.index]=(S[H.target.index]||0)+1;M=0;for(E=Array(L);M<L;++M)H=f[M],E[M]=S[H.source.index]/(S[H.source.index]+S[H.target.index]);A=Array(L);t();G=Array(L);z()}}function t(){if(O)for(var H=0,L=f.length;H<L;++H)A[H]=+n(f[H],H,f)}function z(){if(O)for(var H=0,L=f.length;H<L;++H)G[H]=+C(f[H],H,f)}var D=dq,A,C=Ca(30),G,O,S,E,K=1;null==f&&(f=[]);u.initialize=function(H){O=H;r()};u.links=function(H){return arguments.length?(f=
H,r(),u):f};u.id=function(H){return arguments.length?(D=H,u):D};u.iterations=function(H){return arguments.length?(K=+H,u):K};u.strength=function(H){return arguments.length?(n="function"===typeof H?H:Ca(+H),t(),u):n};u.distance=function(H){return arguments.length?(C="function"===typeof H?H:Ca(+H),z(),u):C};return u};d3.forceManyBody=function(){function f(E){var K,H=t.length,L=pe(t,eq,fq).visitAfter(u);D=E;for(K=0;K<H;++K)z=t[K],L.visit(r)}function n(){if(t){var E,K=t.length;C=Array(K);for(E=0;E<K;++E){var H=
t[E];C[H.index]=+A(H,E,t)}}}function u(E){var K=0,H,L,U=0,M,X,Y;if(E.length){for(M=X=Y=0;4>Y;++Y)(H=E[Y])&&(L=Math.abs(H.value))&&(K+=H.value,U+=L,M+=L*H.x,X+=L*H.y);E.x=M/U;E.y=X/U}else{H=E;H.x=H.data.x;H.y=H.data.y;do K+=C[H.data.index];while(H=H.next)}E.value=K}function r(E,K,H,L){if(!E.value)return!0;var U=E.x-z.x,M=E.y-z.y;K=L-K;L=U*U+M*M;if(K*K/S<L)return L<O&&(0===U&&(U=Gb(),L+=U*U),0===M&&(M=Gb(),L+=M*M),L<G&&(L=Math.sqrt(G*L)),z.vx+=U*E.value*D/L,z.vy+=M*E.value*D/L),!0;if(!(E.length||L>=
O)){if(E.data!==z||E.next)0===U&&(U=Gb(),L+=U*U),0===M&&(M=Gb(),L+=M*M),L<G&&(L=Math.sqrt(G*L));do E.data!==z&&(K=C[E.data.index]*D/L,z.vx+=U*K,z.vy+=M*K);while(E=E.next)}}var t,z,D,A=Ca(-30),C,G=1,O=Infinity,S=.81;f.initialize=function(E){t=E;n()};f.strength=function(E){return arguments.length?(A="function"===typeof E?E:Ca(+E),n(),f):A};f.distanceMin=function(E){return arguments.length?(G=E*E,f):Math.sqrt(G)};f.distanceMax=function(E){return arguments.length?(O=E*E,f):Math.sqrt(O)};f.theta=function(E){return arguments.length?
(S=E*E,f):Math.sqrt(S)};return f};d3.forceRadial=function(f,n,u){function r(G){for(var O=0,S=z.length;O<S;++O){var E=z[O],K=E.x-n||1E-6,H=E.y-u||1E-6,L=Math.sqrt(K*K+H*H);L=(C[O]-L)*A[O]*G/L;E.vx+=K*L;E.vy+=H*L}}function t(){if(z){var G,O=z.length;A=Array(O);C=Array(O);for(G=0;G<O;++G)C[G]=+f(z[G],G,z),A[G]=isNaN(C[G])?0:+D(z[G],G,z)}}var z,D=Ca(.1),A,C;"function"!==typeof f&&(f=Ca(+f));null==n&&(n=0);null==u&&(u=0);r.initialize=function(G){z=G;t()};r.strength=function(G){return arguments.length?
(D="function"===typeof G?G:Ca(+G),t(),r):D};r.radius=function(G){return arguments.length?(f="function"===typeof G?G:Ca(+G),t(),r):f};r.x=function(G){return arguments.length?(n=+G,r):n};r.y=function(G){return arguments.length?(u=+G,r):u};return r};d3.forceSimulation=function(f){function n(){u();K.call("tick",z);D<A&&(E.stop(),K.call("end",z))}function u(){var H,L=f.length;D+=(G-D)*C;S.each(function(M){M(D)});for(H=0;H<L;++H){var U=f[H];null==U.fx?U.x+=U.vx*=O:(U.x=U.fx,U.vx=0);null==U.fy?U.y+=U.vy*=
O:(U.y=U.fy,U.vy=0)}}function r(){for(var H=0,L=f.length,U;H<L;++H){U=f[H];U.index=H;if(isNaN(U.x)||isNaN(U.y)){var M=10*Math.sqrt(H),X=H*vt;U.x=M*Math.cos(X);U.y=M*Math.sin(X)}if(isNaN(U.vx)||isNaN(U.vy))U.vx=U.vy=0}}function t(H){H.initialize&&H.initialize(f);return H}var z,D=1,A=.001,C=1-Math.pow(A,1/300),G=0,O=.6,S=rb(),E=ee(n),K=Ob("tick","end");null==f&&(f=[]);r();return z={tick:u,restart:function(){return E.restart(n),z},stop:function(){return E.stop(),z},nodes:function(H){return arguments.length?
(f=H,r(),S.each(t),z):f},alpha:function(H){return arguments.length?(D=+H,z):D},alphaMin:function(H){return arguments.length?(A=+H,z):A},alphaDecay:function(H){return arguments.length?(C=+H,z):+C},alphaTarget:function(H){return arguments.length?(G=+H,z):G},velocityDecay:function(H){return arguments.length?(O=1-H,z):1-O},force:function(H,L){return 1<arguments.length?(null==L?S.remove(H):S.set(H,t(L)),z):S.get(H)},find:function(H,L,U){var M,X=f.length;U=null==U?Infinity:U*U;for(M=0;M<X;++M){var Y=f[M];
var W=H-Y.x;var ba=L-Y.y;W=W*W+ba*ba;if(W<U){var aa=Y;U=W}}return aa},on:function(H,L){return 1<arguments.length?(K.on(H,L),z):K.on(H)}}};d3.forceX=function(f){function n(A){for(var C=0,G=t.length,O;C<G;++C)O=t[C],O.vx+=(D[C]-O.x)*z[C]*A}function u(){if(t){var A,C=t.length;z=Array(C);D=Array(C);for(A=0;A<C;++A)z[A]=isNaN(D[A]=+f(t[A],A,t))?0:+r(t[A],A,t)}}var r=Ca(.1),t,z,D;"function"!==typeof f&&(f=Ca(null==f?0:+f));n.initialize=function(A){t=A;u()};n.strength=function(A){return arguments.length?
(r="function"===typeof A?A:Ca(+A),u(),n):r};n.x=function(A){return arguments.length?(f="function"===typeof A?A:Ca(+A),u(),n):f};return n};d3.forceY=function(f){function n(A){for(var C=0,G=t.length,O;C<G;++C)O=t[C],O.vy+=(D[C]-O.y)*z[C]*A}function u(){if(t){var A,C=t.length;z=Array(C);D=Array(C);for(A=0;A<C;++A)z[A]=isNaN(D[A]=+f(t[A],A,t))?0:+r(t[A],A,t)}}var r=Ca(.1),t,z,D;"function"!==typeof f&&(f=Ca(null==f?0:+f));n.initialize=function(A){t=A;u()};n.strength=function(A){return arguments.length?
(r="function"===typeof A?A:Ca(+A),u(),n):r};n.y=function(A){return arguments.length?(f="function"===typeof A?A:Ca(+A),u(),n):f};return n};d3.formatDefaultLocale=yj;d3.formatLocale=uj;d3.formatSpecifier=bd;d3.precisionFixed=zj;d3.precisionPrefix=Aj;d3.precisionRound=Bj;d3.geoArea=function(f){wf.reset();gb(f,lb);return 2*wf};d3.geoBounds=function(f){var n,u,r;Za=Aa=-(za=Wa=Infinity);Hb=[];gb(f,ub);if(n=Hb.length){Hb.sort(oq);f=1;var t=Hb[0];for(u=[t];f<n;++f){var z=Hb[f];Rj(t,z[0])||Rj(t,z[1])?(Xa(t[0],
z[1])>Xa(t[0],t[1])&&(t[1]=z[1]),Xa(z[0],t[1])>Xa(t[0],t[1])&&(t[0]=z[0])):u.push(t=z)}var D=-Infinity;n=u.length-1;f=0;for(t=u[n];f<=n;t=z,++f)z=u[f],(r=Xa(t[1],z[0]))>D&&(D=r,za=z[0],Aa=t[1])}Hb=tb=null;return Infinity===za||Infinity===Wa?[[NaN,NaN],[NaN,NaN]]:[[za,Wa],[Aa,Za]]};d3.geoCentroid=function(f){ed=Ce=ze=Ae=Be=De=Ee=Fe=Ag=Bg=Cg=0;gb(f,hb);f=Ag;var n=Bg,u=Cg,r=f*f+n*n+u*u;return 1E-12>r&&(f=De,n=Ee,u=Fe,1E-6>Ce&&(f=ze,n=Ae,u=Be),r=f*f+n*n+u*u,1E-12>r)?[NaN,NaN]:[Ma(n,f)*va,La(u/Ba(r))*
va]};d3.geoCircle=function(){function f(){var A=n.apply(this,arguments),C=u.apply(this,arguments)*ia,G=r.apply(this,arguments)*ia;t=[];z=Fg(-A[0]*ia,-A[1]*ia,0).invert;bk(D,C,G,1);A={type:"Polygon",coordinates:[t]};t=z=null;return A}var n=qc([0,0]),u=qc(90),r=qc(6),t,z,D={point:function(A,C){t.push(A=z(A,C));A[0]*=va;A[1]*=va}};f.center=function(A){return arguments.length?(n="function"===typeof A?A:qc([+A[0],+A[1]]),f):n};f.radius=function(A){return arguments.length?(u="function"===typeof A?A:qc(+A),
f):u};f.precision=function(A){return arguments.length?(r="function"===typeof A?A:qc(+A),f):r};return f};d3.geoClipAntimeridian=Xg;d3.geoClipCircle=ik;d3.geoClipExtent=function(){var f=0,n=0,u=960,r=500,t,z,D;return D={stream:function(A){return t&&z===A?t:t=Ie(f,n,u,r)(z=A)},extent:function(A){return arguments.length?(f=+A[0][0],n=+A[0][1],u=+A[1][0],r=+A[1][1],t=z=null,D):[[f,n],[u,r]]}}};d3.geoClipRectangle=Ie;d3.geoContains=function(f,n){return(f&&ym.hasOwnProperty(f.type)?ym[f.type]:Le)(f,n)};
d3.geoDistance=sc;d3.geoGraticule=qk;d3.geoGraticule10=function(){return qk()()};d3.geoInterpolate=function(f,n){var u=f[0]*ia,r=f[1]*ia;f=n[0]*ia;n=n[1]*ia;var t=da(r),z=ca(r),D=da(n),A=ca(n),C=t*da(u),G=t*ca(u),O=D*da(f),S=D*ca(f),E=2*La(Ba(Ej(n-r)+t*D*Ej(f-u))),K=ca(E);f=E?function(H){var L=ca(H*=E)/K,U=ca(E-H)/K;H=U*C+L*O;var M=U*G+L*S;L=U*z+L*A;return[Ma(M,H)*va,Ma(L,Ba(H*H+M*M))*va]}:function(){return[u*va,r*va]};f.distance=E;return f};d3.geoLength=jk;d3.geoPath=function(f,n){function u(D){D&&
("function"===typeof r&&z.pointRadius(+r.apply(this,arguments)),gb(D,t(z)));return z.result()}var r=4.5,t,z;u.area=function(D){gb(D,t(vb));return vb.result()};u.measure=function(D){gb(D,t(hd));return hd.result()};u.bounds=function(D){gb(D,t(Pe));return Pe.result()};u.centroid=function(D){gb(D,t($a));return $a.result()};u.projection=function(D){return arguments.length?(t=null==D?(f=null,Xb):(f=D).stream,u):f};u.context=function(D){if(!arguments.length)return n;z=null==D?(n=null,new Dk):new zk(n=D);
"function"!==typeof r&&z.pointRadius(r);return u};u.pointRadius=function(D){if(!arguments.length)return r;r="function"===typeof D?D:(z.pointRadius(+D),+D);return u};return u.projection(f).context(n)};d3.geoAlbers=Jk;d3.geoAlbersUsa=function(){function f(E){var K=E[0];E=E[1];return O=null,(z.point(K,E),O)||(A.point(K,E),O)||(G.point(K,E),O)}function n(){u=r=null;return f}var u,r,t=Jk(),z,D=Qe().rotate([154,0]).center([-2,58.5]).parallels([55,65]),A,C=Qe().rotate([157,0]).center([-3,19.9]).parallels([8,
18]),G,O,S={point:function(E,K){O=[E,K]}};f.invert=function(E){var K=t.scale(),H=t.translate(),L=(E[0]-H[0])/K;K=(E[1]-H[1])/K;return(.12<=K&&.234>K&&-.425<=L&&-.214>L?D:.166<=K&&.234>K&&-.214<=L&&-.115>L?C:t).invert(E)};f.stream=function(E){return u&&r===E?u:u=Qq([t.stream(r=E),D.stream(E),C.stream(E)])};f.precision=function(E){if(!arguments.length)return t.precision();t.precision(E);D.precision(E);C.precision(E);return n()};f.scale=function(E){if(!arguments.length)return t.scale();t.scale(E);D.scale(.35*
E);C.scale(E);return f.translate(t.translate())};f.translate=function(E){if(!arguments.length)return t.translate();var K=t.scale(),H=+E[0],L=+E[1];z=t.translate(E).clipExtent([[H-.455*K,L-.238*K],[H+.455*K,L+.238*K]]).stream(S);A=D.translate([H-.307*K,L+.201*K]).clipExtent([[H-.425*K+1E-6,L+.12*K+1E-6],[H-.214*K-1E-6,L+.234*K-1E-6]]).stream(S);G=C.translate([H-.205*K,L+.212*K]).clipExtent([[H-.214*K+1E-6,L+.166*K+1E-6],[H-.115*K-1E-6,L+.234*K-1E-6]]).stream(S);return n()};f.fitExtent=function(E,K){return uc(f,
E,K)};f.fitSize=function(E,K){return uc(f,[[0,0],E],K)};f.fitWidth=function(E,K){return Ug(f,E,K)};f.fitHeight=function(E,K){return Vg(f,E,K)};return f.scale(1070)};d3.geoAzimuthalEqualArea=function(){return ob(Qh).scale(124.75).clipAngle(179.999)};d3.geoAzimuthalEqualAreaRaw=Qh;d3.geoAzimuthalEquidistant=function(){return ob(Rh).scale(79.4188).clipAngle(179.999)};d3.geoAzimuthalEquidistantRaw=Rh;d3.geoConicConformal=function(){return Yg(Mk).scale(109.5).parallels([30,30])};d3.geoConicConformalRaw=
Mk;d3.geoConicEqualArea=Qe;d3.geoConicEqualAreaRaw=Ik;d3.geoConicEquidistant=function(){return Yg(Nk).scale(131.154).center([0,13.9389])};d3.geoConicEquidistantRaw=Nk;d3.geoEqualEarth=function(){return ob($g).scale(177.158)};d3.geoEqualEarthRaw=$g;d3.geoEquirectangular=function(){return ob(od).scale(152.63)};d3.geoEquirectangularRaw=od;d3.geoGnomonic=function(){return ob(ah).scale(144.049).clipAngle(60)};d3.geoGnomonicRaw=ah;d3.geoIdentity=function(){function f(){E=K=null;return H}var n=1,u=0,r=0,
t=1,z=1,D=Xb,A=null,C,G,O,S=Xb,E,K,H;return H={stream:function(L){return E&&K===L?E:E=D(S(K=L))},postclip:function(L){return arguments.length?(S=L,A=C=G=O=null,f()):S},clipExtent:function(L){return arguments.length?(S=null==L?(A=C=G=O=null,Xb):Ie(A=+L[0][0],C=+L[0][1],G=+L[1][0],O=+L[1][1]),f()):null==A?null:[[A,C],[G,O]]},scale:function(L){return arguments.length?(D=Te((n=+L)*t,n*z,u,r),f()):n},translate:function(L){return arguments.length?(D=Te(n*t,n*z,u=+L[0],r=+L[1]),f()):[u,r]},reflectX:function(L){return arguments.length?
(D=Te(n*(t=L?-1:1),n*z,u,r),f()):0>t},reflectY:function(L){return arguments.length?(D=Te(n*t,n*(z=L?-1:1),u,r),f()):0>z},fitExtent:function(L,U){return uc(H,L,U)},fitSize:function(L,U){return uc(H,[[0,0],L],U)},fitWidth:function(L,U){return Ug(H,L,U)},fitHeight:function(L,U){return Vg(H,L,U)}}};d3.geoProjection=ob;d3.geoProjectionMutator=Wg;d3.geoMercator=function(){return Lk(nd).scale(961/Sa)};d3.geoMercatorRaw=nd;d3.geoNaturalEarth1=function(){return ob(bh).scale(175.295)};d3.geoNaturalEarth1Raw=
bh;d3.geoOrthographic=function(){return ob(ch).scale(249.5).clipAngle(90.000001)};d3.geoOrthographicRaw=ch;d3.geoStereographic=function(){return ob(dh).scale(250).clipAngle(142)};d3.geoStereographicRaw=dh;d3.geoTransverseMercator=function(){var f=Lk(eh),n=f.center,u=f.rotate;f.center=function(r){return arguments.length?n([-r[1],r[0]]):(r=n(),[r[1],-r[0]])};f.rotate=function(r){return arguments.length?u([r[0],r[1],2<r.length?r[2]+90:90]):(r=u(),[r[0],r[1],r[2]-90])};return u([0,0,90]).scale(159.155)};
d3.geoTransverseMercatorRaw=eh;d3.geoRotation=ak;d3.geoStream=gb;d3.geoTransform=function(f){return{stream:kd(f)}};d3.cluster=function(){function f(z){var D,A=0;z.eachAfter(function(E){var K=E.children;if(K){var H=K.reduce(Sq,0)/K.length;E.x=H;E.y=1+K.reduce(Tq,0)}else E.x=D?A+=n(E,D):0,E.y=0,D=E});var C=Uq(z),G=Vq(z),O=C.x-n(C,G)/2,S=G.x+n(G,C)/2;return z.eachAfter(t?function(E){E.x=(E.x-z.x)*u;E.y=(z.y-E.y)*r}:function(E){E.x=(E.x-O)/(S-O)*u;E.y=(1-(z.y?E.y/z.y:1))*r})}var n=Rq,u=1,r=1,t=!1;f.separation=
function(z){return arguments.length?(n=z,f):n};f.size=function(z){return arguments.length?(t=!1,u=+z[0],r=+z[1],f):t?null:[u,r]};f.nodeSize=function(z){return arguments.length?(t=!0,u=+z[0],r=+z[1],f):t?[u,r]:null};return f};d3.hierarchy=fh;d3.pack=function(){function f(z){z.x=u/2;z.y=r/2;n?z.eachBefore(Wk(n)).eachAfter(hh(t,.5)).eachBefore(Xk(1)):z.eachBefore(Wk($q)).eachAfter(hh(Zb,1)).eachAfter(hh(t,z.r/Math.min(u,r))).eachBefore(Xk(Math.min(u,r)/(2*z.r)));return z}var n=null,u=1,r=1,t=Zb;f.radius=
function(z){return arguments.length?(n=null==z?null:We(z),f):n};f.size=function(z){return arguments.length?(u=+z[0],r=+z[1],f):[u,r]};f.padding=function(z){return arguments.length?(t="function"===typeof z?z:yc(+z),f):t};return f};d3.packSiblings=function(f){Vk(f);return f};d3.packEnclose=Pk;d3.partition=function(){function f(D){var A=D.height+1;D.x0=D.y0=t;D.x1=u;D.y1=r/A;D.eachBefore(n(r,A));z&&D.eachBefore(Yk);return D}function n(D,A){return function(C){C.children&&qd(C,C.x0,D*(C.depth+1)/A,C.x1,
D*(C.depth+2)/A);var G=C.x0,O=C.y0,S=C.x1-t,E=C.y1-t;S<G&&(G=S=(G+S)/2);E<O&&(O=E=(O+E)/2);C.x0=G;C.y0=O;C.x1=S;C.y1=E}}var u=1,r=1,t=0,z=!1;f.round=function(D){return arguments.length?(z=!!D,f):z};f.size=function(D){return arguments.length?(u=+D[0],r=+D[1],f):[u,r]};f.padding=function(D){return arguments.length?(t=+D,f):t};return f};d3.stratify=function(){function f(r){var t,z=r.length,D=Array(z),A,C={};for(t=0;t<z;++t){var G=r[t];var O=D[t]=new xc(G);null!=(A=n(G,t,r))&&(A+="")&&(G="$"+(O.id=A),
C[G]=G in C?zm:O)}for(t=0;t<z;++t)if(O=D[t],A=u(r[t],t,r),null!=A&&(A+="")){G=C["$"+A];if(!G)throw Error("missing: "+A);if(G===zm)throw Error("ambiguous: "+A);G.children?G.children.push(O):G.children=[O];O.parent=G}else{if(S)throw Error("multiple roots");var S=O}if(!S)throw Error("no root");S.parent=wt;S.eachBefore(function(E){E.depth=E.parent.depth+1;--z}).eachBefore(Ok);S.parent=null;if(0<z)throw Error("cycle");return S}var n=ar,u=br;f.id=function(r){return arguments.length?(n=We(r),f):n};f.parentId=
function(r){return arguments.length?(u=We(r),f):u};return f};d3.tree=function(){function f(C){var G=dr(C);G.eachAfter(n);G.parent.m=-G.z;G.eachBefore(u);if(A)C.eachBefore(r);else{var O=C,S=C,E=C;C.eachBefore(function(U){U.x<O.x&&(O=U);U.x>S.x&&(S=U);U.depth>E.depth&&(E=U)});G=O===S?1:t(O,S)/2;var K=G-O.x,H=z/(S.x+G+K),L=D/(E.depth||1);C.eachBefore(function(U){U.x=(U.x+K)*H;U.y=U.depth*L})}return C}function n(C){var G=C.children,O=C.parent.children,S=C.i?O[C.i-1]:null;if(G){for(var E=0,K=0,H=C.children,
L=H.length,U;0<=--L;)U=H[L],U.z+=E,U.m+=E,E+=U.s+(K+=U.c);G=(G[0].z+G[G.length-1].z)/2;S?(C.z=S.z+t(C._,S._),C.m=C.z-G):C.z=G}else S&&(C.z=S.z+t(C._,S._));G=C.parent;O=C.parent.A||O[0];if(S){K=E=C;H=E.parent.children[0];L=E.m;U=K.m;for(var M=S.m,X=H.m,Y;S=jh(S),E=ih(E),S&&E;){H=ih(H);K=jh(K);K.a=C;Y=S.z+M-E.z-L+t(S._,E._);if(0<Y){var W=S.a.parent===C.parent?S.a:O,ba=C,aa=Y,ha=aa/(ba.i-W.i);ba.c-=ha;ba.s+=aa;W.c+=ha;ba.z+=aa;ba.m+=aa;L+=Y;U+=Y}M+=S.m;L+=E.m;X+=H.m;U+=K.m}S&&!jh(K)&&(K.t=S,K.m+=M-U);
E&&!ih(H)&&(H.t=E,H.m+=L-X,O=C)}G.A=O}function u(C){C._.x=C.z+C.parent.m;C.m+=C.parent.m}function r(C){C.x*=z;C.y=C.depth*D}var t=cr,z=1,D=1,A=null;f.separation=function(C){return arguments.length?(t=C,f):t};f.size=function(C){return arguments.length?(A=!1,z=+C[0],D=+C[1],f):A?null:[z,D]};f.nodeSize=function(C){return arguments.length?(A=!0,z=+C[0],D=+C[1],f):A?[z,D]:null};return f};d3.treemap=function(){function f(E){E.x0=E.y0=0;E.x1=t;E.y1=z;E.eachBefore(n);D=[0];r&&E.eachBefore(Yk);return E}function n(E){var K=
D[E.depth],H=E.x0+K,L=E.y0+K,U=E.x1-K,M=E.y1-K;U<H&&(H=U=(H+U)/2);M<L&&(L=M=(L+M)/2);E.x0=H;E.y0=L;E.x1=U;E.y1=M;E.children&&(K=D[E.depth+1]=A(E)/2,H+=S(E)-K,L+=C(E)-K,U-=G(E)-K,M-=O(E)-K,U<H&&(H=U=(H+U)/2),M<L&&(L=M=(L+M)/2),u(E,H,L,U,M))}var u=Bm,r=!1,t=1,z=1,D=[0],A=Zb,C=Zb,G=Zb,O=Zb,S=Zb;f.round=function(E){return arguments.length?(r=!!E,f):r};f.size=function(E){return arguments.length?(t=+E[0],z=+E[1],f):[t,z]};f.tile=function(E){return arguments.length?(u=We(E),f):u};f.padding=function(E){return arguments.length?
f.paddingInner(E).paddingOuter(E):f.paddingInner()};f.paddingInner=function(E){return arguments.length?(A="function"===typeof E?E:yc(+E),f):A};f.paddingOuter=function(E){return arguments.length?f.paddingTop(E).paddingRight(E).paddingBottom(E).paddingLeft(E):f.paddingTop()};f.paddingTop=function(E){return arguments.length?(C="function"===typeof E?E:yc(+E),f):C};f.paddingRight=function(E){return arguments.length?(G="function"===typeof E?E:yc(+E),f):G};f.paddingBottom=function(E){return arguments.length?
(O="function"===typeof E?E:yc(+E),f):O};f.paddingLeft=function(E){return arguments.length?(S="function"===typeof E?E:yc(+E),f):S};return f};d3.treemapBinary=function(f,n,u,r,t){function z(S,E,K,H,L,U,M){if(S>=E-1)S=D[S],S.x0=H,S.y0=L,S.x1=U,S.y1=M;else{for(var X=O[S],Y=K/2+X,W=S+1,ba=E-1;W<ba;){var aa=W+ba>>>1;O[aa]<Y?W=aa+1:ba=aa}Y-O[W-1]<O[W]-Y&&S+1<W&&--W;X=O[W]-X;Y=K-X;U-H>M-L?(K=(H*Y+U*X)/K,z(S,W,X,H,L,K,M),z(W,E,Y,K,L,U,M)):(K=(L*Y+M*X)/K,z(S,W,X,H,L,U,K),z(W,E,Y,H,K,U,M))}}var D=f.children,
A,C=D.length,G,O=Array(C+1);for(O[0]=G=A=0;A<C;++A)O[A+1]=G+=D[A].value;z(0,C,f.value,n,u,r,t)};d3.treemapDice=qd;d3.treemapSlice=Ye;d3.treemapSliceDice=function(f,n,u,r,t){(f.depth&1?Ye:qd)(f,n,u,r,t)};d3.treemapSquarify=Bm;d3.treemapResquarify=xt;d3.interpolate=Sc;d3.interpolateArray=Ii;d3.interpolateBasis=Ei;d3.interpolateBasisClosed=Fi;d3.interpolateDate=Ji;d3.interpolateDiscrete=function(f){var n=f.length;return function(u){return f[Math.max(0,Math.min(n-1,Math.floor(u*n)))]}};d3.interpolateHue=
function(f,n){var u=ce(+f,+n);return function(r){r=u(r);return r-360*Math.floor(r/360)}};d3.interpolateNumber=Va;d3.interpolateObject=Ki;d3.interpolateRound=Li;d3.interpolateString=Zf;d3.interpolateTransformCss=jm;d3.interpolateTransformSvg=km;d3.interpolateZoom=Qi;d3.interpolateRgb=Tc;d3.interpolateRgbBasis=Bl;d3.interpolateRgbBasisClosed=Xs;d3.interpolateHsl=Ys;d3.interpolateHslLong=Zs;d3.interpolateLab=function(f,n){var u=Ea((f=$d(f)).l,(n=$d(n)).l),r=Ea(f.a,n.a),t=Ea(f.b,n.b),z=Ea(f.opacity,n.opacity);
return function(D){f.l=u(D);f.a=r(D);f.b=t(D);f.opacity=z(D);return f+""}};d3.interpolateHcl=$s;d3.interpolateHclLong=at;d3.interpolateCubehelix=bt;d3.interpolateCubehelixLong=rf;d3.piecewise=function(f,n){for(var u=0,r=n.length-1,t=n[0],z=Array(0>r?0:r);u<r;)z[u]=f(t,t=n[++u]);return function(D){var A=Math.max(0,Math.min(r-1,Math.floor(D*=r)));return z[A](D-A)}};d3.quantize=function(f,n){for(var u=Array(n),r=0;r<n;++r)u[r]=f(r/(n-1));return u};d3.path=Eb;d3.polygonArea=function(f){for(var n=-1,u=
f.length,r,t=f[u-1],z=0;++n<u;)r=t,t=f[n],z+=r[1]*t[0]-r[0]*t[1];return z/2};d3.polygonCentroid=function(f){for(var n=-1,u=f.length,r=0,t=0,z,D=f[u-1],A,C=0;++n<u;)z=D,D=f[n],C+=A=z[0]*D[1]-D[0]*z[1],r+=(z[0]+D[0])*A,t+=(z[1]+D[1])*A;return C*=3,[r/C,t/C]};d3.polygonHull=function(f){if(3>(u=f.length))return null;var n,u,r=Array(u),t=Array(u);for(n=0;n<u;++n)r[n]=[+f[n][0],+f[n][1],n];r.sort(fr);for(n=0;n<u;++n)t[n]=[r[n][0],-r[n][1]];u=$k(r);t=$k(t);var z=t[0]===u[0],D=t[t.length-1]===u[u.length-
1],A=[];for(n=u.length-1;0<=n;--n)A.push(f[r[u[n]][2]]);for(n=+z;n<t.length-D;++n)A.push(f[r[t[n]][2]]);return A};d3.polygonContains=function(f,n){var u=f.length,r=f[u-1],t=n[0];n=n[1];for(var z=r[0],D=r[1],A,C=!1,G=0;G<u;++G)r=f[G],A=r[0],r=r[1],r>n!==D>n&&t<(z-A)*(n-r)/(D-r)+A&&(C=!C),z=A,D=r;return C};d3.polygonLength=function(f){var n=-1,u=f.length,r=f[u-1],t=r[0];r=r[1];for(var z=0;++n<u;){var D=t;var A=r;r=f[n];t=r[0];r=r[1];D-=t;A-=r;z+=Math.sqrt(D*D+A*A)}return z};d3.quadtree=pe;d3.randomUniform=
yt;d3.randomNormal=Cm;d3.randomLogNormal=zt;d3.randomBates=At;d3.randomIrwinHall=Dm;d3.randomExponential=Bt;d3.scaleBand=mh;d3.scalePoint=function(){return al(mh().paddingInner(1))};d3.scaleIdentity=el;d3.scaleLinear=dl;d3.scaleLog=jl;d3.scaleOrdinal=kh;d3.scaleImplicit=lh;d3.scalePow=qh;d3.scaleSqrt=function(){return qh().exponent(.5)};d3.scaleQuantile=kl;d3.scaleQuantize=ll;d3.scaleThreshold=ml;d3.scaleTime=function(){return th(wb,Uh,yd,vd,Th,Sh,Nd,dc,d3.timeFormat).domain([new Date(2E3,0,1),new Date(2E3,
0,2)])};d3.scaleUtc=function(){return th(xb,Xh,Ad,td,Wh,Vh,Nd,dc,d3.utcFormat).domain([Date.UTC(2E3,0,1),Date.UTC(2E3,0,2)])};d3.scaleSequential=zl;d3.scaleDiverging=Al;d3.schemeCategory10=$t;d3.schemeCategory20b=au;d3.schemeCategory20c=bu;d3.schemeCategory20=cu;d3.schemeAccent=du;d3.schemeDark2=eu;d3.schemePaired=fu;d3.schemePastel1=gu;d3.schemePastel2=hu;d3.schemeSet1=iu;d3.schemeSet2=ju;d3.schemeSet3=ku;d3.interpolateBrBG=lu;d3.schemeBrBG=Rm;d3.interpolatePRGn=mu;d3.schemePRGn=Sm;d3.interpolatePiYG=
nu;d3.schemePiYG=Tm;d3.interpolatePuOr=ou;d3.schemePuOr=Um;d3.interpolateRdBu=pu;d3.schemeRdBu=Vm;d3.interpolateRdGy=qu;d3.schemeRdGy=Wm;d3.interpolateRdYlBu=ru;d3.schemeRdYlBu=Xm;d3.interpolateRdYlGn=su;d3.schemeRdYlGn=Ym;d3.interpolateSpectral=tu;d3.schemeSpectral=Zm;d3.interpolateBuGn=uu;d3.schemeBuGn=$m;d3.interpolateBuPu=vu;d3.schemeBuPu=an;d3.interpolateGnBu=wu;d3.schemeGnBu=bn;d3.interpolateOrRd=xu;d3.schemeOrRd=cn;d3.interpolatePuBuGn=yu;d3.schemePuBuGn=dn;d3.interpolatePuBu=zu;d3.schemePuBu=
en;d3.interpolatePuRd=Au;d3.schemePuRd=fn;d3.interpolateRdPu=Bu;d3.schemeRdPu=gn;d3.interpolateYlGnBu=Cu;d3.schemeYlGnBu=hn;d3.interpolateYlGn=Du;d3.schemeYlGn=jn;d3.interpolateYlOrBr=Eu;d3.schemeYlOrBr=kn;d3.interpolateYlOrRd=Fu;d3.schemeYlOrRd=ln;d3.interpolateBlues=Gu;d3.schemeBlues=mn;d3.interpolateGreens=Hu;d3.schemeGreens=nn;d3.interpolateGreys=Iu;d3.schemeGreys=on;d3.interpolatePurples=Ju;d3.schemePurples=pn;d3.interpolateReds=Ku;d3.schemeReds=qn;d3.interpolateOranges=Lu;d3.schemeOranges=rn;
d3.interpolateCubehelixDefault=Mu;d3.interpolateRainbow=function(f){if(0>f||1<f)f-=Math.floor(f);var n=Math.abs(f-.5);zf.h=360*f-100;zf.s=1.5-1.5*n;zf.l=.8-.9*n;return zf+""};d3.interpolateWarm=Nu;d3.interpolateCool=Ou;d3.interpolateSinebow=function(f){var n;f=(.5-f)*Math.PI;Af.r=255*(n=Math.sin(f))*n;Af.g=255*(n=Math.sin(f+Pu))*n;Af.b=255*(n=Math.sin(f+Qu))*n;return Af+""};d3.interpolateViridis=Ru;d3.interpolateMagma=Su;d3.interpolateInferno=Tu;d3.interpolatePlasma=Uu;d3.create=function(f){return Ra(Rd(f).call(document.documentElement))};
d3.creator=Rd;d3.local=si;d3.matcher=Ih;d3.mouse=Bb;d3.namespace=Pc;d3.namespaces=Ua;d3.clientPoint=Ud;d3.select=Ra;d3.selectAll=function(f){return"string"===typeof f?new Ja([document.querySelectorAll(f)],[document.documentElement]):new Ja([null==f?[]:f],Nf)};d3.selection=Qb;d3.selector=Sd;d3.selectorAll=Kf;d3.style=Pb;d3.touch=Vd;d3.touches=function(f,n){null==n&&(n=Pf().touches);for(var u=0,r=n?n.length:0,t=Array(r);u<r;++u)t[u]=Ud(f,n[u]);return t};d3.window=Lf;d3.customEvent=Qc;d3.arc=function(){function f(){var G,
O=+n.apply(this,arguments),S=+u.apply(this,arguments),E=z.apply(this,arguments)-cf,K=D.apply(this,arguments)-cf,H=sn(K-E),L=K>E;C||(C=G=Eb());if(S<O){var U=S;S=O;O=U}if(1E-12<S)if(H>Lb-1E-12)C.moveTo(S*ec(E),S*pb(E)),C.arc(0,0,S,E,K,!L),1E-12<O&&(C.moveTo(O*ec(K),O*pb(K)),C.arc(0,0,O,K,E,L));else{var M=E,X=K;U=E;var Y=K,W=H,ba=H,aa=A.apply(this,arguments)/2,ha=1E-12<aa&&(t?+t.apply(this,arguments):Dc(O*O+S*S)),ea=Yh(sn(S-O)/2,+r.apply(this,arguments)),la=ea,pa=ea;if(1E-12<ha){var R=Cl(ha/O*pb(aa));
aa=Cl(ha/S*pb(aa));1E-12<(W-=2*R)?(R*=L?1:-1,U+=R,Y-=R):(W=0,U=Y=(E+K)/2);1E-12<(ba-=2*aa)?(aa*=L?1:-1,M+=aa,X-=aa):(ba=0,M=X=(E+K)/2)}E=S*ec(M);K=S*pb(M);R=O*ec(Y);aa=O*pb(Y);if(1E-12<ea){var Z=S*ec(X),fa=S*pb(X),ja=O*ec(U),qa=O*pb(U);if(H<Kb){1E-12<W?(la=ja-E,pa=qa-K,H=R-Z,ha=aa-fa,H=(H*(K-fa)-ha*(E-Z))/(ha*la-H*pa),la=[E+H*la,K+H*pa]):la=[R,aa];pa=E-la[0];H=K-la[1];ha=Z-la[0];var ma=fa-la[1];pa=(pa*ha+H*ma)/(Dc(pa*pa+H*H)*Dc(ha*ha+ma*ma));pa=1/pb((1<pa?0:-1>pa?Kb:Math.acos(pa))/2);H=Dc(la[0]*la[0]+
la[1]*la[1]);la=Yh(ea,(O-H)/(pa-1));pa=Yh(ea,(S-H)/(pa+1))}}1E-12<ba?1E-12<pa?(M=df(ja,qa,E,K,S,pa,L),X=df(Z,fa,R,aa,S,pa,L),C.moveTo(M.cx+M.x01,M.cy+M.y01),pa<ea?C.arc(M.cx,M.cy,pa,Ia(M.y01,M.x01),Ia(X.y01,X.x01),!L):(C.arc(M.cx,M.cy,pa,Ia(M.y01,M.x01),Ia(M.y11,M.x11),!L),C.arc(0,0,S,Ia(M.cy+M.y11,M.cx+M.x11),Ia(X.cy+X.y11,X.cx+X.x11),!L),C.arc(X.cx,X.cy,pa,Ia(X.y11,X.x11),Ia(X.y01,X.x01),!L))):(C.moveTo(E,K),C.arc(0,0,S,M,X,!L)):C.moveTo(E,K);1E-12<O&&1E-12<W?1E-12<la?(M=df(R,aa,Z,fa,O,-la,L),X=
df(E,K,ja,qa,O,-la,L),C.lineTo(M.cx+M.x01,M.cy+M.y01),la<ea?C.arc(M.cx,M.cy,la,Ia(M.y01,M.x01),Ia(X.y01,X.x01),!L):(C.arc(M.cx,M.cy,la,Ia(M.y01,M.x01),Ia(M.y11,M.x11),!L),C.arc(0,0,O,Ia(M.cy+M.y11,M.cx+M.x11),Ia(X.cy+X.y11,X.cx+X.x11),L),C.arc(X.cx,X.cy,la,Ia(X.y11,X.x11),Ia(X.y01,X.x01),!L))):C.arc(0,0,O,Y,U,L):C.lineTo(R,aa)}else C.moveTo(0,0);C.closePath();if(G)return C=null,G+""||null}var n=ps,u=qs,r=na(0),t=null,z=rs,D=ss,A=ts,C=null;f.centroid=function(){var G=(+n.apply(this,arguments)+ +u.apply(this,
arguments))/2,O=(+z.apply(this,arguments)+ +D.apply(this,arguments))/2-Kb/2;return[ec(O)*G,pb(O)*G]};f.innerRadius=function(G){return arguments.length?(n="function"===typeof G?G:na(+G),f):n};f.outerRadius=function(G){return arguments.length?(u="function"===typeof G?G:na(+G),f):u};f.cornerRadius=function(G){return arguments.length?(r="function"===typeof G?G:na(+G),f):r};f.padRadius=function(G){return arguments.length?(t=null==G?null:"function"===typeof G?G:na(+G),f):t};f.startAngle=function(G){return arguments.length?
(z="function"===typeof G?G:na(+G),f):z};f.endAngle=function(G){return arguments.length?(D="function"===typeof G?G:na(+G),f):D};f.padAngle=function(G){return arguments.length?(A="function"===typeof G?G:na(+G),f):A};f.context=function(G){return arguments.length?(C=null==G?null:G,f):C};return f};d3.area=El;d3.line=wh;d3.pie=function(){function f(A){var C,G=A.length;var O=0;var S=Array(G),E=Array(G),K=+t.apply(this,arguments);var H=Math.min(Lb,Math.max(-Lb,z.apply(this,arguments)-K));var L=Math.min(Math.abs(H)/
G,D.apply(this,arguments)),U=L*(0>H?-1:1),M;for(C=0;C<G;++C)0<(M=E[S[C]=C]=+n(A[C],C,A))&&(O+=M);null!=u?S.sort(function(Y,W){return u(E[Y],E[W])}):null!=r&&S.sort(function(Y,W){return r(A[Y],A[W])});C=0;for(H=O?(H-G*U)/O:0;C<G;++C,K=X){O=S[C];M=E[O];var X=K+(0<M?M*H:0)+U;E[O]={data:A[O],index:C,value:M,startAngle:K,endAngle:X,padAngle:L}}return E}var n=ws,u=vs,r=null,t=na(0),z=na(Lb),D=na(0);f.value=function(A){return arguments.length?(n="function"===typeof A?A:na(+A),f):n};f.sortValues=function(A){return arguments.length?
(u=A,r=null,f):u};f.sort=function(A){return arguments.length?(r=A,u=null,f):r};f.startAngle=function(A){return arguments.length?(t="function"===typeof A?A:na(+A),f):t};f.endAngle=function(A){return arguments.length?(z="function"===typeof A?A:na(+A),f):z};f.padAngle=function(A){return arguments.length?(D="function"===typeof A?A:na(+A),f):D};return f};d3.areaRadial=Il;d3.radialArea=Il;d3.lineRadial=Gl;d3.radialLine=Gl;d3.pointRadial=Dd;d3.linkHorizontal=function(){return yh(zs)};d3.linkVertical=function(){return yh(As)};
d3.linkRadial=function(){var f=yh(Bs);f.angle=f.x;delete f.x;f.radius=f.y;delete f.y;return f};d3.symbol=function(){function f(){var t;r||(r=t=Eb());n.apply(this,arguments).draw(r,+u.apply(this,arguments));if(t)return r=null,t+""||null}var n=na(Zh),u=na(64),r=null;f.type=function(t){return arguments.length?(n="function"===typeof t?t:na(t),f):n};f.size=function(t){return arguments.length?(u="function"===typeof t?t:na(+t),f):u};f.context=function(t){return arguments.length?(r=null==t?null:t,f):r};return f};
d3.symbols=Zu;d3.symbolCircle=Zh;d3.symbolCross=tn;d3.symbolDiamond=vn;d3.symbolSquare=yn;d3.symbolStar=xn;d3.symbolTriangle=zn;d3.symbolWye=An;d3.curveBasisClosed=function(f){return new Jl(f)};d3.curveBasisOpen=function(f){return new Kl(f)};d3.curveBasis=function(f){return new gf(f)};d3.curveBundle=$u;d3.curveCardinalClosed=bv;d3.curveCardinalOpen=cv;d3.curveCardinal=av;d3.curveCatmullRomClosed=ev;d3.curveCatmullRomOpen=fv;d3.curveCatmullRom=dv;d3.curveLinearClosed=function(f){return new Pl(f)};
d3.curveLinear=ef;d3.curveMonotoneX=function(f){return new jf(f)};d3.curveMonotoneY=function(f){return new Sl(f)};d3.curveNatural=function(f){return new Ul(f)};d3.curveStep=function(f){return new kf(f,.5)};d3.curveStepAfter=function(f){return new kf(f,1)};d3.curveStepBefore=function(f){return new kf(f,0)};d3.stack=function(){function f(z){var D=n.apply(this,arguments),A,C=z.length,G=D.length,O=Array(G);for(A=0;A<G;++A){for(var S=D[A],E=O[A]=Array(C),K=0,H;K<C;++K)E[K]=H=[0,+t(z[K],S,K,z)],H.data=
z[K];E.key=S}A=0;for(D=u(O);A<G;++A)O[D[A]].index=A;r(O,D);return O}var n=na([]),u=Fc,r=Ec,t=Cs;f.keys=function(z){return arguments.length?(n="function"===typeof z?z:na(zh.call(z)),f):n};f.value=function(z){return arguments.length?(t="function"===typeof z?z:na(+z),f):t};f.order=function(z){return arguments.length?(u=null==z?Fc:"function"===typeof z?z:na(zh.call(z)),f):u};f.offset=function(z){return arguments.length?(r=null==z?Ec:z,f):r};return f};d3.stackOffsetExpand=function(f,n){if(0<(r=f.length)){for(var u,
r,t=0,z=f[0].length,D;t<z;++t){for(D=u=0;u<r;++u)D+=f[u][t][1]||0;if(D)for(u=0;u<r;++u)f[u][t][1]/=D}Ec(f,n)}};d3.stackOffsetDiverging=function(f,n){if(1<(C=f.length))for(var u,r=0,t,z,D,A,C,G=f[n[0]].length;r<G;++r)for(u=D=A=0;u<C;++u)0<=(z=(t=f[n[u]][r])[1]-t[0])?(t[0]=D,t[1]=D+=z):0>z?(t[1]=A,t[0]=A+=z):t[0]=D};d3.stackOffsetNone=Ec;d3.stackOffsetSilhouette=function(f,n){if(0<(t=f.length)){for(var u=0,r=f[n[0]],t,z=r.length;u<z;++u){for(var D=0,A=0;D<t;++D)A+=f[D][u][1]||0;r[u][1]+=r[u][0]=-A/
2}Ec(f,n)}};d3.stackOffsetWiggle=function(f,n){if(0<(D=f.length)&&0<(z=(t=f[n[0]]).length)){for(var u=0,r=1,t,z,D;r<z;++r){for(var A=0,C=0,G=0;A<D;++A){var O=f[n[A]],S=O[r][1]||0;O=(S-(O[r-1][1]||0))/2;for(var E=0;E<A;++E){var K=f[n[E]];O+=(K[r][1]||0)-(K[r-1][1]||0)}C+=S;G+=O*S}t[r-1][1]+=t[r-1][0]=u;C&&(u-=G/C)}t[r-1][1]+=t[r-1][0]=u;Ec(f,n)}};d3.stackOrderAscending=Wl;d3.stackOrderDescending=function(f){return Wl(f).reverse()};d3.stackOrderInsideOut=function(f){var n=f.length,u=f.map(Xl),r=Fc(f).sort(function(G,
O){return u[O]-u[G]}),t=0,z=0,D=[],A=[];for(f=0;f<n;++f){var C=r[f];t<z?(t+=u[C],D.push(C)):(z+=u[C],A.push(C))}return A.reverse().concat(D)};d3.stackOrderNone=Fc;d3.stackOrderReverse=function(f){return Fc(f).reverse()};d3.timeInterval=Da;d3.timeMillisecond=dc;d3.timeMilliseconds=Fm;d3.utcMillisecond=dc;d3.utcMilliseconds=Fm;d3.timeSecond=Nd;d3.timeSeconds=Gm;d3.utcSecond=Nd;d3.utcSeconds=Gm;d3.timeMinute=Sh;d3.timeMinutes=Ct;d3.timeHour=Th;d3.timeHours=Dt;d3.timeDay=vd;d3.timeDays=Et;d3.timeWeek=
yd;d3.timeWeeks=Lm;d3.timeSunday=yd;d3.timeSundays=Lm;d3.timeMonday=ud;d3.timeMondays=Ft;d3.timeTuesday=Hm;d3.timeTuesdays=Gt;d3.timeWednesday=Im;d3.timeWednesdays=Ht;d3.timeThursday=zd;d3.timeThursdays=It;d3.timeFriday=Jm;d3.timeFridays=Jt;d3.timeSaturday=Km;d3.timeSaturdays=Kt;d3.timeMonth=Uh;d3.timeMonths=Lt;d3.timeYear=wb;d3.timeYears=Mt;d3.utcMinute=Vh;d3.utcMinutes=Nt;d3.utcHour=Wh;d3.utcHours=Ot;d3.utcDay=td;d3.utcDays=Pt;d3.utcWeek=Ad;d3.utcWeeks=Qm;d3.utcSunday=Ad;d3.utcSundays=Qm;d3.utcMonday=
sd;d3.utcMondays=Qt;d3.utcTuesday=Mm;d3.utcTuesdays=Rt;d3.utcWednesday=Nm;d3.utcWednesdays=St;d3.utcThursday=Bd;d3.utcThursdays=Tt;d3.utcFriday=Om;d3.utcFridays=Ut;d3.utcSaturday=Pm;d3.utcSaturdays=Vt;d3.utcMonth=Xh;d3.utcMonths=Wt;d3.utcYear=xb;d3.utcYears=Xt;d3.timeFormatDefaultLocale=yl;d3.timeFormatLocale=nl;d3.isoFormat=Yt;d3.isoParse=Zt;d3.now=jc;d3.timer=ee;d3.timerFlush=Vi;d3.timeout=cg;d3.interval=function(f,n,u){var r=new Wc,t=n;if(null==n)return r.restart(f,n,u),r;n=+n;u=null==u?jc():+u;
r.restart(function A(D){D+=t;r.restart(A,t+=n,u);f(D)},n,u);return r};d3.transition=Yi;d3.active=function(f,n){var u=f.__transition,r,t;if(u)for(t in n=null==n?null:n+"",u)if(1<(r=u[t]).state&&r.name===n)return new kb([[f]],jt,n,+t);return null};d3.interrupt=Ub;d3.voronoi=function(){function f(t){return new Hh(t.map(function(z,D){var A=[Math.round(n(z,D,t)/ta)*ta,Math.round(u(z,D,t)/ta)*ta];A.index=D;A.data=z;return A}),r)}var n=Ds,u=Es,r=null;f.polygons=function(t){return f(t).polygons()};f.links=
function(t){return f(t).links()};f.triangles=function(t){return f(t).triangles()};f.x=function(t){return arguments.length?(n="function"===typeof t?t:Yl(+t),f):n};f.y=function(t){return arguments.length?(u="function"===typeof t?t:Yl(+t),f):u};f.extent=function(t){return arguments.length?(r=null==t?null:[[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]],f):r&&[[r[0][0],r[0][1]],[r[1][0],r[1][1]]]};f.size=function(t){return arguments.length?(r=null==t?null:[[0,0],[+t[0],+t[1]]],f):r&&[r[1][0]-r[0][0],r[1][1]-
r[0][1]]};return f};d3.zoom=function(){function f(R){R.property("__zoom",fm).on("wheel.zoom",A).on("mousedown.zoom",C).on("dblclick.zoom",G).filter(M).on("touchstart.zoom",O).on("touchmove.zoom",S).on("touchend.zoom touchcancel.zoom",E).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function n(R,Z){Z=Math.max(X[0],Math.min(X[1],Z));return Z===R.k?R:new yb(Z,R.x,R.y)}function u(R,Z,fa){var ja=Z[0]-fa[0]*R.k;Z=Z[1]-fa[1]*R.k;return ja===R.x&&Z===R.y?R:new yb(R.k,ja,
Z)}function r(R){return[(+R[0][0]+ +R[1][0])/2,(+R[0][1]+ +R[1][1])/2]}function t(R,Z,fa){R.on("start.zoom",function(){z(this,arguments).start()}).on("interrupt.zoom end.zoom",function(){z(this,arguments).end()}).tween("zoom",function(){var ja=arguments,qa=z(this,ja),ma=H.apply(this,ja),ya=fa||r(ma),bb=Math.max(ma[1][0]-ma[0][0],ma[1][1]-ma[0][1]);ma=this.__zoom;var bi="function"===typeof Z?Z.apply(this,ja):Z,gv=ba(ma.invert(ya).concat(bb/ma.k),bi.invert(ya).concat(bb/bi.k));return function(zb){if(1===
zb)zb=bi;else{zb=gv(zb);var ci=bb/zb[2];zb=new yb(ci,ya[0]-zb[0]*ci,ya[1]-zb[1]*ci)}qa.zoom(null,zb)}})}function z(R,Z){for(var fa=0,ja=aa.length,qa;fa<ja;++fa)if((qa=aa[fa]).that===R)return qa;return new D(R,Z)}function D(R,Z){this.that=R;this.args=Z;this.index=-1;this.active=0;this.extent=H.apply(R,Z)}function A(){if(K.apply(this,arguments)){var R=z(this,arguments),Z=this.__zoom,fa=Math.max(X[0],Math.min(X[1],Z.k*Math.pow(2,U.apply(this,arguments)))),ja=Bb(this);if(R.wheel){if(R.mouse[0][0]!==ja[0]||
R.mouse[0][1]!==ja[1])R.mouse[1]=Z.invert(R.mouse[0]=ja);clearTimeout(R.wheel)}else{if(Z.k===fa)return;R.mouse=[ja,Z.invert(ja)];Ub(this);R.start()}Jd();R.wheel=setTimeout(function(){R.wheel=null;R.end()},150);R.zoom("mouse",L(u(n(Z,fa),R.mouse[0],R.mouse[1]),R.extent,Y))}}function C(){if(!la&&K.apply(this,arguments)){var R=z(this,arguments),Z=Ra(d3.event.view).on("mousemove.zoom",function(){Jd();if(!R.moved){var ma=d3.event.clientX-ja,ya=d3.event.clientY-qa;R.moved=ma*ma+ya*ya>pa}R.zoom("mouse",
L(u(R.that.__zoom,R.mouse[0]=Bb(R.that),R.mouse[1]),R.extent,Y))},!0).on("mouseup.zoom",function(){Z.on("mousemove.zoom mouseup.zoom",null);Xd(d3.event.view,R.moved);Jd();R.end()},!0),fa=Bb(this),ja=d3.event.clientX,qa=d3.event.clientY;Wd(d3.event.view);d3.event.stopImmediatePropagation();R.mouse=[fa,this.__zoom.invert(fa)];Ub(this);R.start()}}function G(){if(K.apply(this,arguments)){var R=this.__zoom,Z=Bb(this),fa=R.invert(Z);R=L(u(n(R,R.k*(d3.event.shiftKey?.5:2)),Z,fa),H.apply(this,arguments),
Y);Jd();0<W?Ra(this).transition().duration(W).call(t,R,Z):Ra(this).call(f.transform,R)}}function O(){if(K.apply(this,arguments)){var R=z(this,arguments),Z=d3.event.changedTouches,fa=Z.length,ja;d3.event.stopImmediatePropagation();for(ja=0;ja<fa;++ja){var qa=Z[ja];var ma=Vd(this,Z,qa.identifier);ma=[ma,this.__zoom.invert(ma),qa.identifier];if(R.touch0)R.touch1||(R.touch1=ma);else{R.touch0=ma;var ya=!0}}if(ea&&(ea=clearTimeout(ea),!R.touch1)){R.end();(ma=Ra(this).on("dblclick.zoom"))&&ma.apply(this,
arguments);return}ya&&(ea=setTimeout(function(){ea=null},500),Ub(this),R.start())}}function S(){var R=z(this,arguments),Z=d3.event.changedTouches,fa=Z.length,ja;Jd();ea&&(ea=clearTimeout(ea));for(ja=0;ja<fa;++ja){var qa=Z[ja];var ma=Vd(this,Z,qa.identifier);R.touch0&&R.touch0[2]===qa.identifier?R.touch0[0]=ma:R.touch1&&R.touch1[2]===qa.identifier&&(R.touch1[0]=ma)}qa=R.that.__zoom;if(R.touch1){ma=R.touch0[0];Z=R.touch0[1];ja=R.touch1[0];fa=R.touch1[1];var ya=(ya=ja[0]-ma[0])*ya+(ya=ja[1]-ma[1])*ya;
var bb=(bb=fa[0]-Z[0])*bb+(bb=fa[1]-Z[1])*bb;qa=n(qa,Math.sqrt(ya/bb));ma=[(ma[0]+ja[0])/2,(ma[1]+ja[1])/2];ya=[(Z[0]+fa[0])/2,(Z[1]+fa[1])/2]}else if(R.touch0)ma=R.touch0[0],ya=R.touch0[1];else return;R.zoom("touch",L(u(qa,ma,ya),R.extent,Y))}function E(){var R=z(this,arguments),Z=d3.event.changedTouches,fa=Z.length,ja;d3.event.stopImmediatePropagation();la&&clearTimeout(la);la=setTimeout(function(){la=null},500);for(ja=0;ja<fa;++ja){var qa=Z[ja];R.touch0&&R.touch0[2]===qa.identifier?delete R.touch0:
R.touch1&&R.touch1[2]===qa.identifier&&delete R.touch1}R.touch1&&!R.touch0&&(R.touch0=R.touch1,delete R.touch1);R.touch0?R.touch0[1]=this.__zoom.invert(R.touch0[0]):R.end()}var K=Os,H=Ps,L=Ss,U=Qs,M=Rs,X=[0,Infinity],Y=[[-Infinity,-Infinity],[Infinity,Infinity]],W=250,ba=Qi,aa=[],ha=Ob("start","zoom","end"),ea,la,pa=0;f.transform=function(R,Z){var fa=R.selection?R.selection():R;fa.property("__zoom",fm);R!==fa?t(R,Z):fa.interrupt().each(function(){z(this,arguments).start().zoom(null,"function"===typeof Z?
Z.apply(this,arguments):Z).end()})};f.scaleBy=function(R,Z){f.scaleTo(R,function(){var fa=this.__zoom.k,ja="function"===typeof Z?Z.apply(this,arguments):Z;return fa*ja})};f.scaleTo=function(R,Z){f.transform(R,function(){var fa=H.apply(this,arguments),ja=this.__zoom,qa=r(fa),ma=ja.invert(qa),ya="function"===typeof Z?Z.apply(this,arguments):Z;return L(u(n(ja,ya),qa,ma),fa,Y)})};f.translateBy=function(R,Z,fa){f.transform(R,function(){return L(this.__zoom.translate("function"===typeof Z?Z.apply(this,
arguments):Z,"function"===typeof fa?fa.apply(this,arguments):fa),H.apply(this,arguments),Y)})};f.translateTo=function(R,Z,fa){f.transform(R,function(){var ja=H.apply(this,arguments),qa=this.__zoom,ma=r(ja);return L(pf.translate(ma[0],ma[1]).scale(qa.k).translate("function"===typeof Z?-Z.apply(this,arguments):-Z,"function"===typeof fa?-fa.apply(this,arguments):-fa),ja,Y)})};D.prototype={start:function(){1===++this.active&&(this.index=aa.push(this)-1,this.emit("start"));return this},zoom:function(R,
Z){this.mouse&&"mouse"!==R&&(this.mouse[1]=Z.invert(this.mouse[0]));this.touch0&&"touch"!==R&&(this.touch0[1]=Z.invert(this.touch0[0]));this.touch1&&"touch"!==R&&(this.touch1[1]=Z.invert(this.touch1[0]));this.that.__zoom=Z;this.emit("zoom");return this},end:function(){0===--this.active&&(aa.splice(this.index,1),this.index=-1,this.emit("end"));return this},emit:function(R){Qc(new Ns(f,R,this.that.__zoom),ha.apply,ha,[R,this.that,this.args])}};f.wheelDelta=function(R){return arguments.length?(U="function"===
typeof R?R:of(+R),f):U};f.filter=function(R){return arguments.length?(K="function"===typeof R?R:of(!!R),f):K};f.touchable=function(R){return arguments.length?(M="function"===typeof R?R:of(!!R),f):M};f.extent=function(R){return arguments.length?(H="function"===typeof R?R:of([[+R[0][0],+R[0][1]],[+R[1][0],+R[1][1]]]),f):H};f.scaleExtent=function(R){return arguments.length?(X[0]=+R[0],X[1]=+R[1],f):[X[0],X[1]]};f.translateExtent=function(R){return arguments.length?(Y[0][0]=+R[0][0],Y[1][0]=+R[1][0],
Y[0][1]=+R[0][1],Y[1][1]=+R[1][1],f):[[Y[0][0],Y[0][1]],[Y[1][0],Y[1][1]]]};f.constrain=function(R){return arguments.length?(L=R,f):L};f.duration=function(R){return arguments.length?(W=+R,f):W};f.interpolate=function(R){return arguments.length?(ba=R,f):ba};f.on=function(){var R=ha.on.apply(ha,arguments);return R===ha?f:R};f.clickDistance=function(R){return arguments.length?(pa=(R=+R)*R,f):Math.sqrt(pa)};return f};d3.zoomTransform=em;d3.zoomIdentity=pf;Ua.svg=Ua.svg;Ua.xhtml=Ua.xhtml;Ua.xlink=Ua.xlink;
Ua.xml=Ua.xml;Ua.xmlns=Ua.xmlns})();
//learning/brain/mobile/lite/tooling/model_graph_visualizer/worker_bin.jstrimmer_bootstrap.js

//javascript/closure/base.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * Avoid including base.js more than once. This is strictly discouraged and not
 * supported. goog.require(...) won't work properly in that case.
 *
 * @suppress {deprecated} Users cannot remove deprecated uses here.
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};

/**
 * Reference to the global object.
 * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-global-object
 *
 * More info on this implementation here:
 * https://docs.google.com/document/d/1NAeW4Wk7I7FV0Y2tcUFvQdGMc89k2vdgSXInw8_nvCI/edit
 *
 * @const
 * @suppress {undefinedVars} self won't be referenced unless `this` is falsy.
 * @type {!Global}
 */
goog.global =
    // Check `this` first for backwards compatibility.
    // Valid unless running as an ES module or in a function wrapper called
    //   without setting `this` properly.
    // Note that base.js can't usefully be imported as an ES module, but it may
    // be compiled into bundles that are loadable as ES modules.
    this ||
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/self
    // For in-page browser environments and workers.
    self;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, `CLOSURE_UNCOMPILED_DEFINES` may be defined before
 * loading base.js.  If a key is defined in `CLOSURE_UNCOMPILED_DEFINES`,
 * `goog.define` will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * Currently the Closure Compiler will only recognize very simple definitions of
 * this value when looking for values to apply to compiled code and ignore all
 * other references.  Specifically, it looks the value defined at the variable
 * declaration, as with the example above.
 *
 * TODO(b/202066289): Improve the recognized definitions.
 *
 * @type {!Object<string, (string|number|boolean)>|null|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name The name of the object that this file defines.
 * @param {*=} object The object to expose at the end of the path.
 * @param {boolean=} overwriteImplicit If object is set and a previous call
 *     implicitly constructed the namespace given by name, this parameter
 *     controls whether object should overwrite the implicitly constructed
 *     namespace or be merged into it. Defaults to false.
 * @param {?Object=} objectToExportTo The object to add the path to; if this
 *     field is not specified, its value defaults to `goog.global`.
 * @private
 */
goog.exportPath_ = function(name, object, overwriteImplicit, objectToExportTo) {
  var parts = name.split('.');
  var cur = objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && typeof cur.execScript != 'undefined') {
    cur.execScript('var ' + parts[0]);
  }

  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && object !== undefined) {
      if (!overwriteImplicit && goog.isObject(object) &&
          goog.isObject(cur[part])) {
        // Merge properties on object (the input parameter) with the existing
        // implicitly defined namespace, so as to not clobber previously
        // defined child namespaces.
        for (var prop in object) {
          if (object.hasOwnProperty(prop)) {
            cur[part][prop] = object[prop];
          }
        }
      } else {
        // Either there is no existing implicit namespace, or overwriteImplicit
        // is set to true, so directly assign object (the input parameter) to
        // the namespace.
        cur[part] = object;
      }
    } else if (cur[part] && cur[part] !== Object.prototype[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler options or the
 * value set in the CLOSURE_DEFINES object. Returns the defined value so that it
 * can be used safely in modules. Note that the value type MUST be either
 * boolean, number, or string.
 *
 * @param {string} name The distinguished name to provide.
 * @param {T} defaultValue
 * @return {T} The defined value.
 * @template T
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;
    var defines = goog.global.CLOSURE_DEFINES;
    if (uncompiledDefines &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (uncompiledDefines).nodeType === undefined &&
        Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {
      value = uncompiledDefines[name];
    } else if (
        defines &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (defines).nodeType === undefined &&
        Object.prototype.hasOwnProperty.call(defines, name)) {
      value = defines[name];
    }
  }
  return value;
};


/**
 * @define {number} Integer year indicating the set of browser features that are
 * guaranteed to be present.  This is defined to include exactly features that
 * work correctly on all "modern" browsers that are stable on January 1 of the
 * specified year.  For example,
 * ```js
 * if (goog.FEATURESET_YEAR >= 2019) {
 *   // use APIs known to be available on all major stable browsers Jan 1, 2019
 * } else {
 *   // polyfill for older browsers
 * }
 * ```
 * This is intended to be the primary define for removing
 * unnecessary browser compatibility code (such as ponyfills and workarounds),
 * and should inform the default value for most other defines:
 * ```js
 * const ASSUME_NATIVE_PROMISE =
 *     goog.define('ASSUME_NATIVE_PROMISE', goog.FEATURESET_YEAR >= 2016);
 * ```
 *
 * The default assumption is that IE9 is the lowest supported browser, which was
 * first available Jan 1, 2012.
 *
 * TODO(mathiasb): Reference more thorough documentation when it's available.
 */
goog.FEATURESET_YEAR = goog.define('goog.FEATURESET_YEAR', 2012);


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production. It can be easily stripped
 * by specifying --define goog.DEBUG=false to the Closure Compiler aka
 * JSCompiler. For example, most toString() methods should be declared inside an
 * "if (goog.DEBUG)" conditional because they are generally used for debugging
 * purposes and it is difficult for the JSCompiler to statically determine
 * whether they are used.
 */
goog.DEBUG = goog.define('goog.DEBUG', true);


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as a compiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he).
 *
 * MOE:begin_intracomment_strip
 * See http://g3doc/i18n/identifiers/g3doc/synonyms.
 * MOE:end_intracomment_strip
 */
goog.LOCALE = goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the compiler.
 */
goog.TRUSTED_SITE = goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */
goog.DISALLOW_TEST_ONLY_CODE =
    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);


/**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */
goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING =
    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);


// MOE:begin_strip
/**
 * Read a flag from the runtime flags object.
 * @param {number} googFlagId Enum ordinal
 * @param {boolean} defaultValue Value to return if the flag is not given
 * @return {boolean}
 */
goog.readFlagInternalDoNotUseOrElse = function(googFlagId, defaultValue) {
  var obj = goog.getObjectByName(goog.FLAGS_OBJECT_);
  var val = obj && obj[googFlagId];
  return val != null ? val : defaultValue;
};


/**
 * Name of the object to look for when looking up runtime flag values.  May be a
 * fully qualified object name (e.g. 'foo.bar').
 * @define {string}
 * @private
 */
goog.FLAGS_OBJECT_ = goog.define('goog.FLAGS_OBJECT', 'CLOSURE_FLAGS');


/**
 * Default value for the STAGING flag.  Defaults to `true`, indicating that
 * flags are enabled by default once they reach the STAGING lifecycle stage.
 * Risk-averse products should set this to `false` in their production builds.
 * This is only necessary for non-Boq products because Boq Web configures this
 * via the goog.flag system by default.
 *
 * @define {boolean}
 */
goog.FLAGS_STAGING_DEFAULT = goog.define('goog.FLAGS_STAGING_DEFAULT', true);


/**
 * Read a toggle's value.  This should not be called directly.  Use the
 * `toggle_provider` build rule instead.  See go/toggle-provider.
 * @param {string} name
 * @return {boolean}
 */
goog.readToggleInternalDoNotCallDirectly = function(name) {
  var ordinals = typeof CLOSURE_TOGGLE_ORDINALS === 'object' ?
      CLOSURE_TOGGLE_ORDINALS :
      undefined;
  var ordinal = ordinals && ordinals[name];
  if (typeof ordinal !== 'number') return Boolean(ordinal);
  return Boolean(
      goog.TOGGLES_[Math.floor(ordinal / 30)] & (1 << (ordinal % 30)));
};


/**
 * Bootstrap variable mapping toggle names to ordinals.  This is intended to be
 * read by JSCompiler to replace goog.readToggle...() calls with direct lookups,
 * but is also used by the debug-mode version of the toggle reader.
 * @const {!Object<string, number|boolean>|undefined}
 */
goog.global.CLOSURE_TOGGLE_ORDINALS;


/**
 * @define {string} Global variable to check for toggles.
 * @private
 */
goog.TOGGLE_VAR_ = goog.define('goog.TOGGLE_VAR', '_F_toggles');


/** @private @const {!Array<number>} */
goog.TOGGLES_ = goog.global[goog.TOGGLE_VAR_] || [];
// MOE:end_strip


/**
 * A hook for providing an object that should be used to track the "legacy
 * namespaces". The legacy namespace is where symbols from `goog.provide` as
 * well as symbols from `goog.module` with `goog.module.declareLegacyNamespace`
 * are placed.
 *
 * If this isn't specified, `goog.global` will be considered the legacy
 * namespace object.
 *
 * @type {!Object|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_LEGACY_NAMESPACE_OBJECT;


/**
 * @type {!Object}
 * @private
 */
goog.LEGACY_NAMESPACE_OBJECT_ =
    (!COMPILED &&
     typeof CLOSURE_UNCOMPILED_LEGACY_NAMESPACE_OBJECT !== 'undefined') ?
    CLOSURE_UNCOMPILED_LEGACY_NAMESPACE_OBJECT :
    goog.global;


/**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * deprecated Use goog.module (see b/159289405)
 */
goog.provide = function(name) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.provide cannot be used within a module.');
  }
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
  }

  goog.constructNamespace_(name);
};


/**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {?Object=} object The object to embed in the namespace.
 * @param {boolean=} overwriteImplicit If object is set and a previous call
 *     implicitly constructed the namespace given by name, this parameter
 *     controls whether opt_obj should overwrite the implicitly constructed
 *     namespace or be merged into it. Defaults to false.
 * @private
 */
goog.constructNamespace_ = function(name, object, overwriteImplicit) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace, goog.LEGACY_NAMESPACE_OBJECT_)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(
      name, object, overwriteImplicit, goog.LEGACY_NAMESPACE_OBJECT_);
};


/**
 * According to the CSP3 spec a nonce must be a valid base64 string.
 * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value
 * @private @const
 */
goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;


/**
 * Returns CSP nonce, if set for any script tag.
 * @param {?Window=} opt_window The window context used to retrieve the nonce.
 *     Defaults to global context.
 * @return {string} CSP nonce or empty string if no nonce is present.
 * @private
 */
goog.getScriptNonce_ = function(opt_window) {
  var doc = (opt_window || goog.global).document;
  var script = doc.querySelector && doc.querySelector('script[nonce]');
  if (script) {
    // Try to get the nonce from the IDL property first, because browsers that
    // implement additional nonce protection features (currently only Chrome) to
    // prevent nonce stealing via CSS do not expose the nonce via attributes.
    // See https://github.com/whatwg/html/issues/2369
    var nonce = script['nonce'] || script.getAttribute('nonce');
    if (nonce && goog.NONCE_PATTERN_.test(nonce)) {
      return nonce;
    }
  }
  return '';
};


/**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;


/**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 * MOE:begin_intracomment_strip
 * See the goog.module announcement at http://go/goog.module-announce
 * MOE:end_intracomment_strip
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 * @return {void}
 */
goog.module = function(name) {
  if (typeof name !== 'string' || !name ||
      name.search(goog.VALID_MODULE_RE_) == -1) {
    throw new Error('Invalid module identifier');
  }
  if (!goog.isInGoogModuleLoader_()) {
    throw new Error(
        'Module ' + name + ' has been loaded incorrectly. Note, ' +
        'modules cannot be loaded as normal scripts. They require some kind of ' +
        'pre-processing step. You\'re likely trying to load a module via a ' +
        'script tag or as a part of a concatenated bundle without rewriting the ' +
        'module. For more info see: ' +
        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw new Error('goog.module may only be called once per module.');
  }

  // Store the module name for the loader.
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (name in goog.loadedModules_) {
      return goog.loadedModules_[name].exports;
    } else if (!goog.implicitNamespaces_[name]) {
      var ns = goog.getObjectByName(name, goog.LEGACY_NAMESPACE_OBJECT_);
      return ns != null ? ns : null;
    }
  }
  return null;
};

// MOE:begin_strip
/**
 * Defines dynamic import execution path for uncompiled mode.
 *
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * NOTE: In compiled code, JsCompiler will transpile this function call.
 * DO NOT OPENSOURCE
 */
goog.requireDynamic = function(name) {
  if (!COMPILED) {
    if (!goog.importHandler_ || !goog.uncompiledChunkIdHandler_) {
      throw new Error('Need to setup import handler and chunk id handler.');
    }
    return goog.importHandler_(goog.uncompiledChunkIdHandler_(name))
        .then(function() {
          var module = goog.module.getInternal_(name);
          if (module == null) {
            throw new Error('Module ' + name + ' is not loaded.');
          }
          return module;
        });
  }
  return null;
};


/**
 * Handler for dynamic import.
 * DO NOT OPENSOURCE
 */
goog.importHandler_ = null;


/**
 * Chunk ID calculator.
 * @private {?function(string)}
 * DO NOT OPENSOURCE
 */
goog.uncompiledChunkIdHandler_ = null;


/**
 * Sets import handler.
 * @param {function(string)} fn
 * DO NOT OPENSOURCE
 */
goog.setImportHandlerInternalDoNotCallOrElse = function(fn) {
  goog.importHandler_ = fn;
};


/**
 * Sets chunk ID calculator.
 * @param {function(string)} fn
 * NOTE: The chunk ID calculator is only used in uncompiled mode.
 * DO NOT OPENSOURCE
 */
goog.setUncompiledChunkIdHandlerInternalDoNotCallOrElse = function(fn) {
  goog.uncompiledChunkIdHandler_ = fn;
};


/**
 * This exists purely as a hint to JsTrimmer, so that it can convert it to
 * goog.require in certain circumstances.
 *
 * @param {string} namespace
 * DO NOT OPENSOURCE
 */
goog.maybeRequireFrameworkInternalOnlyDoNotCallOrElse = function(namespace) {};
// MOE:end_strip

/**
 * Types of modules the debug loader can load.
 * @enum {string}
 */
goog.ModuleType = {
  ES6: 'es6',
  GOOG: 'goog'
};


/**
 * @private {?{
 *   moduleName: (string|undefined),
 *   declareLegacyNamespace:boolean,
 *   type: ?goog.ModuleType
 * }}
 */
goog.moduleLoaderState_ = null;


/**
 * @private
 * @return {boolean} Whether a goog.module or an es6 module is currently being
 *     initialized.
 */
goog.isInModuleLoader_ = function() {
  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
};


/**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */
goog.isInGoogModuleLoader_ = function() {
  return !!goog.moduleLoaderState_ &&
      goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
};


/**
 * @private
 * @return {boolean} Whether an es6 module is currently being initialized.
 */
goog.isInEs6ModuleLoader_ = function() {
  var inLoader = !!goog.moduleLoaderState_ &&
      goog.moduleLoaderState_.type == goog.ModuleType.ES6;

  if (inLoader) {
    return true;
  }

  var jscomp = goog.LEGACY_NAMESPACE_OBJECT_['$jscomp'];

  if (jscomp) {
    // jscomp may not have getCurrentModulePath if this is a compiled bundle
    // that has some of the runtime, but not all of it. This can happen if
    // optimizations are turned on so the unused runtime is removed but renaming
    // and Closure pass are off (so $jscomp is still named $jscomp and the
    // goog.provide/require calls still exist).
    if (typeof jscomp.getCurrentModulePath != 'function') {
      return false;
    }

    // Bundled ES6 module.
    return !!jscomp.getCurrentModulePath();
  }

  return false;
};


/**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInGoogModuleLoader_()) {
    throw new Error(
        'goog.module.declareLegacyNamespace must be called from ' +
        'within a goog.module');
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw new Error(
        'goog.module must be called prior to ' +
        'goog.module.declareLegacyNamespace.');
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};


/**
 * Associates an ES6 module with a Closure module ID so that is available via
 * goog.require. The associated ID  acts like a goog.module ID - it does not
 * create any global names, it is merely available via goog.require /
 * goog.module.get / goog.forwardDeclare / goog.requireType. goog.require and
 * goog.module.get will return the entire module as if it was import *'d. This
 * allows Closure files to reference ES6 modules for the sake of migration.
 *
 * @param {string} namespace
 * @suppress {missingProvide}
 */
goog.declareModuleId = function(namespace) {
  if (!COMPILED) {
    if (!goog.isInEs6ModuleLoader_()) {
      throw new Error(
          'goog.declareModuleId may only be called from ' +
          'within an ES6 module');
    }
    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {
      throw new Error(
          'goog.declareModuleId may only be called once per module.');
    }
    if (namespace in goog.loadedModules_) {
      throw new Error(
          'Module with namespace "' + namespace + '" already exists.');
    }
  }
  if (goog.moduleLoaderState_) {
    // Not bundled - debug loading.
    goog.moduleLoaderState_.moduleName = namespace;
  } else {
    // Bundled - not debug loading, no module loader state.
    var jscomp = goog.LEGACY_NAMESPACE_OBJECT_['$jscomp'];
    if (!jscomp || typeof jscomp.getCurrentModulePath != 'function') {
      throw new Error(
          'Module with namespace "' + namespace +
          '" has been loaded incorrectly.');
    }
    var exports = jscomp.require(jscomp.getCurrentModulePath());
    goog.loadedModules_[namespace] = {
      exports: exports,
      type: goog.ModuleType.ES6,
      moduleId: namespace
    };
  }
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || '';
    throw new Error(
        'Importing test-only code into non-debug environment' +
        (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 * Before using goog.forwardDeclare, please read the documentation at
 * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to
 * understand the options and tradeoffs when working with forward declarations.
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 * @deprecated See go/noforwarddeclaration, Use `goog.requireType` instead.
 */
goog.forwardDeclare = function(name) {};

if (!COMPILED) {
  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return (name in goog.loadedModules_) ||
        (!goog.implicitNamespaces_[name] &&
         goog.getObjectByName(name, goog.LEGACY_NAMESPACE_OBJECT_) != null);
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */
  goog.implicitNamespaces_ = {'goog.module': true};

  // NOTE: We add goog.module as an implicit namespace as goog.module is defined
  // here and because the existing module package has not been moved yet out of
  // the goog.module namespace. This satisfies both the debug loader and
  // ahead-of-time dependency management.
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var i = 0; i < parts.length; i++) {
    cur = cur[parts[i]];
    if (cur == null) {
      return null;
    }
  }
  return cur;
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
 *     how the file must be loaded.  The boolean 'true' is equivalent
 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
 */
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
  if (!COMPILED && goog.DEPENDENCIES_ENABLED) {
    goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags);
  }
};


// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// MOE:begin_strip
// Internally: http://go/deps-files and http://go/be#js_deps
// MOE:end_strip
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work was done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.ENABLE_DEBUG_LOADER = goog.define('goog.ENABLE_DEBUG_LOADER', false);


/**
 * @param {string} msg
 * @private
 */
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console['error'](msg);
  }
};


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system.
 *
 * Note that all calls to goog.require will be stripped by the compiler.
 *
 * @see goog.provide
 * @param {string} namespace Namespace (as was given in goog.provide,
 *     goog.module, or goog.declareModuleId) in the form
 *     "goog.package.part".
 * @return {?} If called within a goog.module or ES6 module file, the associated
 *     namespace or module otherwise null.
 */
goog.require = function(namespace) {
  if (!COMPILED) {
    // Might need to lazy load on old IE.
    if (goog.ENABLE_DEBUG_LOADER) {
      goog.debugLoader_.requested(namespace);
    }

    // If the object already exists we do not need to do anything.
    if (goog.isProvided_(namespace)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(namespace);
      }
    } else if (goog.ENABLE_DEBUG_LOADER) {
      var moduleLoaderState = goog.moduleLoaderState_;
      goog.moduleLoaderState_ = null;
      try {
        goog.debugLoader_.load_(namespace);
      } finally {
        goog.moduleLoaderState_ = moduleLoaderState;
      }
    }

    return null;
  }
};


/**
 * Requires a symbol for its type information. This is an indication to the
 * compiler that the symbol may appear in type annotations, yet it is not
 * referenced at runtime.
 *
 * When called within a goog.module or ES6 module file, the return value may be
 * assigned to or destructured into a variable, but it may not be otherwise used
 * in code outside of a type annotation.
 *
 * Note that all calls to goog.requireType will be stripped by the compiler.
 *
 * @param {string} namespace Namespace (as was given in goog.provide,
 *     goog.module, or goog.declareModuleId) in the form
 *     "goog.package.part".
 * @return {?}
 */
goog.requireType = function(namespace) {
  // Return an empty object so that single-level destructuring of the return
  // value doesn't crash at runtime when using the debug loader. Multi-level
  // destructuring isn't supported.
  return {};
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The first parameter the script source, which is a relative URI. The second,
 * optional parameter is the script contents, in the event the script needed
 * transformation. It should return true if the script was imported, false
 * otherwise.
 * @type {(function(string, string=): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 * @deprecated Use "@abstract" annotation instead of goog.abstractMethod in new
 *     code. See
 *     https://github.com/google/closure-compiler/wiki/@abstract-classes-and-methods
 */
goog.abstractMethod = function() {
  throw new Error('unimplemented abstract method');
};


/**
 * Adds a `getInstance` static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 * @suppress {missingProperties} 'instance_' isn't a property on 'Function'
 *     but we don't have a better type to use here.
 */
goog.addSingletonGetter = function(ctor) {
  // instance_ is immediately set to prevent issues with sealed constructors
  // such as are encountered when a constructor is returned as the export object
  // of a goog.module in unoptimized code.
  // Declare type to avoid conformance violations that ctor.instance_ is unknown
  /** @type {undefined|!Object} @suppress {underscore} */
  ctor.instance_ = undefined;
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    // Cast to avoid conformance violations that ctor.instance_ is unknown
    return /** @type {!Object|undefined} */ (ctor.instance_) = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the `goog.testing.singleton` module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * @define {boolean} Whether to load goog.modules using `eval` when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of `eval` is banned
 * so we provide an alternative.
 */
goog.LOAD_MODULE_USING_EVAL = goog.define('goog.LOAD_MODULE_USING_EVAL', true);


/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.SEAL_MODULE_EXPORTS = goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);


/**
 * The registry of initialized modules:
 * The module identifier or path to module exports map.
 * @private @const {!Object<string, {exports:?,type:string,moduleId:string}>}
 */
goog.loadedModules_ = {};


/**
 * True if the debug loader enabled and used.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;




/**
 * @define {boolean} If true assume that ES modules have already been
 * transpiled by the jscompiler (in the same way that transpile.js would
 * transpile them - to jscomp modules). Useful only for servers that wish to use
 * the debug loader and transpile server side. Thus this is only respected if
 * goog.TRANSPILE is "never".
 */
goog.ASSUME_ES_MODULES_TRANSPILED =
    goog.define('goog.ASSUME_ES_MODULES_TRANSPILED', false);


/**
 * @define {string} Trusted Types policy name. If non-empty then Closure will
 * use Trusted Types.
 */
goog.TRUSTED_TYPES_POLICY_NAME =
    goog.define('goog.TRUSTED_TYPES_POLICY_NAME', 'goog');


/**
 * @package {?boolean}
 * Visible for testing.
 */
goog.hasBadLetScoping = null;


/**
 * @param {function(?):?|string} moduleDef The module definition.
 */
goog.loadModule = function(moduleDef) {
  // NOTE: we allow function definitions to be either in the from
  // of a string to eval (which keeps the original source intact) or
  // in a eval forbidden environment (CSP) we allow a function definition
  // which in its body must call `goog.module`, and return the exports
  // of the module.
  var previousState = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {
      moduleName: '',
      declareLegacyNamespace: false,
      type: goog.ModuleType.GOOG
    };
    var origExports = {};
    var exports = origExports;
    if (typeof moduleDef === 'function') {
      exports = moduleDef.call(undefined, exports);
    } else if (typeof moduleDef === 'string') {
      exports = goog.loadModuleFromSource_.call(undefined, exports, moduleDef);
    } else {
      throw new Error('Invalid module definition');
    }

    var moduleName = goog.moduleLoaderState_.moduleName;
    if (typeof moduleName === 'string' && moduleName) {
      // Don't seal legacy namespaces as they may be used as a parent of
      // another namespace
      if (goog.moduleLoaderState_.declareLegacyNamespace) {
        // Whether exports was overwritten via default export assignment.
        // This is important for legacy namespaces as it dictates whether
        // previously a previously loaded implicit namespace should be clobbered
        // or not.
        var isDefaultExport = origExports !== exports;
        goog.constructNamespace_(moduleName, exports, isDefaultExport);
      } else if (
          goog.SEAL_MODULE_EXPORTS && Object.seal &&
          typeof exports == 'object' && exports != null) {
        Object.seal(exports);
      }

      var data = {
        exports: exports,
        type: goog.ModuleType.GOOG,
        moduleId: goog.moduleLoaderState_.moduleName
      };
      goog.loadedModules_[moduleName] = data;
    } else {
      throw new Error('Invalid module name \"' + moduleName + '\"');
    }
  } finally {
    goog.moduleLoaderState_ = previousState;
  }
};


/**
 * @private @const
 */
goog.loadModuleFromSource_ =
    /** @type {function(!Object, string):?} */ (function(exports) {
      // NOTE: we avoid declaring parameters or local variables here to avoid
      // masking globals or leaking values into the module definition.
      'use strict';
      eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(arguments[1]));
      return exports;
    });


/**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */
goog.normalizePath_ = function(path) {
  var components = path.split('/');
  var i = 0;
  while (i < components.length) {
    if (components[i] == '.') {
      components.splice(i, 1);
    } else if (
        i && components[i] == '..' && components[i - 1] &&
        components[i - 1] != '..') {
      components.splice(--i, 2);
    } else {
      i++;
    }
  }
  return components.join('/');
};


/**
 * Provides a hook for loading a file when using Closure's goog.require() API
 * with goog.modules.  In particular this hook is provided to support Node.js.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_LOAD_FILE_SYNC;


/**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {?string} File contents, or null if load failed.
 * @private
 */
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    try {
      /** @type {XMLHttpRequest} */
      var xhr = new goog.global['XMLHttpRequest']();
      xhr.open('get', src, false);
      xhr.send();
      // NOTE: Successful http: requests have a status of 200, but successful
      // file: requests may have a status of zero.  Any other status, or a
      // thrown exception (particularly in case of file: requests) indicates
      // some sort of error, which we treat as a missing or unavailable file.
      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;
    } catch (err) {
      // No need to rethrow or log, since errors should show up on their own.
      return null;
    }
  }
};

//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {?} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;

  if (s != 'object') {
    return s;
  }

  if (!value) {
    return 'null';
  }

  if (Array.isArray(value)) {
    return 'array';
  }
  return s;
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. Note that for this function neither strings nor functions are
 * considered "array-like".
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  // We do not use goog.isObject here in order to exclude function values.
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into `getUid`. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.
  return Object.prototype.hasOwnProperty.call(obj, goog.UID_PROPERTY_) &&
      obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using `goog.getUid` in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if (obj !== null && 'removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }

  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (typeof obj.clone === 'function') {
      return obj.clone();
    }
    if (typeof Map !== 'undefined' && obj instanceof Map) {
      return new Map(obj);
    } else if (typeof Set !== 'undefined' && obj instanceof Set) {
      return new Set(obj);
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 * @deprecated use `=> {}` or Function.prototype.bind instead.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like goog.bind(), except that a 'this object' is not required. Useful when
 * the target function is already bound.
 *
 * Usage:
 * var g = goog.partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(/** @type {?} */ (this), newArgs);
  };
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 * @deprecated Use Date.now
 */
goog.now = function() {
  return Date.now();
};


/**
 * Evals JavaScript in the global scope.
 *
 * Throws an exception if neither execScript or eval is defined.
 * @param {string|!TrustedScript} script JavaScript string.
 */
goog.globalEval = function(script) {
  (0, eval)(script);
};


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;



/**
 * A hook for modifying the default behavior goog.getCssName. The function
 * if present, will receive the standard output of the goog.getCssName as
 * its input.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAP_FN;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x = 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  // String() is used for compatibility with compiled soy where the passed
  // className can be non-string objects.
  if (String(className).charAt(0) == '.') {
    throw new Error(
        'className passed in goog.getCssName must not start with ".".' +
        ' You passed: ' + className);
  }

  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename =
        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  var result =
      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);

  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further
  // processing of the class name.
  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {
    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
  }

  return result;
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --process_closure_primitives flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}

/**
 * Options bag type for `goog.getMsg()` third argument.
 *
 * It is important to note that these options need to be known at compile time,
 * so they must always be provided to `goog.getMsg()` as an actual object
 * literal in the function call. Otherwise, closure-compiler will report an
 * error.
 * @record
 */
goog.GetMsgOptions = function() {};

/**
 * If `true`, escape '<' in the message string to '&lt;'.
 *
 * Used by Closure Templates where the generated code size and performance is
 * critical which is why {@link goog.html.SafeHtmlFormatter} is not used.
 * The value must be literal `true` or `false`.
 * @type {boolean|undefined}
 */
goog.GetMsgOptions.prototype.html;

/**
 * If `true`, unescape common html entities: &gt;, &lt;, &apos;, &quot; and
 * &amp;.
 *
 * Used for messages not in HTML context, such as with the `textContent`
 * property.
 * The value must be literal `true` or `false`.
 * @type {boolean|undefined}
 */
goog.GetMsgOptions.prototype.unescapeHtmlEntities;

/**
 * Associates placeholder names with strings showing how their values are
 * obtained.
 *
 * This field is intended for use in automatically generated JS code.
 * Human-written code should use meaningful placeholder names instead.
 *
 * closure-compiler uses this as the contents of the `<ph>` tag in the
 * XMB file it generates or defaults to `-` for historical reasons.
 *
 * Must be an object literal.
 * Ignored at runtime.
 * Keys are placeholder names.
 * Values are string literals indicating how the value is obtained.
 * Typically this is a snippet of source code.
 * @type {!Object<string, string>|undefined}
 */
goog.GetMsgOptions.prototype.original_code;

/**
 * Associates placeholder names with example values.
 *
 * closure-compiler uses this as the contents of the `<ex>` tag in the
 * XMB file it generates or defaults to `-` for historical reasons.
 *
 * Must be an object literal.
 * Ignored at runtime.
 * Keys are placeholder names.
 * Values are string literals containing example placeholder values.
 * (e.g. "George McFly" for a name placeholder)
 * @type {!Object<string, string>|undefined}
 */
goog.GetMsgOptions.prototype.example;

/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * This function produces a string which should be treated as plain text. Use
 * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to
 * produce SafeHtml.
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {!Object<string, string>=} opt_values Maps place holder name to value.
 * @param {!goog.GetMsgOptions=} opt_options see `goog.GetMsgOptions`
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values, opt_options) {
  if (opt_options && opt_options.html) {
    // Note that '&' is not replaced because the translation can contain HTML
    // entities.
    str = str.replace(/</g, '&lt;');
  }
  if (opt_options && opt_options.unescapeHtmlEntities) {
    // Note that "&amp;" must be the last to avoid "creating" new entities.
    str = str.replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&apos;/g, '\'')
              .replace(/&quot;/g, '"')
              .replace(/&amp;/g, '&');
  }
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return (opt_values != null && key in opt_values) ? opt_values[key] :
                                                         match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {?Object=} objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, objectToExportTo) {
  goog.exportPath_(
      publicPath, object, /* overwriteImplicit= */ true, objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {!Function} childCtor Child class.
 * @param {!Function} parentCtor Parent class.
 * @suppress {strictMissingProperties} superClass_ and base is not defined on
 *    Function.
 * @deprecated Use ECMAScript class syntax instead.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {}
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 * MOE:begin_intracomment_strip
 * See the goog.scope document at http://go/goog.scope
 *
 * For more on goog.scope deprecation, see the style guide entry:
 * http://go/jsstyle#appendices-legacy-exceptions-goog-scope
 * MOE:end_intracomment_strip
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 * @deprecated Use goog.module instead.
 */
goog.scope = function(fn) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.scope is not supported within a module.');
  }
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.LEGACY_NAMESPACE_OBJECT_['COMPILED'] = COMPILED;
}


//==============================================================================
// goog.defineClass implementation
//==============================================================================


/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 * @deprecated Use ECMAScript class syntax instead.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw new Error(
          'cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {{
 *   constructor: (!Function|undefined),
 *   statics: (Object|undefined|function(Function):void)
 * }}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by goog.defineClass should
 *     be sealed when possible.
 *
 * When sealing is disabled the constructor function will not be wrapped by
 * goog.defineClass, making it incompatible with ES6 class methods.
 */
goog.defineClass.SEAL_CLASS_INSTANCES =
    goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {
    // Do now wrap the constructor when sealing is disabled. Angular code
    // depends on this for injection to work properly.
    return ctr;
  }

  // NOTE: The sealing behavior has been removed

  /**
   * @this {Object}
   * @return {?}
   */
  var wrappedCtr = function() {
    // Don't seal an instance of a subclass when it calls the constructor of
    // its super class as there is most likely still setup to do.
    var instance = ctr.apply(this, arguments) || this;
    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];

    return instance;
  };

  return wrappedCtr;
};



// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
  'toLocaleString', 'toString', 'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properties from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};

/**
 * Returns the parameter.
 * @param {string} s
 * @return {string}
 * @private
 */
goog.identity_ = function(s) {
  return s;
};


/**
 * Creates Trusted Types policy if Trusted Types are supported by the browser.
 * The policy just blesses any string as a Trusted Type. It is not visibility
 * restricted because anyone can also call trustedTypes.createPolicy directly.
 * However, the allowed names should be restricted by a HTTP header and the
 * reference to the created policy should be visibility restricted.
 * @param {string} name
 * @return {?TrustedTypePolicy}
 */
goog.createTrustedTypesPolicy = function(name) {
  var policy = null;
  var policyFactory = goog.global.trustedTypes;
  if (!policyFactory || !policyFactory.createPolicy) {
    return policy;
  }
  // trustedTypes.createPolicy throws if called with a name that is already
  // registered, even in report-only mode. Until the API changes, catch the
  // error not to break the applications functionally. In such case, the code
  // will fall back to using regular Safe Types.
  // TODO(koto): Remove catching once createPolicy API stops throwing.
  try {
    policy = policyFactory.createPolicy(name, {
      createHTML: goog.identity_,
      createScript: goog.identity_,
      createScriptURL: goog.identity_
    });
  } catch (e) {
    goog.logToConsole_(e.message);
  }
  return policy;
};

// There's a bug in the compiler where without collapse properties the
// Closure namespace defines do not guard code correctly. To help reduce code
// size also check for !COMPILED even though it redundant until this is fixed.
if (!COMPILED && goog.DEPENDENCIES_ENABLED) {
  // MOE:begin_strip
  // TODO(b/67050526) This object is obsolete but some people are relying on
  // it internally. Keep it around until we migrate them.
  /**
   * @private
   * @type {{
   *   loadFlags: !Object<string, !Object<string, string>>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */
  goog.dependencies_ = {
    loadFlags: {},  // 1 to 1

    nameToPath: {},  // 1 to 1

    requires: {},  // 1 to many

    // Used when resolving dependencies to prevent us from visiting file
    // twice.
    visited: {},

    written: {},  // Used to keep track of script files we have written.

    deferred: {}  // Used to track deferred module evaluations in old IEs
  };

  /**
   * @return {!Object}
   * @private
   */
  goog.getLoader_ = function() {
    return {
      dependencies_: goog.dependencies_,
      writeScriptTag_: goog.writeScriptTag_
    };
  };


  /**
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      /** @type {!HTMLDocument} */
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page. This does not apply to the CSP-compliant method
      // of writing script tags.
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
          doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      var nonceAttr = '';
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        nonceAttr = ' nonce="' + nonce + '"';
      }

      if (opt_sourceText === undefined) {
        var script = '<script src="' + src + '"' + nonceAttr + '></' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      } else {
        var script = '<script' + nonceAttr + '>' +
            goog.protectScriptTag_(opt_sourceText) + '</' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      }
      return true;
    } else {
      return false;
    }
  };
  // MOE:end_strip


  /**
   * Tries to detect whether the current browser is Edge, based on the user
   * agent. This matches only pre-Chromium Edge.
   * @see https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string
   * @return {boolean} True if the current browser is Edge.
   * @private
   */
  goog.isEdge_ = function() {
    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?
        goog.global.navigator.userAgent :
        '';
    var edgeRe = /Edge\/(\d+)(\.\d)*/i;
    return !!userAgent.match(edgeRe);
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    /** @type {!Document} */
    var doc = goog.global.document;
    return doc != null && 'write' in doc;  // XULDocument misses write.
  };


  /**
   * We'd like to check for if the document readyState is 'loading'; however
   * there are bugs on IE 10 and below where the readyState being anything other
   * than 'complete' is not reliable.
   * @return {boolean}
   * @private
   */
  goog.isDocumentLoading_ = function() {
    // attachEvent is available on IE 6 thru 10 only, and thus can be used to
    // detect those browsers.
    /** @type {!HTMLDocument} */
    var doc = goog.global.document;
    return doc.attachEvent ? doc.readyState != 'complete' :
                             doc.readyState == 'loading';
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH != undefined &&
        // Anti DOM-clobbering runtime check (b/37736576).
        typeof goog.global.CLOSURE_BASE_PATH === 'string') {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    /** @type {!Document} */
    var doc = goog.global.document;
    // If we have a currentScript available, use it exclusively.
    var currentScript = doc.currentScript;
    if (currentScript) {
      var scripts = [currentScript];
    } else {
      var scripts = doc.getElementsByTagName('SCRIPT');
    }
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);
      var src = script.src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.slice(l - 7, l) == 'base.js') {
        goog.basePath = src.slice(0, l - 7);
        return;
      }
    }
  };

  goog.findBasePath_();

  /**
   * Rewrites closing script tags in input to avoid ending an enclosing script
   * tag.
   *
   * @param {string} str
   * @return {string}
   * @private
   */
  goog.protectScriptTag_ = function(str) {
    return str.replace(/<\/(SCRIPT)/ig, '\\x3c/$1');
  };


  /**
   * A debug loader is responsible for downloading and executing javascript
   * files in an unbundled, uncompiled environment.
   *
   * This can be custimized via the setDependencyFactory method, or by
   * CLOSURE_IMPORT_SCRIPT/CLOSURE_LOAD_FILE_SYNC.
   *
   * @struct @constructor @final @private
   */
  goog.DebugLoader_ = function() {
    /** @private @const {!Object<string, !goog.Dependency>} */
    this.dependencies_ = {};
    /** @private @const {!Object<string, string>} */
    this.idToPath_ = {};
    /** @private @const {!Object<string, boolean>} */
    this.written_ = {};
    /** @private @const {!Array<!goog.Dependency>} */
    this.loadingDeps_ = [];
    /** @private {!Array<!goog.Dependency>} */
    this.depsToLoad_ = [];
    /** @private {boolean} */
    this.paused_ = false;
    /** @private {!goog.DependencyFactory} */
    this.factory_ = new goog.DependencyFactory();
    /** @private @const {!Object<string, !Function>} */
    this.deferredCallbacks_ = {};
    /** @private @const {!Array<string>} */
    this.deferredQueue_ = [];
  };


  /**
   * Loads the Closure deps.js file.
   *
   * Exposed a function so after base is loaded, and
   * then this can be called to load the closure deps.js file.
   */
  goog.DebugLoader_.prototype.loadClosureDeps = function() {
    // Circumvent addDependency, which would try to transpile deps.js if
    // transpile is set to always.
    var relPath = 'deps.js';
    this.depsToLoad_.push(this.factory_.createDependency(
        goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {}));
    this.loadDeps_();
  };


  /**
   * Notifies the debug loader when a dependency has been requested.
   *
   * @param {string} absPathOrId Path of the dependency or goog id.
   * @param {boolean=} opt_force
   */
  goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {
    var path = this.getPathFromDeps_(absPathOrId);
    if (path &&
        (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {
      var callback = this.deferredCallbacks_[path];
      if (callback) {
        delete this.deferredCallbacks_[path];
        callback();
      }
    }
  };


  /**
   * Sets the dependency factory, which can be used to create custom
   * goog.Dependency implementations to control how dependencies are loaded.
   *
   * @param {!goog.DependencyFactory} factory
   */
  goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {
    this.factory_ = factory;
  };


  /**
   * Travserses the dependency graph and queues the given dependency, and all of
   * its transitive dependencies, for loading and then starts loading if not
   * paused.
   *
   * @param {string} namespace
   * @private
   */
  goog.DebugLoader_.prototype.load_ = function(namespace) {
    if (!this.getPathFromDeps_(namespace)) {
      var errorMessage = 'goog.require could not find: ' + namespace;
      goog.logToConsole_(errorMessage);
    } else {
      var loader = this;

      var deps = [];

      /** @param {string} namespace */
      var visit = function(namespace) {
        var path = loader.getPathFromDeps_(namespace);

        if (!path) {
          throw new Error('Bad dependency path or symbol: ' + namespace);
        }

        if (loader.written_[path]) {
          return;
        }

        loader.written_[path] = true;

        var dep = loader.dependencies_[path];
        // MOE:begin_strip
        if (goog.dependencies_.written[dep.relativePath]) {
          return;
        }
        // MOE:end_strip
        for (var i = 0; i < dep.requires.length; i++) {
          if (!goog.isProvided_(dep.requires[i])) {
            visit(dep.requires[i]);
          }
        }

        deps.push(dep);
      };

      visit(namespace);

      var wasLoading = !!this.depsToLoad_.length;
      this.depsToLoad_ = this.depsToLoad_.concat(deps);

      if (!this.paused_ && !wasLoading) {
        this.loadDeps_();
      }
    }
  };


  /**
   * Loads any queued dependencies until they are all loaded or paused.
   *
   * @private
   */
  goog.DebugLoader_.prototype.loadDeps_ = function() {
    var loader = this;
    var paused = this.paused_;

    while (this.depsToLoad_.length && !paused) {
      (function() {
        var loadCallDone = false;
        var dep = loader.depsToLoad_.shift();

        var loaded = false;
        loader.loading_(dep);

        var controller = {
          pause: function() {
            if (loadCallDone) {
              throw new Error('Cannot call pause after the call to load.');
            } else {
              paused = true;
            }
          },
          resume: function() {
            if (loadCallDone) {
              loader.resume_();
            } else {
              // Some dep called pause and then resume in the same load call.
              // Just keep running this same loop.
              paused = false;
            }
          },
          loaded: function() {
            if (loaded) {
              throw new Error('Double call to loaded.');
            }

            loaded = true;
            loader.loaded_(dep);
          },
          pending: function() {
            // Defensive copy.
            var pending = [];
            for (var i = 0; i < loader.loadingDeps_.length; i++) {
              pending.push(loader.loadingDeps_[i]);
            }
            return pending;
          },
          /**
           * @param {goog.ModuleType} type
           */
          setModuleState: function(type) {
            goog.moduleLoaderState_ = {
              type: type,
              moduleName: '',
              declareLegacyNamespace: false
            };
          },
          /** @type {function(string, string, string=)} */
          registerEs6ModuleExports: function(
              path, exports, opt_closureNamespace) {
            if (opt_closureNamespace) {
              goog.loadedModules_[opt_closureNamespace] = {
                exports: exports,
                type: goog.ModuleType.ES6,
                moduleId: opt_closureNamespace || ''
              };
            }
          },
          /** @type {function(string, ?)} */
          registerGoogModuleExports: function(moduleId, exports) {
            goog.loadedModules_[moduleId] = {
              exports: exports,
              type: goog.ModuleType.GOOG,
              moduleId: moduleId
            };
          },
          clearModuleState: function() {
            goog.moduleLoaderState_ = null;
          },
          defer: function(callback) {
            if (loadCallDone) {
              throw new Error(
                  'Cannot register with defer after the call to load.');
            }
            loader.defer_(dep, callback);
          },
          areDepsLoaded: function() {
            return loader.areDepsLoaded_(dep.requires);
          }
        };

        try {
          dep.load(controller);
        } finally {
          loadCallDone = true;
        }
      })();
    }

    if (paused) {
      this.pause_();
    }
  };


  /** @private */
  goog.DebugLoader_.prototype.pause_ = function() {
    this.paused_ = true;
  };


  /** @private */
  goog.DebugLoader_.prototype.resume_ = function() {
    if (this.paused_) {
      this.paused_ = false;
      this.loadDeps_();
    }
  };


  /**
   * Marks the given dependency as loading (load has been called but it has not
   * yet marked itself as finished). Useful for dependencies that want to know
   * what else is loading. Example: goog.modules cannot eval if there are
   * loading dependencies.
   *
   * @param {!goog.Dependency} dep
   * @private
   */
  goog.DebugLoader_.prototype.loading_ = function(dep) {
    this.loadingDeps_.push(dep);
  };


  /**
   * Marks the given dependency as having finished loading and being available
   * for require.
   *
   * @param {!goog.Dependency} dep
   * @private
   */
  goog.DebugLoader_.prototype.loaded_ = function(dep) {
    for (var i = 0; i < this.loadingDeps_.length; i++) {
      if (this.loadingDeps_[i] == dep) {
        this.loadingDeps_.splice(i, 1);
        break;
      }
    }

    for (var i = 0; i < this.deferredQueue_.length; i++) {
      if (this.deferredQueue_[i] == dep.path) {
        this.deferredQueue_.splice(i, 1);
        break;
      }
    }

    if (this.loadingDeps_.length == this.deferredQueue_.length &&
        !this.depsToLoad_.length) {
      // Something has asked to load these, but they may not be directly
      // required again later, so load them now that we know we're done loading
      // everything else. e.g. a goog module entry point.
      while (this.deferredQueue_.length) {
        this.requested(this.deferredQueue_.shift(), true);
      }
    }

    dep.loaded();
  };


  /**
   * @param {!Array<string>} pathsOrIds
   * @return {boolean}
   * @private
   */
  goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {
    for (var i = 0; i < pathsOrIds.length; i++) {
      var path = this.getPathFromDeps_(pathsOrIds[i]);
      if (!path ||
          (!(path in this.deferredCallbacks_) &&
           !goog.isProvided_(pathsOrIds[i]))) {
        return false;
      }
    }

    return true;
  };


  /**
   * @param {string} absPathOrId
   * @return {?string}
   * @private
   */
  goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {
    if (absPathOrId in this.idToPath_) {
      return this.idToPath_[absPathOrId];
    } else if (absPathOrId in this.dependencies_) {
      return absPathOrId;
    } else {
      return null;
    }
  };


  /**
   * @param {!goog.Dependency} dependency
   * @param {!Function} callback
   * @private
   */
  goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {
    this.deferredCallbacks_[dependency.path] = callback;
    this.deferredQueue_.push(dependency.path);
  };


  /**
   * Interface for goog.Dependency implementations to have some control over
   * loading of dependencies.
   *
   * @record
   */
  goog.LoadController = function() {};


  /**
   * Tells the controller to halt loading of more dependencies.
   */
  goog.LoadController.prototype.pause = function() {};


  /**
   * Tells the controller to resume loading of more dependencies if paused.
   */
  goog.LoadController.prototype.resume = function() {};


  /**
   * Tells the controller that this dependency has finished loading.
   *
   * This causes this to be removed from pending() and any load callbacks to
   * fire.
   */
  goog.LoadController.prototype.loaded = function() {};


  /**
   * List of dependencies on which load has been called but which have not
   * called loaded on their controller. This includes the current dependency.
   *
   * @return {!Array<!goog.Dependency>}
   */
  goog.LoadController.prototype.pending = function() {};


  /**
   * Registers an object as an ES6 module's exports so that goog.modules may
   * require it by path.
   *
   * @param {string} path Full path of the module.
   * @param {?} exports
   * @param {string=} opt_closureNamespace Closure namespace to associate with
   *     this module.
   */
  goog.LoadController.prototype.registerEs6ModuleExports = function(
      path, exports, opt_closureNamespace) {};


  /**
   * Sets the current module state.
   *
   * @param {goog.ModuleType} type Type of module.
   */
  goog.LoadController.prototype.setModuleState = function(type) {};


  /**
   * Clears the current module state.
   */
  goog.LoadController.prototype.clearModuleState = function() {};


  /**
   * Registers a callback to call once the dependency is actually requested
   * via goog.require + all of the immediate dependencies have been loaded or
   * all other files have been loaded. Allows for lazy loading until
   * require'd without pausing dependency loading, which is needed on old IE.
   *
   * @param {!Function} callback
   */
  goog.LoadController.prototype.defer = function(callback) {};


  /**
   * @return {boolean}
   */
  goog.LoadController.prototype.areDepsLoaded = function() {};


  /**
   * Basic super class for all dependencies Closure Library can load.
   *
   * This default implementation is designed to load untranspiled, non-module
   * scripts in a web broswer.
   *
   * For goog.modules see {@see goog.GoogModuleDependency}.
   * For untranspiled ES6 modules {@see goog.Es6ModuleDependency}.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   */
  goog.Dependency = function(
      path, relativePath, provides, requires, loadFlags) {
    /** @const */
    this.path = path;
    /** @const */
    this.relativePath = relativePath;
    /** @const */
    this.provides = provides;
    /** @const */
    this.requires = requires;
    /** @const */
    this.loadFlags = loadFlags;
    /** @private {boolean} */
    this.loaded_ = false;
    /** @private {!Array<function()>} */
    this.loadCallbacks_ = [];
  };


  /**
   * @return {string} The pathname part of this dependency's path if it is a
   *     URI.
   */
  goog.Dependency.prototype.getPathName = function() {
    var pathName = this.path;
    var protocolIndex = pathName.indexOf('://');
    if (protocolIndex >= 0) {
      pathName = pathName.substring(protocolIndex + 3);
      var slashIndex = pathName.indexOf('/');
      if (slashIndex >= 0) {
        pathName = pathName.substring(slashIndex + 1);
      }
    }
    return pathName;
  };


  /**
   * @param {function()} callback Callback to fire as soon as this has loaded.
   * @final
   */
  goog.Dependency.prototype.onLoad = function(callback) {
    if (this.loaded_) {
      callback();
    } else {
      this.loadCallbacks_.push(callback);
    }
  };


  /**
   * Marks this dependency as loaded and fires any callbacks registered with
   * onLoad.
   * @final
   */
  goog.Dependency.prototype.loaded = function() {
    this.loaded_ = true;
    var callbacks = this.loadCallbacks_;
    this.loadCallbacks_ = [];
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i]();
    }
  };


  /**
   * Whether or not document.written / appended script tags should be deferred.
   *
   * @private {boolean}
   */
  goog.Dependency.defer_ = false;


  /**
   * Map of script ready / state change callbacks. Old IE cannot handle putting
   * these properties on goog.global.
   *
   * @private @const {!Object<string, function(?):undefined>}
   */
  goog.Dependency.callbackMap_ = {};


  /**
   * @param {function(...?):?} callback
   * @return {string}
   * @private
   */
  goog.Dependency.registerCallback_ = function(callback) {
    var key = Math.random().toString(32);
    goog.Dependency.callbackMap_[key] = callback;
    return key;
  };


  /**
   * @param {string} key
   * @private
   */
  goog.Dependency.unregisterCallback_ = function(key) {
    delete goog.Dependency.callbackMap_[key];
  };


  /**
   * @param {string} key
   * @param {...?} var_args
   * @private
   * @suppress {unusedPrivateMembers}
   */
  goog.Dependency.callback_ = function(key, var_args) {
    if (key in goog.Dependency.callbackMap_) {
      var callback = goog.Dependency.callbackMap_[key];
      var args = [];
      for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      callback.apply(undefined, args);
    } else {
      var errorMessage = 'Callback key ' + key +
          ' does not exist (was base.js loaded more than once?).';
      // MOE:begin_strip
      // TODO(johnplaisted): Some people internally are mistakenly loading
      // base.js twice, and this can happen while a dependency is loading,
      // wiping out state.
      goog.logToConsole_(errorMessage);
      // MOE:end_strip
      // MOE:insert throw Error(errorMessage);
    }
  };


  /**
   * Starts loading this dependency. This dependency can pause loading if it
   * needs to and resume it later via the controller interface.
   *
   * When this is loaded it should call controller.loaded(). Note that this will
   * end up calling the loaded method of this dependency; there is no need to
   * call it explicitly.
   *
   * @param {!goog.LoadController} controller
   */
  goog.Dependency.prototype.load = function(controller) {
    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    if (!goog.inHtmlDocument_()) {
      goog.logToConsole_(
          'Cannot use default debug loader outside of HTML documents.');
      if (this.relativePath == 'deps.js') {
        // CLOSURE_IMPORT_SCRIPT should be set *before* base.js is loaded.
        goog.logToConsole_(
            'Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js.');
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    /** @type {!HTMLDocument} */
    var doc = goog.global.document;

    // If the user tries to require a new symbol after document load,
    // something has gone terribly wrong. Doing a document.write would
    // wipe out the page. This does not apply to the CSP-compliant method
    // of writing script tags.
    if (doc.readyState == 'complete' &&
        !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
      // Certain test frameworks load base.js multiple times, which tries
      // to write deps.js each time. If that happens, just fail silently.
      // These frameworks wipe the page between each load of base.js, so this
      // is OK.
      var isDeps = /\bdeps.js$/.test(this.path);
      if (isDeps) {
        controller.loaded();
        return;
      } else {
        throw Error('Cannot write "' + this.path + '" after document load');
      }
    }

    var nonce = goog.getScriptNonce_();
    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
        goog.isDocumentLoading_()) {
      var key;
      var callback = function(script) {
        if (script.readyState && script.readyState != 'complete') {
          script.onload = callback;
          return;
        }
        goog.Dependency.unregisterCallback_(key);
        controller.loaded();
      };
      key = goog.Dependency.registerCallback_(callback);

      var defer = goog.Dependency.defer_ ? ' defer' : '';
      var nonceAttr = nonce ? ' nonce="' + nonce + '"' : '';
      var script = '<script src="' + this.path + '"' + nonceAttr + defer +
          ' id="script-' + key + '"><\/script>';

      script += '<script' + nonceAttr + '>';

      if (goog.Dependency.defer_) {
        script += 'document.getElementById(\'script-' + key +
            '\').onload = function() {\n' +
            '  goog.Dependency.callback_(\'' + key + '\', this);\n' +
            '};\n';
      } else {
        script += 'goog.Dependency.callback_(\'' + key +
            '\', document.getElementById(\'script-' + key + '\'));';
      }

      script += '<\/script>';

      doc.write(
          goog.TRUSTED_TYPES_POLICY_ ?
              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
              script);
    } else {
      var scriptEl =
          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));
      scriptEl.defer = goog.Dependency.defer_;
      scriptEl.async = false;

      // If CSP nonces are used, propagate them to dynamically created scripts.
      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.
      if (nonce) {
        scriptEl.nonce = nonce;
      }

      scriptEl.onload = function() {
        scriptEl.onload = null;
        controller.loaded();
      };

      scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?
          goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) :
          this.path;
      doc.head.appendChild(scriptEl);
    }
  };


  /**
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides Should be an empty array.
   *     TODO(johnplaisted) add support for adding closure namespaces to ES6
   *     modules for interop purposes.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   * @extends {goog.Dependency}
   */
  goog.Es6ModuleDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.Es6ModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
  };
  goog.inherits(goog.Es6ModuleDependency, goog.Dependency);


  /**
   * @override
   * @param {!goog.LoadController} controller
   */
  goog.Es6ModuleDependency.prototype.load = function(controller) {
    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    if (!goog.inHtmlDocument_()) {
      goog.logToConsole_(
          'Cannot use default debug loader outside of HTML documents.');
      controller.pause();
      return;
    }

    /** @type {!HTMLDocument} */
    var doc = goog.global.document;

    var dep = this;

    // TODO(johnplaisted): Does document.writing really speed up anything? Any
    // difference between this and just waiting for interactive mode and then
    // appending?
    function write(src, contents) {
      var nonceAttr = '';
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        nonceAttr = ' nonce="' + nonce + '"';
      }

      if (contents) {
        var script = '<script type="module" crossorigin' + nonceAttr + '>' +
            contents + '</' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      } else {
        var script = '<script type="module" crossorigin src="' + src + '"' +
            nonceAttr + '></' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      }
    }

    function append(src, contents) {
      var scriptEl =
          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));
      scriptEl.defer = true;
      scriptEl.async = false;
      scriptEl.type = 'module';
      scriptEl.setAttribute('crossorigin', true);

      // If CSP nonces are used, propagate them to dynamically created scripts.
      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        scriptEl.nonce = nonce;
      }

      if (contents) {
        scriptEl.text = goog.TRUSTED_TYPES_POLICY_ ?
            goog.TRUSTED_TYPES_POLICY_.createScript(contents) :
            contents;
      } else {
        scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?
            goog.TRUSTED_TYPES_POLICY_.createScriptURL(src) :
            src;
      }

      doc.head.appendChild(scriptEl);
    }

    var create;

    if (goog.isDocumentLoading_()) {
      create = write;
      // We can ONLY call document.write if we are guaranteed that any
      // non-module script tags document.written after this are deferred.
      // Small optimization, in theory document.writing is faster.
      goog.Dependency.defer_ = true;
    } else {
      create = append;
    }

    // Write 4 separate tags here:
    // 1) Sets the module state at the correct time (just before execution).
    // 2) A src node for this, which just hopefully lets the browser load it a
    //    little early (no need to parse #3).
    // 3) Import the module and register it.
    // 4) Clear the module state at the correct time. Guaranteed to run even
    //    if there is an error in the module (#3 will not run if there is an
    //    error in the module).
    var beforeKey = goog.Dependency.registerCallback_(function() {
      goog.Dependency.unregisterCallback_(beforeKey);
      controller.setModuleState(goog.ModuleType.ES6);
    });
    create(undefined, 'goog.Dependency.callback_("' + beforeKey + '")');

    // TODO(johnplaisted): Does this really speed up anything?
    create(this.path, undefined);

    var registerKey = goog.Dependency.registerCallback_(function(exports) {
      goog.Dependency.unregisterCallback_(registerKey);
      controller.registerEs6ModuleExports(
          dep.path, exports, goog.moduleLoaderState_.moduleName);
    });
    create(
        undefined,
        'import * as m from "' + this.path + '"; goog.Dependency.callback_("' +
            registerKey + '", m)');

    var afterKey = goog.Dependency.registerCallback_(function() {
      goog.Dependency.unregisterCallback_(afterKey);
      controller.clearModuleState();
      controller.loaded();
    });
    create(undefined, 'goog.Dependency.callback_("' + afterKey + '")');
  };


  /**
   * Superclass of any dependency that needs to be loaded into memory,
   * transformed, and then eval'd (goog.modules and transpiled files).
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor @abstract
   * @extends {goog.Dependency}
   */
  goog.TransformedDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.TransformedDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
    /** @private {?string} */
    this.contents_ = null;

    /**
     * Whether to lazily make the synchronous XHR (when goog.require'd) or make
     * the synchronous XHR when initially loading. On FireFox 61 there is a bug
     * where an ES6 module cannot make a synchronous XHR (rather, it can, but if
     * it does then no other ES6 modules will load after).
     *
     * tl;dr we lazy load due to bugs on older browsers and eager load due to
     * bugs on newer ones.
     *
     * https://bugzilla.mozilla.org/show_bug.cgi?id=1477090
     *
     * @private @const {boolean}
     */
    this.lazyFetch_ = !goog.inHtmlDocument_() ||
        !('noModule' in goog.global.document.createElement('script'));
  };
  goog.inherits(goog.TransformedDependency, goog.Dependency);


  /**
   * @override
   * @param {!goog.LoadController} controller
   */
  goog.TransformedDependency.prototype.load = function(controller) {
    var dep = this;

    function fetch() {
      dep.contents_ = goog.loadFileSync_(dep.path);

      if (dep.contents_) {
        dep.contents_ = dep.transform(dep.contents_);
        if (dep.contents_) {
          dep.contents_ += '\n//# sourceURL=' + dep.path;
        }
      }
    }

    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      fetch();
      if (this.contents_ &&
          goog.global.CLOSURE_IMPORT_SCRIPT('', this.contents_)) {
        this.contents_ = null;
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }


    var isEs6 = this.loadFlags['module'] == goog.ModuleType.ES6;

    if (!this.lazyFetch_) {
      fetch();
    }

    function load() {
      if (dep.lazyFetch_) {
        fetch();
      }

      if (!dep.contents_) {
        // loadFileSync_ or transform are responsible. Assume they logged an
        // error.
        return;
      }

      if (isEs6) {
        controller.setModuleState(goog.ModuleType.ES6);
      }

      var namespace;

      try {
        var contents = dep.contents_;
        dep.contents_ = null;
        goog.globalEval(goog.CLOSURE_EVAL_PREFILTER_.createScript(contents));
        if (isEs6) {
          namespace = goog.moduleLoaderState_.moduleName;
        }
      } finally {
        if (isEs6) {
          controller.clearModuleState();
        }
      }

      if (isEs6) {
        // Due to circular dependencies this may not be available for require
        // right now.
        goog.LEGACY_NAMESPACE_OBJECT_['$jscomp']['require']['ensure'](
            [dep.getPathName()], function() {
              controller.registerEs6ModuleExports(
                  dep.path,
                  goog.LEGACY_NAMESPACE_OBJECT_['$jscomp']['require'](
                      dep.getPathName()),
                  namespace);
            });
      }

      controller.loaded();
    }

    // Do not fetch now; in FireFox 47 the synchronous XHR doesn't block all
    // events. If we fetched now and then document.write'd the contents the
    // document.write would be an eval and would execute too soon! Instead write
    // a script tag to fetch and eval synchronously at the correct time.
    function fetchInOwnScriptThenLoad() {
      /** @type {!HTMLDocument} */
      var doc = goog.global.document;

      var key = goog.Dependency.registerCallback_(function() {
        goog.Dependency.unregisterCallback_(key);
        load();
      });

      var nonce = goog.getScriptNonce_();
      var nonceAttr = nonce ? ' nonce="' + nonce + '"' : '';
      var script = '<script' + nonceAttr + '>' +
          goog.protectScriptTag_('goog.Dependency.callback_("' + key + '");') +
          '</' +
          'script>';
      doc.write(
          goog.TRUSTED_TYPES_POLICY_ ?
              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
              script);
    }

    // If one thing is pending it is this.
    var anythingElsePending = controller.pending().length > 1;

    // Additionally if we are meant to defer scripts but the page is still
    // loading (e.g. an ES6 module is loading) then also defer. Or if we are
    // meant to defer and anything else is pending then defer (those may be
    // scripts that did not need transformation and are just script tags with
    // defer set to true, and we need to evaluate after that deferred script).
    var needsAsyncLoading = goog.Dependency.defer_ &&
        (anythingElsePending || goog.isDocumentLoading_());

    if (needsAsyncLoading) {
      // Note that we only defer when we have to rather than 100% of the time.
      // Always defering would work, but then in theory the order of
      // goog.require calls would then matter. We want to enforce that most of
      // the time the order of the require calls does not matter.
      controller.defer(function() {
        load();
      });
      return;
    }
    // TODO(johnplaisted): Externs are missing onreadystatechange for
    // HTMLDocument.
    /** @type {?} */
    var doc = goog.global.document;

    var isInternetExplorerOrEdge = goog.inHtmlDocument_() &&
        ('ActiveXObject' in goog.global || goog.isEdge_());

    // Don't delay in any version of IE or pre-Chromium Edge. There's a bug
    // around this that will cause out of order script execution. This means
    // that on older IE ES6 modules will load too early (while the document is
    // still loading + the dom is not available). The other option is to load
    // too late (when the document is complete and the onload even will never
    // fire). This seems to be the lesser of two evils as scripts already act
    // like the former.
    if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() &&
        !isInternetExplorerOrEdge) {
      goog.Dependency.defer_ = true;
      // Transpiled ES6 modules still need to load like regular ES6 modules,
      // aka only after the document is interactive.
      controller.pause();
      var oldCallback = doc.onreadystatechange;
      doc.onreadystatechange = function() {
        if (doc.readyState == 'interactive') {
          doc.onreadystatechange = oldCallback;
          load();
          controller.resume();
        }
        if (typeof oldCallback === 'function') {
          oldCallback.apply(undefined, arguments);
        }
      };
    } else {
      // Always eval on old IE.
      if (!goog.inHtmlDocument_() || !goog.isDocumentLoading_()) {
        load();
      } else {
        fetchInOwnScriptThenLoad();
      }
    }
  };


  /**
   * @param {string} contents
   * @return {string}
   * @abstract
   */
  goog.TransformedDependency.prototype.transform = function(contents) {};


  /**
   * An ES6 module dependency that was transpiled to a jscomp module outside
   * of the debug loader, e.g. server side.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   * @extends {goog.TransformedDependency}
   */
  goog.PreTranspiledEs6ModuleDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.PreTranspiledEs6ModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
  };
  goog.inherits(
      goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency);


  /**
   * @override
   * @param {string} contents
   * @return {string}
   */
  goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(
      contents) {
    return contents;
  };


  /**
   * A goog.module, transpiled or not. Will always perform some minimal
   * transformation even when not transpiled to wrap in a goog.loadModule
   * statement.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   * @extends {goog.TransformedDependency}
   */
  goog.GoogModuleDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.GoogModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
  };
  goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);


  /**
   * @override
   * @param {string} contents
   * @return {string}
   */
  goog.GoogModuleDependency.prototype.transform = function(contents) {
    if (!goog.LOAD_MODULE_USING_EVAL || goog.global.JSON === undefined) {
      return '' +
          'goog.loadModule(function(exports) {' +
          '"use strict";' + contents +
          '\n' +  // terminate any trailing single line comment.
          ';return exports' +
          '});' +
          '\n//# sourceURL=' + this.path + '\n';
    } else {
      return '' +
          'goog.loadModule(' +
          goog.global.JSON.stringify(
              contents + '\n//# sourceURL=' + this.path + '\n') +
          ');';
    }
  };


  /**
   * @param {string} relPath
   * @param {!Array<string>|undefined} provides
   * @param {!Array<string>} requires
   * @param {boolean|!Object<string>=} opt_loadFlags
   * @see goog.addDependency
   */
  goog.DebugLoader_.prototype.addDependency = function(
      relPath, provides, requires, opt_loadFlags) {
    provides = provides || [];
    relPath = relPath.replace(/\\/g, '/');
    var path = goog.normalizePath_(goog.basePath + relPath);
    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
      opt_loadFlags = opt_loadFlags ? {'module': goog.ModuleType.GOOG} : {};
    }
    var dep = this.factory_.createDependency(
        path, relPath, provides, requires, opt_loadFlags);
    this.dependencies_[path] = dep;
    for (var i = 0; i < provides.length; i++) {
      this.idToPath_[provides[i]] = path;
    }
    this.idToPath_[relPath] = path;
  };


  /**
   * Creates goog.Dependency instances for the debug loader to load.
   *
   * Should be overridden to have the debug loader use custom subclasses of
   * goog.Dependency.
   *
   * @struct @constructor
   */
  goog.DependencyFactory = function() {};


  /**
   * @param {string} path Absolute path of the file.
   * @param {string} relativePath Path relative to closureâs base.js.
   * @param {!Array<string>} provides Array of provided goog.provide/module ids.
   * @param {!Array<string>} requires Array of required goog.provide/module /
   *     relative ES6 module paths.
   * @param {!Object<string, string>} loadFlags
   * @return {!goog.Dependency}
   */
  goog.DependencyFactory.prototype.createDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    // MOE:begin_strip
    var provide, require;
    for (var i = 0; provide = provides[i]; i++) {
      goog.dependencies_.nameToPath[provide] = relativePath;
      goog.dependencies_.loadFlags[relativePath] = loadFlags;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(relativePath in goog.dependencies_.requires)) {
        goog.dependencies_.requires[relativePath] = {};
      }
      goog.dependencies_.requires[relativePath][require] = true;
    }
    // MOE:end_strip

    if (loadFlags['module'] == goog.ModuleType.GOOG) {
      return new goog.GoogModuleDependency(
          path, relativePath, provides, requires, loadFlags);
    } else {
      if (loadFlags['module'] == goog.ModuleType.ES6) {
        if (goog.ASSUME_ES_MODULES_TRANSPILED) {
          return new goog.PreTranspiledEs6ModuleDependency(
              path, relativePath, provides, requires, loadFlags);
        } else {
          return new goog.Es6ModuleDependency(
              path, relativePath, provides, requires, loadFlags);
        }
      } else {
        return new goog.Dependency(
            path, relativePath, provides, requires, loadFlags);
      }
    }
  };


  /** @private @const */
  goog.debugLoader_ = new goog.DebugLoader_();


  /**
   * Loads the Closure deps.js file.
   *
   * Exposed a public function so after base is loaded, and
   * then this can be called to load the closure deps.js file.
   */
  goog.loadClosureDeps = function() {
    goog.debugLoader_.loadClosureDeps();
  };


  /**
   * Sets the dependency factory, which can be used to create custom
   * goog.Dependency implementations to control how dependencies are loaded.
   *
   * Note:
   * You can call goog.loadClosureDeps to load the Closure dependency file
   * later, after your factory is injected.
   *
   * @param {!goog.DependencyFactory} factory
   */
  goog.setDependencyFactory = function(factory) {
    goog.debugLoader_.setDependencyFactory(factory);
  };


  /**
   * Trusted Types policy for the debug loader.
   * @private @const {?TrustedTypePolicy}
   */
  goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ?
      goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#base') :
      null;
}


if (!COMPILED) {
  var isChrome87 = false;
  // Cannot run check for Chrome <87 bug in case of strict CSP environments.
  // TODO(aaronshim): Remove once Chrome <87 bug is no longer a problem.
  try {
    isChrome87 = eval(goog.global.trustedTypes.emptyScript) !==
        goog.global.trustedTypes.emptyScript;
  } catch (err) {
  }

  /**
   * Trusted Types for running dev servers.
   *
   * @private @const
   */
  goog.CLOSURE_EVAL_PREFILTER_ =
      // Detect Chrome <87 bug with TT and eval.
      goog.global.trustedTypes && isChrome87 &&
          goog.createTrustedTypesPolicy('goog#base#devonly#eval') ||
      {createScript: goog.identity_};
}

//third_party/javascript/tslib/tslib_closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview
 * Hand-modified Closure version of tslib.js.
 * These use the literal space optimized code from TypeScript for
 * compatibility.
 *
 * @suppress {undefinedVars}
 */

// Do not use @license

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

goog.module('google3.third_party.javascript.tslib.tslib');

/** @suppress {missingPolyfill} the code below intentionally feature-tests. */
var extendStatics = Object.setPrototypeOf ||
    function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

/**
 * @param {?} d
 * @param {?} b
 */
exports.__extends = function(d, b) {
  extendStatics(d, b);
  // LOCAL MODIFICATION: Add jsdoc annotation here:
  /** @constructor */
  function __() { /** @type {?} */
    (this).constructor = d;
  }
  d.prototype =
      b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/** @type {typeof Object.assign} */
exports.__assign = Object.assign || /** @return {?} */ function(/** ? */ t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
  }
  return t;
};

/**
 * @param {?} s
 * @param {?} e
 * @return {?}
 */
exports.__rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === 'function')
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};

/**
 * @param {?} decorators
 * @param {T} target
 * @param {?=} key
 * @param {?=} desc
 * @return {T}
 * @template T
 */
exports.__decorate = function(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3     ? target :
      desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) :
                      desc,
      d;
  // google3 local modification: use quoted property access to work around
  // https://b.corp.google.com/issues/77140019.
  if (typeof Reflect === 'object' && Reflect &&
      typeof Reflect['decorate'] === 'function')
    r = Reflect['decorate'](decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * @param {?} paramIndex
 * @param {?} decorator
 * @return {?}
 */
exports.__param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};

exports.__setFunctionName = function(f, name, prefix) {
  if (typeof name === 'symbol')
    name = name.description ? '['.concat(name.description, ']') : '';
  return Object.defineProperty(f, 'name', {
    configurable: true,
    value: prefix ? ''.concat(prefix, ' ', name) : name
  });
};

/**
 * @param {?} metadataKey
 * @param {?} metadataValue
 * @return {?}
 */
exports.__metadata = function(metadataKey, metadataValue) {
  // google3 local modification: use quoted property access to work around
  // https://b.corp.google.com/issues/77140019.
  if (typeof Reflect === 'object' && Reflect &&
      typeof Reflect['metadata'] === 'function')
    return Reflect['metadata'](metadataKey, metadataValue);
};

/**
 * @template T
 * @param {T} thisArg
 * @param {?} _arguments
 * @param {?} P
 * @param {function(this:T)} generator
 * @return {?}
 */
exports.__awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    // LOCAL MODIFICATION: Cannot express the function + keys pattern in
    // closure, so we escape generator.next with ? type.
    function fulfilled(value) {
      try {
        step((/** @type {?} */ (generator)).next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator['throw'](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) :
                    adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

/**
 * @param {?} thisArg
 * @param {?} body
 * @return {?}
 */
exports.__generator = function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1) throw (/** @type {!Error} */ (t[1]));
      return t[1];
    },
    trys: [],
    ops: []
  },
      f, y, t, g;
  // LOCAL MODIFICATION: Originally iterator body was "return this", but it
  // doesn't compile as this is unknown. Changed to g, which is equivalent.
  return g = {next: verb(0), 'throw': verb(1), 'return': verb(2)},
         typeof Symbol === 'function' && (g[Symbol.iterator] = function() {
           return g;
         }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  /**
   * @suppress {strictMissingProperties} TODO(b/214874268): Remove
   * strictMissingProperties suppression after b/214427036 is fixed
   */
  function step(op) {
    if (f) throw new TypeError('Generator is already executing.');
    while (_) try {
        if (f = 1,
            y &&
                (t = op[0] & 2 ? y['return'] :
                     op[0] ? y['throw'] || ((t = y['return']) && t.call(y), 0) :
                             y.next) &&
                !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {value: op[1], done: false};
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) &&
                (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5) throw (/** @type {!Error} */ (op[1]));
    return {value: op[0] ? op[1] : void 0, done: true};
  }
};

/**
 * @param {?} m
 * @param {?} o
 */
exports.__exportStar = function(m, o) {
  for (var p in m)
    if (!o.hasOwnProperty(p)) o[p] = m[p];
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__values = function(o) {
  var m = typeof Symbol === 'function' && o[Symbol.iterator], i = 0;
  if (m) return m.call(o);
  return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return {value: o && o[i++], done: !o};
    }
  };
};

/**
 * @param {?} o
 * @param {?=} n
 * @return {?}
 */
exports.__read = function(o, n) {
  var m = typeof Symbol === 'function' && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {error: error};
  } finally {
    try {
      if (r && !r.done && (m = i['return'])) m.call(i);
    } finally {
      if (e) throw (/** @type {!Error} */ (e.error));
    }
  }
  return ar;
};


/** @deprecated */
exports.__spread = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(exports.__read(arguments[i]));
  return ar;
};

/** @deprecated */
exports.__spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};

/**
 * @param {!Array<?>} to
 * @param {!Array<?>} from
 * @param {!Array<?>} pack
 * @return {!Array<?>}
 */
exports.__spreadArray = function(to, from, pack) {
  // LOCAL MODIFICATION: https://github.com/microsoft/TypeScript/issues/43353
  // We have to accept NodeList because they don't implement Iterable in Edge.
  if (!Array.isArray(from) && !(from instanceof NodeList) &&
      Object.prototype.toString.call(from) !== '[object Arguments]') {
    throw new TypeError(
        'Expected an Array, NodeList, or or Arguments: ' + String(from));
  }
  // END LOCAL MODIFICATION
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * @constructor
 * LOCAL MODIFICATION: Originally used "this" in function body,
 * @this {?}
 * END LOCAL MODIFICATION
 * @param {?} v
 * @return {?}
 */
exports.__await = function(v) {
  return this instanceof exports.__await ? (this.v = v, this) :
                                           new exports.__await(v);
};

/**
 * @template T
 * @param {T} thisArg
 * @param {?} _arguments
 * @param {function(this:T)} generator
 * @return {?}
 */
exports.__asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb('next'), verb('throw'), verb('return', awaitReturn),
         i[Symbol.asyncIterator] = function() {
           return (/** @type {?} */ (this));
         }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  /**
   * @param {?} n
   * @param {?=} f
   * @return {?}
   */
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof exports.__await ?
        Promise.resolve(/** @type {?} */ (r.value).v).then(fulfill, reject) :
        settle(q[0][2], r);
  }
  function fulfill(value) {
    resume('next', value);
  }
  function reject(value) {
    resume('throw', value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__asyncDelegator = function(o) {
  var i, p;
  // LOCAL MODIFICATION: Originally iterator body was "return this", but it
  // doesn't compile in some builds, as this is unknown. Changed to i, which is
  // equivalent.
  return i = {}, verb('next'), verb('throw', function(e) {
           throw e;
         }), verb('return'), i[Symbol.iterator] = function() {
    return i;
  }, i;
  /**
   * @param {?} n
   * @param {?=} f
   * @return {?}
   */
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ?
          {value: new exports.__await(o[n](v)), done: n === 'return'} :
          f ? f(v) :
              v;
    } : f;
  }
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var m = o[Symbol.asyncIterator], i;
  return m ?
      m.call(o) :
      (o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator](),
       i = {}, verb('next'), verb('throw'), verb('return'),
       i[Symbol.asyncIterator] = function() {
         return (/** @type {?} */ (this));
       }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v) {
      resolve({value: v, done: d});
    }, reject);
  }
};

/**
 * @param {?=} cooked
 * @param {?=} raw
 * @return {?}
 */
exports.__makeTemplateObject = function(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, 'raw', {value: raw});
  } else {
    cooked.raw = raw;
  }
  return cooked;
};

/**
 * @param {?} receiver
 * @param {?} state
 * @param {?} kind
 * @param {?} f
 * @return {?}
 */
exports.__classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === 'a' && !f)
    throw new TypeError('Private accessor was defined without a getter');
  if (typeof state === 'function' ? receiver !== state || !f :
                                    !state.has(receiver))
    throw new TypeError(
        'Cannot read private member from an object whose class did not declare it');
  return kind === 'm' ? f :
      kind === 'a'    ? f.call(receiver) :
      f               ? f.value :
                        state.get(receiver);
};

/**
 * @param {?} receiver
 * @param {?} state
 * @param {?} value
 * @param {?} kind
 * @param {?} f
 * @return {?}
 */
exports.__classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === 'm') throw new TypeError('Private method is not writable');
  if (kind === 'a' && !f)
    throw new TypeError('Private accessor was defined without a setter');
  if (typeof state === 'function' ? receiver !== state || !f :
                                    !state.has(receiver))
    throw new TypeError(
        'Cannot write private member to an object whose class did not declare it');
  return (kind === 'a' ? f.call(receiver, value) :
              f        ? f.value = value :
                         state.set(receiver, value)),
         value;
};

/**
 * @param {?} state
 * @param {?} receiver
 * @return {?}
 */
exports.__classPrivateFieldIn = function(state, receiver) {
  if (receiver === null ||
      (typeof receiver !== 'object' && typeof receiver !== 'function'))
    throw new TypeError('Cannot use \'in\' operator on non-object');
  return typeof state === 'function' ? receiver === state : state.has(receiver);
};

;return exports;});

//javascript/typescript/contrib/check.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Helper methods for checking program state.
 *
 * Statically all helpers assert that the type of the input is sufficiently
 * narrow. At runtime the helpers behave in two different ways:
 * - checkExhaustive* - unconditionally throws.
 * - assumeExhaustive* - does nothing.
 *
 * Prefer `checkExhaustive()` unless you find yourself writing
 * `try {
 *    checkExhaustive(value);
 *  } catch (error) {
 *    // Handle the error.
 *  }`
 * in which case use `assumeExhaustive()` directly, without the `try`.
 * Generated from: javascript/typescript/contrib/check.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.javascript.typescript.contrib.check');
var module = module || { id: 'javascript/typescript/contrib/check.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Throw an exception on unexpected values.
 *
 * checkExhaustive can be used along with type narrowing to ensure at
 * compile time that all possible types for a value have been handled. For cases
 * where exhaustiveness can not be guaranteed at compile time (i.e. proto enums)
 * an exception will be thrown.
 *
 * A common use-case is in switch statements:
 *
 * ```
 * // enumValue: Enum.A | Enum.B
 * switch(enumValue) {
 *   case Enum.A:
 *   case Enum.B:
 *     break;
 *   default:
 *     checkExhaustive(enumValue);
 * }
 * ```
 *
 * This method throws an exception rather than using an assertion because
 * assertions are stripped in production code and we need the check to fail in
 * production.
 *
 * @param {?} value The value to be checked
 * @param {(undefined|string)=} msg An optional error message to throw
 * @return {?}
 */
function checkExhaustive(value, msg) {
    return checkExhaustiveAllowing(value, msg);
}
exports.checkExhaustive = checkExhaustive;
/**
 * Throw an exception on unexpected values.
 *
 * checkExhaustiveAllowing is similar to checkExhaustive, with one difference
 * that user can specify expected type of value other than 'never'.
 *
 * The template parameter is absolutely required so that the type checker can
 * actually ensure that nothing other than the explicitly-allowed types is
 * passed.  If the allowed type is broader than you expect, consider trying a
 * different approach to narrow it, or else using the go/guards-and-assertions
 * library to make a different kind of assertion.
 *
 * It is useful when enum contains values that should never occur. Those should
 * be passed as the type argument to checkExhaustiveAllowing. A common use-case
 * would be like:
 *
 * ```
 * // enumValue: Enum.A | Enum.B | Enum.UNSPECIFIED | Enum.UNKNOWN
 * switch(enumValue) {
 *   case Enum.A:
 *   case Enum.B:
 *     break;
 *   default:
 *     checkExhaustiveAllowing<Enum.UNSPECIFIED|Enum.UNKNOWN>(enumValue);
 * }
 * ```
 *
 * @template Allowed, Arg
 * @param {Arg} value The value to be checked
 * @param {string=} msg An optional error message to throw
 * @return {?}
 */
function checkExhaustiveAllowing(value, msg = `unexpected value ${value}!`) {
    throw new Error(msg);
}
exports.checkExhaustiveAllowing = checkExhaustiveAllowing;
/**
 * Type argument for legacy incorrect usages of `checkExhaustiveAllowing`.
 * This function is intended to be called with an explicit template parameter,
 * but this was not always enforced. When the parameter is elided, the type
 * checker cannot actually verify anything useful. This placeholder type allows
 * legacy callsites to continue passing type checking, but should not be used in
 * new calls.
 *
 * Consider replacing the call to `checkExhaustiveAllowing` with a call to the
 * Guards and Assertions library (go/guards-and-assertions).
 * @typedef {*}
 */
exports.LegacyIncorrectUsage;
/**
 * Fail to compile on unexpected values.
 *
 * assumeExhaustive can be used along with type narrowing to ensure at compile
 * time that all possible types for a value have been handled. At runtime it is
 * a no-op.
 *
 * A common use-case is in switch statements:
 *
 * ```
 * // sensibleDefault: string
 * // numericEnumValue: Enum.A | Enum.B
 * switch(numericEnumValue) {
 *   case Enum.A:
 *     return 'A';
 *   case Enum.B:
 *     return 'B';
 *   default:
 *     assumeExhaustive(numericEnumValue);
 *     return sensibleDefault;
 * }
 * ```
 * @param {?} value
 * @return {void}
 */
function assumeExhaustive(value) { }
exports.assumeExhaustive = assumeExhaustive;
/**
 * Fail to compile on unexpected values.
 *
 * assumeExhaustiveAllowing is similar to assumeExhaustive, with one difference
 * that user can specify expected type of value other than 'never'.
 *
 * It is useful when enum contains values that should never occur. Those should
 * be passed as the type argument to assumeExhaustiveAllowing. A common use-case
 * would be like:
 *
 * ```
 * // enumValue: Enum.A | Enum.B | Enum.UNSPECIFIED | Enum.UNKNOWN
 * switch(enumValue) {
 *   case Enum.A:
 *     break;
 *   case Enum.B:
 *     break;
 *   default:
 *     assumeExhaustiveAllowing<Enum.UNSPECIFIED|Enum.UNKNOWN>(enumValue);
 *     break;
 * }
 * ```
 * @template Allowed, Arg
 * @param {Arg} value
 * @return {void}
 */
function assumeExhaustiveAllowing(value) { }
exports.assumeExhaustiveAllowing = assumeExhaustiveAllowing;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3R5cGVzY3JpcHQvY29udHJpYi9jaGVjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBLFNBQWdCLGVBQWUsQ0FBQyxLQUFZLEVBQUUsR0FBWTtJQUN4RCxPQUFPLHVCQUF1QixDQUFRLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRkQsMENBRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDRCxTQUFnQix1QkFBdUIsQ0FHckMsS0FBVSxFQUFFLEdBQUcsR0FBRyxvQkFBb0IsS0FBSyxHQUFHO0lBQzlDLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUxELDBEQUtDOzs7Ozs7Ozs7Ozs7O0FBYUQsNkJBQTJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCM0MsU0FBZ0IsZ0JBQWdCLENBQUMsS0FBWSxJQUFTLENBQUM7QUFBdkQsNENBQXVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QnZELFNBQWdCLHdCQUF3QixDQUd0QyxLQUFVLElBQVMsQ0FBQztBQUh0Qiw0REFHc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGVscGVyIG1ldGhvZHMgZm9yIGNoZWNraW5nIHByb2dyYW0gc3RhdGUuXG4gKlxuICogU3RhdGljYWxseSBhbGwgaGVscGVycyBhc3NlcnQgdGhhdCB0aGUgdHlwZSBvZiB0aGUgaW5wdXQgaXMgc3VmZmljaWVudGx5XG4gKiBuYXJyb3cuIEF0IHJ1bnRpbWUgdGhlIGhlbHBlcnMgYmVoYXZlIGluIHR3byBkaWZmZXJlbnQgd2F5czpcbiAqIC0gY2hlY2tFeGhhdXN0aXZlKiAtIHVuY29uZGl0aW9uYWxseSB0aHJvd3MuXG4gKiAtIGFzc3VtZUV4aGF1c3RpdmUqIC0gZG9lcyBub3RoaW5nLlxuICpcbiAqIFByZWZlciBgY2hlY2tFeGhhdXN0aXZlKClgIHVubGVzcyB5b3UgZmluZCB5b3Vyc2VsZiB3cml0aW5nXG4gKiBgdHJ5IHtcbiAqICAgIGNoZWNrRXhoYXVzdGl2ZSh2YWx1ZSk7XG4gKiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAqICAgIC8vIEhhbmRsZSB0aGUgZXJyb3IuXG4gKiAgfWBcbiAqIGluIHdoaWNoIGNhc2UgdXNlIGBhc3N1bWVFeGhhdXN0aXZlKClgIGRpcmVjdGx5LCB3aXRob3V0IHRoZSBgdHJ5YC5cbiAqL1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBvbiB1bmV4cGVjdGVkIHZhbHVlcy5cbiAqXG4gKiBjaGVja0V4aGF1c3RpdmUgY2FuIGJlIHVzZWQgYWxvbmcgd2l0aCB0eXBlIG5hcnJvd2luZyB0byBlbnN1cmUgYXRcbiAqIGNvbXBpbGUgdGltZSB0aGF0IGFsbCBwb3NzaWJsZSB0eXBlcyBmb3IgYSB2YWx1ZSBoYXZlIGJlZW4gaGFuZGxlZC4gRm9yIGNhc2VzXG4gKiB3aGVyZSBleGhhdXN0aXZlbmVzcyBjYW4gbm90IGJlIGd1YXJhbnRlZWQgYXQgY29tcGlsZSB0aW1lIChpLmUuIHByb3RvIGVudW1zKVxuICogYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEEgY29tbW9uIHVzZS1jYXNlIGlzIGluIHN3aXRjaCBzdGF0ZW1lbnRzOlxuICpcbiAqIGBgYFxuICogLy8gZW51bVZhbHVlOiBFbnVtLkEgfCBFbnVtLkJcbiAqIHN3aXRjaChlbnVtVmFsdWUpIHtcbiAqICAgY2FzZSBFbnVtLkE6XG4gKiAgIGNhc2UgRW51bS5COlxuICogICAgIGJyZWFrO1xuICogICBkZWZhdWx0OlxuICogICAgIGNoZWNrRXhoYXVzdGl2ZShlbnVtVmFsdWUpO1xuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBtZXRob2QgdGhyb3dzIGFuIGV4Y2VwdGlvbiByYXRoZXIgdGhhbiB1c2luZyBhbiBhc3NlcnRpb24gYmVjYXVzZVxuICogYXNzZXJ0aW9ucyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBjb2RlIGFuZCB3ZSBuZWVkIHRoZSBjaGVjayB0byBmYWlsIGluXG4gKiBwcm9kdWN0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIG1zZyBBbiBvcHRpb25hbCBlcnJvciBtZXNzYWdlIHRvIHRocm93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0V4aGF1c3RpdmUodmFsdWU6IG5ldmVyLCBtc2c/OiBzdHJpbmcpOiBuZXZlciB7XG4gIHJldHVybiBjaGVja0V4aGF1c3RpdmVBbGxvd2luZzxuZXZlcj4odmFsdWUsIG1zZyk7XG59XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIG9uIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICpcbiAqIGNoZWNrRXhoYXVzdGl2ZUFsbG93aW5nIGlzIHNpbWlsYXIgdG8gY2hlY2tFeGhhdXN0aXZlLCB3aXRoIG9uZSBkaWZmZXJlbmNlXG4gKiB0aGF0IHVzZXIgY2FuIHNwZWNpZnkgZXhwZWN0ZWQgdHlwZSBvZiB2YWx1ZSBvdGhlciB0aGFuICduZXZlcicuXG4gKlxuICogVGhlIHRlbXBsYXRlIHBhcmFtZXRlciBpcyBhYnNvbHV0ZWx5IHJlcXVpcmVkIHNvIHRoYXQgdGhlIHR5cGUgY2hlY2tlciBjYW5cbiAqIGFjdHVhbGx5IGVuc3VyZSB0aGF0IG5vdGhpbmcgb3RoZXIgdGhhbiB0aGUgZXhwbGljaXRseS1hbGxvd2VkIHR5cGVzIGlzXG4gKiBwYXNzZWQuICBJZiB0aGUgYWxsb3dlZCB0eXBlIGlzIGJyb2FkZXIgdGhhbiB5b3UgZXhwZWN0LCBjb25zaWRlciB0cnlpbmcgYVxuICogZGlmZmVyZW50IGFwcHJvYWNoIHRvIG5hcnJvdyBpdCwgb3IgZWxzZSB1c2luZyB0aGUgZ28vZ3VhcmRzLWFuZC1hc3NlcnRpb25zXG4gKiBsaWJyYXJ5IHRvIG1ha2UgYSBkaWZmZXJlbnQga2luZCBvZiBhc3NlcnRpb24uXG4gKlxuICogSXQgaXMgdXNlZnVsIHdoZW4gZW51bSBjb250YWlucyB2YWx1ZXMgdGhhdCBzaG91bGQgbmV2ZXIgb2NjdXIuIFRob3NlIHNob3VsZFxuICogYmUgcGFzc2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50IHRvIGNoZWNrRXhoYXVzdGl2ZUFsbG93aW5nLiBBIGNvbW1vbiB1c2UtY2FzZVxuICogd291bGQgYmUgbGlrZTpcbiAqXG4gKiBgYGBcbiAqIC8vIGVudW1WYWx1ZTogRW51bS5BIHwgRW51bS5CIHwgRW51bS5VTlNQRUNJRklFRCB8IEVudW0uVU5LTk9XTlxuICogc3dpdGNoKGVudW1WYWx1ZSkge1xuICogICBjYXNlIEVudW0uQTpcbiAqICAgY2FzZSBFbnVtLkI6XG4gKiAgICAgYnJlYWs7XG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgY2hlY2tFeGhhdXN0aXZlQWxsb3dpbmc8RW51bS5VTlNQRUNJRklFRHxFbnVtLlVOS05PV04+KGVudW1WYWx1ZSk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSBtc2cgQW4gb3B0aW9uYWwgZXJyb3IgbWVzc2FnZSB0byB0aHJvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeGhhdXN0aXZlQWxsb3dpbmc8XG4gIEFsbG93ZWQgPSBuZXZlcixcbiAgQXJnIGV4dGVuZHMgQWxsb3dlZCA9IEFsbG93ZWQsXG4+KHZhbHVlOiBBcmcsIG1zZyA9IGB1bmV4cGVjdGVkIHZhbHVlICR7dmFsdWV9IWApOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuXG4vKipcbiAqIFR5cGUgYXJndW1lbnQgZm9yIGxlZ2FjeSBpbmNvcnJlY3QgdXNhZ2VzIG9mIGBjaGVja0V4aGF1c3RpdmVBbGxvd2luZ2AuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV4cGxpY2l0IHRlbXBsYXRlIHBhcmFtZXRlcixcbiAqIGJ1dCB0aGlzIHdhcyBub3QgYWx3YXlzIGVuZm9yY2VkLiBXaGVuIHRoZSBwYXJhbWV0ZXIgaXMgZWxpZGVkLCB0aGUgdHlwZVxuICogY2hlY2tlciBjYW5ub3QgYWN0dWFsbHkgdmVyaWZ5IGFueXRoaW5nIHVzZWZ1bC4gVGhpcyBwbGFjZWhvbGRlciB0eXBlIGFsbG93c1xuICogbGVnYWN5IGNhbGxzaXRlcyB0byBjb250aW51ZSBwYXNzaW5nIHR5cGUgY2hlY2tpbmcsIGJ1dCBzaG91bGQgbm90IGJlIHVzZWQgaW5cbiAqIG5ldyBjYWxscy5cbiAqXG4gKiBDb25zaWRlciByZXBsYWNpbmcgdGhlIGNhbGwgdG8gYGNoZWNrRXhoYXVzdGl2ZUFsbG93aW5nYCB3aXRoIGEgY2FsbCB0byB0aGVcbiAqIEd1YXJkcyBhbmQgQXNzZXJ0aW9ucyBsaWJyYXJ5IChnby9ndWFyZHMtYW5kLWFzc2VydGlvbnMpLlxuICovXG5leHBvcnQgdHlwZSBMZWdhY3lJbmNvcnJlY3RVc2FnZSA9IHVua25vd247XG5cbi8qKlxuICogRmFpbCB0byBjb21waWxlIG9uIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICpcbiAqIGFzc3VtZUV4aGF1c3RpdmUgY2FuIGJlIHVzZWQgYWxvbmcgd2l0aCB0eXBlIG5hcnJvd2luZyB0byBlbnN1cmUgYXQgY29tcGlsZVxuICogdGltZSB0aGF0IGFsbCBwb3NzaWJsZSB0eXBlcyBmb3IgYSB2YWx1ZSBoYXZlIGJlZW4gaGFuZGxlZC4gQXQgcnVudGltZSBpdCBpc1xuICogYSBuby1vcC5cbiAqXG4gKiBBIGNvbW1vbiB1c2UtY2FzZSBpcyBpbiBzd2l0Y2ggc3RhdGVtZW50czpcbiAqXG4gKiBgYGBcbiAqIC8vIHNlbnNpYmxlRGVmYXVsdDogc3RyaW5nXG4gKiAvLyBudW1lcmljRW51bVZhbHVlOiBFbnVtLkEgfCBFbnVtLkJcbiAqIHN3aXRjaChudW1lcmljRW51bVZhbHVlKSB7XG4gKiAgIGNhc2UgRW51bS5BOlxuICogICAgIHJldHVybiAnQSc7XG4gKiAgIGNhc2UgRW51bS5COlxuICogICAgIHJldHVybiAnQic7XG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzdW1lRXhoYXVzdGl2ZShudW1lcmljRW51bVZhbHVlKTtcbiAqICAgICByZXR1cm4gc2Vuc2libGVEZWZhdWx0O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3N1bWVFeGhhdXN0aXZlKHZhbHVlOiBuZXZlcik6IHZvaWQge31cblxuLyoqXG4gKiBGYWlsIHRvIGNvbXBpbGUgb24gdW5leHBlY3RlZCB2YWx1ZXMuXG4gKlxuICogYXNzdW1lRXhoYXVzdGl2ZUFsbG93aW5nIGlzIHNpbWlsYXIgdG8gYXNzdW1lRXhoYXVzdGl2ZSwgd2l0aCBvbmUgZGlmZmVyZW5jZVxuICogdGhhdCB1c2VyIGNhbiBzcGVjaWZ5IGV4cGVjdGVkIHR5cGUgb2YgdmFsdWUgb3RoZXIgdGhhbiAnbmV2ZXInLlxuICpcbiAqIEl0IGlzIHVzZWZ1bCB3aGVuIGVudW0gY29udGFpbnMgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyIG9jY3VyLiBUaG9zZSBzaG91bGRcbiAqIGJlIHBhc3NlZCBhcyB0aGUgdHlwZSBhcmd1bWVudCB0byBhc3N1bWVFeGhhdXN0aXZlQWxsb3dpbmcuIEEgY29tbW9uIHVzZS1jYXNlXG4gKiB3b3VsZCBiZSBsaWtlOlxuICpcbiAqIGBgYFxuICogLy8gZW51bVZhbHVlOiBFbnVtLkEgfCBFbnVtLkIgfCBFbnVtLlVOU1BFQ0lGSUVEIHwgRW51bS5VTktOT1dOXG4gKiBzd2l0Y2goZW51bVZhbHVlKSB7XG4gKiAgIGNhc2UgRW51bS5BOlxuICogICAgIGJyZWFrO1xuICogICBjYXNlIEVudW0uQjpcbiAqICAgICBicmVhaztcbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3N1bWVFeGhhdXN0aXZlQWxsb3dpbmc8RW51bS5VTlNQRUNJRklFRHxFbnVtLlVOS05PV04+KGVudW1WYWx1ZSk7XG4gKiAgICAgYnJlYWs7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc3VtZUV4aGF1c3RpdmVBbGxvd2luZzxcbiAgQWxsb3dlZCA9IG5ldmVyLFxuICBBcmcgZXh0ZW5kcyBBbGxvd2VkID0gQWxsb3dlZCxcbj4odmFsdWU6IEFyZyk6IHZvaWQge31cbiJdfQ==
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/common/flags/generated_flags.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: blaze-out/k8-fastbuild/bin/learning/brain/mobile/lite/tooling/model_graph_visualizer/common/flags/generated_flags.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
// overriding flags from learning/brain/mobile/lite/tooling/model_graph_visualizer/common/flags/external.txt
//   overriding IS_EXTERNAL = true
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.common.flags.generated_flags');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/common/flags/generated_flags.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Sets this to true to enable external-only features.
 * @type {boolean}
 */
exports.IS_EXTERNAL = true;
/**
 * Sets this to true to make the local external app talking to the local ME
 * python server for better development experience.
 * @type {boolean}
 */
exports.LOCAL_EXTERNAL_DEV = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkX2ZsYWdzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL2NvbW1vbi9mbGFncy9nZW5lcmF0ZWRfZmxhZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUthLFFBQUEsV0FBVyxHQUFHLElBQUk7Ozs7OztBQU1sQixRQUFBLGtCQUFrQixHQUFHLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBvdmVycmlkaW5nIGZsYWdzIGZyb20gbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL2NvbW1vbi9mbGFncy9leHRlcm5hbC50eHRcbi8vICAgb3ZlcnJpZGluZyBJU19FWFRFUk5BTCA9IHRydWVcbi8qKlxuKiBTZXRzIHRoaXMgdG8gdHJ1ZSB0byBlbmFibGUgZXh0ZXJuYWwtb25seSBmZWF0dXJlcy5cbiovXG5leHBvcnQgY29uc3QgSVNfRVhURVJOQUwgPSB0cnVlO1xuXG4vKipcbiogU2V0cyB0aGlzIHRvIHRydWUgdG8gbWFrZSB0aGUgbG9jYWwgZXh0ZXJuYWwgYXBwIHRhbGtpbmcgdG8gdGhlIGxvY2FsIE1FXG4qIHB5dGhvbiBzZXJ2ZXIgZm9yIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlLlxuKi9cbmV4cG9ydCBjb25zdCBMT0NBTF9FWFRFUk5BTF9ERVYgPSBmYWxzZTtcbiJdfQ==
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/consts.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/consts.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/consts.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_generated_flags_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.common.flags.generated_flags");
const generated_flags_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.common.flags.generated_flags');
/**
 * The padding between the label and the value in node's attrs table.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_LABEL_VALUE_PADDING = 4;
/**
 * The padding of the left and right of the attrs table.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_LEFT_RIGHT_PADDING = 4;
/**
 * The font size of the attrs table.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_FONT_SIZE = 9;
/**
 * The top margin above node's attrs table.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_MARGIN_TOP = 16;
/**
 * The max width of the node's attrs table values.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_VALUE_MAX_WIDTH = 200;
/**
 * The height of attrs table row.
 * @type {number}
 */
exports.NODE_ATTRS_TABLE_ROW_HEIGHT = 12;
/**
 * The maximum number of children nodes under a group node.
 * @type {number}
 */
exports.DEFAULT_GROUP_NODE_CHILDREN_COUNT_THRESHOLD = generated_flags_1.IS_EXTERNAL
    ? 1000
    : 400;
/**
 * The corner radius of the op node.
 * @type {number}
 */
exports.OP_NODE_CORNER_RADIUS = 6;
/**
 * Y factor for elements rendered in webgl.
 * @type {number}
 */
exports.WEBGL_ELEMENT_Y_FACTOR = 0.001;
/**
 * Number of segments on a curve.
 * @type {number}
 */
exports.WEBGL_CURVE_SEGMENTS = 25;
/**
 * Height of the bg color bars for node data provider.
 * @type {number}
 */
exports.NODE_DATA_PROVIDER_BG_COLOR_BAR_HEIGHT = 5;
/**
 * The key to expose test related objects.
 * @type {string}
 */
exports.GLOBAL_KEY = 'me_test';
/**
 * The tension for the catmullrom curve.
 * @type {number}
 */
exports.CATMULLROM_CURVE_TENSION = 0.1;
/**
 * The key to store the show on node item types in local storage.
 * @type {string}
 */
exports.LOCAL_STORAGE_KEY_SHOW_ON_NODE_ITEM_TYPES = 'model_explorer_show_on_node_item_types_v2';
/**
 * The key to store the show on edge item types in local storage.
 * @type {string}
 */
exports.LOCAL_STORAGE_KEY_SHOW_ON_EDGE_ITEM_TYPES = 'model_explorer_show_on_edge_item_types_v2';
/**
 * The prefix for node data provider show on node type.
 * @type {string}
 */
exports.NODE_DATA_PROVIDER_SHOW_ON_NODE_TYPE_PREFIX = 'Node data provider: ';
/**
 * The maximum number of input/output rows in the attrs table.
 * @type {number}
 */
exports.MAX_IO_ROWS_IN_ATTRS_TABLE = 10;
/**
 * The default font size of the edge label.
 * @type {number}
 */
exports.DEFAULT_EDGE_LABEL_FONT_SIZE = 7.5;
/**
 * The key to store the tensor values in node attributes.
 * @type {string}
 */
exports.TENSOR_VALUES_KEY = '__value';
/**
 * The key to store the tensor tag in i/o metadata.
 * @type {string}
 */
exports.TENSOR_TAG_METADATA_KEY = '__tensor_tag';
/**
 * A map from color names to the corresponding hex color.
 * @type {?}
 */
exports.COLOR_NAME_TO_HEX = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred ': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'rebeccapurple': '#663399',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32',
};
/**
 * The port number for external local dev server.
 * @type {number}
 */
exports.EXTERNAL_LOCAL_DEV_PORT = 8081;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL21vZHVsZS9jb21tb24vY29uc3RzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUlBQStEOzs7OztBQUtsRCxRQUFBLG9DQUFvQyxHQUFHLENBQUM7Ozs7O0FBR3hDLFFBQUEsbUNBQW1DLEdBQUcsQ0FBQzs7Ozs7QUFHdkMsUUFBQSwwQkFBMEIsR0FBRyxDQUFDOzs7OztBQUc5QixRQUFBLDJCQUEyQixHQUFHLEVBQUU7Ozs7O0FBR2hDLFFBQUEsZ0NBQWdDLEdBQUcsR0FBRzs7Ozs7QUFHdEMsUUFBQSwyQkFBMkIsR0FBRyxFQUFFOzs7OztBQUdoQyxRQUFBLDJDQUEyQyxHQUFHLDZCQUFXO0lBQ3BFLENBQUMsQ0FBQyxJQUFJO0lBQ04sQ0FBQyxDQUFDLEdBQUc7Ozs7O0FBR00sUUFBQSxxQkFBcUIsR0FBRyxDQUFDOzs7OztBQUd6QixRQUFBLHNCQUFzQixHQUFHLEtBQUs7Ozs7O0FBRzlCLFFBQUEsb0JBQW9CLEdBQUcsRUFBRTs7Ozs7QUFHekIsUUFBQSxzQ0FBc0MsR0FBRyxDQUFDOzs7OztBQUcxQyxRQUFBLFVBQVUsR0FBRyxTQUFTOzs7OztBQUd0QixRQUFBLHdCQUF3QixHQUFHLEdBQUc7Ozs7O0FBRzlCLFFBQUEseUNBQXlDLEdBQ3BELDJDQUEyQzs7Ozs7QUFHaEMsUUFBQSx5Q0FBeUMsR0FDcEQsMkNBQTJDOzs7OztBQUdoQyxRQUFBLDJDQUEyQyxHQUN0RCxzQkFBc0I7Ozs7O0FBR1gsUUFBQSwwQkFBMEIsR0FBRyxFQUFFOzs7OztBQUcvQixRQUFBLDRCQUE0QixHQUFHLEdBQUc7Ozs7O0FBR2xDLFFBQUEsaUJBQWlCLEdBQUcsU0FBUzs7Ozs7QUFHN0IsUUFBQSx1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QUFXLEVBQUUsU0FBUztJQUN0QixXQUFXLEVBQUUsU0FBUztJQUN0QixNQUFNLEVBQUUsU0FBUztJQUNqQixhQUFhLEVBQUUsU0FBUztJQUN4QixXQUFXLEVBQUUsU0FBUztJQUN0QixLQUFLLEVBQUUsU0FBUztJQUNoQixNQUFNLEVBQUUsU0FBUztJQUNqQixTQUFTLEVBQUUsU0FBUztJQUNwQixRQUFRLEVBQUUsU0FBUztJQUNuQixXQUFXLEVBQUUsU0FBUztJQUN0QixRQUFRLEVBQUUsU0FBUztJQUNuQixPQUFPLEVBQUUsU0FBUztJQUNsQixPQUFPLEVBQUUsU0FBUztJQUNsQixZQUFZLEVBQUUsU0FBUztJQUN2QixRQUFRLEVBQUUsU0FBUztJQUNuQixhQUFhLEVBQUUsU0FBUztDQUN6Qjs7Ozs7QUFHWSxRQUFBLHVCQUF1QixHQUFHLElBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0lTX0VYVEVSTkFMfSBmcm9tICcuLi8uLi9jb21tb24vZmxhZ3MvZ2VuZXJhdGVkX2ZsYWdzJztcblxuLyoqXG4gKiBUaGUgcGFkZGluZyBiZXR3ZWVuIHRoZSBsYWJlbCBhbmQgdGhlIHZhbHVlIGluIG5vZGUncyBhdHRycyB0YWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IE5PREVfQVRUUlNfVEFCTEVfTEFCRUxfVkFMVUVfUEFERElORyA9IDQ7XG5cbi8qKiBUaGUgcGFkZGluZyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGF0dHJzIHRhYmxlLiAqL1xuZXhwb3J0IGNvbnN0IE5PREVfQVRUUlNfVEFCTEVfTEVGVF9SSUdIVF9QQURESU5HID0gNDtcblxuLyoqIFRoZSBmb250IHNpemUgb2YgdGhlIGF0dHJzIHRhYmxlLiAqL1xuZXhwb3J0IGNvbnN0IE5PREVfQVRUUlNfVEFCTEVfRk9OVF9TSVpFID0gOTtcblxuLyoqIFRoZSB0b3AgbWFyZ2luIGFib3ZlIG5vZGUncyBhdHRycyB0YWJsZS4gKi9cbmV4cG9ydCBjb25zdCBOT0RFX0FUVFJTX1RBQkxFX01BUkdJTl9UT1AgPSAxNjtcblxuLyoqIFRoZSBtYXggd2lkdGggb2YgdGhlIG5vZGUncyBhdHRycyB0YWJsZSB2YWx1ZXMuICovXG5leHBvcnQgY29uc3QgTk9ERV9BVFRSU19UQUJMRV9WQUxVRV9NQVhfV0lEVEggPSAyMDA7XG5cbi8qKiBUaGUgaGVpZ2h0IG9mIGF0dHJzIHRhYmxlIHJvdy4gKi9cbmV4cG9ydCBjb25zdCBOT0RFX0FUVFJTX1RBQkxFX1JPV19IRUlHSFQgPSAxMjtcblxuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGlsZHJlbiBub2RlcyB1bmRlciBhIGdyb3VwIG5vZGUuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9HUk9VUF9OT0RFX0NISUxEUkVOX0NPVU5UX1RIUkVTSE9MRCA9IElTX0VYVEVSTkFMXG4gID8gMTAwMFxuICA6IDQwMDtcblxuLyoqIFRoZSBjb3JuZXIgcmFkaXVzIG9mIHRoZSBvcCBub2RlLiAqL1xuZXhwb3J0IGNvbnN0IE9QX05PREVfQ09STkVSX1JBRElVUyA9IDY7XG5cbi8qKiBZIGZhY3RvciBmb3IgZWxlbWVudHMgcmVuZGVyZWQgaW4gd2ViZ2wuICovXG5leHBvcnQgY29uc3QgV0VCR0xfRUxFTUVOVF9ZX0ZBQ1RPUiA9IDAuMDAxO1xuXG4vKiogTnVtYmVyIG9mIHNlZ21lbnRzIG9uIGEgY3VydmUuICovXG5leHBvcnQgY29uc3QgV0VCR0xfQ1VSVkVfU0VHTUVOVFMgPSAyNTtcblxuLyoqIEhlaWdodCBvZiB0aGUgYmcgY29sb3IgYmFycyBmb3Igbm9kZSBkYXRhIHByb3ZpZGVyLiAqL1xuZXhwb3J0IGNvbnN0IE5PREVfREFUQV9QUk9WSURFUl9CR19DT0xPUl9CQVJfSEVJR0hUID0gNTtcblxuLyoqIFRoZSBrZXkgdG8gZXhwb3NlIHRlc3QgcmVsYXRlZCBvYmplY3RzLiAqL1xuZXhwb3J0IGNvbnN0IEdMT0JBTF9LRVkgPSAnbWVfdGVzdCc7XG5cbi8qKiBUaGUgdGVuc2lvbiBmb3IgdGhlIGNhdG11bGxyb20gY3VydmUuICovXG5leHBvcnQgY29uc3QgQ0FUTVVMTFJPTV9DVVJWRV9URU5TSU9OID0gMC4xO1xuXG4vKiogVGhlIGtleSB0byBzdG9yZSB0aGUgc2hvdyBvbiBub2RlIGl0ZW0gdHlwZXMgaW4gbG9jYWwgc3RvcmFnZS4gKi9cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX0tFWV9TSE9XX09OX05PREVfSVRFTV9UWVBFUyA9XG4gICdtb2RlbF9leHBsb3Jlcl9zaG93X29uX25vZGVfaXRlbV90eXBlc192Mic7XG5cbi8qKiBUaGUga2V5IHRvIHN0b3JlIHRoZSBzaG93IG9uIGVkZ2UgaXRlbSB0eXBlcyBpbiBsb2NhbCBzdG9yYWdlLiAqL1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZX1NIT1dfT05fRURHRV9JVEVNX1RZUEVTID1cbiAgJ21vZGVsX2V4cGxvcmVyX3Nob3dfb25fZWRnZV9pdGVtX3R5cGVzX3YyJztcblxuLyoqIFRoZSBwcmVmaXggZm9yIG5vZGUgZGF0YSBwcm92aWRlciBzaG93IG9uIG5vZGUgdHlwZS4gKi9cbmV4cG9ydCBjb25zdCBOT0RFX0RBVEFfUFJPVklERVJfU0hPV19PTl9OT0RFX1RZUEVfUFJFRklYID1cbiAgJ05vZGUgZGF0YSBwcm92aWRlcjogJztcblxuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnB1dC9vdXRwdXQgcm93cyBpbiB0aGUgYXR0cnMgdGFibGUuICovXG5leHBvcnQgY29uc3QgTUFYX0lPX1JPV1NfSU5fQVRUUlNfVEFCTEUgPSAxMDtcblxuLyoqIFRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgZWRnZSBsYWJlbC4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VER0VfTEFCRUxfRk9OVF9TSVpFID0gNy41O1xuXG4vKiogVGhlIGtleSB0byBzdG9yZSB0aGUgdGVuc29yIHZhbHVlcyBpbiBub2RlIGF0dHJpYnV0ZXMuICovXG5leHBvcnQgY29uc3QgVEVOU09SX1ZBTFVFU19LRVkgPSAnX192YWx1ZSc7XG5cbi8qKiBUaGUga2V5IHRvIHN0b3JlIHRoZSB0ZW5zb3IgdGFnIGluIGkvbyBtZXRhZGF0YS4gKi9cbmV4cG9ydCBjb25zdCBURU5TT1JfVEFHX01FVEFEQVRBX0tFWSA9ICdfX3RlbnNvcl90YWcnO1xuXG4vKiogQSBtYXAgZnJvbSBjb2xvciBuYW1lcyB0byB0aGUgY29ycmVzcG9uZGluZyBoZXggY29sb3IuICovXG5leHBvcnQgY29uc3QgQ09MT1JfTkFNRV9UT19IRVg6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICdhbGljZWJsdWUnOiAnI2YwZjhmZicsXG4gICdhbnRpcXVld2hpdGUnOiAnI2ZhZWJkNycsXG4gICdhcXVhJzogJyMwMGZmZmYnLFxuICAnYXF1YW1hcmluZSc6ICcjN2ZmZmQ0JyxcbiAgJ2F6dXJlJzogJyNmMGZmZmYnLFxuICAnYmVpZ2UnOiAnI2Y1ZjVkYycsXG4gICdiaXNxdWUnOiAnI2ZmZTRjNCcsXG4gICdibGFjayc6ICcjMDAwMDAwJyxcbiAgJ2JsYW5jaGVkYWxtb25kJzogJyNmZmViY2QnLFxuICAnYmx1ZSc6ICcjMDAwMGZmJyxcbiAgJ2JsdWV2aW9sZXQnOiAnIzhhMmJlMicsXG4gICdicm93bic6ICcjYTUyYTJhJyxcbiAgJ2J1cmx5d29vZCc6ICcjZGViODg3JyxcbiAgJ2NhZGV0Ymx1ZSc6ICcjNWY5ZWEwJyxcbiAgJ2NoYXJ0cmV1c2UnOiAnIzdmZmYwMCcsXG4gICdjaG9jb2xhdGUnOiAnI2QyNjkxZScsXG4gICdjb3JhbCc6ICcjZmY3ZjUwJyxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogJyM2NDk1ZWQnLFxuICAnY29ybnNpbGsnOiAnI2ZmZjhkYycsXG4gICdjcmltc29uJzogJyNkYzE0M2MnLFxuICAnY3lhbic6ICcjMDBmZmZmJyxcbiAgJ2RhcmtibHVlJzogJyMwMDAwOGInLFxuICAnZGFya2N5YW4nOiAnIzAwOGI4YicsXG4gICdkYXJrZ29sZGVucm9kJzogJyNiODg2MGInLFxuICAnZGFya2dyYXknOiAnI2E5YTlhOScsXG4gICdkYXJrZ3JlZW4nOiAnIzAwNjQwMCcsXG4gICdkYXJra2hha2knOiAnI2JkYjc2YicsXG4gICdkYXJrbWFnZW50YSc6ICcjOGIwMDhiJyxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogJyM1NTZiMmYnLFxuICAnZGFya29yYW5nZSc6ICcjZmY4YzAwJyxcbiAgJ2RhcmtvcmNoaWQnOiAnIzk5MzJjYycsXG4gICdkYXJrcmVkJzogJyM4YjAwMDAnLFxuICAnZGFya3NhbG1vbic6ICcjZTk5NjdhJyxcbiAgJ2RhcmtzZWFncmVlbic6ICcjOGZiYzhmJyxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiAnIzQ4M2Q4YicsXG4gICdkYXJrc2xhdGVncmF5JzogJyMyZjRmNGYnLFxuICAnZGFya3R1cnF1b2lzZSc6ICcjMDBjZWQxJyxcbiAgJ2Rhcmt2aW9sZXQnOiAnIzk0MDBkMycsXG4gICdkZWVwcGluayc6ICcjZmYxNDkzJyxcbiAgJ2RlZXBza3libHVlJzogJyMwMGJmZmYnLFxuICAnZGltZ3JheSc6ICcjNjk2OTY5JyxcbiAgJ2RvZGdlcmJsdWUnOiAnIzFlOTBmZicsXG4gICdmaXJlYnJpY2snOiAnI2IyMjIyMicsXG4gICdmbG9yYWx3aGl0ZSc6ICcjZmZmYWYwJyxcbiAgJ2ZvcmVzdGdyZWVuJzogJyMyMjhiMjInLFxuICAnZnVjaHNpYSc6ICcjZmYwMGZmJyxcbiAgJ2dhaW5zYm9ybyc6ICcjZGNkY2RjJyxcbiAgJ2dob3N0d2hpdGUnOiAnI2Y4ZjhmZicsXG4gICdnb2xkJzogJyNmZmQ3MDAnLFxuICAnZ29sZGVucm9kJzogJyNkYWE1MjAnLFxuICAnZ3JheSc6ICcjODA4MDgwJyxcbiAgJ2dyZWVuJzogJyMwMDgwMDAnLFxuICAnZ3JlZW55ZWxsb3cnOiAnI2FkZmYyZicsXG4gICdob25leWRldyc6ICcjZjBmZmYwJyxcbiAgJ2hvdHBpbmsnOiAnI2ZmNjliNCcsXG4gICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLFxuICAnaW5kaWdvJzogJyM0YjAwODInLFxuICAnaXZvcnknOiAnI2ZmZmZmMCcsXG4gICdraGFraSc6ICcjZjBlNjhjJyxcbiAgJ2xhdmVuZGVyJzogJyNlNmU2ZmEnLFxuICAnbGF2ZW5kZXJibHVzaCc6ICcjZmZmMGY1JyxcbiAgJ2xhd25ncmVlbic6ICcjN2NmYzAwJyxcbiAgJ2xlbW9uY2hpZmZvbic6ICcjZmZmYWNkJyxcbiAgJ2xpZ2h0Ymx1ZSc6ICcjYWRkOGU2JyxcbiAgJ2xpZ2h0Y29yYWwnOiAnI2YwODA4MCcsXG4gICdsaWdodGN5YW4nOiAnI2UwZmZmZicsXG4gICdsaWdodGdvbGRlbnJvZHllbGxvdyc6ICcjZmFmYWQyJyxcbiAgJ2xpZ2h0Z3JleSc6ICcjZDNkM2QzJyxcbiAgJ2xpZ2h0Z3JlZW4nOiAnIzkwZWU5MCcsXG4gICdsaWdodHBpbmsnOiAnI2ZmYjZjMScsXG4gICdsaWdodHNhbG1vbic6ICcjZmZhMDdhJyxcbiAgJ2xpZ2h0c2VhZ3JlZW4nOiAnIzIwYjJhYScsXG4gICdsaWdodHNreWJsdWUnOiAnIzg3Y2VmYScsXG4gICdsaWdodHNsYXRlZ3JheSc6ICcjNzc4ODk5JyxcbiAgJ2xpZ2h0c3RlZWxibHVlJzogJyNiMGM0ZGUnLFxuICAnbGlnaHR5ZWxsb3cnOiAnI2ZmZmZlMCcsXG4gICdsaW1lJzogJyMwMGZmMDAnLFxuICAnbGltZWdyZWVuJzogJyMzMmNkMzInLFxuICAnbGluZW4nOiAnI2ZhZjBlNicsXG4gICdtYWdlbnRhJzogJyNmZjAwZmYnLFxuICAnbWFyb29uJzogJyM4MDAwMDAnLFxuICAnbWVkaXVtYXF1YW1hcmluZSc6ICcjNjZjZGFhJyxcbiAgJ21lZGl1bWJsdWUnOiAnIzAwMDBjZCcsXG4gICdtZWRpdW1vcmNoaWQnOiAnI2JhNTVkMycsXG4gICdtZWRpdW1wdXJwbGUnOiAnIzkzNzBkOCcsXG4gICdtZWRpdW1zZWFncmVlbic6ICcjM2NiMzcxJyxcbiAgJ21lZGl1bXNsYXRlYmx1ZSc6ICcjN2I2OGVlJyxcbiAgJ21lZGl1bXNwcmluZ2dyZWVuJzogJyMwMGZhOWEnLFxuICAnbWVkaXVtdHVycXVvaXNlJzogJyM0OGQxY2MnLFxuICAnbWVkaXVtdmlvbGV0cmVkJzogJyNjNzE1ODUnLFxuICAnbWlkbmlnaHRibHVlJzogJyMxOTE5NzAnLFxuICAnbWludGNyZWFtJzogJyNmNWZmZmEnLFxuICAnbWlzdHlyb3NlJzogJyNmZmU0ZTEnLFxuICAnbW9jY2FzaW4nOiAnI2ZmZTRiNScsXG4gICduYXZham93aGl0ZSc6ICcjZmZkZWFkJyxcbiAgJ25hdnknOiAnIzAwMDA4MCcsXG4gICdvbGRsYWNlJzogJyNmZGY1ZTYnLFxuICAnb2xpdmUnOiAnIzgwODAwMCcsXG4gICdvbGl2ZWRyYWInOiAnIzZiOGUyMycsXG4gICdvcmFuZ2UnOiAnI2ZmYTUwMCcsXG4gICdvcmFuZ2VyZWQnOiAnI2ZmNDUwMCcsXG4gICdvcmNoaWQnOiAnI2RhNzBkNicsXG4gICdwYWxlZ29sZGVucm9kJzogJyNlZWU4YWEnLFxuICAncGFsZWdyZWVuJzogJyM5OGZiOTgnLFxuICAncGFsZXR1cnF1b2lzZSc6ICcjYWZlZWVlJyxcbiAgJ3BhbGV2aW9sZXRyZWQnOiAnI2Q4NzA5MycsXG4gICdwYXBheWF3aGlwJzogJyNmZmVmZDUnLFxuICAncGVhY2hwdWZmJzogJyNmZmRhYjknLFxuICAncGVydSc6ICcjY2Q4NTNmJyxcbiAgJ3BpbmsnOiAnI2ZmYzBjYicsXG4gICdwbHVtJzogJyNkZGEwZGQnLFxuICAncG93ZGVyYmx1ZSc6ICcjYjBlMGU2JyxcbiAgJ3B1cnBsZSc6ICcjODAwMDgwJyxcbiAgJ3JlYmVjY2FwdXJwbGUnOiAnIzY2MzM5OScsXG4gICdyZWQnOiAnI2ZmMDAwMCcsXG4gICdyb3N5YnJvd24nOiAnI2JjOGY4ZicsXG4gICdyb3lhbGJsdWUnOiAnIzQxNjllMScsXG4gICdzYWRkbGVicm93bic6ICcjOGI0NTEzJyxcbiAgJ3NhbG1vbic6ICcjZmE4MDcyJyxcbiAgJ3NhbmR5YnJvd24nOiAnI2Y0YTQ2MCcsXG4gICdzZWFncmVlbic6ICcjMmU4YjU3JyxcbiAgJ3NlYXNoZWxsJzogJyNmZmY1ZWUnLFxuICAnc2llbm5hJzogJyNhMDUyMmQnLFxuICAnc2lsdmVyJzogJyNjMGMwYzAnLFxuICAnc2t5Ymx1ZSc6ICcjODdjZWViJyxcbiAgJ3NsYXRlYmx1ZSc6ICcjNmE1YWNkJyxcbiAgJ3NsYXRlZ3JheSc6ICcjNzA4MDkwJyxcbiAgJ3Nub3cnOiAnI2ZmZmFmYScsXG4gICdzcHJpbmdncmVlbic6ICcjMDBmZjdmJyxcbiAgJ3N0ZWVsYmx1ZSc6ICcjNDY4MmI0JyxcbiAgJ3Rhbic6ICcjZDJiNDhjJyxcbiAgJ3RlYWwnOiAnIzAwODA4MCcsXG4gICd0aGlzdGxlJzogJyNkOGJmZDgnLFxuICAndG9tYXRvJzogJyNmZjYzNDcnLFxuICAndHVycXVvaXNlJzogJyM0MGUwZDAnLFxuICAndmlvbGV0JzogJyNlZTgyZWUnLFxuICAnd2hlYXQnOiAnI2Y1ZGViMycsXG4gICd3aGl0ZSc6ICcjZmZmZmZmJyxcbiAgJ3doaXRlc21va2UnOiAnI2Y1ZjVmNScsXG4gICd5ZWxsb3cnOiAnI2ZmZmYwMCcsXG4gICd5ZWxsb3dncmVlbic6ICcjOWFjZDMyJyxcbn07XG5cbi8qKiBUaGUgcG9ydCBudW1iZXIgZm9yIGV4dGVybmFsIGxvY2FsIGRldiBzZXJ2ZXIuICovXG5leHBvcnQgY29uc3QgRVhURVJOQUxfTE9DQUxfREVWX1BPUlQgPSA4MDgxO1xuIl19
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/model_graph.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/model_graph.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/model_graph.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_types_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.ModelGraph} */
exports.ModelGraph;
/**
 * Node tyoes in a model graph.
 * @enum {number}
 */
const NodeType = {
    OP_NODE: 0,
    GROUP_NODE: 1,
};
exports.NodeType = NodeType;
NodeType[NodeType.OP_NODE] = 'OP_NODE';
NodeType[NodeType.GROUP_NODE] = 'GROUP_NODE';
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.ModelNodeBase} */
exports.ModelNodeBase;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.OpNode} */
exports.OpNode;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.GroupNode} */
exports.GroupNode;
/**
 * A node in a model graph.
 * @typedef {(!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.OpNode|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.GroupNode)}
 */
exports.ModelNode;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$model_graph.ModelEdge} */
exports.ModelEdge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxfZ3JhcGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL2NvbW1vbi9tb2RlbF9ncmFwaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtFQSxNQUFZLFFBQVE7SUFDbEIsT0FBTyxHQUFBO0lBQ1AsVUFBVSxHQUFBO0VBQ1g7Ozs7Ozs7Ozs7Ozs7O0FBMkpELGtCQUEyQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEdyYXBoTm9kZVN0eWxlLFxuICBJbmNvbWluZ0VkZ2UsXG4gIEtleVZhbHVlUGFpcnMsXG4gIE91dGdvaW5nRWRnZSxcbiAgUG9pbnQsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIEEgbW9kZWwgZ3JhcGggdG8gYmUgdmlzdWFsaXplZC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnRlcm5hbCBmb3JtYXQgdXNlZCBieSB0aGUgdmlzdWFsaXplci4gSXQgaXMgcHJvY2Vzc2VkIGZyb20gYW5cbiAqIGlucHV0IGBHcmFwaGAgKHNlZSBgaW5wdXRfZ3JhcGgudHNgKS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE1vZGVsR3JhcGgge1xuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogSXQgaXMgdGhlIHNhbWUgYXMgdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgYEdyYXBoYC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBsYWJlbCBvZiB0aGUgY29sbGVjdGlvbiB0aGlzIGdyYXBoIGJlbG9uZ3MgdG8uICovXG4gIGNvbGxlY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBBbGwgbm9kZXMgaW4gdGhlIG1vZGVsIGdyYXBoLiAqL1xuICBub2RlczogTW9kZWxOb2RlW107XG5cbiAgLyoqIElkcyBvZiBhbGwgZ3JvdXAgbm9kZXMgdGhhdCBhcmUgYXJ0aWZpY2lhbGx5IGNyZWF0ZWQuICovXG4gIGFydGlmaWNpYWxHcm91cE5vZGVJZHM/OiBzdHJpbmdbXTtcblxuICAvKiogQWxsIG5vZGVzIGluIHRoZSBtb2RlbCBncmFwaCBpbmRleGVkIGJ5IG5vZGUgaWQuICovXG4gIG5vZGVzQnlJZDogUmVjb3JkPHN0cmluZywgTW9kZWxOb2RlPjtcblxuICAvKiogVGhlIHJvb3Qgbm9kZXMuICovXG4gIHJvb3ROb2RlczogQXJyYXk8R3JvdXBOb2RlIHwgT3BOb2RlPjtcblxuICAvKiogRnJvbSB0aGUgaWRzIG9mIGdyb3VwIG5vZGVzIHRvIHRoZSBlZGdlcyBvZiB0aGVpciBzdWJncmFwaHMuICovXG4gIGVkZ2VzQnlHcm91cE5vZGVJZHM6IHtbaWQ6IHN0cmluZ106IE1vZGVsRWRnZVtdfTtcblxuICAvKiogTWF4IGNvdW50IG9mIGRlc2NlbmRhbnQgb3Agbm9kZXMgZm9yIGFjcm9zcyBncm91cCBub2Rlcy4gKi9cbiAgbWF4RGVzY2VuZGFudE9wTm9kZUNvdW50OiBudW1iZXI7XG5cbiAgLyoqIE1pbiBjb3VudCBvZiBkZXNjZW5kYW50IG9wIG5vZGVzIGZvciBhY3Jvc3MgZ3JvdXAgbm9kZXMuICovXG4gIG1pbkRlc2NlbmRhbnRPcE5vZGVDb3VudDogbnVtYmVyO1xuXG4gIC8qKiBBIG1hcCBmcm9tIG91dHB1dCB0ZW5zb3IgaWQgdG8gdGhlaXIgb3duZXIgbm9kZSBpZC4gKi9cbiAgb3V0cHV0VGVuc29ySWRUb05vZGVJZD86IHtbaWQ6IHN0cmluZ106IHN0cmluZ307XG5cbiAgLyoqIE51bWJlciBvZiBlZGdlIGN1cnZlIHNlZ21lbnRzLCB1c2VkIGZvciB3ZWJnbCByZW5kZXJpbmcuICovXG4gIG51bUVkZ2VTZWdtZW50cz86IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGVuZCBwb2ludHMgZm9yIGFsbCBlZGdlIGN1cnZlIHNlZ21lbnRzLCB1c2VkIGZvciB3ZWJnbFxuICAgKiByZW5kZXJpbmcuXG4gICAqL1xuICBudW1FZGdlU2VnbWVudEVuZFBvaW50cz86IG51bWJlcjtcblxuICAvKipcbiAgICogQSBtYXAgZnJvbSB0aGUgaWQgb2YgYSBncm91cCB0byB0aGUgZWRnZXMgb2YgaXRzXG4gICAqIE5TIGNoaWxkcmVuIG5vZGVzIChmcm9tTm9kZUlkIC0+IHRhcmdldE5vZGVJZHMpLlxuICAgKi9cbiAgbGF5b3V0R3JhcGhFZGdlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgYm9vbGVhbj4+Pjtcbn1cblxuLyoqIE5vZGUgdHlvZXMgaW4gYSBtb2RlbCBncmFwaC4gKi9cbmV4cG9ydCBlbnVtIE5vZGVUeXBlIHtcbiAgT1BfTk9ERSxcbiAgR1JPVVBfTk9ERSxcbn1cblxuLyoqIFRoZSBiYXNlIGludGVyZmFjZSBvZiBhIG5vZGUgaW4gbW9kZWwgZ3JhcGguICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTW9kZWxOb2RlQmFzZSB7XG4gIC8qKiBUaGUgdHlwZSBvZiB0aGUgbm9kZS4gKi9cbiAgbm9kZVR5cGU6IE5vZGVUeXBlO1xuXG4gIC8qKiBUaGUgdW5pcXVlIGlmIG9mIHRoZSBub2RlLiAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgbGFiZWwgb2YgdGhlIG5vZGUuICovXG4gIGxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lc3BhY2UvaGllcmFyY2h5IGRhdGEgb2YgdGhlIG5vZGUuIFNlZSBpbnB1dF9ncmFwaC50cyBmb3IgbW9yZVxuICAgKiBkZXRhaWxzLlxuICAgKi9cbiAgbmFtZXNwYWNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lc3BhY2UgZmllbGQgYWJvdmUgd2lsbCBiZSBjbGVhcmVkIHdoZW4gdGhlIGdyYXBoJ3MgbGF5ZXJzIGFyZVxuICAgKiBmbGF0dGVuZWQuIEluIHRoZXNlIGNhc2VzLCB3ZSBzdG9yZSB0aGUgbmFtZXNwYWNlIGRhdGEgaGVyZSBmb3IgZGlzcGxheVxuICAgKiBwdXJwb3NlLlxuICAgKi9cbiAgc2F2ZWROYW1lc3BhY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsZXZlbCBvZiB0aGUgbm9kZSBpbiB0aGUgaGllcmFyY2h5LiBJdCBpcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgaW5cbiAgICogaXRzIG5hbWVzcGFjZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRoZSBsZXZlbCBvZiBhIG5vZGUgd2l0aCBuYW1lc3BhY2UgJ2EvYi9jJyBpcyAzLlxuICAgKi9cbiAgbGV2ZWw6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGlkIG9mIGl0cyBwYXJlbnQgbm9kZSBpbiBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBhIG5vZGUgd2l0aCBuYW1lc3BhY2UgXCJhL2JcIiBpcyB0aGUgYG5zUGFyZW50YCBvZiBhIG5vZGUgd2l0aFxuICAgKiBuYW1lc3BhY2UgXCJhL2IvY1wiLlxuICAgKi9cbiAgbnNQYXJlbnRJZD86IHN0cmluZztcblxuICAvLyBMYXlvdXQgZGF0YS5cblxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBub2RlLiAqL1xuICB3aWR0aD86IG51bWJlcjtcblxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgbm9kZS4gKi9cbiAgaGVpZ2h0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgcG9zaXRpb24gKHgpIG9mIHRoZSBub2RlLiBUaGlzIGlzIHJlbGF0aXZlIHRvIGl0cyBuYW1lc3BhY2VcbiAgICogcGFyZW50LlxuICAgKi9cbiAgeD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxvY2FsIHBvc2l0aW9uICh5KSBvZiB0aGUgbm9kZS4gVGhpcyBpcyByZWxhdGl2ZSB0byBpdHMgbmFtZXNwYWNlXG4gICAqIHBhcmVudC5cbiAgICovXG4gIHk/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExvY2FsIG9mZnNldCAoeCksIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRoZSBzaXR1YXRpb25zIHdoZXJlOlxuICAgKiAtIFN1YmdyYXBocyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gaXRzIHBhcmVudC5cbiAgICogLSBFZGdlcyBnb2luZyBvdXQgb2YgdGhlIGJvbmRpbmcgYm94IG9mIGFsbCB0aGUgbm9kZXMuXG4gICAqL1xuICBsb2NhbE9mZnNldFg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExvY2FsIG9mZnNldCAoeSksIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRoZSBzaXR1YXRpb25zIHdoZXJlOlxuICAgKiAtIFRoZSBucyBwYXJlbnQgbm9kZSBoYXMgYXR0cnMgdGFibGUgc2hvd24uXG4gICAqL1xuICBsb2NhbE9mZnNldFk/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBnbG9iYWwgcG9zaXRpb24gKHgpIG9mIHRoZSBub2RlLCByZWxhdGl2ZSB0byB0aGUgc3ZnIGVsZW1lbnQuXG4gICAqL1xuICBnbG9iYWxYPzogbnVtYmVyO1xuXG4gIC8qKiBUaGUgZ2xvYmFsIHBvc2l0aW9uICh5KSBvZiB0aGUgbm9kZSwgcmVsYXRpdmUgdG8gdGhlIHN2ZyBlbGVtZW50LiAqL1xuICBnbG9iYWxZPzogbnVtYmVyO1xufVxuXG4vKiogQW4gb3BlcmF0aW9uIG5vZGUgaW4gYSBtb2RlbCBncmFwaC4gICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgT3BOb2RlIGV4dGVuZHMgTW9kZWxOb2RlQmFzZSB7XG4gIG5vZGVUeXBlOiBOb2RlVHlwZS5PUF9OT0RFO1xuXG4gIC8qKiBJbmNvbWluZyBlZGdlcy4gKi9cbiAgaW5jb21pbmdFZGdlcz86IEluY29taW5nRWRnZVtdO1xuXG4gIC8qKlxuICAgKiBPdXRnb2luZyBlZGdlcy5cbiAgICpcbiAgICogV2UgcG9wdWxhdGUgZWRnZXMgZm9yIGJvdGggZGlyZWN0aW9uIGZvciBjb252ZW5pZW5jZS5cbiAgICovXG4gIG91dGdvaW5nRWRnZXM/OiBPdXRnb2luZ0VkZ2VbXTtcblxuICAvKiogVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuICovXG4gIGF0dHJzPzogS2V5VmFsdWVQYWlycztcblxuICAvKipcbiAgICogTWV0YWRhdGEgZm9yIGlucHV0cywgaW5kZXhlZCBieSBpbnB1dCBpZHMuIEVhY2ggaW5wdXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICoga2V5LXZhbHVlIHBhaXJzIGFzIGl0cyBtZXRhZGF0YS5cbiAgICovXG4gIGlucHV0c01ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgS2V5VmFsdWVQYWlycz47XG5cbiAgLyoqXG4gICAqIE1ldGFkYXRhIGZvciBvdXRwdXRzLCBpbmRleGVkIGJ5IG91dHB1dCBpZHMuIEVhY2ggb3V0cHV0IGNhbiBoYXZlIG11bHRpcGxlXG4gICAqIGtleS12YWx1ZSBwYXJpcyBhcyBpdHMgbWV0YWRhdGEuXG4gICAqL1xuICBvdXRwdXRzTWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBLZXlWYWx1ZVBhaXJzPjtcblxuICAvKiogV2hldGhlciB0aGlzIG5vZGUgc2hvdWxkIGJlIGhpZGRlbiBpbiBsYXlvdXQuICovXG4gIGhpZGVJbkxheW91dD86IGJvb2xlYW47XG5cbiAgLyoqIElkcyBmb3Igc3ViZ3JhcGhzLiAqL1xuICBzdWJncmFwaElkcz86IHN0cmluZ1tdO1xuXG4gIC8qKiBUaGUgc3R5bGUgb2YgdGhlIG5vZGUuICovXG4gIHN0eWxlPzogR3JhcGhOb2RlU3R5bGU7XG59XG5cbi8qKlxuICogQSBncm91cCBub2RlIHRoYXQgZ3JvdXBzIG9wIG5vZGVzIGFuZCBvdGhlciBncm91cCBub2Rlcy5cbiAqXG4gKiBHcm91cGluZyBoYXBwZW5zIG9uIG5hbWVzcGFjZSBsZXZlbC4gQSBncm91cCBub2RlIHdpbGwgYmUgY3JlYXRlZCBmb3IgZWFjaFxuICogdW5pcXVlIG5hbWVzcGFjZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEdyb3VwTm9kZSBleHRlbmRzIE1vZGVsTm9kZUJhc2Uge1xuICBub2RlVHlwZTogTm9kZVR5cGUuR1JPVVBfTk9ERTtcblxuICAvKiogSXRzIGNoaWxkcmVuIG5vZGVzIHVuZGVyIGl0cyBuYW1lc3BhY2UuICovXG4gIG5zQ2hpbGRyZW5JZHM/OiBzdHJpbmdbXTtcblxuICAvKiogQWxsIGRlc2NlbmRhbnQgbm9kZXMgdW5kZXIgdGhpcyBncm91cCdzIG5hbWVzcGFjZS4gKi9cbiAgZGVzY2VuZGFudHNOb2RlSWRzPzogc3RyaW5nW107XG5cbiAgLyoqIEFsbCBkZXNjZW5kYW50IG9wIG5vZGVzIHVuZGVyIHRoaXMgZ3JvdXAncyBuYW1lc3BhY2UuICovXG4gIGRlc2NlbmRhbnRzT3BOb2RlSWRzPzogc3RyaW5nW107XG5cbiAgLyoqIFdoZXRoZXIgdGhpcyBub2RlIGlzIGV4cGFuZGVkICh0cnVlKSBvciBjb2xsYXBzZWQgKGZhbHNlKS4gKi9cbiAgZXhwYW5kZWQ6IGJvb2xlYW47XG5cbiAgLyoqIEluZGV4IG9mIGlkZW50aWNhbCBncm91cC4gKi9cbiAgaWRlbnRpY2FsR3JvdXBJbmRleD86IG51bWJlcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGdyb3VwIG5vZGUgc2VydmVzIGFzIGEgc2VjdGlvbiBjb250YWluZXIgdG8gcmVkdWNlIG51bWJlciBvZlxuICAgKiBub2RlcyB0byBsYXlvdXQuXG4gICAqL1xuICBzZWN0aW9uQ29udGFpbmVyPzogYm9vbGVhbjtcbn1cblxuLyoqIEEgbm9kZSBpbiBhIG1vZGVsIGdyYXBoLiAqL1xuZXhwb3J0IHR5cGUgTW9kZWxOb2RlID0gT3BOb2RlIHwgR3JvdXBOb2RlO1xuXG4vKiogQW4gZWRnZSBpbiBhIG1vZGVsIGdyYXBoLCAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE1vZGVsRWRnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGZyb21Ob2RlSWQ6IHN0cmluZztcbiAgdG9Ob2RlSWQ6IHN0cmluZztcbiAgcG9pbnRzOiBQb2ludFtdO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGZvciB3ZWJnbCByZW5kZXJpbmcuXG4gIGN1cnZlUG9pbnRzPzogUG9pbnRbXTtcbn1cbiJdfQ==
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/types.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/types.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/types.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_model_graph_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
/**
 * A type for key-value pairs.
 * @typedef {?}
 */
exports.KeyValuePairs;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.KeyValue} */
exports.KeyValue;
/**
 * A type for a list of key-value pairs.
 * @typedef {!Array<!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.KeyValue>}
 */
exports.KeyValueList;
/**
 * An item in input/output metadata.
 * @record
 */
function MetadataItem() { }
exports.MetadataItem = MetadataItem;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    MetadataItem.prototype.id;
    /**
     * @type {!Array<!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.KeyValue>}
     * @public
     */
    MetadataItem.prototype.attrs;
}
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.IncomingEdge} */
exports.IncomingEdge;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.OutgoingEdge} */
exports.OutgoingEdge;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.Point} */
exports.Point;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.Rect} */
exports.Rect;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.GraphNodeStyle} */
exports.GraphNodeStyle;
/**
 * Data to pass along when clicking "open in popup" on a group node.
 * @record
 */
function PopupPanelData() { }
exports.PopupPanelData = PopupPanelData;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    PopupPanelData.prototype.id;
    /**
     * @type {!tsickle_model_graph_1.GroupNode}
     * @public
     */
    PopupPanelData.prototype.groupNode;
    /**
     * @type {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.Point}
     * @public
     */
    PopupPanelData.prototype.initialPosition;
    /**
     * @type {!tsickle_model_graph_1.ModelGraph}
     * @public
     */
    PopupPanelData.prototype.curModelGraph;
}
/**
 * Data to pass along when a node is located.
 * @record
 */
function NodeLocatedData() { }
exports.NodeLocatedData = NodeLocatedData;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    NodeLocatedData.prototype.nodeId;
    /**
     * @type {!Array<string>}
     * @public
     */
    NodeLocatedData.prototype.deepestExpandedGroupNodeIds;
}
/**
 * Data to pass along when revealing a node.
 * @record
 */
function NodeToRevealInfo() { }
exports.NodeToRevealInfo = NodeToRevealInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    NodeToRevealInfo.prototype.graphId;
    /**
     * @type {string}
     * @public
     */
    NodeToRevealInfo.prototype.paneId;
    /**
     * @type {string}
     * @public
     */
    NodeToRevealInfo.prototype.nodeId;
}
/**
 * Info about a renderer.
 * @record
 */
function RendererInfo() { }
exports.RendererInfo = RendererInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    RendererInfo.prototype.id;
    /**
     * @type {!RendererOwner}
     * @public
     */
    RendererInfo.prototype.ownerType;
}
/**
 * The owner of the renderer.
 * @enum {number}
 */
const RendererOwner = {
    MAIN_PANEL: 0,
    POPUP: 1,
    GRAPH_PANEL: 2,
};
exports.RendererOwner = RendererOwner;
RendererOwner[RendererOwner.MAIN_PANEL] = 'MAIN_PANEL';
RendererOwner[RendererOwner.POPUP] = 'POPUP';
RendererOwner[RendererOwner.GRAPH_PANEL] = 'GRAPH_PANEL';
/**
 * Info about a selected node.
 * @record
 */
function SelectedNodeInfo() { }
exports.SelectedNodeInfo = SelectedNodeInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    SelectedNodeInfo.prototype.nodeId;
    /**
     * @type {string}
     * @public
     */
    SelectedNodeInfo.prototype.rendererId;
    /**
     * @type {boolean}
     * @public
     */
    SelectedNodeInfo.prototype.isGroupNode;
    /**
     * @type {(undefined|boolean)}
     * @public
     */
    SelectedNodeInfo.prototype.noNodeShake;
}
/**
 * Info about a node to locate.
 * @record
 * @extends {SelectedNodeInfo}
 */
function LocateNodeInfo() { }
exports.LocateNodeInfo = LocateNodeInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {(undefined|boolean)}
     * @public
     */
    LocateNodeInfo.prototype.select;
}
/**
 * Types of renderer.
 * @enum {number}
 */
const RendererType = {
    WEBGL: 0,
};
exports.RendererType = RendererType;
RendererType[RendererType.WEBGL] = 'WEBGL';
/**
 * Info to pass along when clicking "add snapshot"
 * @record
 */
function AddSnapshotInfo() { }
exports.AddSnapshotInfo = AddSnapshotInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    AddSnapshotInfo.prototype.rendererId;
}
/**
 * Info for restoring a snapshot.
 * @record
 */
function RestoreSnapshotInfo() { }
exports.RestoreSnapshotInfo = RestoreSnapshotInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    RestoreSnapshotInfo.prototype.rendererId;
    /**
     * @type {!SnapshotData}
     * @public
     */
    RestoreSnapshotInfo.prototype.snapshot;
}
/**
 * Data related to a snapshot.
 * @record
 */
function SnapshotData() { }
exports.SnapshotData = SnapshotData;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    SnapshotData.prototype.id;
    /**
     * @type {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.Rect}
     * @public
     */
    SnapshotData.prototype.rect;
    /**
     * @type {!ImageBitmap}
     * @public
     */
    SnapshotData.prototype.imageBitmap;
    /**
     * @type {(undefined|!Array<string>)}
     * @public
     */
    SnapshotData.prototype.deepestExpandedGroupNodeIds;
    /**
     * @type {(undefined|string)}
     * @public
     */
    SnapshotData.prototype.selectedNodeId;
    /**
     * @type {(undefined|?)}
     * @public
     */
    SnapshotData.prototype.showOnNodeItemTypes;
    /**
     * @type {(undefined|?)}
     * @public
     */
    SnapshotData.prototype.showOnEdgeItemTypes;
    /**
     * @type {(undefined|boolean)}
     * @public
     */
    SnapshotData.prototype.flattenLayers;
}
/**
 * Info to pass along when clicking "expand/collapse all layers"
 * @record
 */
function ExpandOrCollapseAllGraphLayersInfo() { }
exports.ExpandOrCollapseAllGraphLayersInfo = ExpandOrCollapseAllGraphLayersInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {boolean}
     * @public
     */
    ExpandOrCollapseAllGraphLayersInfo.prototype.expandOrCollapse;
    /**
     * @type {string}
     * @public
     */
    ExpandOrCollapseAllGraphLayersInfo.prototype.rendererId;
}
/**
 * Info to pass along when clicking "download as png"
 * @record
 */
function DownloadAsPngInfo() { }
exports.DownloadAsPngInfo = DownloadAsPngInfo;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    DownloadAsPngInfo.prototype.rendererId;
    /**
     * @type {boolean}
     * @public
     */
    DownloadAsPngInfo.prototype.fullGraph;
    /**
     * @type {boolean}
     * @public
     */
    DownloadAsPngInfo.prototype.transparentBackground;
}
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderRunInfo} */
exports.NodeDataProviderRunInfo;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderGraphData} */
exports.NodeDataProviderGraphData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderData} */
exports.NodeDataProviderData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderRunData} */
exports.NodeDataProviderRunData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderResultData} */
exports.NodeDataProviderResultData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeDataProviderResultProcessedData} */
exports.NodeDataProviderResultProcessedData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.ThresholdItem} */
exports.ThresholdItem;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.GradientItem} */
exports.GradientItem;
/**
 * A pane in the main UI.
 * @record
 */
function Pane() { }
exports.Pane = Pane;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    Pane.prototype.id;
    /**
     * @type {number}
     * @public
     */
    Pane.prototype.widthFraction;
    /**
     * @type {(undefined|!SelectedNodeInfo)}
     * @public
     */
    Pane.prototype.selectedNodeInfo;
    /**
     * @type {(undefined|boolean)}
     * @public
     */
    Pane.prototype.hasArtificialLayers;
    /**
     * @type {(undefined|string)}
     * @public
     */
    Pane.prototype.nodeIdToReveal;
    /**
     * @type {(undefined|?)}
     * @public
     */
    Pane.prototype.snapshots;
    /**
     * @type {(undefined|boolean)}
     * @public
     */
    Pane.prototype.flattenLayers;
    /**
     * @type {(undefined|!SnapshotData)}
     * @public
     */
    Pane.prototype.snapshotToRestore;
    /**
     * @type {(undefined|!Array<!SubgraphBreadcrumbItem>)}
     * @public
     */
    Pane.prototype.subgraphBreadcrumbs;
    /**
     * @type {(undefined|!SearchResults)}
     * @public
     */
    Pane.prototype.searchResults;
    /**
     * @type {(undefined|string)}
     * @public
     */
    Pane.prototype.selectedNodeDataProviderRunId;
    /**
     * @type {(undefined|?)}
     * @public
     */
    Pane.prototype.showOnNodeItemTypes;
    /**
     * @type {(undefined|?)}
     * @public
     */
    Pane.prototype.showOnEdgeItemTypes;
    /**
     * @type {(undefined|!tsickle_model_graph_1.ModelGraph)}
     * @public
     */
    Pane.prototype.modelGraph;
}
/**
 * The data for processed model graph and related info.
 * @record
 */
function ProcessedModelGraphData() { }
exports.ProcessedModelGraphData = ProcessedModelGraphData;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!tsickle_model_graph_1.ModelGraph}
     * @public
     */
    ProcessedModelGraphData.prototype.modelGraph;
    /**
     * @type {string}
     * @public
     */
    ProcessedModelGraphData.prototype.paneId;
}
/**
 * Color used in various webgl components. Each field is from 0 to 1.
 * @record
 */
function WebglColor() { }
exports.WebglColor = WebglColor;
/* istanbul ignore if */
if (false) {
    /**
     * @type {number}
     * @public
     */
    WebglColor.prototype.r;
    /**
     * @type {number}
     * @public
     */
    WebglColor.prototype.g;
    /**
     * @type {number}
     * @public
     */
    WebglColor.prototype.b;
}
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.UniformValue} */
exports.UniformValue;
/**
 * An event indicating a model graph has been processed.
 * @record
 */
function ModelGraphProcessedEvent() { }
exports.ModelGraphProcessedEvent = ModelGraphProcessedEvent;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!tsickle_model_graph_1.ModelGraph}
     * @public
     */
    ModelGraphProcessedEvent.prototype.modelGraph;
    /**
     * @type {number}
     * @public
     */
    ModelGraphProcessedEvent.prototype.paneIndex;
}
/**
 * A single item in subgraph breadcrumbs.
 * @record
 */
function SubgraphBreadcrumbItem() { }
exports.SubgraphBreadcrumbItem = SubgraphBreadcrumbItem;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    SubgraphBreadcrumbItem.prototype.graphId;
    /**
     * @type {(undefined|!SnapshotData)}
     * @public
     */
    SubgraphBreadcrumbItem.prototype.snapshot;
}
/**
 * Base interface for a search match.
 * @record
 */
function SearchMatchBase() { }
exports.SearchMatchBase = SearchMatchBase;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!SearchMatchType}
     * @public
     */
    SearchMatchBase.prototype.type;
}
/**
 * Interface for a search match for a node label.
 * @record
 * @extends {SearchMatchBase}
 */
function SearchMatchNodeLabel() { }
exports.SearchMatchNodeLabel = SearchMatchNodeLabel;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!SearchMatchType}
     * @public
     */
    SearchMatchNodeLabel.prototype.type;
}
/**
 * Interface for a search match for an input metadata.
 * @record
 * @extends {SearchMatchBase}
 */
function SearchMatchInputMetadata() { }
exports.SearchMatchInputMetadata = SearchMatchInputMetadata;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!SearchMatchType}
     * @public
     */
    SearchMatchInputMetadata.prototype.type;
    /**
     * @type {string}
     * @public
     */
    SearchMatchInputMetadata.prototype.matchedText;
}
/**
 * Interface for a search match for an output metadata.
 * @record
 * @extends {SearchMatchBase}
 */
function SearchMatchOutputMetadata() { }
exports.SearchMatchOutputMetadata = SearchMatchOutputMetadata;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!SearchMatchType}
     * @public
     */
    SearchMatchOutputMetadata.prototype.type;
    /**
     * @type {string}
     * @public
     */
    SearchMatchOutputMetadata.prototype.matchedText;
}
/**
 * Interface for a search match for an attribute.
 * @record
 * @extends {SearchMatchBase}
 */
function SearchMatchAttr() { }
exports.SearchMatchAttr = SearchMatchAttr;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!SearchMatchType}
     * @public
     */
    SearchMatchAttr.prototype.type;
    /**
     * @type {string}
     * @public
     */
    SearchMatchAttr.prototype.matchedAttrId;
}
/**
 * Union type for search match.
 * @typedef {(!SearchMatchNodeLabel|!SearchMatchInputMetadata|!SearchMatchOutputMetadata|!SearchMatchAttr)}
 */
exports.SearchMatch;
/**
 * Multiple search matches.
 * @record
 */
function SearchMatches() { }
exports.SearchMatches = SearchMatches;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!Array<(!SearchMatchNodeLabel|!SearchMatchInputMetadata|!SearchMatchOutputMetadata|!SearchMatchAttr)>}
     * @public
     */
    SearchMatches.prototype.matches;
    /**
     * @type {!Set<string>}
     * @public
     */
    SearchMatches.prototype.matchTypes;
}
/**
 * Types of search match.
 *
 * The value should correspond to a material icon.
 * @enum {string}
 */
const SearchMatchType = {
    NODE_LABEL: "title",
    INPUT_METADATA: "input",
    OUTPUT_METADATA: "output",
    ATTRIBUTE: "list",
};
exports.SearchMatchType = SearchMatchType;
/**
 * Search results.
 * @record
 */
function SearchResults() { }
exports.SearchResults = SearchResults;
/* istanbul ignore if */
if (false) {
    /**
     * From node id to matches
     * @type {?}
     * @public
     */
    SearchResults.prototype.results;
}
/**
 * Item types to be shown on node.
 *
 * To add a entry, follow the steps below:
 *
 * 1. Add an entry here.
 * 2. Add to the ALL_SHOW_ON_NODE_ITEM_TYPES list in renderer_wrapper.ts.
 * 3. Update renderAttrsTable in webgl_renderer.ts.
 * 4. Update getNodeHeight and getNodeWidth in graph_layout.ts.
 * @enum {string}
 */
const ShowOnNodeItemType = {
    OP_NODE_ID: "Op node id",
    OP_ATTRS: "Op node attributes",
    OP_INPUTS: "Op node inputs",
    OP_OUTPUTS: "Op node outputs",
    LAYER_NODE_CHILDREN_COUNT: "Layer node children count",
    LAYER_NODE_DESCENDANTS_COUNT: "Layer node descendants count",
};
exports.ShowOnNodeItemType = ShowOnNodeItemType;
/**
 * Item types to be shown on edge.
 * @enum {string}
 */
const ShowOnEdgeItemType = {
    TENSOR_SHAPE: "Tensor shape",
};
exports.ShowOnEdgeItemType = ShowOnEdgeItemType;
/**
 * Weight of the font.
 * @enum {number}
 */
const FontWeight = {
    REGULAR: 0,
    MEDIUM: 1,
    BOLD: 2,
    MONOSPACE_MEDIUM: 3,
    ICONS: 4,
};
exports.FontWeight = FontWeight;
FontWeight[FontWeight.REGULAR] = 'REGULAR';
FontWeight[FontWeight.MEDIUM] = 'MEDIUM';
FontWeight[FontWeight.BOLD] = 'BOLD';
FontWeight[FontWeight.MONOSPACE_MEDIUM] = 'MONOSPACE_MEDIUM';
FontWeight[FontWeight.ICONS] = 'ICONS';
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.CharInfo} */
exports.CharInfo;
/**
 * Field labels in info panel.
 * @enum {string}
 */
const FieldLabel = {
    OP_NODE_ID: "id",
    NUMBER_OF_CHILDREN: "#children",
    NUMBER_OF_DESCENDANTS: "#descendants",
};
exports.FieldLabel = FieldLabel;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.ShowOnNodeItemData} */
exports.ShowOnNodeItemData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.ShowOnEdgeItemData} */
exports.ShowOnEdgeItemData;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeStylerRule} */
exports.NodeStylerRule;
/**
 * Version of node styler rule.
 * @enum {string}
 */
const NodeStylerRuleVersion = {
    V2: "v2",
};
exports.NodeStylerRuleVersion = NodeStylerRuleVersion;
/**
 * A rule width processed node styler rules.
 * @record
 */
function ProcessedNodeStylerRule() { }
exports.ProcessedNodeStylerRule = ProcessedNodeStylerRule;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!Array<(!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeAttrValueRangeQuery|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeTypeQuery|!ProcessedNodeRegexQuery)>}
     * @public
     */
    ProcessedNodeStylerRule.prototype.queries;
    /**
     * @type {!SearchNodeType}
     * @public
     */
    ProcessedNodeStylerRule.prototype.nodeType;
    /**
     * @type {?}
     * @public
     */
    ProcessedNodeStylerRule.prototype.styles;
}
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeRegexQuery} */
exports.NodeRegexQuery;
/**
 * A processed node regex query (not serializable).
 * @record
 * @extends {ProcessedNodeQueryBase}
 */
function ProcessedNodeRegexQuery() { }
exports.ProcessedNodeRegexQuery = ProcessedNodeRegexQuery;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!NodeQueryType}
     * @public
     */
    ProcessedNodeRegexQuery.prototype.type;
    /**
     * @type {!RegExp}
     * @public
     */
    ProcessedNodeRegexQuery.prototype.queryRegex;
}
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeAttrValueRangeQuery} */
exports.NodeAttrValueRangeQuery;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeTypeQuery} */
exports.NodeTypeQuery;
/**
 * Union type for node query.
 * @typedef {(!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeRegexQuery|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeAttrValueRangeQuery|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeTypeQuery)}
 */
exports.NodeQuery;
/**
 * Union type for processed node query.
 * @typedef {(!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeAttrValueRangeQuery|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.NodeTypeQuery|!ProcessedNodeRegexQuery)}
 */
exports.ProcessedNodeQuery;
/**
 * Types of node query.
 * @enum {string}
 */
const NodeQueryType = {
    REGEX: "regex",
    ATTR_VALUE_RANGE: "attr_value_range",
    NODE_TYPE: "node_type",
};
exports.NodeQueryType = NodeQueryType;
/**
 * Types of node to match in a search.
 * @enum {string}
 */
const SearchNodeType = {
    OP_NODES: "op_nodes",
    LAYER_NODES: "layer_nodes",
    OP_AND_LAYER_NODES: "op_and_layer_nodes",
};
exports.SearchNodeType = SearchNodeType;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$types.SerializedStyle} */
exports.SerializedStyle;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL2NvbW1vbi90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSxzQkFBbUQ7Ozs7Ozs7QUFTbkQscUJBQXNDOzs7OztBQUd0QywyQkFHQzs7Ozs7Ozs7SUFGQywwQkFBVzs7Ozs7SUFDWCw2QkFBb0I7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4RnRCLDZCQUtDOzs7Ozs7OztJQUpDLDRCQUFXOzs7OztJQUNYLG1DQUFxQjs7Ozs7SUFDckIseUNBQXVCOzs7OztJQUN2Qix1Q0FBMEI7Ozs7OztBQUk1Qiw4QkFHQzs7Ozs7Ozs7SUFGQyxpQ0FBZTs7Ozs7SUFDZixzREFBc0M7Ozs7OztBQUl4QywrQkFJQzs7Ozs7Ozs7SUFIQyxtQ0FBZ0I7Ozs7O0lBQ2hCLGtDQUFlOzs7OztJQUNmLGtDQUFlOzs7Ozs7QUFJakIsMkJBR0M7Ozs7Ozs7O0lBRkMsMEJBQVc7Ozs7O0lBQ1gsaUNBQXlCOzs7Ozs7QUFJM0IsTUFBWSxhQUFhO0lBQ3ZCLFVBQVUsR0FBQTtJQUNWLEtBQUssR0FBQTtJQUNMLFdBQVcsR0FBQTtFQUNaOzs7Ozs7Ozs7QUFHRCwrQkFLQzs7Ozs7Ozs7SUFKQyxrQ0FBZTs7Ozs7SUFDZixzQ0FBbUI7Ozs7O0lBQ25CLHVDQUFxQjs7Ozs7SUFDckIsdUNBQXNCOzs7Ozs7O0FBSXhCLDZCQUVDOzs7Ozs7OztJQURDLGdDQUFpQjs7Ozs7O0FBSW5CLE1BQVksWUFBWTtJQUN0QixLQUFLLEdBQUE7RUFDTjs7Ozs7OztBQUdELDhCQUVDOzs7Ozs7OztJQURDLHFDQUFtQjs7Ozs7O0FBSXJCLGtDQUdDOzs7Ozs7OztJQUZDLHlDQUFtQjs7Ozs7SUFDbkIsdUNBQXVCOzs7Ozs7QUFJ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O0FBR2xCLE1BQVksYUFBYTtJQUN2QixLQUFLLFNBQVU7SUFDZixnQkFBZ0Isb0JBQXFCO0lBQ3JDLFNBQVMsYUFBYztFQUN4Qjs7Ozs7O0FBR0QsTUFBWSxjQUFjO0lBQ3hCLFFBQVEsWUFBYTtJQUNyQixXQUFXLGVBQWdCO0lBQzNCLGtCQUFrQixzQkFBdUI7RUFDMUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0dyb3VwTm9kZSwgTW9kZWxHcmFwaH0gZnJvbSAnLi9tb2RlbF9ncmFwaCc7XG5cbi8qKiBBIHR5cGUgZm9yIGtleS12YWx1ZSBwYWlycy4gKi9cbmV4cG9ydCB0eXBlIEtleVZhbHVlUGFpcnMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4vKiogQW4gb2JqZWN0IHdpdGggXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIGZpZWxkLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEtleVZhbHVlIHtcbiAga2V5OiBzdHJpbmc7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbi8qKiBBIHR5cGUgZm9yIGEgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMuICovXG5leHBvcnQgdHlwZSBLZXlWYWx1ZUxpc3QgPSBLZXlWYWx1ZVtdO1xuXG4vKiogQW4gaXRlbSBpbiBpbnB1dC9vdXRwdXQgbWV0YWRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhSXRlbSB7XG4gIGlkOiBzdHJpbmc7XG4gIGF0dHJzOiBLZXlWYWx1ZUxpc3Q7XG59XG5cbi8qKiBBbiBpbmNvbWluZyBlZGdlIGluIHRoZSBncmFwaC4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJbmNvbWluZ0VkZ2Uge1xuICAvKiogVGhlIGlkIG9mIHRoZSBzb3VyY2Ugbm9kZSAod2hlcmUgdGhlIGVkZ2UgY29tZXMgZnJvbSkuICovXG4gIC8vIExJTlQuSWZDaGFuZ2VcbiAgc291cmNlTm9kZUlkOiBzdHJpbmc7XG4gIC8vIExJTlQuVGhlbkNoYW5nZSgvL2RlcG90L2dvb2dsZTMvdGhpcmRfcGFydHkvdGVuc29yZmxvdy9jb21waWxlci9tbGlyL2xpdGUvZXhwZXJpbWVudGFsL2dvb2dsZS90b29saW5nL2Zvcm1hdHMvc2NoZW1hX3N0cnVjdHMuY2MpXG5cbiAgLyoqIFRoZSBpZCBvZiB0aGUgb3V0cHV0IGZyb20gdGhlIHNvdXJjZSBub2RlIHRoYXQgdGhpcyBlZGdlIGdvZXMgb3V0IG9mLiAqL1xuICAvLyBMSU5ULklmQ2hhbmdlXG4gIHNvdXJjZU5vZGVPdXRwdXRJZDogc3RyaW5nO1xuICAvLyBMSU5ULlRoZW5DaGFuZ2UoLy9kZXBvdC9nb29nbGUzL3RoaXJkX3BhcnR5L3RlbnNvcmZsb3cvY29tcGlsZXIvbWxpci9saXRlL2V4cGVyaW1lbnRhbC9nb29nbGUvdG9vbGluZy9mb3JtYXRzL3NjaGVtYV9zdHJ1Y3RzLmNjKVxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGlucHV0IGZyb20gdGhlIHRhcmdldCBub2RlICh0aGlzIG5vZGUpIHRoYXQgdGhpcyBlZGdlXG4gICAqIGNvbm5lY3RzIHRvLlxuICAgKi9cbiAgLy8gTElOVC5JZkNoYW5nZVxuICB0YXJnZXROb2RlSW5wdXRJZDogc3RyaW5nO1xuICAvLyBMSU5ULlRoZW5DaGFuZ2UoLy9kZXBvdC9nb29nbGUzL3RoaXJkX3BhcnR5L3RlbnNvcmZsb3cvY29tcGlsZXIvbWxpci9saXRlL2V4cGVyaW1lbnRhbC9nb29nbGUvdG9vbGluZy9mb3JtYXRzL3NjaGVtYV9zdHJ1Y3RzLmNjKVxuXG4gIC8qKiBPdGhlciBhc3NvY2lhdGVkIG1ldGFkYXRhIGZvciB0aGlzIGVkZ2UuICovXG4gIC8vIExJTlQuSWZDaGFuZ2VcbiAgbWV0YWRhdGE/OiBLZXlWYWx1ZVBhaXJzO1xuICAvLyBMSU5ULlRoZW5DaGFuZ2UoLy9kZXBvdC9nb29nbGUzL3RoaXJkX3BhcnR5L3RlbnNvcmZsb3cvY29tcGlsZXIvbWxpci9saXRlL2V4cGVyaW1lbnRhbC9nb29nbGUvdG9vbGluZy9mb3JtYXRzL3NjaGVtYV9zdHJ1Y3RzLmNjKVxufVxuXG4vKiogQW4gb3V0Z29pbmcgZWRnZSBpbiB0aGUgZ3JhcGguICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgT3V0Z29pbmdFZGdlIHtcbiAgLyoqIFRoZSBpZCBvZiB0aGUgdGFyZ2V0IG5vZGUgKHdoZXJlIHRoZSBlZGdlIGNvbm5lY3RzIHRvKS4gKi9cbiAgLy8gTElOVC5JZkNoYW5nZVxuICB0YXJnZXROb2RlSWQ6IHN0cmluZztcbiAgLy8gTElOVC5UaGVuQ2hhbmdlKC8vZGVwb3QvZ29vZ2xlMy90aGlyZF9wYXJ0eS90ZW5zb3JmbG93L2NvbXBpbGVyL21saXIvbGl0ZS9leHBlcmltZW50YWwvZ29vZ2xlL3Rvb2xpbmcvZm9ybWF0cy9zY2hlbWFfc3RydWN0cy5jYylcblxuICAvKiogVGhlIGlkIG9mIHRoZSBvdXRwdXQgZnJvbSB0aGUgc291cmNlIG5vZGUgdGhhdCB0aGlzIGVkZ2UgZ29lcyBvdXQgb2YuICovXG4gIC8vIExJTlQuSWZDaGFuZ2VcbiAgc291cmNlTm9kZU91dHB1dElkOiBzdHJpbmc7XG4gIC8vIExJTlQuVGhlbkNoYW5nZSgvL2RlcG90L2dvb2dsZTMvdGhpcmRfcGFydHkvdGVuc29yZmxvdy9jb21waWxlci9tbGlyL2xpdGUvZXhwZXJpbWVudGFsL2dvb2dsZS90b29saW5nL2Zvcm1hdHMvc2NoZW1hX3N0cnVjdHMuY2MpXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgaW5wdXQgZnJvbSB0aGUgdGFyZ2V0IG5vZGUgKHRoaXMgbm9kZSkgdGhhdCB0aGlzIGVkZ2VcbiAgICogY29ubmVjdHMgdG8uXG4gICAqL1xuICAvLyBMSU5ULklmQ2hhbmdlXG4gIHRhcmdldE5vZGVJbnB1dElkOiBzdHJpbmc7XG4gIC8vIExJTlQuVGhlbkNoYW5nZSgvL2RlcG90L2dvb2dsZTMvdGhpcmRfcGFydHkvdGVuc29yZmxvdy9jb21waWxlci9tbGlyL2xpdGUvZXhwZXJpbWVudGFsL2dvb2dsZS90b29saW5nL2Zvcm1hdHMvc2NoZW1hX3N0cnVjdHMuY2MpXG5cbiAgLyoqIE90aGVyIGFzc29jaWF0ZWQgbWV0YWRhdGEgZm9yIHRoaXMgZWRnZS4gKi9cbiAgLy8gTElOVC5JZkNoYW5nZVxuICBtZXRhZGF0YT86IEtleVZhbHVlUGFpcnM7XG4gIC8vIExJTlQuVGhlbkNoYW5nZSgvL2RlcG90L2dvb2dsZTMvdGhpcmRfcGFydHkvdGVuc29yZmxvdy9jb21waWxlci9tbGlyL2xpdGUvZXhwZXJpbWVudGFsL2dvb2dsZS90b29saW5nL2Zvcm1hdHMvc2NoZW1hX3N0cnVjdHMuY2MpXG59XG5cbi8qKiBBIHBvaW50IHdpdGggeCBhbmQgeSBjb29yZGluYXRlLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbi8qKiBBIHJlY3RhbmdsZS4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBSZWN0IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xufVxuXG4vKiogVGhlIHN0eWxlIG9mIHRoZSBvcCBub2RlLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEdyYXBoTm9kZVN0eWxlIHtcbiAgLyoqXG4gICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBJdCBzaG91bGQgYmUgaW4gY3NzIGZvcm1hdC5cbiAgICovXG4gIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogSXQgc2hvdWxkIGJlIGluIGNzcyBmb3JtYXQuXG4gICAqL1xuICBib3JkZXJDb2xvcj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgbm9kZSB3aGVuIGl0IGlzIGhvdmVyZWQuXG4gICAqXG4gICAqIEl0IHNob3VsZCBiZSBpbiBjc3MgZm9ybWF0LlxuICAgKi9cbiAgaG92ZXJlZEJvcmRlckNvbG9yPzogc3RyaW5nO1xufVxuXG4vKiogRGF0YSB0byBwYXNzIGFsb25nIHdoZW4gY2xpY2tpbmcgXCJvcGVuIGluIHBvcHVwXCIgb24gYSBncm91cCBub2RlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb3B1cFBhbmVsRGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIGdyb3VwTm9kZTogR3JvdXBOb2RlO1xuICBpbml0aWFsUG9zaXRpb246IFBvaW50O1xuICBjdXJNb2RlbEdyYXBoOiBNb2RlbEdyYXBoO1xufVxuXG4vKiogRGF0YSB0byBwYXNzIGFsb25nIHdoZW4gYSBub2RlIGlzIGxvY2F0ZWQuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVMb2NhdGVkRGF0YSB7XG4gIG5vZGVJZDogc3RyaW5nO1xuICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHM6IHN0cmluZ1tdO1xufVxuXG4vKiogRGF0YSB0byBwYXNzIGFsb25nIHdoZW4gcmV2ZWFsaW5nIGEgbm9kZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVRvUmV2ZWFsSW5mbyB7XG4gIGdyYXBoSWQ6IHN0cmluZztcbiAgcGFuZUlkOiBzdHJpbmc7XG4gIG5vZGVJZDogc3RyaW5nO1xufVxuXG4vKiogSW5mbyBhYm91dCBhIHJlbmRlcmVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW5kZXJlckluZm8ge1xuICBpZDogc3RyaW5nO1xuICBvd25lclR5cGU6IFJlbmRlcmVyT3duZXI7XG59XG5cbi8qKiBUaGUgb3duZXIgb2YgdGhlIHJlbmRlcmVyLiAqL1xuZXhwb3J0IGVudW0gUmVuZGVyZXJPd25lciB7XG4gIE1BSU5fUEFORUwsXG4gIFBPUFVQLFxuICBHUkFQSF9QQU5FTCxcbn1cblxuLyoqIEluZm8gYWJvdXQgYSBzZWxlY3RlZCBub2RlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RlZE5vZGVJbmZvIHtcbiAgbm9kZUlkOiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgaXNHcm91cE5vZGU6IGJvb2xlYW47XG4gIG5vTm9kZVNoYWtlPzogYm9vbGVhbjtcbn1cblxuLyoqIEluZm8gYWJvdXQgYSBub2RlIHRvIGxvY2F0ZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRlTm9kZUluZm8gZXh0ZW5kcyBTZWxlY3RlZE5vZGVJbmZvIHtcbiAgc2VsZWN0PzogYm9vbGVhbjtcbn1cblxuLyoqIFR5cGVzIG9mIHJlbmRlcmVyLiAqL1xuZXhwb3J0IGVudW0gUmVuZGVyZXJUeXBlIHtcbiAgV0VCR0wsXG59XG5cbi8qKiBJbmZvIHRvIHBhc3MgYWxvbmcgd2hlbiBjbGlja2luZyBcImFkZCBzbmFwc2hvdFwiICovXG5leHBvcnQgaW50ZXJmYWNlIEFkZFNuYXBzaG90SW5mbyB7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbn1cblxuLyoqIEluZm8gZm9yIHJlc3RvcmluZyBhIHNuYXBzaG90LiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXN0b3JlU25hcHNob3RJbmZvIHtcbiAgcmVuZGVyZXJJZDogc3RyaW5nO1xuICBzbmFwc2hvdDogU25hcHNob3REYXRhO1xufVxuXG4vKiogRGF0YSByZWxhdGVkIHRvIGEgc25hcHNob3QuICovXG5leHBvcnQgaW50ZXJmYWNlIFNuYXBzaG90RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIHJlY3Q6IFJlY3Q7XG4gIGltYWdlQml0bWFwOiBJbWFnZUJpdG1hcDtcbiAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzPzogc3RyaW5nW107XG4gIHNlbGVjdGVkTm9kZUlkPzogc3RyaW5nO1xuICBzaG93T25Ob2RlSXRlbVR5cGVzPzogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPjtcbiAgc2hvd09uRWRnZUl0ZW1UeXBlcz86IFJlY29yZDxzdHJpbmcsIFNob3dPbkVkZ2VJdGVtRGF0YT47XG4gIGZsYXR0ZW5MYXllcnM/OiBib29sZWFuO1xufVxuXG4vKiogSW5mbyB0byBwYXNzIGFsb25nIHdoZW4gY2xpY2tpbmcgXCJleHBhbmQvY29sbGFwc2UgYWxsIGxheWVyc1wiICovXG5leHBvcnQgaW50ZXJmYWNlIEV4cGFuZE9yQ29sbGFwc2VBbGxHcmFwaExheWVyc0luZm8ge1xuICBleHBhbmRPckNvbGxhcHNlOiBib29sZWFuO1xuICByZW5kZXJlcklkOiBzdHJpbmc7XG59XG5cbi8qKiBJbmZvIHRvIHBhc3MgYWxvbmcgd2hlbiBjbGlja2luZyBcImRvd25sb2FkIGFzIHBuZ1wiICovXG5leHBvcnQgaW50ZXJmYWNlIERvd25sb2FkQXNQbmdJbmZvIHtcbiAgcmVuZGVyZXJJZDogc3RyaW5nO1xuICAvLyBmYWxzZTogZ3JhcGggaW4gdmlld3BvcnQuXG4gIGZ1bGxHcmFwaDogYm9vbGVhbjtcbiAgLy8gV2hldGhlciB0byBzZXQgYmFja2dyb3VuZCB0byB0cmFuc3BhcmVudC5cbiAgdHJhbnNwYXJlbnRCYWNrZ3JvdW5kOiBib29sZWFuO1xufVxuXG4vKiogVGhlIGJhc2ljIGluZm8gb2YgYSBub2RlIGRhdGEgcHJvdmlkZXIgcnVuLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE5vZGVEYXRhUHJvdmlkZXJSdW5JbmZvIHtcbiAgcnVuSWQ6IHN0cmluZztcbiAgcnVuTmFtZTogc3RyaW5nO1xufVxuXG4vKiogTm9kZSBkYXRhIHByb3ZpZGVyIGRhdGEgZm9yIGEgc2luZ2xlIGdyYXBoLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE5vZGVEYXRhUHJvdmlkZXJHcmFwaERhdGEge1xuICAvKipcbiAgICogTm9kZSBkYXRhIGluZGV4ZWQgYnkgbm9kZSBrZXlzLlxuICAgKlxuICAgKiBUaGUga2V5IGNvdWxkIGJlOlxuICAgKiAtIEFueSBvZiB0aGUgb3V0cHV0IHRlbnNvciBuYW1lcyBvZiBhIG5vZGUuXG4gICAqIC0gVGhlIG5vZGUgaWQgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBncmFwaCBqc29uLlxuICAgKiAgIChzZWUgaHR0cDovL2dvb2dsZTMvbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL21vZHVsZS9jb21tb24vaW5wdXRfZ3JhcGgudHM7bD00NztyY2w9NTkxMTAzNTIwKS5cbiAgICovXG4gIHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSZXN1bHREYXRhPjtcblxuICAvKipcbiAgICogVGhyZXNob2xkcyB0aGF0IGRlZmluZSB2YXJpb3VzIHJhbmdlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBzdHlsZXNcbiAgICogKGUuZy4gbm9kZSBiZyBjb2xvcikgdG8gYmUgYXBwbGllZCBmb3IgdGhhdCByYW5nZS5cbiAgICpcbiAgICogVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiBgTm9kZURhdGFQcm92aWRlclJlc3VsdERhdGEudmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBUYWtlIHRoZSBmb2xsb3dpbmcgdGhyZXNob2xkcyBhcyBhbiBleGFtcGxlOlxuICAgKlxuICAgKiBbXG4gICAqICAge3ZhbHVlOiAxMCwgYmdDb2xvcjogJ3JlZCd9XG4gICAqICAge3ZhbHVlOiA1MCwgYmdDb2xvcjogJ2JsdWUnfVxuICAgKiAgIHt2YWx1ZTogMTAwLCBiZ0NvbG9yOiAneWVsbG93J31cbiAgICogXVxuICAgKlxuICAgKiBUaGlzIG1lYW5zOlxuICAgKiAtIE5vZGUgZGF0YSB3aXRoIHZhbHVlIDw9MTAgaGF2ZSBcInJlZFwiIGJhY2tncm91bmQgY29sb3IuXG4gICAqIC0gTm9kZSBkYXRhIHdpdGggdmFsdWUgPjEwIGFuZCA8PTUwIGhhdmUgXCJibHVlXCIgYmFja2dyb3VuZCBjb2xvci5cbiAgICogLSBOb2RlIGRhdGEgd2l0aCB2YWx1ZSA+NTAgYW5kIDw9MTAwIGhhdmUgXCJ5ZWxsb3dcIiBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiAtIE5vZGUgZGF0YSB3aXRoIHZhbHVlID4xMDAgaGF2ZSBubyBiYWNrZ3JvdW5kIGNvbG9yICh3aGl0ZSkuXG4gICAqL1xuICB0aHJlc2hvbGRzPzogVGhyZXNob2xkSXRlbVtdO1xuXG4gIC8qKlxuICAgKiBBIGdyYWRpZW50IHRoYXQgZGVmaW5lcyB0aGUgc3RvcHMgKGZyb20gMCB0byAxKSBhbmQgdGhlIGFzc29jaWF0ZWQgY29sb3JzLlxuICAgKiBBIHN0b3AgdmFsdWUgMCBjb3JyZXNwb25kZyB0byB0aGUgbWluaW11bSB2YWx1ZSBpbiBgcmVzdWx0c2AsIGFuZCBhIHN0b3BcbiAgICogdmFsdWUgMSBjb3JyZXNwb25kcyB0byB0aGUgbWF4aW11bSB2YWx1ZSBpbiByZXN1bHRzLiBTdG9wcyBmb3IgMCBhbmQgMVxuICAgKiBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkLlxuICAgKlxuICAgKiBXaGVuIGNvbG9yLWNvZGluZyBhIG5vZGUsIHRoZSBzeXN0ZW0gdXNlcyB0aGUgbm9kZSdzIGRhdGEgdmFsdWUgdG9cbiAgICogY2FsY3VsYXRlIGEgY29ycmVzcG9uZGluZyBzdG9wIGFuZCBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBncmFkaWVudCBjb2xvcnMuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBgdGhyZXNob2xkc2AgZmllbGQgYWJvdmUuXG4gICAqL1xuICBncmFkaWVudD86IEdyYWRpZW50SXRlbVtdO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL015bmRleC9lMTAyNTcwNjQzNjczNjE2NjU2MWQzMzlmZDY2NzQ5M1xufVxuXG4vKiogVGhlIHRvcCBsZXZlbCBub2RlIGRhdGEgcHJvdmlkZXIgZGF0YSwgaW5kZXhlZCBieSBncmFwaCBpZC4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBOb2RlRGF0YVByb3ZpZGVyRGF0YSB7XG4gIFtrZXk6IHN0cmluZ106IE5vZGVEYXRhUHJvdmlkZXJHcmFwaERhdGE7XG59XG5cbi8qKiBUaGUgZGF0YSBmb3IgYSBub2RlIGRhdGEgcHJvdmlkZXIgcnVuLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhIHtcbiAgcnVuSWQ6IHN0cmluZztcbiAgcnVuTmFtZTogc3RyaW5nO1xuICBleHRlbnNpb25JZDogc3RyaW5nO1xuICBjb2xsZWN0aW9uSWQ6IHN0cmluZztcbiAgcmVtb3RlUGF0aD86IHN0cmluZztcblxuICBub2RlRGF0YVByb3ZpZGVyRGF0YT86IE5vZGVEYXRhUHJvdmlkZXJEYXRhO1xuXG4gIC8vIHNlbGVjdGVkOiBib29sZWFuO1xuXG4gIGRvbmU6IGJvb2xlYW47XG4gIC8qKiBBIG51bWJlciBmcm9tIDAgdG8gMSBhcyBwcm9ncmVzcy4gKi9cbiAgcHJvZ3Jlc3M/OiBudW1iZXI7XG5cbiAgLy8gZ3JhcGhJZCAtPiB7bm9kZUlkIC0+IHByb2Nlc3NlZCByZXN1bHRzfVxuICByZXN1bHRzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJlc3VsdFByb2Nlc3NlZERhdGE+PjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbi8qKiBUaGUgcmVzdWx0IGRhdGEgZm9yIGEgbm9kZSBpbiBhIG5vZGUgZGF0YSBwcm92aWRlciBydW4uICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTm9kZURhdGFQcm92aWRlclJlc3VsdERhdGEge1xuICAvKiogVGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSByZXN1bHQuICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgQWxsb3cgYXJiaXRyYXJ5IHR5cGVzLlxuICB2YWx1ZTogYW55O1xuXG4gIC8qKlxuICAgKiBUaGUgYmcgY29sb3IgdG8gcmVuZGVyIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgZm9yLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIG92ZXJyaWRlcyB0aGUgdmFsdWUgY2FsY3VsYXRlZCBmcm9tIHRoZSB0aHJlc2hvbGRzXG4gICAqIChgTm9kZURhdGFQcm92aWRlckRhdGEudGhyZXNob2xkc2ApIGlmIHNwZWNpZmllZC5cbiAgICovXG4gIGJnQ29sb3I/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbG9yIHRvIHJlbmRlciB0aGUgY29ycmVzcG9uZGluZyBub2RlIGZvci5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIHZhbHVlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdGhyZXNob2xkc1xuICAgKiAoYE5vZGVEYXRhUHJvdmlkZXJEYXRhLnRocmVzaG9sZHNgKSBpZiBzcGVjaWZpZWQuXG4gICAqL1xuICB0ZXh0Q29sb3I/OiBzdHJpbmc7XG59XG5cbi8qKiBUaGUgcHJvY2Vzc2VkIHJlc3VsdCBkYXRhIGZvciBhIG5vZGUgaW4gYSBub2RlIGRhdGEgcHJvdmlkZXIgcnVuLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE5vZGVEYXRhUHJvdmlkZXJSZXN1bHRQcm9jZXNzZWREYXRhXG4gIGV4dGVuZHMgTm9kZURhdGFQcm92aWRlclJlc3VsdERhdGEge1xuICAvKipcbiAgICogVGhlIGFjY3VtdWxhdGVkIHZhbHVlcyBmcm9tIGFsbCB0aGUgcmVzdWx0cyB3aG9zZSBrZXkgbWFwcyB0byB0aGlzIG5vZGUuXG4gICAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IEFsbG93IGFyYml0cmFyeSB0eXBlcy5cbiAgYWxsVmFsdWVzOiB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICAvKiogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUuICovXG4gIHN0clZhbHVlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSB0aHJlc2hvbGQgaXRlbSB3aXRoIHRoZSB1cHBlcmJvdW5kIHZhbHVlIGFuZCBpdHMgY29ycmVzcG9uZGluZyBiZyBjb2xvci5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFRocmVzaG9sZEl0ZW0ge1xuICB2YWx1ZTogbnVtYmVyO1xuICBiZ0NvbG9yOiBzdHJpbmc7XG4gIHRleHRDb2xvcj86IHN0cmluZztcbn1cblxuLyoqIEEgZ3JhZGllbnQgaXRlbSB3aXRoIHRoZSBzdG9wIGFuZCBpdHMgY29ycmVzcG9uZGluZyBjb2xvcnMuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgR3JhZGllbnRJdGVtIHtcbiAgLyoqIEEgbnVtYmVyIGZyb20gMCB0byAxLiAqL1xuICBzdG9wOiBudW1iZXI7XG4gIC8qKiBPbmx5IHN1cHBvcnQgaGV4IGZvcm0gKGUuZy4gI2FhYmIwMCkgb3IgY29sb3IgbmFtZSAoZS5nLiByZWQpICovXG4gIGJnQ29sb3I/OiBzdHJpbmc7XG4gIC8qKiBPbmx5IHN1cHBvcnQgaGV4IGZvcm0gKGUuZy4gI2FhYmIwMCkgb3IgY29sb3IgbmFtZSAoZS5nLiByZWQpICovXG4gIHRleHRDb2xvcj86IHN0cmluZztcbn1cblxuLyoqIEEgcGFuZSBpbiB0aGUgbWFpbiBVSS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFuZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHdpZHRoRnJhY3Rpb246IG51bWJlcjtcbiAgc2VsZWN0ZWROb2RlSW5mbz86IFNlbGVjdGVkTm9kZUluZm87XG4gIGhhc0FydGlmaWNpYWxMYXllcnM/OiBib29sZWFuO1xuICAvLyBVc2UgdGhpcyB0byByZXZlYWwgYSBub2RlIGluIHRoaXMgcGFuZSBhbmQgc2VsZWN0IGl0LlxuICBub2RlSWRUb1JldmVhbD86IHN0cmluZztcbiAgLy8gR3JhcGggaWQgdG8gc25hcHNob3RzLlxuICBzbmFwc2hvdHM/OiBSZWNvcmQ8c3RyaW5nLCBTbmFwc2hvdERhdGFbXT47XG4gIC8vIFdoZXRoZXIgdG8gZmxhdHRlbiBhbGwgbGF5ZXJzIChpZ25vcmUgbmFtZXNwYWNlcyBpbiBub2RlKS5cbiAgZmxhdHRlbkxheWVycz86IGJvb2xlYW47XG4gIHNuYXBzaG90VG9SZXN0b3JlPzogU25hcHNob3REYXRhO1xuICBzdWJncmFwaEJyZWFkY3J1bWJzPzogU3ViZ3JhcGhCcmVhZGNydW1iSXRlbVtdO1xuICBzZWFyY2hSZXN1bHRzPzogU2VhcmNoUmVzdWx0cztcbiAgc2VsZWN0ZWROb2RlRGF0YVByb3ZpZGVyUnVuSWQ/OiBzdHJpbmc7XG5cbiAgLy8gUmVuZGVyZXIgaWQgLT4gPGl0ZW0gdHlwZSBzaG93biBvbiBub2RlIC0+IGRhdGE+XG4gIHNob3dPbk5vZGVJdGVtVHlwZXM/OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+PjtcblxuICAvLyBSZW5kZXJlciBpZCAtPiA8aXRlbSB0eXBlIHNob3duIG9uIGVkZ2UgLT4gZGF0YT5cbiAgc2hvd09uRWRnZUl0ZW1UeXBlcz86IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFNob3dPbkVkZ2VJdGVtRGF0YT4+O1xuXG4gIG1vZGVsR3JhcGg/OiBNb2RlbEdyYXBoO1xufVxuXG4vKiogVGhlIGRhdGEgZm9yIHByb2Nlc3NlZCBtb2RlbCBncmFwaCBhbmQgcmVsYXRlZCBpbmZvLiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWRNb2RlbEdyYXBoRGF0YSB7XG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGg7XG4gIHBhbmVJZDogc3RyaW5nO1xufVxuXG4vKiogQ29sb3IgdXNlZCBpbiB2YXJpb3VzIHdlYmdsIGNvbXBvbmVudHMuIEVhY2ggZmllbGQgaXMgZnJvbSAwIHRvIDEuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlYmdsQ29sb3Ige1xuICByOiBudW1iZXI7XG4gIGc6IG51bWJlcjtcbiAgYjogbnVtYmVyO1xufVxuXG4vKiogQSB2YWx1ZSBmb3IgYSBzaGFkZXIgdW5pZm9ybS4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBVbmlmb3JtVmFsdWUge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IEFsbG93IGFyYml0cmFyeSB0eXBlcy5cbiAgdmFsdWU6IGFueTtcbn1cblxuLyoqIEFuIGV2ZW50IGluZGljYXRpbmcgYSBtb2RlbCBncmFwaCBoYXMgYmVlbiBwcm9jZXNzZWQuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsR3JhcGhQcm9jZXNzZWRFdmVudCB7XG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGg7XG4gIHBhbmVJbmRleDogbnVtYmVyO1xufVxuXG4vKiogQSBzaW5nbGUgaXRlbSBpbiBzdWJncmFwaCBicmVhZGNydW1icy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3ViZ3JhcGhCcmVhZGNydW1iSXRlbSB7XG4gIGdyYXBoSWQ6IHN0cmluZztcbiAgc25hcHNob3Q/OiBTbmFwc2hvdERhdGE7XG59XG5cbi8qKiBCYXNlIGludGVyZmFjZSBmb3IgYSBzZWFyY2ggbWF0Y2guICovXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaE1hdGNoQmFzZSB7XG4gIHR5cGU6IFNlYXJjaE1hdGNoVHlwZTtcbn1cblxuLyoqIEludGVyZmFjZSBmb3IgYSBzZWFyY2ggbWF0Y2ggZm9yIGEgbm9kZSBsYWJlbC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoTWF0Y2hOb2RlTGFiZWwgZXh0ZW5kcyBTZWFyY2hNYXRjaEJhc2Uge1xuICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuTk9ERV9MQUJFTDtcbn1cblxuLyoqIEludGVyZmFjZSBmb3IgYSBzZWFyY2ggbWF0Y2ggZm9yIGFuIGlucHV0IG1ldGFkYXRhLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hNYXRjaElucHV0TWV0YWRhdGEgZXh0ZW5kcyBTZWFyY2hNYXRjaEJhc2Uge1xuICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuSU5QVVRfTUVUQURBVEE7XG4gIG1hdGNoZWRUZXh0OiBzdHJpbmc7XG59XG5cbi8qKiBJbnRlcmZhY2UgZm9yIGEgc2VhcmNoIG1hdGNoIGZvciBhbiBvdXRwdXQgbWV0YWRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaE1hdGNoT3V0cHV0TWV0YWRhdGEgZXh0ZW5kcyBTZWFyY2hNYXRjaEJhc2Uge1xuICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuT1VUUFVUX01FVEFEQVRBO1xuICBtYXRjaGVkVGV4dDogc3RyaW5nO1xufVxuXG4vKiogSW50ZXJmYWNlIGZvciBhIHNlYXJjaCBtYXRjaCBmb3IgYW4gYXR0cmlidXRlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hNYXRjaEF0dHIgZXh0ZW5kcyBTZWFyY2hNYXRjaEJhc2Uge1xuICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuQVRUUklCVVRFO1xuICBtYXRjaGVkQXR0cklkOiBzdHJpbmc7XG59XG5cbi8qKiBVbmlvbiB0eXBlIGZvciBzZWFyY2ggbWF0Y2guICovXG5leHBvcnQgdHlwZSBTZWFyY2hNYXRjaCA9XG4gIHwgU2VhcmNoTWF0Y2hOb2RlTGFiZWxcbiAgfCBTZWFyY2hNYXRjaElucHV0TWV0YWRhdGFcbiAgfCBTZWFyY2hNYXRjaE91dHB1dE1ldGFkYXRhXG4gIHwgU2VhcmNoTWF0Y2hBdHRyO1xuXG4vKiogTXVsdGlwbGUgc2VhcmNoIG1hdGNoZXMuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaE1hdGNoZXMge1xuICBtYXRjaGVzOiBTZWFyY2hNYXRjaFtdO1xuICBtYXRjaFR5cGVzOiBTZXQ8c3RyaW5nPjtcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiBzZWFyY2ggbWF0Y2guXG4gKlxuICogVGhlIHZhbHVlIHNob3VsZCBjb3JyZXNwb25kIHRvIGEgbWF0ZXJpYWwgaWNvbi5cbiAqL1xuZXhwb3J0IGVudW0gU2VhcmNoTWF0Y2hUeXBlIHtcbiAgTk9ERV9MQUJFTCA9ICd0aXRsZScsXG4gIElOUFVUX01FVEFEQVRBID0gJ2lucHV0JyxcbiAgT1VUUFVUX01FVEFEQVRBID0gJ291dHB1dCcsXG4gIEFUVFJJQlVURSA9ICdsaXN0Jyxcbn1cblxuLyoqIFNlYXJjaCByZXN1bHRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hSZXN1bHRzIHtcbiAgLyoqIEZyb20gbm9kZSBpZCB0byBtYXRjaGVzICovXG4gIHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIFNlYXJjaE1hdGNoW10+O1xufVxuXG4vKipcbiAqIEl0ZW0gdHlwZXMgdG8gYmUgc2hvd24gb24gbm9kZS5cbiAqXG4gKiBUbyBhZGQgYSBlbnRyeSwgZm9sbG93IHRoZSBzdGVwcyBiZWxvdzpcbiAqXG4gKiAxLiBBZGQgYW4gZW50cnkgaGVyZS5cbiAqIDIuIEFkZCB0byB0aGUgQUxMX1NIT1dfT05fTk9ERV9JVEVNX1RZUEVTIGxpc3QgaW4gcmVuZGVyZXJfd3JhcHBlci50cy5cbiAqIDMuIFVwZGF0ZSByZW5kZXJBdHRyc1RhYmxlIGluIHdlYmdsX3JlbmRlcmVyLnRzLlxuICogNC4gVXBkYXRlIGdldE5vZGVIZWlnaHQgYW5kIGdldE5vZGVXaWR0aCBpbiBncmFwaF9sYXlvdXQudHMuXG4gKi9cbmV4cG9ydCBlbnVtIFNob3dPbk5vZGVJdGVtVHlwZSB7XG4gIE9QX05PREVfSUQgPSAnT3Agbm9kZSBpZCcsXG4gIE9QX0FUVFJTID0gJ09wIG5vZGUgYXR0cmlidXRlcycsXG4gIE9QX0lOUFVUUyA9ICdPcCBub2RlIGlucHV0cycsXG4gIE9QX09VVFBVVFMgPSAnT3Agbm9kZSBvdXRwdXRzJyxcbiAgTEFZRVJfTk9ERV9DSElMRFJFTl9DT1VOVCA9ICdMYXllciBub2RlIGNoaWxkcmVuIGNvdW50JyxcbiAgTEFZRVJfTk9ERV9ERVNDRU5EQU5UU19DT1VOVCA9ICdMYXllciBub2RlIGRlc2NlbmRhbnRzIGNvdW50Jyxcbn1cblxuLyoqIEl0ZW0gdHlwZXMgdG8gYmUgc2hvd24gb24gZWRnZS4gKi9cbmV4cG9ydCBlbnVtIFNob3dPbkVkZ2VJdGVtVHlwZSB7XG4gIFRFTlNPUl9TSEFQRSA9ICdUZW5zb3Igc2hhcGUnLFxufVxuXG4vKiogV2VpZ2h0IG9mIHRoZSBmb250LiAqL1xuZXhwb3J0IGVudW0gRm9udFdlaWdodCB7XG4gIFJFR1VMQVIsXG4gIE1FRElVTSxcbiAgQk9MRCxcbiAgTU9OT1NQQUNFX01FRElVTSxcbiAgSUNPTlMsXG59XG5cbi8qKiBJbmZvIGZvciBhIGNoYXIgcmVuZGVyZWQgaW4gd2ViZ2wuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgQ2hhckluZm8ge1xuICBjaGFyOiBzdHJpbmc7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICB4b2Zmc2V0OiBudW1iZXI7XG4gIHlvZmZzZXQ6IG51bWJlcjtcbiAgeGFkdmFuY2U6IG51bWJlcjtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbi8qKiBGaWVsZCBsYWJlbHMgaW4gaW5mbyBwYW5lbC4gKi9cbmV4cG9ydCBlbnVtIEZpZWxkTGFiZWwge1xuICBPUF9OT0RFX0lEID0gJ2lkJyxcbiAgTlVNQkVSX09GX0NISUxEUkVOID0gJyNjaGlsZHJlbicsXG4gIE5VTUJFUl9PRl9ERVNDRU5EQU5UUyA9ICcjZGVzY2VuZGFudHMnLFxufVxuXG4vKiogRGF0YSBmb3Igc2hvdyBvbiBub2RlIGl0ZW0uICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU2hvd09uTm9kZUl0ZW1EYXRhIHtcbiAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gIGZpbHRlclJlZ2V4Pzogc3RyaW5nO1xufVxuXG4vKiogRGF0YSBmb3Igc2hvdyBvbiBlZGdlIGl0ZW0uICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU2hvd09uRWRnZUl0ZW1EYXRhIHtcbiAgc2VsZWN0ZWQ6IGJvb2xlYW47XG59XG5cbi8qKiBBIHJ1bGUgZm9yIG5vZGUgc3R5bGVyLiBBbGwgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemFibGUuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTm9kZVN0eWxlclJ1bGUge1xuICBxdWVyaWVzOiBOb2RlUXVlcnlbXTtcbiAgbm9kZVR5cGU6IFNlYXJjaE5vZGVUeXBlO1xuICAvLyBJbmRleGVkIGJ5IHN0eWxlIGlkcy5cbiAgc3R5bGVzOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkU3R5bGU+O1xuICB2ZXJzaW9uPzogTm9kZVN0eWxlclJ1bGVWZXJzaW9uO1xufVxuXG4vKiogVmVyc2lvbiBvZiBub2RlIHN0eWxlciBydWxlLiAqL1xuZXhwb3J0IGVudW0gTm9kZVN0eWxlclJ1bGVWZXJzaW9uIHtcbiAgVjIgPSAndjInLFxufVxuXG5kZWNsYXJlIGludGVyZmFjZSBOb2RlUXVlcnlCYXNlIHtcbiAgdHlwZTogTm9kZVF1ZXJ5VHlwZTtcbn1cblxuLyoqIEEgcnVsZSB3aWR0aCBwcm9jZXNzZWQgbm9kZSBzdHlsZXIgcnVsZXMuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NlZE5vZGVTdHlsZXJSdWxlIHtcbiAgcXVlcmllczogUHJvY2Vzc2VkTm9kZVF1ZXJ5W107XG4gIG5vZGVUeXBlOiBTZWFyY2hOb2RlVHlwZTtcbiAgc3R5bGVzOiBSZWNvcmQ8c3RyaW5nLCBTZXJpYWxpemVkU3R5bGU+O1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBQcm9jZXNzZWROb2RlUXVlcnlCYXNlIHtcbiAgdHlwZTogTm9kZVF1ZXJ5VHlwZTtcbiAgbWF0Y2hUeXBlczogU2V0PFNlYXJjaE1hdGNoVHlwZT47XG59XG5cbi8qKiBBIG5vZGUgcmVnZXggcXVlcnkuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTm9kZVJlZ2V4UXVlcnkgZXh0ZW5kcyBOb2RlUXVlcnlCYXNlIHtcbiAgdHlwZTogTm9kZVF1ZXJ5VHlwZS5SRUdFWDtcbiAgcXVlcnlSZWdleDogc3RyaW5nO1xuICBtYXRjaFR5cGVzOiBTZWFyY2hNYXRjaFR5cGVbXTtcbn1cblxuLyoqIEEgcHJvY2Vzc2VkIG5vZGUgcmVnZXggcXVlcnkgKG5vdCBzZXJpYWxpemFibGUpLiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzZWROb2RlUmVnZXhRdWVyeSBleHRlbmRzIFByb2Nlc3NlZE5vZGVRdWVyeUJhc2Uge1xuICB0eXBlOiBOb2RlUXVlcnlUeXBlLlJFR0VYO1xuICBxdWVyeVJlZ2V4OiBSZWdFeHA7XG59XG5cbi8qKiBBIG5vZGUgYXR0ciB2YWx1ZSByYW5nZSBxdWVyeS4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBOb2RlQXR0clZhbHVlUmFuZ2VRdWVyeSBleHRlbmRzIE5vZGVRdWVyeUJhc2Uge1xuICB0eXBlOiBOb2RlUXVlcnlUeXBlLkFUVFJfVkFMVUVfUkFOR0U7XG4gIGF0dHJOYW1lOiBzdHJpbmc7XG4gIG1pbjogbnVtYmVyO1xuICBtYXg6IG51bWJlcjtcbn1cblxuLyoqIEEgbm9kZSB0eXBlIHF1ZXJ5LiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE5vZGVUeXBlUXVlcnkgZXh0ZW5kcyBOb2RlUXVlcnlCYXNlIHtcbiAgdHlwZTogTm9kZVF1ZXJ5VHlwZS5OT0RFX1RZUEU7XG4gIG5vZGVUeXBlOiBTZWFyY2hOb2RlVHlwZTtcbn1cblxuLyoqIFVuaW9uIHR5cGUgZm9yIG5vZGUgcXVlcnkuICovXG5leHBvcnQgdHlwZSBOb2RlUXVlcnkgPVxuICB8IE5vZGVSZWdleFF1ZXJ5XG4gIHwgTm9kZUF0dHJWYWx1ZVJhbmdlUXVlcnlcbiAgfCBOb2RlVHlwZVF1ZXJ5O1xuXG4vKiogVW5pb24gdHlwZSBmb3IgcHJvY2Vzc2VkIG5vZGUgcXVlcnkuICovXG5leHBvcnQgdHlwZSBQcm9jZXNzZWROb2RlUXVlcnkgPVxuICB8IFByb2Nlc3NlZE5vZGVSZWdleFF1ZXJ5XG4gIHwgTm9kZUF0dHJWYWx1ZVJhbmdlUXVlcnlcbiAgfCBOb2RlVHlwZVF1ZXJ5O1xuXG4vKiogVHlwZXMgb2Ygbm9kZSBxdWVyeS4gKi9cbmV4cG9ydCBlbnVtIE5vZGVRdWVyeVR5cGUge1xuICBSRUdFWCA9ICdyZWdleCcsXG4gIEFUVFJfVkFMVUVfUkFOR0UgPSAnYXR0cl92YWx1ZV9yYW5nZScsXG4gIE5PREVfVFlQRSA9ICdub2RlX3R5cGUnLFxufVxuXG4vKiogVHlwZXMgb2Ygbm9kZSB0byBtYXRjaCBpbiBhIHNlYXJjaC4gKi9cbmV4cG9ydCBlbnVtIFNlYXJjaE5vZGVUeXBlIHtcbiAgT1BfTk9ERVMgPSAnb3Bfbm9kZXMnLFxuICBMQVlFUl9OT0RFUyA9ICdsYXllcl9ub2RlcycsXG4gIE9QX0FORF9MQVlFUl9OT0RFUyA9ICdvcF9hbmRfbGF5ZXJfbm9kZXMnLFxufVxuXG4vKiogU2VyaWFsaXplZCBzdHlsZS4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBTZXJpYWxpemVkU3R5bGUge1xuICBpZDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/environment/dev.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/environment/dev.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
// BEGIN-INTERNAL
goog.module('google3.third_party.javascript.safevalues.environment.dev');
var module = module || { id: 'third_party/javascript/safevalues/environment/dev.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Whether we are in development mode. Used for stripping out unnecessary error
 * messages and security checks from production binaries. This will be rewritten
 * to use process.env.NODE_ENV in open-source.
 * @type {boolean}
 */
exports.DEV_MODE = goog.DEBUG;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2Vudmlyb25tZW50L2Rldi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXYSxRQUFBLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLy8gQkVHSU4tSU5URVJOQUxcbi8qKlxuICogV2hldGhlciB3ZSBhcmUgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVXNlZCBmb3Igc3RyaXBwaW5nIG91dCB1bm5lY2Vzc2FyeSBlcnJvclxuICogbWVzc2FnZXMgYW5kIHNlY3VyaXR5IGNoZWNrcyBmcm9tIHByb2R1Y3Rpb24gYmluYXJpZXMuIFRoaXMgd2lsbCBiZSByZXdyaXR0ZW5cbiAqIHRvIHVzZSBwcm9jZXNzLmVudi5OT0RFX0VOViBpbiBvcGVuLXNvdXJjZS5cbiAqL1xuZXhwb3J0IGNvbnN0IERFVl9NT0RFID0gZ29vZy5ERUJVRztcbi8vIEVORC1JTlRFUk5BTFxuXG4vLyBCRUdJTi1FWFRFUk5BTFxuLy8gLyoqXG4vLyAgKiBFbnN1cmUgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgaXMgc2V0IGV2ZW4gd2hlbiBub3QgcnVubmluZyB1bmRlciBXZWJwYWNrIG9yXG4vLyAgKiBOb2RlLiBUZXJzZXIgd2lsbCBzdHJpcCB0aGlzIG91dCBvZiBwcm9kdWN0aW9uIGJpbmFyaWVzLlxuLy8gICovXG4vLyAvKiNfX1BVUkVfXyovICgoKSA9PiB7XG4vLyAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbi8vICAgICAod2luZG93LnByb2Nlc3MgYXMgdW5rbm93bikgPSB7XG4vLyAgICAgICBlbnY6IHtcbi8vICAgICAgICAgTk9ERV9FTlY6ICdkZXZlbG9wbWVudCdcbi8vICAgICAgIH1cbi8vICAgICB9O1xuLy8gICB9XG4vLyB9KSgpO1xuLy8gRU5ELUVYVEVSTkFMXG4iXX0=
;return exports;});

//third_party/javascript/safevalues/internals/pure.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/internals/pure.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.pure');
var module = module || { id: 'third_party/javascript/safevalues/internals/pure.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Mark an expression as being free of side effects.
 * @template T
 * @param {function(): T} valueOf
 * @return {T}
 */
function pure(valueOf) {
    // This odd looking expression is a workaround specific to the Closure
    // compiler to mark an expression as pure.
    // BEGIN-INTERNAL
    // Note: @nosideeffects can get dropped if calls to this function get inlined,
    // whereas this expression is better preserved across inlining, resulting in
    // smaller sizes in most cases. See
    // https://groups.google.com/a/google.com/g/ise-web/c/vh4Ky_0KunY for context.
    // END-INTERNAL
    return { valueOf }.valueOf();
}
exports.pure = pure;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9pbnRlcm5hbHMvcHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLFNBQWdCLElBQUksQ0FBSSxPQUFnQjtJQUN0QyxzRUFBc0U7SUFDdEUsMENBQTBDO0lBQzFDLGlCQUFpQjtJQUNqQiw4RUFBOEU7SUFDOUUsNEVBQTRFO0lBQzVFLG1DQUFtQztJQUNuQyw4RUFBOEU7SUFDOUUsZUFBZTtJQUNmLE9BQU8sRUFBQyxPQUFPLEVBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM3QixDQUFDO0FBVkQsb0JBVUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qKiBNYXJrIGFuIGV4cHJlc3Npb24gYXMgYmVpbmcgZnJlZSBvZiBzaWRlIGVmZmVjdHMuICovXG5leHBvcnQgZnVuY3Rpb24gcHVyZTxUPih2YWx1ZU9mOiAoKSA9PiBUKTogVCB7XG4gIC8vIFRoaXMgb2RkIGxvb2tpbmcgZXhwcmVzc2lvbiBpcyBhIHdvcmthcm91bmQgc3BlY2lmaWMgdG8gdGhlIENsb3N1cmVcbiAgLy8gY29tcGlsZXIgdG8gbWFyayBhbiBleHByZXNzaW9uIGFzIHB1cmUuXG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIC8vIE5vdGU6IEBub3NpZGVlZmZlY3RzIGNhbiBnZXQgZHJvcHBlZCBpZiBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGdldCBpbmxpbmVkLFxuICAvLyB3aGVyZWFzIHRoaXMgZXhwcmVzc2lvbiBpcyBiZXR0ZXIgcHJlc2VydmVkIGFjcm9zcyBpbmxpbmluZywgcmVzdWx0aW5nIGluXG4gIC8vIHNtYWxsZXIgc2l6ZXMgaW4gbW9zdCBjYXNlcy4gU2VlXG4gIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9nb29nbGUuY29tL2cvaXNlLXdlYi9jL3ZoNEt5XzBLdW5ZIGZvciBjb250ZXh0LlxuICAvLyBFTkQtSU5URVJOQUxcbiAgcmV0dXJuIHt2YWx1ZU9mfS52YWx1ZU9mKCk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/closure/debug/error.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw DebugError(msg) directly, Error(msg) is
 * sufficient.
 */

goog.module('goog.debug.Error');
goog.module.declareLegacyNamespace();



/**
 * Base class for custom error objects.
 * @param {*=} msg The message associated with the error.
 * @param {{
 *    message: (?|undefined),
 *    name: (?|undefined),
 *    lineNumber: (?|undefined),
 *    fileName: (?|undefined),
 *    stack: (?|undefined),
 *    cause: (?|undefined),
 * }=} cause The original error object to chain with.
 * @constructor
 * @extends {Error}
 */
function DebugError(msg = undefined, cause = undefined) {
  // Attempt to ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, DebugError);
  } else {
    const stack = new Error().stack;
    if (stack) {
      /** @override @type {string} */
      this.stack = stack;
    }
  }

  if (msg) {
    /** @override @type {string} */
    this.message = String(msg);
  }

  if (cause !== undefined) {
    /** @type {?} */
    this.cause = cause;
  }

  /**
   * Whether to report this error to the server. Setting this to false will
   * cause the error reporter to not report the error back to the server,
   * which can be useful if the client knows that the error has already been
   * logged on the server.
   * @type {boolean}
   */
  this.reportErrorToServer = true;
}
goog.inherits(DebugError, Error);


/** @override @type {string} */
DebugError.prototype.name = 'CustomError';


exports = DebugError;

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

;return exports;});

//third_party/javascript/closure/dom/nodetype.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

//third_party/javascript/closure/asserts/asserts.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package are given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will make the compiler treat <code>foo</code> as non-nullable. Similarly,
 * <code>goog.asserts.assertNumber(foo)</code> informs the compiler about the
 * type of <code>foo</code>. Where applicable, such assertions are preferable to
 * casts by jsdoc with <code>@type</code>.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo());
 * goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * Additionally, note the compiler will consider the type to be "tightened" for
 * all statements <em>after</em> the assertion. For example:
 * <code>
 * const /** ?Object &#ast;/ value = foo();
 * goog.asserts.assert(value);
 * // "value" is of type {!Object} at this point.
 * </code>
 */

goog.module('goog.asserts');
goog.module.declareLegacyNamespace();

const DebugError = goog.require('goog.debug.Error');
const NodeType = goog.require('goog.dom.NodeType');


// NOTE: this needs to be exported directly and referenced via the exports
// object because unit tests stub it out.
/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
exports.ENABLE_ASSERTS = goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {DebugError}
 * @final
 */
function AssertionError(messagePattern, messageArgs) {
  DebugError.call(this, subs(messagePattern, messageArgs));

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
}
goog.inherits(AssertionError, DebugError);
exports.AssertionError = AssertionError;

/** @override @type {string} */
AssertionError.prototype.name = 'AssertionError';


/**
 * The default error handler.
 * @param {!AssertionError} e The exception to be handled.
 * @return {void}
 */
exports.DEFAULT_ERROR_HANDLER = function(e) {
  throw e;
};


/**
 * The handler responsible for throwing or logging assertion errors.
 * @type {function(!AssertionError)}
 */
let errorHandler_ = exports.DEFAULT_ERROR_HANDLER;


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} pattern The string containing the pattern.
 * @param {!Array<*>} subs The items to substitute into the pattern.
 * @return {string} A copy of `str` in which each occurrence of
 *     `%s` has been replaced an argument from `var_args`.
 */
function subs(pattern, subs) {
  const splitParts = pattern.split('%s');
  let returnString = '';

  // Replace up to the last split part. We are inserting in the
  // positions between split parts.
  const subLast = splitParts.length - 1;
  for (let i = 0; i < subLast; i++) {
    // keep unsupplied as '%s'
    const sub = (i < subs.length) ? subs[i] : '%s';
    returnString += splitParts[i] + sub;
  }
  return returnString + splitParts[subLast];
}


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {?Array<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {!Array<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {AssertionError} When the value is not a number.
 */
function doAssertFailure(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  let message = 'Assertion failed';
  let args;
  if (givenMessage) {
    message += ': ' + givenMessage;
    args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  const e = new AssertionError('' + message, args || []);
  errorHandler_(e);
}


/**
 * Sets a custom error handler that can be used to customize the behavior of
 * assertion failures, for example by turning all assertion failures into log
 * messages.
 * @param {function(!AssertionError)} errorHandler
 * @return {void}
 */
exports.setErrorHandler = function(errorHandler) {
  if (exports.ENABLE_ASSERTS) {
    errorHandler_ = errorHandler;
  }
};


/**
 * Checks if the condition evaluates to true if ENABLE_ASSERTS is
 * true.
 * @template T
 * @param {T} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {T} The value of the condition.
 * @throws {AssertionError} When the condition evaluates to false.
 * @closurePrimitive {asserts.truthy}
 */
exports.assert = function(condition, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && !condition) {
    doAssertFailure(
        '', null, opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Checks if `value` is `null` or `undefined` if goog.asserts.ENABLE_ASSERTS is
 * true.
 *
 * @param {T} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {R} `value` with its type narrowed to exclude `null` and `undefined`.
 *
 * @template T
 * @template R :=
 *     mapunion(T, (V) =>
 *         cond(eq(V, 'null'),
 *             none(),
 *             cond(eq(V, 'undefined'),
 *                 none(),
 *                 V)))
 *  =:
 *
 * @throws {!AssertionError} When `value` is `null` or `undefined`.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertExists = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && value == null) {
    doAssertFailure(
        'Expected to exist: %s.', [value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return value;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.asserts.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {void}
 * @throws {AssertionError} Failure.
 * @closurePrimitive {asserts.fail}
 */
exports.fail = function(opt_message, var_args) {
  if (exports.ENABLE_ASSERTS) {
    errorHandler_(new AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1)));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {AssertionError} When the value is not a number.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertNumber = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && typeof value !== 'number') {
    doAssertFailure(
        'Expected number but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {AssertionError} When the value is not a string.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertString = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && typeof value !== 'string') {
    doAssertFailure(
        'Expected string but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {AssertionError} When the value is not a function.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertFunction = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && typeof value !== 'function') {
    doAssertFailure(
        'Expected function but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {AssertionError} When the value is not an object.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertObject = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && !goog.isObject(value)) {
    doAssertFailure(
        'Expected object but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array<?>} The value, guaranteed to be a non-null array.
 * @throws {AssertionError} When the value is not an array.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertArray = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && !Array.isArray(value)) {
    doAssertFailure(
        'Expected array but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array<?>} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {AssertionError} When the value is not a boolean.
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertBoolean = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && typeof value !== 'boolean') {
    doAssertFailure(
        'Expected boolean but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {AssertionError} When the value is not an Element.
 * @closurePrimitive {asserts.matchesReturn}
 * @deprecated Use goog.asserts.dom.assertIsElement instead.
 */
exports.assertElement = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS &&
      (!goog.isObject(value) ||
       /** @type {!Node} */ (value).nodeType != NodeType.ELEMENT)) {
    doAssertFailure(
        'Expected Element but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * Do not use this to ensure a value is an HTMLElement or a subclass! Cross-
 * document DOM inherits from separate - though identical - browser classes, and
 * such a check will unexpectedly fail. Please use the methods in
 * goog.asserts.dom for these purposes.
 *
 * @param {?} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {AssertionError} When the value is not an instance of
 *     type.
 * @return {T}
 * @template T
 * @closurePrimitive {asserts.matchesReturn}
 */
exports.assertInstanceof = function(value, type, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS && !(value instanceof type)) {
    doAssertFailure(
        'Expected instanceof %s but got %s.', [getType(type), getType(value)],
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks whether the value is a finite number, if ENABLE_ASSERTS
 * is true.
 *
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {AssertionError} When the value is not a number, or is
 *     a non-finite number such as NaN, Infinity or -Infinity.
 * @return {number} The value initially passed in.
 */
exports.assertFinite = function(value, opt_message, var_args) {
  if (exports.ENABLE_ASSERTS &&
      (typeof value != 'number' || !isFinite(value))) {
    doAssertFailure(
        'Expected %s to be a finite number but it is not.', [value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};

/**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 */
function getType(value) {
  if (value instanceof Function) {
    return value.displayName || value.name || 'unknown type name';
  } else if (value instanceof Object) {
    return /** @type {string} */ (value.constructor.displayName) ||
        value.constructor.name || Object.prototype.toString.call(value);
  } else {
    return value === null ? 'null' : typeof value;
  }
}

;return exports;});

//third_party/javascript/closure/html/trustedtypes.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Policy to convert strings to Trusted Types. See
 * https://github.com/WICG/trusted-types for details.
 */

goog.provide('goog.html.trustedtypes');


/**
 * @define {string} Name for the Trusted Types policy used in Closure Safe
 * Types. Differs from `goog.TRUSTED_TYPES_POLICY_NAME` in that the latter is
 * also used for other purposes like the debug loader. If empty, Closure Safe
 * Types will not use Trusted Types. Default is `goog.TRUSTED_TYPES_POLICY_NAME`
 * plus the suffix `#html`, unless `goog.TRUSTED_TYPES_POLICY_NAME` is empty.
 * @package
 */
goog.html.trustedtypes.POLICY_NAME = goog.define(
    'goog.html.trustedtypes.POLICY_NAME',
    goog.TRUSTED_TYPES_POLICY_NAME ? goog.TRUSTED_TYPES_POLICY_NAME + '#html' :
                                     '');


/**
 * Cached result of goog.createTrustedTypesPolicy.
 * @type {?TrustedTypePolicy|undefined}
 * @private
 */
goog.html.trustedtypes.cachedPolicy_;


/**
 * Creates a (singleton) Trusted Type Policy for Safe HTML Types.
 * @return {?TrustedTypePolicy}
 */
goog.html.trustedtypes.getPolicyPrivateDoNotAccessOrElse = function() {
  'use strict';
  if (!goog.html.trustedtypes.POLICY_NAME) {
    // Binary not configured for Trusted Types.
    return null;
  }

  if (goog.html.trustedtypes.cachedPolicy_ === undefined) {
    goog.html.trustedtypes.cachedPolicy_ =
        goog.createTrustedTypesPolicy(goog.html.trustedtypes.POLICY_NAME);
  }

  return goog.html.trustedtypes.cachedPolicy_;
};

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

//third_party/javascript/closure/string/const.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.string.Const');

goog.require('goog.asserts');



/**
 * Wrapper for compile-time-constant strings.
 *
 * Const is a wrapper for strings that can only be created from program
 * constants (i.e., string literals).  This property relies on a custom Closure
 * compiler check that `goog.string.Const.from` is only invoked on
 * compile-time-constant expressions.
 *
 * Const is useful in APIs whose correct and secure use requires that certain
 * arguments are not attacker controlled: Compile-time constants are inherently
 * under the control of the application and not under control of external
 * attackers, and hence are safe to use in such contexts.
 *
 * Instances of this type must be created via its factory method
 * `goog.string.Const.from` and not by invoking its constructor.  The
 * constructor intentionally takes no parameters and the type is immutable;
 * hence only a default instance corresponding to the empty string can be
 * obtained via constructor invocation.  Use goog.string.Const.EMPTY
 * instead of using this constructor to get an empty Const string.
 *
 * @see goog.string.Const#from
 * @constructor
 * @final
 * @struct
 * @param {Object=} opt_token package-internal implementation detail.
 * @param {string=} opt_content package-internal implementation detail.
 *
 * @deprecated Enforcing literalness of values created with this class is
 *     expensive for the compiler to do & this feature will get removed soon.
 *     If you're using APIs from closure, please migrate to safevalues instead
 *     (see go/lsc-closure-safevalues).
 *     If you're using `Const` in your own APIs and want to keep ensuring that
 *     values passed to it are literal, you can use tagged template literals &
 *     a custom type to achieve the same result, otherwise please migrate your
 *     code to use plain strings directly.
 */
goog.string.Const = function(opt_token, opt_content) {
  'use strict';
  /**
   * The wrapped value of this Const object.  The field has a purposely ugly
   * name to make (non-compiled) code that attempts to directly access this
   * field stand out.
   * @private {string}
   */
  this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ =
      ((opt_token ===
        goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_) &&
       opt_content) ||
      '';

  /**
   * A type marker used to implement additional run-time type checking.
   * @see goog.string.Const#unwrap
   * @const {!Object}
   * @private
   */
  this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ =
      goog.string.Const.TYPE_MARKER_;
};


/**
 * Returns this Const's value as a string.
 *
 * IMPORTANT: In code where it is security-relevant that an object's type is
 * indeed `goog.string.Const`, use `goog.string.Const.unwrap`
 * instead of this method.
 *
 * @see goog.string.Const#unwrap
 * @override
 * @return {string}
 */
goog.string.Const.prototype.toString = function() {
  'use strict';
  return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
};


/**
 * Performs a runtime check that the provided object is indeed an instance
 * of `goog.string.Const`, and returns its value.
 * @param {!goog.string.Const} stringConst The object to extract from.
 * @return {string} The Const object's contained string, unless the run-time
 *     type check fails. In that case, `unwrap` returns an innocuous
 *     string, or, if assertions are enabled, throws
 *     `goog.asserts.AssertionError`.
 *
 * @deprecated Enforcing literalness of values created with this class is
 *     expensive for the compiler to do & this feature will get removed soon.
 *     If you're using APIs from closure, please migrate to safevalues instead
 *     (see go/lsc-closure-safevalues).
 *     If you're using `Const` in your own APIs and want to keep ensuring that
 *     values passed to it are literal, you can use tagged template literals &
 *     a custom type to achieve the same result, otherwise please migrate your
 *     code to use plain strings directly.
 */
goog.string.Const.unwrap = function(stringConst) {
  'use strict';
  // Perform additional run-time type-checking to ensure that stringConst is
  // indeed an instance of the expected type.  This provides some additional
  // protection against security bugs due to application code that disables type
  // checks.
  if (stringConst instanceof goog.string.Const &&
      stringConst.constructor === goog.string.Const &&
      stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ ===
          goog.string.Const.TYPE_MARKER_) {
    return stringConst
        .stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  } else {
    goog.asserts.fail(
        'expected object of type Const, got \'' + stringConst + '\'');
    return 'type_error:Const';
  }
};


/**
 * Creates a Const object from a compile-time constant string.
 *
 * It is illegal to invoke this function on an expression whose
 * compile-time-constant value cannot be determined by the Closure compiler.
 *
 * Correct invocations include,
 * <pre>
 *   var s = goog.string.Const.from('hello');
 *   var t = goog.string.Const.from('hello' + 'world');
 * </pre>
 *
 * In contrast, the following are illegal:
 * <pre>
 *   var s = goog.string.Const.from(getHello());
 *   var t = goog.string.Const.from('hello' + world);
 * </pre>
 *
 * @param {string} s A constant string from which to create a Const.
 * @return {!goog.string.Const} A Const object initialized to stringConst.
 *
 * @deprecated Enforcing literalness of values created with this class is
 *     expensive for the compiler to do & this feature will get removed soon.
 *     If you're using APIs from closure, please migrate to safevalues instead
 *     (see go/lsc-closure-safevalues).
 *     If you're using `Const` in your own APIs and want to keep ensuring that
 *     values passed to it are literal, you can use tagged template literals &
 *     a custom type to achieve the same result, otherwise please migrate your
 *     code to use plain strings directly.
 */
goog.string.Const.from = function(s) {
  'use strict';
  return new goog.string.Const(
      goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, s);
};

/**
 * Type marker for the Const type, used to implement additional run-time
 * type checking.
 * @const {!Object}
 * @private
 */
goog.string.Const.TYPE_MARKER_ = {};

/**
 * @type {!Object}
 * @private
 * @const
 */
goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {};

/**
 * A Const instance wrapping the empty string.
 * @const {!goog.string.Const}
 */
goog.string.Const.EMPTY = goog.string.Const.from('');

//third_party/javascript/closure/html/trustedresourceurl.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The TrustedResourceUrl type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.provide('goog.html.TrustedResourceUrl');

goog.require('goog.asserts');
goog.require('goog.html.trustedtypes');
goog.require('goog.string.Const');



/**
 * A URL which is under application control and from which script, CSS, and
 * other resources that represent executable code, can be fetched.
 *
 * Given that the URL can only be constructed from strings under application
 * control and is used to load resources, bugs resulting in a malformed URL
 * should not have a security impact and are likely to be easily detectable
 * during testing. Given the wide number of non-RFC compliant URLs in use,
 * stricter validation could prevent some applications from being able to use
 * this type.
 *
 * Instances of this type must be created via the factory method,
 * (`fromConstant`, `fromConstants`, `format` or `formatWithParams`), and not by
 * invoking its constructor. The constructor intentionally takes an extra
 * parameter that cannot be constructed outside of this file and the type is
 * immutable; hence only a default instance corresponding to the empty string
 * can be obtained via constructor invocation.
 *
 * Creating TrustedResourceUrl objects HAS SIDE-EFFECTS due to calling
 * Trusted Types Web API.
 *
 * @see goog.html.TrustedResourceUrl#fromConstant
 * @final
 * @struct
 */
goog.html.TrustedResourceUrl = class {
  /**
   * @private
   * @param {!TrustedScriptURL|string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    if (goog.DEBUG &&
        token !== goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_) {
      throw Error('TrustedResourceUrl is not meant to be built directly');
    }

    /**
     * The contained value of this TrustedResourceUrl.  The field has a
     * purposely ugly name to make (non-compiled) code that attempts to directly
     * access this field stand out.
     * @const
     * @private {!TrustedScriptURL|string}
     */
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = value;
  }

  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a TrustedResourceUrl, use
   * `goog.html.TrustedResourceUrl.unwrap`.
   *
   * @return {string}
   * @see goog.html.TrustedResourceUrl#unwrap
   * @override
   */
  toString() {
    return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + '';
  }
};


/**
 * Creates a new TrustedResourceUrl with params added to URL. Both search and
 * hash params can be specified.
 *
 * @param {string|?Object<string, *>|undefined} searchParams Search parameters
 *     to add to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for
 *     exact format definition.
 * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @return {!goog.html.TrustedResourceUrl} New TrustedResourceUrl with params.
 * @deprecated Use `safevalues.appendParams` and `safevalues.replaceFragment`
 *     instead.
 */
goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(
    searchParams, opt_hashParams) {
  'use strict';
  var url = goog.html.TrustedResourceUrl.unwrap(this);
  var parts = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(url);
  var urlBase = parts[1];
  var urlSearch = parts[2] || '';
  var urlHash = parts[3] || '';

  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(
          urlBase +
          goog.html.TrustedResourceUrl.stringifyParams_(
              '?', urlSearch, searchParams) +
          goog.html.TrustedResourceUrl.stringifyParams_(
              '#', urlHash, opt_hashParams));
};

/**
 * Performs a runtime check that the provided object is indeed a
 * TrustedResourceUrl object, and returns its value.
 *
 * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl The object to
 *     extract from.
 * @return {string} The trustedResourceUrl object's contained string, unless
 *     the run-time type check fails. In that case, `unwrap` returns an
 *     innocuous string, or, if assertions are enabled, throws
 *     `goog.asserts.AssertionError`.
 * @deprecated Use `safevalues.unwrapResourceUrl` and `toString()` instead
 */
goog.html.TrustedResourceUrl.unwrap = function(trustedResourceUrl) {
  'use strict';
  return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(trustedResourceUrl)
      .toString();
};


/**
 * Unwraps value as TrustedScriptURL if supported or as a string if not.
 * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl
 * @return {!TrustedScriptURL|string}
 * @see goog.html.TrustedResourceUrl.unwrap
 * @deprecated Use `safevalues.unwrapResourceUrl` instead.
 */
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(
    trustedResourceUrl) {
  'use strict';
  // Perform additional Run-time type-checking to ensure that
  // trustedResourceUrl is indeed an instance of the expected type.  This
  // provides some additional protection against security bugs due to
  // application code that disables type checks.
  // Specifically, the following checks are performed:
  // 1. The object is an instance of the expected type.
  // 2. The object is not an instance of a subclass.
  if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl &&
      trustedResourceUrl.constructor === goog.html.TrustedResourceUrl) {
    return trustedResourceUrl
        .privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
  } else {
    goog.asserts.fail(
        'expected object of type TrustedResourceUrl, got \'%s\' of type %s',
        trustedResourceUrl, goog.typeOf(trustedResourceUrl));
    return 'type_error:TrustedResourceUrl';
  }
};


/**
 * Creates a TrustedResourceUrl from a format string and arguments.
 *
 * The arguments for interpolation into the format string map labels to values.
 * Values of type `goog.string.Const` are interpolated without modifcation.
 * Values of other types are cast to string and encoded with
 * encodeURIComponent.
 *
 * `%{<label>}` markers are used in the format string to indicate locations
 * to be interpolated with the valued mapped to the given label. `<label>`
 * must contain only alphanumeric and `_` characters.
 *
 * The format string must match goog.html.TrustedResourceUrl.BASE_URL_.
 *
 * Example usage:
 *
 *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
 *        'https://www.google.com/search?q=%{query}'), {'query': searchTerm});
 *
 *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
 *        '//www.youtube.com/v/%{videoId}?hl=en&fs=1%{autoplay}'), {
 *        'videoId': videoId,
 *        'autoplay': opt_autoplay ?
 *            goog.string.Const.from('&autoplay=1') : goog.string.Const.EMPTY
 *    });
 *
 * While this function can be used to create a TrustedResourceUrl from only
 * constants, fromConstant() and fromConstants() are generally preferable for
 * that purpose.
 *
 * @param {!goog.string.Const} format The format string.
 * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
 *     of labels to values to be interpolated into the format string.
 *     goog.string.Const values are interpolated without encoding.
 * @return {!goog.html.TrustedResourceUrl}
 * @throws {!Error} On an invalid format string or if a label used in the
 *     the format string is not present in args.
 * @deprecated Use the `safevalues.trustedResourceUrl` template string literal
 *     builder instead.
 */
goog.html.TrustedResourceUrl.format = function(format, args) {
  'use strict';
  var formatStr = goog.string.Const.unwrap(format);
  if (!goog.html.TrustedResourceUrl.BASE_URL_.test(formatStr)) {
    throw new Error('Invalid TrustedResourceUrl format: ' + formatStr);
  }
  var result = formatStr.replace(
      goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(match, id) {
        'use strict';
        if (!Object.prototype.hasOwnProperty.call(args, id)) {
          throw new Error(
              'Found marker, "' + id + '", in format string, "' + formatStr +
              '", but no valid label mapping found ' +
              'in args: ' + JSON.stringify(args));
        }
        var arg = args[id];
        if (arg instanceof goog.string.Const) {
          return goog.string.Const.unwrap(arg);
        } else {
          return encodeURIComponent(String(arg));
        }
      });
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(result);
};


/**
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g;


/**
 * The URL must be absolute, scheme-relative or path-absolute. So it must
 * start with:
 * - https:// followed by allowed origin characters.
 * - // followed by allowed origin characters.
 * - Any absolute or relative path.
 *
 * Based on
 * https://url.spec.whatwg.org/commit-snapshots/56b74ce7cca8883eab62e9a12666e2fac665d03d/#url-parsing
 * an initial / which is not followed by another / or \ will end up in the "path
 * state" and from there it can only go to "fragment state" and "query state".
 *
 * We don't enforce a well-formed domain name. So '.' or '1.2' are valid.
 * That's ok because the origin comes from a compile-time constant.
 *
 * A regular expression is used instead of goog.uri for several reasons:
 * - Strictness. E.g. we don't want any userinfo component and we don't
 *   want '/./, nor \' in the first path component.
 * - Small trusted base. goog.uri is generic and might need to change,
 *   reasoning about all the ways it can parse a URL now and in the future
 *   is error-prone.
 * - Code size. We expect many calls to .format(), many of which might
 *   not be using goog.uri.
 * - Simplicity. Using goog.uri would likely not result in simpler nor shorter
 *   code.
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.BASE_URL_ = new RegExp(
    '^((https:)?//[0-9a-z.:[\\]-]+/'  // Origin.
        + '|/[^/\\\\]'                // Absolute path.
        + '|[^:/\\\\%]+/'             // Relative path.
        + '|[^:/\\\\%]*[?#]'          // Query string or fragment.
        + '|about:blank#'             // about:blank with fragment.
        + ')',
    'i');

/**
 * RegExp for splitting a URL into the base, search field, and hash field.
 *
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ =
    /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;


/**
 * Formats the URL same as TrustedResourceUrl.format and then adds extra URL
 * parameters.
 *
 * Example usage:
 *
 *     // Creates '//www.youtube.com/v/abc?autoplay=1' for videoId='abc' and
 *     // opt_autoplay=1. Creates '//www.youtube.com/v/abc' for videoId='abc'
 *     // and opt_autoplay=undefined.
 *     var url = goog.html.TrustedResourceUrl.formatWithParams(
 *         goog.string.Const.from('//www.youtube.com/v/%{videoId}'),
 *         {'videoId': videoId},
 *         {'autoplay': opt_autoplay});
 *
 * @param {!goog.string.Const} format The format string.
 * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
 *     of labels to values to be interpolated into the format string.
 *     goog.string.Const values are interpolated without encoding.
 * @param {string|?Object<string, *>|undefined} searchParams Parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @return {!goog.html.TrustedResourceUrl}
 * @throws {!Error} On an invalid format string or if a label used in the
 *     the format string is not present in args.
 * @deprecated Use `safevalues.trustedResourceUrl` and `safevalues.appendParams`
 *     instead.
 */
goog.html.TrustedResourceUrl.formatWithParams = function(
    format, args, searchParams, opt_hashParams) {
  'use strict';
  var url = goog.html.TrustedResourceUrl.format(format, args);
  return url.cloneWithParams(searchParams, opt_hashParams);
};


/**
 * Creates a TrustedResourceUrl object from a compile-time constant string.
 *
 * Compile-time constant strings are inherently program-controlled and hence
 * trusted.
 *
 * @param {!goog.string.Const} url A compile-time-constant string from which to
 *     create a TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
 *     initialized to `url`.
 * @deprecated Use `safevalues.trustedResourceUrl` instead.
 */
goog.html.TrustedResourceUrl.fromConstant = function(url) {
  'use strict';
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(
          goog.string.Const.unwrap(url));
};


/**
 * Creates a TrustedResourceUrl object from a compile-time constant strings.
 *
 * Compile-time constant strings are inherently program-controlled and hence
 * trusted.
 *
 * @param {!Array<!goog.string.Const>} parts Compile-time-constant strings from
 *     which to create a TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
 *     initialized to concatenation of `parts`.
 * @deprecated Use `safevalues.trustedResourceUrl` instead.
 */
goog.html.TrustedResourceUrl.fromConstants = function(parts) {
  'use strict';
  var unwrapped = '';
  for (var i = 0; i < parts.length; i++) {
    unwrapped += goog.string.Const.unwrap(parts[i]);
  }
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(unwrapped);
};


/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @private {!Object}
 * @const
 */
goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {};


/**
 * Package-internal utility method to create TrustedResourceUrl instances.
 *
 * @param {string} url The string to initialize the TrustedResourceUrl object
 *     with.
 * @return {!goog.html.TrustedResourceUrl} The initialized TrustedResourceUrl
 *     object.
 * @package
 */
goog.html.TrustedResourceUrl
    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(url) {
  'use strict';
  /** @noinline */
  const noinlineUrl = url;
  const policy = goog.html.trustedtypes.getPolicyPrivateDoNotAccessOrElse();
  const value = policy ? policy.createScriptURL(noinlineUrl) : noinlineUrl;
  return new goog.html.TrustedResourceUrl(
      value, goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_);
};


/**
 * Stringifies the passed params to be used as either a search or hash field of
 * a URL.
 *
 * @param {string} prefix The prefix character for the given field ('?' or '#').
 * @param {string} currentString The existing field value (including the prefix
 *     character, if the field is present).
 * @param {string|?Object<string, *>|undefined} params The params to set or
 *     append to the field.
 * - If `undefined` or `null`, the field remains unchanged.
 * - If a string, then the string will be escaped and the field will be
 *   overwritten with that value.
 * - If an Object, that object is treated as a set of key-value pairs to be
 *   appended to the current field. Note that JavaScript doesn't guarantee the
 *   order of values in an object which might result in non-deterministic order
 *   of the parameters. However, browsers currently preserve the order. The
 *   rules for each entry:
 *   - If an array, it will be processed as if each entry were an additional
 *     parameter with exactly the same key, following the same logic below.
 *   - If `undefined` or `null`, it will be skipped.
 *   - Otherwise, it will be turned into a string, escaped, and appended.
 * @return {string}
 * @private
 */
goog.html.TrustedResourceUrl.stringifyParams_ = function(
    prefix, currentString, params) {
  'use strict';
  if (params == null) {
    // Do not modify the field.
    return currentString;
  }
  if (typeof params === 'string') {
    // Set field to the passed string.
    return params ? prefix + encodeURIComponent(params) : '';
  }
  // Add on parameters to field from key-value object.
  for (var key in params) {
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      var value = params[key];
      var outputValues = Array.isArray(value) ? value : [value];
      for (var i = 0; i < outputValues.length; i++) {
        var outputValue = outputValues[i];
        if (outputValue != null) {
          if (!currentString) {
            currentString = prefix;
          }
          currentString += (currentString.length > prefix.length ? '&' : '') +
              encodeURIComponent(key) + '=' +
              encodeURIComponent(String(outputValue));
        }
      }
    }
  }
  return currentString;
};

//third_party/javascript/closure/html/trustedresourceurl_internals_for_safevalues.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview File that re-exports the internals of
 * goog.html.TrustedResourceUrl type so that they can be used in safevalues for
 * compatibility purposes.
 * DO NOT OPENSOURCE
 */

goog.module('goog.html.trustedresourceurl_internals_for_safevalues');

const TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');

exports.createTrustedResourceUrl =
    TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse;

;return exports;});

//third_party/javascript/safevalues/internals/resource_url_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Internal implementations of TrustedResourceUrl.
 * DO NOT OPENSOURCE
 * Generated from: third_party/javascript/safevalues/internals/resource_url_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.resource_url_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/resource_url_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_trustedresourceurl_1 = goog.requireType("goog.html.TrustedResourceUrl");
const tsickle_trustedresourceurl_internals_for_safevalues_2 = goog.requireType("goog.html.trustedresourceurl_internals_for_safevalues");
const trustedresourceurl_1 = goog.require('goog.html.TrustedResourceUrl');
const trustedresourceurl_internals_for_safevalues_1 = goog.require('goog.html.trustedresourceurl_internals_for_safevalues');
// tslint:disable:enforce-name-casing
/**
 * Export the object separately to break the use of legacy static functions on
 * the re-export, but preserve instanceof checks.
 *
 * Please have a look at go/safehtml?polygot=ts to see what functions are
 * available in safevalues.
 * @type {function(new:tsickle_trustedresourceurl_1, ?)}
 */
exports.TrustedResourceUrl = (/** @type {function(new:tsickle_trustedresourceurl_1, ?)} */ ((/** @type {*} */ (trustedresourceurl_1))));
/**
 * Builds a new `TrustedResourceUrl` from the given string, without
 * enforcing safety guarantees. It may cause side effects by creating a Trusted
 * Types policy. This shouldn't be exposed to application developers, and must
 * only be used as a step towards safe builders or safe constants.
 * @param {string} url
 * @return {!tsickle_trustedresourceurl_1}
 */
function createResourceUrlInternal(url) {
    return (0, trustedresourceurl_internals_for_safevalues_1.createTrustedResourceUrl)(url);
}
exports.createResourceUrlInternal = createResourceUrlInternal;
/**
 * Checks if the given value is a `TrustedResourceUrl` instance.
 * @param {*} value
 * @return {boolean}
 */
function isResourceUrl(value) {
    return value instanceof trustedresourceurl_1;
}
exports.isResourceUrl = isResourceUrl;
/**
 * Returns the value of the passed `TrustedResourceUrl` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedScriptURL` or a string if Trusted Types are
 * disabled.
 * @param {!tsickle_trustedresourceurl_1} value
 * @return {(string|!TrustedScriptURL)}
 */
function unwrapResourceUrl(value) {
    return trustedresourceurl_1.unwrapTrustedScriptURL(value);
}
exports.unwrapResourceUrl = unwrapResourceUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2VfdXJsX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUEsMEVBQStIO0FBQy9ILDRIQUFpSTs7Ozs7Ozs7OztBQWFwSCxRQUFBLGtCQUFrQixHQUFHLCtEQUFBLHlDQUFvQyxFQUVyRTs7Ozs7Ozs7O0FBUUQsU0FBZ0IseUJBQXlCLENBQUMsR0FBVztJQUNuRCxPQUFPLElBQUEsc0VBQXdCLEVBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUZELDhEQUVDOzs7Ozs7QUFLRCxTQUFnQixhQUFhLENBQUMsS0FBYztJQUMxQyxPQUFPLEtBQUssZ0NBQXFDLENBQUM7QUFDcEQsQ0FBQztBQUZELHNDQUVDOzs7Ozs7Ozs7O0FBU0QsU0FBZ0IsaUJBQWlCLENBQy9CLEtBQXlCO0lBRXpCLE9BQU8scUJBQTBCLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFKRCw4Q0FJQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEludGVybmFsIGltcGxlbWVudGF0aW9ucyBvZiBUcnVzdGVkUmVzb3VyY2VVcmwuXG4gKiBETyBOT1QgT1BFTlNPVVJDRVxuICovXG5cbmltcG9ydCB7VHJ1c3RlZFJlc291cmNlVXJsIGFzIENsb3N1cmVUcnVzdGVkUmVzb3VyY2VVcmx9IGZyb20gJ2dvb2dsZTMvdGhpcmRfcGFydHkvamF2YXNjcmlwdC9jbG9zdXJlL2h0bWwvdHJ1c3RlZHJlc291cmNldXJsJztcbmltcG9ydCB7Y3JlYXRlVHJ1c3RlZFJlc291cmNlVXJsfSBmcm9tICdnb29nbGUzL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvY2xvc3VyZS9odG1sL3RydXN0ZWRyZXNvdXJjZXVybF9pbnRlcm5hbHNfZm9yX3NhZmV2YWx1ZXMnO1xuXG4vKiogUmUtZXhwb3J0cyB0aGUgQ2xvc3VyZSB0eXBlIHRvIGVuc3VyZSBib3RoIGNvZGViYXNlcyBhcmUgY29tcGF0aWJsZS4gKi9cbmV4cG9ydCB0eXBlIFRydXN0ZWRSZXNvdXJjZVVybCA9IENsb3N1cmVUcnVzdGVkUmVzb3VyY2VVcmw7XG5cbi8vIHRzbGludDpkaXNhYmxlOmVuZm9yY2UtbmFtZS1jYXNpbmdcbi8qKlxuICogRXhwb3J0IHRoZSBvYmplY3Qgc2VwYXJhdGVseSB0byBicmVhayB0aGUgdXNlIG9mIGxlZ2FjeSBzdGF0aWMgZnVuY3Rpb25zIG9uXG4gKiB0aGUgcmUtZXhwb3J0LCBidXQgcHJlc2VydmUgaW5zdGFuY2VvZiBjaGVja3MuXG4gKlxuICogUGxlYXNlIGhhdmUgYSBsb29rIGF0IGdvL3NhZmVodG1sP3BvbHlnb3Q9dHMgdG8gc2VlIHdoYXQgZnVuY3Rpb25zIGFyZVxuICogYXZhaWxhYmxlIGluIHNhZmV2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBUcnVzdGVkUmVzb3VyY2VVcmwgPSBDbG9zdXJlVHJ1c3RlZFJlc291cmNlVXJsIGFzIHVua25vd24gYXMge1xuICBuZXcgKF86IG5ldmVyKTogVHJ1c3RlZFJlc291cmNlVXJsO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBuZXcgYFRydXN0ZWRSZXNvdXJjZVVybGAgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCB3aXRob3V0XG4gKiBlbmZvcmNpbmcgc2FmZXR5IGd1YXJhbnRlZXMuIEl0IG1heSBjYXVzZSBzaWRlIGVmZmVjdHMgYnkgY3JlYXRpbmcgYSBUcnVzdGVkXG4gKiBUeXBlcyBwb2xpY3kuIFRoaXMgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8gYXBwbGljYXRpb24gZGV2ZWxvcGVycywgYW5kIG11c3RcbiAqIG9ubHkgYmUgdXNlZCBhcyBhIHN0ZXAgdG93YXJkcyBzYWZlIGJ1aWxkZXJzIG9yIHNhZmUgY29uc3RhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2VVcmxJbnRlcm5hbCh1cmw6IHN0cmluZyk6IFRydXN0ZWRSZXNvdXJjZVVybCB7XG4gIHJldHVybiBjcmVhdGVUcnVzdGVkUmVzb3VyY2VVcmwodXJsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYFRydXN0ZWRSZXNvdXJjZVVybGAgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc291cmNlVXJsKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVHJ1c3RlZFJlc291cmNlVXJsIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xvc3VyZVRydXN0ZWRSZXNvdXJjZVVybDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcGFzc2VkIGBUcnVzdGVkUmVzb3VyY2VVcmxgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKlxuICogUmV0dXJucyBhIG5hdGl2ZSBgVHJ1c3RlZFNjcmlwdFVSTGAgb3IgYSBzdHJpbmcgaWYgVHJ1c3RlZCBUeXBlcyBhcmVcbiAqIGRpc2FibGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwUmVzb3VyY2VVcmwoXG4gIHZhbHVlOiBUcnVzdGVkUmVzb3VyY2VVcmwsXG4pOiBUcnVzdGVkU2NyaXB0VVJMIHwgc3RyaW5nIHtcbiAgcmV0dXJuIENsb3N1cmVUcnVzdGVkUmVzb3VyY2VVcmwudW53cmFwVHJ1c3RlZFNjcmlwdFVSTCh2YWx1ZSk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/internals/string_literal.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/internals/string_literal.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.string_literal');
var module = module || { id: 'third_party/javascript/safevalues/internals/string_literal.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * An object of type TemplateStringsArray represents the literal part(s) of a
 * template literal. This function checks if a TemplateStringsArray object is
 * actually from a template literal.
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @param {number} numExprs The number of embedded expressions
 * @return {void}
 */
function assertIsTemplateObject(templateObj, numExprs) {
    if (!isTemplateObject(templateObj) || numExprs + 1 !== templateObj.length) {
        throw new TypeError(`
    ############################## ERROR ##############################

    It looks like you are trying to call a template tag function (fn\`...\`)
    using the normal function syntax (fn(...)), which is not supported.

    The functions in the safevalues library are not designed to be called
    like normal functions, and doing so invalidates the security guarantees
    that safevalues provides.

    If you are stuck and not sure how to proceed, please reach out to us
    instead through:
     - go/ise-hardening-yaqs (preferred) // LINE-INTERNAL
     - g/ise-hardening // LINE-INTERNAL
     - https://github.com/google/safevalues/issues

    ############################## ERROR ##############################`);
    }
}
exports.assertIsTemplateObject = assertIsTemplateObject;
/**
 * Checks if `templateObj` and its raw property are frozen.
 * @param {!TemplateStringsArray} templateObj
 * @return {boolean}
 */
function checkFrozen(templateObj) {
    return Object.isFrozen(templateObj) && Object.isFrozen(templateObj.raw);
}
/** @typedef {function(!TemplateStringsArray): !TemplateStringsArray} */
var TagFn;
/**
 * Checks if a function containing a tagged template expression is transpiled.
 * @param {function(function(!TemplateStringsArray): !TemplateStringsArray): !TemplateStringsArray} fn
 * @return {boolean}
 */
function checkTranspiled(fn) {
    return fn.toString().indexOf('`') === -1;
}
/**
 * This value tells us if the code is transpiled, in which case we don't
 * check certain things that transpilers typically don't support. The
 * transpilation turns it into a function call that takes an array.
 * @type {boolean}
 */
const isTranspiled = checkTranspiled((/**
 * @param {function(!TemplateStringsArray): !TemplateStringsArray} tag
 * @return {!TemplateStringsArray}
 */
(tag) => tag ``)) ||
    checkTranspiled((/**
     * @param {function(!TemplateStringsArray): !TemplateStringsArray} tag
     * @return {!TemplateStringsArray}
     */
    (tag) => tag `\0`)) ||
    checkTranspiled((/**
     * @param {function(!TemplateStringsArray): !TemplateStringsArray} tag
     * @return {!TemplateStringsArray}
     */
    (tag) => tag `\n`)) ||
    checkTranspiled((/**
     * @param {function(!TemplateStringsArray): !TemplateStringsArray} tag
     * @return {!TemplateStringsArray}
     */
    (tag) => tag `\u0000`));
/**
 * This value tells us if `TemplateStringsArray` are typically frozen in the
 * current environment.
 * @type {boolean}
 */
const frozenTSA = checkFrozen `` && checkFrozen `\0` && checkFrozen `\n` && checkFrozen `\u0000`;
/**
 * Polyfill of https://github.com/tc39/proposal-array-is-template-object
 * @param {!TemplateStringsArray} templateObj
 * @return {boolean}
 */
function isTemplateObject(templateObj) {
    /*
     * ############################## WARNING ##############################
     *
     * If you are reading this code to understand how to create a value
     * that satisfies this check, STOP and read this paragraph.
     *
     * This function is there to ensure that our tagged template functions are
     * always called using the tag syntax fn`...`, rather than the normal
     * function syntax fn(...). Bypassing this check invalidates the guarantees
     * that safevalues provides and will result in security issues in your code.
     *
     * If you are stuck and not sure how to proceed, please reach out to us
     * instead through:
     *  - go/ise-hardening-yaqs (preferred) // LINE-INTERNAL
     *  - g/ise-hardening // LINE-INTERNAL
     *  - https://github.com/google/safevalues/issues
     *
     * ############################## WARNING ##############################
     */
    if (!Array.isArray(templateObj) || !Array.isArray(templateObj.raw)) {
        return false;
    }
    if (templateObj.length !== (/** @type {!Array<?>} */ (templateObj.raw)).length) {
        return false;
    }
    if (!isTranspiled && templateObj === templateObj.raw) {
        // Sometimes transpilers use the same array to save on codesize if the
        // template has no special characters that would cause the values in each
        // array to be different.
        return false;
    }
    if ((!isTranspiled || frozenTSA) && !checkFrozen(templateObj)) {
        // Transpilers typically don't freeze `TemplateStringsArray` objects, but we
        // expect that if they did, they would do it consistently, so we also
        // dynamically check if they do.
        return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nX2xpdGVyYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW50ZXJuYWxzL3N0cmluZ19saXRlcmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBZ0Isc0JBQXNCLENBQ3BDLFdBQWlDLEVBQ2pDLFFBQWdCO0lBRWhCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxLQUFLLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUMxRSxNQUFNLElBQUksU0FBUyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O3dFQWdCZ0QsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7QUFDSCxDQUFDO0FBdkJELHdEQXVCQzs7Ozs7O0FBR0QsU0FBUyxXQUFXLENBQUMsV0FBaUM7SUFDcEQsT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFFLENBQUM7O0FBRUQsVUFBcUU7Ozs7OztBQUtyRSxTQUFTLGVBQWUsQ0FBQyxFQUF3QztJQUMvRCxPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQzs7Ozs7OztNQU9LLFlBQVksR0FDaEIsZUFBZTs7OztBQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUEsRUFBRSxFQUFDO0lBQy9CLGVBQWU7Ozs7SUFBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFBLElBQUksRUFBQztJQUNqQyxlQUFlOzs7O0lBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQSxJQUFJLEVBQUM7SUFDakMsZUFBZTs7OztJQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUEsUUFBUSxFQUFDOzs7Ozs7TUFNakMsU0FBUyxHQUNiLFdBQVcsQ0FBQSxFQUFFLElBQUksV0FBVyxDQUFBLElBQUksSUFBSSxXQUFXLENBQUEsSUFBSSxJQUFJLFdBQVcsQ0FBQSxRQUFROzs7Ozs7QUFHNUUsU0FBUyxnQkFBZ0IsQ0FBQyxXQUFpQztJQUN6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ25FLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSywyQkFBQSxXQUFXLENBQUMsR0FBRyxFQUFBLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDbEQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsSUFBSSxDQUFDLFlBQVksSUFBSSxXQUFXLEtBQUssV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3JELHNFQUFzRTtRQUN0RSx5RUFBeUU7UUFDekUseUJBQXlCO1FBQ3pCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLFlBQVksSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDO1FBQzlELDRFQUE0RTtRQUM1RSxxRUFBcUU7UUFDckUsZ0NBQWdDO1FBQ2hDLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgdHlwZSBUZW1wbGF0ZVN0cmluZ3NBcnJheSByZXByZXNlbnRzIHRoZSBsaXRlcmFsIHBhcnQocykgb2YgYVxuICogdGVtcGxhdGUgbGl0ZXJhbC4gVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgYSBUZW1wbGF0ZVN0cmluZ3NBcnJheSBvYmplY3QgaXNcbiAqIGFjdHVhbGx5IGZyb20gYSB0ZW1wbGF0ZSBsaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB0ZW1wbGF0ZU9iaiBUaGlzIGNvbnRhaW5zIHRoZSBsaXRlcmFsIHBhcnQgb2YgdGhlIHRlbXBsYXRlIGxpdGVyYWwuXG4gKiBAcGFyYW0gbnVtRXhwcnMgVGhlIG51bWJlciBvZiBlbWJlZGRlZCBleHByZXNzaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNUZW1wbGF0ZU9iamVjdChcbiAgdGVtcGxhdGVPYmo6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICBudW1FeHByczogbnVtYmVyLFxuKTogdm9pZCB7XG4gIGlmICghaXNUZW1wbGF0ZU9iamVjdCh0ZW1wbGF0ZU9iaikgfHwgbnVtRXhwcnMgKyAxICE9PSB0ZW1wbGF0ZU9iai5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgRVJST1IgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICBJdCBsb29rcyBsaWtlIHlvdSBhcmUgdHJ5aW5nIHRvIGNhbGwgYSB0ZW1wbGF0ZSB0YWcgZnVuY3Rpb24gKGZuXFxgLi4uXFxgKVxuICAgIHVzaW5nIHRoZSBub3JtYWwgZnVuY3Rpb24gc3ludGF4IChmbiguLi4pKSwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC5cblxuICAgIFRoZSBmdW5jdGlvbnMgaW4gdGhlIHNhZmV2YWx1ZXMgbGlicmFyeSBhcmUgbm90IGRlc2lnbmVkIHRvIGJlIGNhbGxlZFxuICAgIGxpa2Ugbm9ybWFsIGZ1bmN0aW9ucywgYW5kIGRvaW5nIHNvIGludmFsaWRhdGVzIHRoZSBzZWN1cml0eSBndWFyYW50ZWVzXG4gICAgdGhhdCBzYWZldmFsdWVzIHByb3ZpZGVzLlxuXG4gICAgSWYgeW91IGFyZSBzdHVjayBhbmQgbm90IHN1cmUgaG93IHRvIHByb2NlZWQsIHBsZWFzZSByZWFjaCBvdXQgdG8gdXNcbiAgICBpbnN0ZWFkIHRocm91Z2g6XG4gICAgIC0gZ28vaXNlLWhhcmRlbmluZy15YXFzIChwcmVmZXJyZWQpIC8vIExJTkUtSU5URVJOQUxcbiAgICAgLSBnL2lzZS1oYXJkZW5pbmcgLy8gTElORS1JTlRFUk5BTFxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvc2FmZXZhbHVlcy9pc3N1ZXNcblxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBFUlJPUiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNgKTtcbiAgfVxufVxuXG4vKiogQ2hlY2tzIGlmIGB0ZW1wbGF0ZU9iamAgYW5kIGl0cyByYXcgcHJvcGVydHkgYXJlIGZyb3plbi4gKi9cbmZ1bmN0aW9uIGNoZWNrRnJvemVuKHRlbXBsYXRlT2JqOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKHRlbXBsYXRlT2JqKSAmJiBPYmplY3QuaXNGcm96ZW4odGVtcGxhdGVPYmoucmF3KTtcbn1cblxudHlwZSBUYWdGbiA9IChzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSkgPT4gVGVtcGxhdGVTdHJpbmdzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gY29udGFpbmluZyBhIHRhZ2dlZCB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIHRyYW5zcGlsZWQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHJhbnNwaWxlZChmbjogKHRhZzogVGFnRm4pID0+IFRlbXBsYXRlU3RyaW5nc0FycmF5KTogYm9vbGVhbiB7XG4gIHJldHVybiBmbi50b1N0cmluZygpLmluZGV4T2YoJ2AnKSA9PT0gLTE7XG59XG5cbi8qKlxuICogVGhpcyB2YWx1ZSB0ZWxscyB1cyBpZiB0aGUgY29kZSBpcyB0cmFuc3BpbGVkLCBpbiB3aGljaCBjYXNlIHdlIGRvbid0XG4gKiBjaGVjayBjZXJ0YWluIHRoaW5ncyB0aGF0IHRyYW5zcGlsZXJzIHR5cGljYWxseSBkb24ndCBzdXBwb3J0LiBUaGVcbiAqIHRyYW5zcGlsYXRpb24gdHVybnMgaXQgaW50byBhIGZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyBhbiBhcnJheS5cbiAqL1xuY29uc3QgaXNUcmFuc3BpbGVkID1cbiAgY2hlY2tUcmFuc3BpbGVkKCh0YWcpID0+IHRhZ2BgKSB8fFxuICBjaGVja1RyYW5zcGlsZWQoKHRhZykgPT4gdGFnYFxcMGApIHx8XG4gIGNoZWNrVHJhbnNwaWxlZCgodGFnKSA9PiB0YWdgXFxuYCkgfHxcbiAgY2hlY2tUcmFuc3BpbGVkKCh0YWcpID0+IHRhZ2BcXHUwMDAwYCk7XG5cbi8qKlxuICogVGhpcyB2YWx1ZSB0ZWxscyB1cyBpZiBgVGVtcGxhdGVTdHJpbmdzQXJyYXlgIGFyZSB0eXBpY2FsbHkgZnJvemVuIGluIHRoZVxuICogY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuY29uc3QgZnJvemVuVFNBID1cbiAgY2hlY2tGcm96ZW5gYCAmJiBjaGVja0Zyb3plbmBcXDBgICYmIGNoZWNrRnJvemVuYFxcbmAgJiYgY2hlY2tGcm96ZW5gXFx1MDAwMGA7XG5cbi8qKiBQb2x5ZmlsbCBvZiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1pcy10ZW1wbGF0ZS1vYmplY3QgKi9cbmZ1bmN0aW9uIGlzVGVtcGxhdGVPYmplY3QodGVtcGxhdGVPYmo6IFRlbXBsYXRlU3RyaW5nc0FycmF5KTogYm9vbGVhbiB7XG4gIC8qXG4gICAqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBXQVJOSU5HICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgKlxuICAgKiBJZiB5b3UgYXJlIHJlYWRpbmcgdGhpcyBjb2RlIHRvIHVuZGVyc3RhbmQgaG93IHRvIGNyZWF0ZSBhIHZhbHVlXG4gICAqIHRoYXQgc2F0aXNmaWVzIHRoaXMgY2hlY2ssIFNUT1AgYW5kIHJlYWQgdGhpcyBwYXJhZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlcmUgdG8gZW5zdXJlIHRoYXQgb3VyIHRhZ2dlZCB0ZW1wbGF0ZSBmdW5jdGlvbnMgYXJlXG4gICAqIGFsd2F5cyBjYWxsZWQgdXNpbmcgdGhlIHRhZyBzeW50YXggZm5gLi4uYCwgcmF0aGVyIHRoYW4gdGhlIG5vcm1hbFxuICAgKiBmdW5jdGlvbiBzeW50YXggZm4oLi4uKS4gQnlwYXNzaW5nIHRoaXMgY2hlY2sgaW52YWxpZGF0ZXMgdGhlIGd1YXJhbnRlZXNcbiAgICogdGhhdCBzYWZldmFsdWVzIHByb3ZpZGVzIGFuZCB3aWxsIHJlc3VsdCBpbiBzZWN1cml0eSBpc3N1ZXMgaW4geW91ciBjb2RlLlxuICAgKlxuICAgKiBJZiB5b3UgYXJlIHN0dWNrIGFuZCBub3Qgc3VyZSBob3cgdG8gcHJvY2VlZCwgcGxlYXNlIHJlYWNoIG91dCB0byB1c1xuICAgKiBpbnN0ZWFkIHRocm91Z2g6XG4gICAqICAtIGdvL2lzZS1oYXJkZW5pbmcteWFxcyAocHJlZmVycmVkKSAvLyBMSU5FLUlOVEVSTkFMXG4gICAqICAtIGcvaXNlLWhhcmRlbmluZyAvLyBMSU5FLUlOVEVSTkFMXG4gICAqICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvc2FmZXZhbHVlcy9pc3N1ZXNcbiAgICpcbiAgICogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdBUk5JTkcgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAqL1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh0ZW1wbGF0ZU9iaikgfHwgIUFycmF5LmlzQXJyYXkodGVtcGxhdGVPYmoucmF3KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZW1wbGF0ZU9iai5sZW5ndGggIT09IHRlbXBsYXRlT2JqLnJhdy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzVHJhbnNwaWxlZCAmJiB0ZW1wbGF0ZU9iaiA9PT0gdGVtcGxhdGVPYmoucmF3KSB7XG4gICAgLy8gU29tZXRpbWVzIHRyYW5zcGlsZXJzIHVzZSB0aGUgc2FtZSBhcnJheSB0byBzYXZlIG9uIGNvZGVzaXplIGlmIHRoZVxuICAgIC8vIHRlbXBsYXRlIGhhcyBubyBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgdmFsdWVzIGluIGVhY2hcbiAgICAvLyBhcnJheSB0byBiZSBkaWZmZXJlbnQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoIWlzVHJhbnNwaWxlZCB8fCBmcm96ZW5UU0EpICYmICFjaGVja0Zyb3plbih0ZW1wbGF0ZU9iaikpIHtcbiAgICAvLyBUcmFuc3BpbGVycyB0eXBpY2FsbHkgZG9uJ3QgZnJlZXplIGBUZW1wbGF0ZVN0cmluZ3NBcnJheWAgb2JqZWN0cywgYnV0IHdlXG4gICAgLy8gZXhwZWN0IHRoYXQgaWYgdGhleSBkaWQsIHRoZXkgd291bGQgZG8gaXQgY29uc2lzdGVudGx5LCBzbyB3ZSBhbHNvXG4gICAgLy8gZHluYW1pY2FsbHkgY2hlY2sgaWYgdGhleSBkby5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/internals/secrets.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/internals/secrets.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.secrets');
var module = module || { id: 'third_party/javascript/safevalues/internals/secrets.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
/**
 * A secret token that must be passed to safe type constructors. It is only
 * accessible from within safevalues, ensuring that unrestricted safe type
 * creation is only possible within safevalues. In particular, this prevents
 * forgery such as `safeHtmlValue.constructor('javascript:evil')`.
 * @type {*}
 */
exports.secretToken = {};
/**
 * Asserts that the given token matches the secret safevalues token. An
 * exception is thrown if that is not the case.
 * @param {!Object} token
 * @return {void}
 */
function ensureTokenIsValid(token) {
    if (dev_1.DEV_MODE) {
        if (token !== exports.secretToken) {
            throw new Error('Bad secret');
        }
    }
}
exports.ensureTokenIsValid = ensureTokenIsValid;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcmV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9pbnRlcm5hbHMvc2VjcmV0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx3RkFBNEM7Ozs7Ozs7O0FBUS9CLFFBQUEsV0FBVyxHQUFHLEVBQUU7Ozs7Ozs7QUFNN0IsU0FBZ0Isa0JBQWtCLENBQUMsS0FBYTtJQUM5QyxJQUFJLGNBQVEsRUFBRSxDQUFDO1FBQ2IsSUFBSSxLQUFLLEtBQUssbUJBQVcsRUFBRSxDQUFDO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDaEMsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBTkQsZ0RBTUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uL2Vudmlyb25tZW50L2Rldic7XG5cbi8qKlxuICogQSBzZWNyZXQgdG9rZW4gdGhhdCBtdXN0IGJlIHBhc3NlZCB0byBzYWZlIHR5cGUgY29uc3RydWN0b3JzLiBJdCBpcyBvbmx5XG4gKiBhY2Nlc3NpYmxlIGZyb20gd2l0aGluIHNhZmV2YWx1ZXMsIGVuc3VyaW5nIHRoYXQgdW5yZXN0cmljdGVkIHNhZmUgdHlwZVxuICogY3JlYXRpb24gaXMgb25seSBwb3NzaWJsZSB3aXRoaW4gc2FmZXZhbHVlcy4gSW4gcGFydGljdWxhciwgdGhpcyBwcmV2ZW50c1xuICogZm9yZ2VyeSBzdWNoIGFzIGBzYWZlSHRtbFZhbHVlLmNvbnN0cnVjdG9yKCdqYXZhc2NyaXB0OmV2aWwnKWAuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNyZXRUb2tlbiA9IHt9O1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gdG9rZW4gbWF0Y2hlcyB0aGUgc2VjcmV0IHNhZmV2YWx1ZXMgdG9rZW4uIEFuXG4gKiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoYXQgaXMgbm90IHRoZSBjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVG9rZW5Jc1ZhbGlkKHRva2VuOiBvYmplY3QpIHtcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgaWYgKHRva2VuICE9PSBzZWNyZXRUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgc2VjcmV0Jyk7XG4gICAgfVxuICB9XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/internals/url_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Internal implementations of SafeUrl.
 * Generated from: third_party/javascript/safevalues/internals/url_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.url_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/url_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_secrets_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.secrets");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const secrets_1 = goog.require('google3.third_party.javascript.safevalues.internals.secrets');
/**
 * URL that is safe to use in navigation contexts
 * (e.g. `document.location`, `a.href`)
 */
class SafeUrl {
    /**
     * @private
     * @param {!Object} token
     * @param {string} value
     */
    constructor(token, value) {
        if (dev_1.DEV_MODE) {
            (0, secrets_1.ensureTokenIsValid)(token);
        }
        this.privateDoNotAccessOrElseWrappedUrl = value;
    }
    /**
     * @public
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedUrl;
    }
}
exports.SafeUrl = SafeUrl;
/* istanbul ignore if */
if (false) {
    /**
     * @const {string}
     * @private
     */
    SafeUrl.prototype.privateDoNotAccessOrElseWrappedUrl;
}
// WARNING: interface has both a type and a value, skipping emit
/** @type {function(new:SafeUrl, !Object, string)} */
const UrlImpl = (/** @type {function(new:SafeUrl, !Object, string)} */ (SafeUrl));
/**
 * Builds a new `SafeUrl` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} value
 * @return {!SafeUrl}
 */
function createUrlInternal(value) {
    return new UrlImpl(secrets_1.secretToken, value);
}
exports.createUrlInternal = createUrlInternal;
/**
 * A SafeUrl containing 'about:blank'.
 * @type {!SafeUrl}
 */
exports.ABOUT_BLANK = createUrlInternal('about:blank');
/**
 * A SafeUrl containing an inert URL, used as an inert return value when
 * an unsafe input was sanitized.
 * @type {!SafeUrl}
 */
exports.INNOCUOUS_URL = createUrlInternal('about:invalid#zClosurez');
/**
 * Checks if the given value is a `SafeUrl` instance.
 * @param {*} value
 * @return {boolean}
 */
function isUrl(value) {
    return value instanceof SafeUrl;
}
exports.isUrl = isUrl;
/**
 * Returns the string value of the passed `SafeUrl` object while ensuring it
 * has the correct type.
 * @param {!SafeUrl} value
 * @return {string}
 */
function unwrapUrl(value) {
    if (isUrl(value)) {
        return ((/** @type {?} */ ((/** @type {*} */ (value))))).privateDoNotAccessOrElseWrappedUrl;
    }
    /** @type {string} */
    let message = '';
    if (dev_1.DEV_MODE) {
        message = `Unexpected type when unwrapping SafeUrl, got '${value}' of type '${typeof value}'`;
    }
    throw new Error(message);
}
exports.unwrapUrl = unwrapUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW50ZXJuYWxzL3VybF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQSx3RkFBNEM7QUFFNUMsOEZBQTBEOzs7OztBQU0xRCxNQUFhLE9BQU87Ozs7OztJQUdsQixZQUFvQixLQUFhLEVBQUUsS0FBYTtRQUM5QyxJQUFJLGNBQVEsRUFBRSxDQUFDO1lBQ2IsSUFBQSw0QkFBa0IsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUM1QixDQUFDO1FBRUQsSUFBSSxDQUFDLGtDQUFrQyxHQUFHLEtBQUssQ0FBQztJQUNsRCxDQUFDOzs7OztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQztJQUNqRCxDQUFDO0NBQ0Y7QUFkRCwwQkFjQzs7Ozs7OztJQWJDLHFEQUE0RDs7OztNQWtCeEQsT0FBTyxHQUFHLHdEQUFBLE9BQU8sRUFFdEI7Ozs7Ozs7O0FBT0QsU0FBZ0IsaUJBQWlCLENBQUMsS0FBYTtJQUM3QyxPQUFPLElBQUksT0FBTyxDQUFDLHFCQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUZELDhDQUVDOzs7OztBQUdZLFFBQUEsV0FBVyxHQUFZLGlCQUFpQixDQUFDLGFBQWEsQ0FBQzs7Ozs7O0FBTXZELFFBQUEsYUFBYSxHQUFZLGlCQUFpQixDQUNyRCx5QkFBeUIsQ0FDMUI7Ozs7OztBQUtELFNBQWdCLEtBQUssQ0FBQyxLQUFjO0lBQ2xDLE9BQU8sS0FBSyxZQUFZLE9BQU8sQ0FBQztBQUNsQyxDQUFDO0FBRkQsc0JBRUM7Ozs7Ozs7QUFNRCxTQUFnQixTQUFTLENBQUMsS0FBYztJQUN0QyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ2pCLE9BQU8sQ0FBQyxtQkFBQSxtQkFBQSxLQUFLLEVBQVcsRUFBVyxDQUFDLENBQUMsa0NBQWtDLENBQUM7SUFDMUUsQ0FBQzs7UUFDRyxPQUFPLEdBQUcsRUFBRTtJQUNoQixJQUFJLGNBQVEsRUFBRSxDQUFDO1FBQ2IsT0FBTyxHQUFHLGlEQUFpRCxLQUFLLGNBQWMsT0FBTyxLQUFLLEdBQUcsQ0FBQztJQUNoRyxDQUFDO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQixDQUFDO0FBVEQsOEJBU0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qKiBAZmlsZW92ZXJ2aWV3IEludGVybmFsIGltcGxlbWVudGF0aW9ucyBvZiBTYWZlVXJsLiAqL1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi9lbnZpcm9ubWVudC9kZXYnO1xuXG5pbXBvcnQge2Vuc3VyZVRva2VuSXNWYWxpZCwgc2VjcmV0VG9rZW59IGZyb20gJy4vc2VjcmV0cyc7XG5cbi8qKlxuICogVVJMIHRoYXQgaXMgc2FmZSB0byB1c2UgaW4gbmF2aWdhdGlvbiBjb250ZXh0c1xuICogKGUuZy4gYGRvY3VtZW50LmxvY2F0aW9uYCwgYGEuaHJlZmApXG4gKi9cbmV4cG9ydCBjbGFzcyBTYWZlVXJsIHtcbiAgcHJpdmF0ZSByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkVXJsOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih0b2tlbjogb2JqZWN0LCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICBlbnN1cmVUb2tlbklzVmFsaWQodG9rZW4pO1xuICAgIH1cblxuICAgIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFVybCA9IHZhbHVlO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkVXJsO1xuICB9XG59XG5cbmludGVyZmFjZSBVcmxJbXBsIHtcbiAgcHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFVybDogc3RyaW5nO1xufVxuY29uc3QgVXJsSW1wbCA9IFNhZmVVcmwgYXMge1xuICBuZXcgKHRva2VuOiBvYmplY3QsIHZhbHVlOiBzdHJpbmcpOiBTYWZlVXJsO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBuZXcgYFNhZmVVcmxgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVybEludGVybmFsKHZhbHVlOiBzdHJpbmcpOiBTYWZlVXJsIHtcbiAgcmV0dXJuIG5ldyBVcmxJbXBsKHNlY3JldFRva2VuLCB2YWx1ZSk7XG59XG5cbi8qKiBBIFNhZmVVcmwgY29udGFpbmluZyAnYWJvdXQ6YmxhbmsnLiAqL1xuZXhwb3J0IGNvbnN0IEFCT1VUX0JMQU5LOiBTYWZlVXJsID0gY3JlYXRlVXJsSW50ZXJuYWwoJ2Fib3V0OmJsYW5rJyk7XG5cbi8qKlxuICogQSBTYWZlVXJsIGNvbnRhaW5pbmcgYW4gaW5lcnQgVVJMLCB1c2VkIGFzIGFuIGluZXJ0IHJldHVybiB2YWx1ZSB3aGVuXG4gKiBhbiB1bnNhZmUgaW5wdXQgd2FzIHNhbml0aXplZC5cbiAqL1xuZXhwb3J0IGNvbnN0IElOTk9DVU9VU19VUkw6IFNhZmVVcmwgPSBjcmVhdGVVcmxJbnRlcm5hbChcbiAgJ2Fib3V0OmludmFsaWQjekNsb3N1cmV6Jyxcbik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGBTYWZlVXJsYCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVXJsKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2FmZVVybCB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNhZmVVcmw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFNhZmVVcmxgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBVcmwodmFsdWU6IFNhZmVVcmwpOiBzdHJpbmcge1xuICBpZiAoaXNVcmwodmFsdWUpKSB7XG4gICAgcmV0dXJuICh2YWx1ZSBhcyB1bmtub3duIGFzIFVybEltcGwpLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRVcmw7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHR5cGUgd2hlbiB1bndyYXBwaW5nIFNhZmVVcmwsIGdvdCAnJHt2YWx1ZX0nIG9mIHR5cGUgJyR7dHlwZW9mIHZhbHVlfSdgO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/url_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/url_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.url_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/url_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_pure_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.pure");
const tsickle_resource_url_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_string_literal_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_url_impl_5 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_TrustedResourceUrl_6 = goog.requireType("goog.html.TrustedResourceUrl");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
// BEGIN-INTERNAL
const pure_1 = goog.require('google3.third_party.javascript.safevalues.internals.pure');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
const url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.url_impl');
// END-INTERNAL
// BEGIN-INTERNAL
/**
 * A pattern that matches safe MIME types. Only matches image, video and audio
 * types, with some parameter support (most notably, we haven't implemented the
 * more complex parts like %-encoded characters or non-alphanumerical ones for
 * simplicity's sake). Also, the specs are fairly complex, and they don't
 * necessarily agree with Chrome on some aspects, and so we settled on a subset
 * where the behavior makes sense to all parties involved.
 *
 * The spec is available at https://mimesniff.spec.whatwg.org/ (and see
 * https://tools.ietf.org/html/rfc2397 for data: urls, which override some of
 * it).
 * @param {string} mimeType
 * @return {boolean}
 */
function isSafeMimeType(mimeType) {
    /** @type {(null|!RegExpMatchArray)} */
    const match = mimeType.match(/^([^;]+)(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i);
    return (match?.length === 2 &&
        (isSafeImageMimeType(match[1]) ||
            isSafeVideoMimeType(match[1]) ||
            isSafeAudioMimeType(match[1]) ||
            isSafeFontMimeType(match[1])));
}
/**
 * @param {string} mimeType
 * @return {boolean}
 */
function isSafeImageMimeType(mimeType) {
    return /^image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon|heic|heif|avif|x-ms-bmp)$/i.test(mimeType);
}
/**
 * @param {string} mimeType
 * @return {boolean}
 */
function isSafeVideoMimeType(mimeType) {
    return /^video\/(?:mpeg|mp4|ogg|webm|x-matroska|quicktime|x-ms-wmv)$/i.test(mimeType);
}
/**
 * @param {string} mimeType
 * @return {boolean}
 */
function isSafeAudioMimeType(mimeType) {
    return /^audio\/(?:3gpp2|3gpp|aac|amr|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)$/i.test(mimeType);
}
/**
 * @param {string} mimeType
 * @return {boolean}
 */
function isSafeFontMimeType(mimeType) {
    return /^font\/\w+/i.test(mimeType);
}
/**
 * Interface representing a scheme that sanitizeUrl can optionally accommodate.
 * Even though this interface could be implemented by user code, the code will
 * ignore any implementation that doesn't come from this file.
 * @record
 */
function Scheme() { }
exports.Scheme = Scheme;
/* istanbul ignore if */
if (false) {
    /**
     * @public
     * @param {string} url
     * @return {boolean}
     */
    Scheme.prototype.isValid = function (url) { };
}
/**
 * @implements {Scheme}
 */
class SchemeImpl {
    /**
     * @public
     * @param {function(string): boolean} isValid
     */
    constructor(isValid) {
        this.isValid = isValid;
    }
}
/* istanbul ignore if */
if (false) {
    /**
     * @const {function(string): boolean}
     * @public
     */
    SchemeImpl.prototype.isValid;
}
/**
 * @param {!Scheme} scheme
 * @return {boolean}
 */
function isValidScheme(scheme) {
    return scheme instanceof SchemeImpl;
}
/**
 * @param {string} scheme
 * @return {!Scheme}
 */
function simpleScheme(scheme) {
    return new SchemeImpl((/**
     * @param {string} url
     * @return {boolean}
     */
    (url) => {
        return url.substr(0, scheme.length + 1).toLowerCase() === scheme + ':';
    }));
}
/** @type {!Scheme} */
const RELATIVE_SCHEME = new SchemeImpl((/**
 * @param {string} url
 * @return {boolean}
 */
(url) => /^[^:]*([/?#]|$)/.test(url)));
/** @type {!Scheme} */
const CALLTO_SCHEME = new SchemeImpl((/**
 * @param {string} url
 * @return {boolean}
 */
(url) => /^callto:\+?\d*$/i.test(url)));
/** @type {!Scheme} */
const SSH_SCHEME = new SchemeImpl((/**
 * @param {string} url
 * @return {boolean}
 */
(url) => url.indexOf('ssh://') === 0));
/** @type {!Scheme} */
const EXTENSION_SCHEME = new SchemeImpl((/**
 * @param {string} url
 * @return {boolean}
 */
(url) => {
    return (url.indexOf('chrome-extension://') === 0 ||
        url.indexOf('moz-extension://') === 0 ||
        url.indexOf('ms-browser-extension://') === 0);
}));
/** @type {!Scheme} */
const SIP_SCHEME = new SchemeImpl((/**
 * @param {string} url
 * @return {boolean}
 */
(url) => {
    return url.indexOf('sip:') === 0 || url.indexOf('sips:') === 0;
}));
// This used to be an enum, we preserved the name avoid changing the API.
// tslint:disable:enforce-name-casing
/**
 * The list of schemes sanitizeUrl can optionally accommodate.
 * @type {{TEL: !Scheme, CALLTO: !Scheme, SSH: !Scheme, RTSP: !Scheme, DATA: !Scheme, HTTP: !Scheme, HTTPS: !Scheme, EXTENSION: !Scheme, FTP: !Scheme, RELATIVE: !Scheme, MAILTO: !Scheme, INTENT: !Scheme, MARKET: !Scheme, ITMS: !Scheme, ITMS_APPSS: !Scheme, ITMS_SERVICES: !Scheme, FACEBOOK_MESSENGER: !Scheme, WHATSAPP: !Scheme, SIP: !Scheme, SMS: !Scheme, VND_YOUTUBE: !Scheme}}
 */
exports.SanitizableUrlScheme = {
    TEL: simpleScheme('tel'),
    CALLTO: CALLTO_SCHEME,
    SSH: SSH_SCHEME,
    RTSP: simpleScheme('rtsp'),
    DATA: simpleScheme('data'),
    HTTP: simpleScheme('http'),
    HTTPS: simpleScheme('https'),
    EXTENSION: EXTENSION_SCHEME,
    FTP: simpleScheme('ftp'),
    RELATIVE: RELATIVE_SCHEME,
    MAILTO: simpleScheme('mailto'),
    INTENT: simpleScheme('intent'),
    MARKET: simpleScheme('market'),
    ITMS: simpleScheme('itms'),
    ITMS_APPSS: simpleScheme('itms-appss'),
    ITMS_SERVICES: simpleScheme('itms-services'),
    FACEBOOK_MESSENGER: simpleScheme('fb-messenger'),
    WHATSAPP: simpleScheme('whatsapp'),
    SIP: SIP_SCHEME,
    SMS: simpleScheme('sms'),
    VND_YOUTUBE: simpleScheme('vnd.youtube'),
};
// tslint:enable:enforce-name-casing
/**
 * List of schemes used by default.
 * @type {!Array<!Scheme>}
 */
const DEFAULT_SCHEMES = [
    exports.SanitizableUrlScheme.DATA,
    exports.SanitizableUrlScheme.HTTP,
    exports.SanitizableUrlScheme.HTTPS,
    exports.SanitizableUrlScheme.MAILTO,
    exports.SanitizableUrlScheme.FTP,
    exports.SanitizableUrlScheme.RELATIVE,
];
/**
 * Creates a SafeUrl object from a string `url` by sanitizing it.
 *
 * Note: If your url is partially known statically, you should prefer using the
 * `safeUrl` function directly.
 *
 * The input string is validated against the set of `allowedSchemes`, which
 * defaults to a set of commonly used safe URL schemes. If validation fails,
 * `undefined` is returned.
 *
 * If no `allowedSchemes` are passed, the `url` may use the http, https, mailto,
 * ftp or data schemes, or a relative URL (i.e., a URL without a scheme;
 * specifically, a scheme-relative, absolute-path-relative, or path-relative
 * URL).
 *
 * Other supported schemes don't have direct security issues (i.e. no JS
 * execution), but their inherent capabilities are not touched: for instance, if
 * you allow TEL only, you won't get javascript execution, but the resulting
 * link could still potentially be used to call toll numbers.
 * @param {(string|!tsickle_url_impl_5.SafeUrl)} url
 * @param {!ReadonlyArray<!Scheme>=} allowedSchemes
 * @return {(undefined|!tsickle_url_impl_5.SafeUrl)}
 */
function trySanitizeUrl(url, allowedSchemes = DEFAULT_SCHEMES) {
    if ((0, url_impl_1.isUrl)(url)) {
        return url;
    }
    // Using simple iteration because the compiler doesn't optimize this well for
    // es5.
    for (let i = 0; i < allowedSchemes.length; ++i) {
        /** @type {!Scheme} */
        const scheme = allowedSchemes[i];
        if (isValidScheme(scheme) && scheme.isValid(url)) {
            return (0, url_impl_1.createUrlInternal)(url);
        }
    }
    return undefined;
}
exports.trySanitizeUrl = trySanitizeUrl;
/**
 * Creates a SafeUrl object from a string `url` by sanitizing it.
 *
 * Works the same way as `trySanitizeUrl`, but returns an innocuous url instead
 * of `undefined`.
 * Triggers the sanitization callbacks if the url is sanitized away (see
 * addJavaScriptUrlSanitizationCallback).
 * @param {(string|!tsickle_url_impl_5.SafeUrl)} url
 * @param {!ReadonlyArray<!Scheme>=} allowedSchemes
 * @return {!tsickle_url_impl_5.SafeUrl}
 */
function sanitizeUrl(url, allowedSchemes = DEFAULT_SCHEMES) {
    /** @type {(undefined|!tsickle_url_impl_5.SafeUrl)} */
    const sanitizedUrl = trySanitizeUrl(url, allowedSchemes);
    if (sanitizedUrl === undefined) {
        triggerCallbacks(url.toString());
    }
    return sanitizedUrl || url_impl_1.INNOCUOUS_URL;
}
exports.sanitizeUrl = sanitizeUrl;
/**
 * Creates a SafeUrl object from a Blob or MediaSource. For blobs, the function
 * validates that the Blob's type is amongst the safe MIME types, and throws if
 * that's not the case.
 *
 * Caller must call `URL.revokeObjectUrl()` on the stringified url to
 * release the underlying `Blob`.
 * @param {(!Blob|!MediaSource)} source
 * @return {!tsickle_url_impl_5.SafeUrl}
 */
function objectUrlFromSafeSource(source) {
    // MediaSource support in Safari is limited
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource#browser_compatibility
    if (typeof MediaSource !== 'undefined' && source instanceof MediaSource) {
        return (0, url_impl_1.createUrlInternal)(URL.createObjectURL(source));
    }
    /** @type {!Blob} */
    const blob = (/** @type {!Blob} */ (source));
    if (!isSafeMimeType(blob.type)) {
        /** @type {string} */
        let message = '';
        if (dev_1.DEV_MODE) {
            message = `unsafe blob MIME type: ${blob.type}`;
        }
        throw new Error(message);
    }
    return (0, url_impl_1.createUrlInternal)(URL.createObjectURL(blob));
}
exports.objectUrlFromSafeSource = objectUrlFromSafeSource;
/**
 * Creates a SafeUrl object from a MediaSource.
 * @deprecated Use objectUrlFromSafeSource.
 * @param {!MediaSource} media
 * @return {!tsickle_url_impl_5.SafeUrl}
 */
function fromMediaSource(media) {
    // MediaSource support in Safari is limited
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource#browser_compatibility
    if (typeof MediaSource !== 'undefined' && media instanceof MediaSource) {
        return (0, url_impl_1.createUrlInternal)(URL.createObjectURL(media));
    }
    /** @type {string} */
    let message = '';
    if (dev_1.DEV_MODE) {
        message = `fromMediaSource only accepts MediaSource instances, but was called with ${media}.`;
    }
    throw new Error(message);
}
exports.fromMediaSource = fromMediaSource;
/**
 * Builds SafeUrl object from a TrustedResourceUrl. This is safe because
 * TrustedResourceUrl is more tightly restricted than SafeUrl.
 * @deprecated Unwrap to string instead. SafeUrl sinks accept string values.
 * @param {!tsickle_TrustedResourceUrl_6} url
 * @return {!tsickle_url_impl_5.SafeUrl}
 */
function fromTrustedResourceUrl(url) {
    return (0, url_impl_1.createUrlInternal)((0, resource_url_impl_1.unwrapResourceUrl)(url).toString());
}
exports.fromTrustedResourceUrl = fromTrustedResourceUrl;
/**
 * Checks whether this url prefix contains:
 *  - a fully specified and valid scheme
 *  - a character forcing it to be a relative url
 *
 * Since this function is only called with compile-time constants, we don't need
 * to be as careful as in `sanitizeUrl` and we can just check that the scheme is
 * valid and non-'javascript:'. If we discover other dangerous schemes we want
 * to prevent, we can statically find all instances and refactor them. See
 * https://url.spec.whatwg.org/#url-scheme-string for scheme validation.
 * @param {string} prefix
 * @param {boolean} isWholeUrl
 * @return {boolean}
 */
function isSafeUrlPrefix(prefix, isWholeUrl) {
    /** @type {number} */
    const markerIdx = prefix.search(/[:/?#]/);
    if (markerIdx < 0) {
        // If we don't find a marker, but there is no interpolation, the url is
        // relative
        return isWholeUrl;
    }
    if (prefix.charAt(markerIdx) !== ':') {
        // Relative URL
        return true;
    }
    /** @type {string} */
    const scheme = prefix.substring(0, markerIdx).toLowerCase();
    return /^[a-z][a-z\d+.-]*$/.test(scheme) && scheme !== 'javascript';
}
/**
 * Builds a SafeUrl from a template literal.
 *
 * Use this function if your url has a static prefix containing the whole scheme
 * of the url.
 *
 * This factory is a template literal tag function. It should be called with
 * a template literal, with or without embedded expressions. For example,
 *               safeUrl`./somepath.html`;
 * or
 *               safeUrl`data:text/html;base64,${btoa('<div></div>')}`;
 *
 * To be successfully built, we must ensure that the scheme is correctly defined
 * and not dangerous. In practice this means the first chunk of the template
 * must satisfy one of the following conditions:
 * - Start with an explicit scheme that is valid and is not `javascript`
 *    (e.g. safeUrl`https:${...}`)
 * - Start with a prefix that ensures the url is relative
 *    (e.g. safeUrl`./${...}` or safeUrl`#${...}`)
 * Embedded expressions are interpolated as-is and no URL encoding is applied.
 * @param {!TemplateStringsArray} templateObj
 * @param {...*} rest
 * @return {!tsickle_url_impl_5.SafeUrl}
 */
function safeUrl(templateObj, ...rest) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, rest.length);
    }
    /** @type {string} */
    const prefix = templateObj[0];
    if (dev_1.DEV_MODE) {
        if (!isSafeUrlPrefix(prefix, rest.length === 0)) {
            throw new Error(`Trying to interpolate with unsupported prefix: ${prefix}`);
        }
    }
    /** @type {!Array<string>} */
    const urlParts = [prefix];
    for (let i = 0; i < rest.length; i++) {
        urlParts.push(String(rest[i]));
        urlParts.push(templateObj[i + 1]);
    }
    return (0, url_impl_1.createUrlInternal)(urlParts.join(''));
}
exports.safeUrl = safeUrl;
/**
 * @define {boolean}
 */
const ASSUME_IMPLEMENTS_URL_API = goog.define('ASSUME_IMPLEMENTS_URL_API', 
// TODO(b/154845327) narrow this down if earlier featureset years allow,
// if they get defined. FY2020 does NOT include Edge (EdgeHTML), which is
// good as workarounds are needed for spec compliance and a searchParams
// polyfill.
goog.FEATURESET_YEAR >= 2020);
// Tests for URL browser API support. e.g. IE doesn't support it.
/** @type {boolean} */
const supportsURLAPI = (0, pure_1.pure)((/**
 * @return {boolean}
 */
() => {
    // TODO(b/155106210) Does this work without JSCompiler?
    if (ASSUME_IMPLEMENTS_URL_API) {
        return true;
    }
    return typeof URL === 'function';
}));
/**
 * @param {string} url
 * @return {(undefined|string)}
 */
function legacyExtractScheme(url) {
    /** @type {!HTMLAnchorElement} */
    const aTag = document.createElement('a');
    try {
        // We don't use the safe wrapper here because we don't want to sanitize the
        // URL (which would lead to a dependency loop anyway). This is safe because
        // this node is NEVER attached to the DOM.
        aTag.href = url;
    }
    catch (e) {
        return undefined;
    }
    // Chrome and Firefox resolve relative scheme to https directly,
    // while IE keeps a ':' or empty string protocol.
    /** @type {string} */
    const protocol = aTag.protocol;
    return protocol === ':' || protocol === '' ? 'https:' : protocol;
}
/** @typedef {function(string): void} */
var JavaScriptUrlSanitizationCallback;
// END-INTERNAL
/**
 * Extracts the scheme from the given URL. If the URL is relative, https: is
 * assumed.
 * @param {string} url The URL to extract the scheme from.
 * @return {(undefined|string)} the URL scheme.
 */
function extractScheme(url) {
    // BEGIN-INTERNAL
    // We defer to the browser URL parsing as much as possible to detect
    // javascript: schemes. However, old browsers like IE don't support it.
    if (!supportsURLAPI) {
        return legacyExtractScheme(url);
    }
    // END-INTERNAL
    /** @type {?} */
    let parsedUrl;
    try {
        parsedUrl = new URL(url);
    }
    catch (e) {
        // According to https://url.spec.whatwg.org/#constructors, the URL
        // constructor with one parameter throws if `url` is not absolute. In this
        // case, we are sure that no explicit scheme (javascript: ) is set.
        // This can also be a URL parsing error, but in this case the URL won't be
        // run anyway.
        return 'https:';
    }
    return (/** @type {!URL} */ (parsedUrl)).protocol;
}
exports.extractScheme = extractScheme;
// We can't use an ES6 Set here because gws somehow depends on this code and
// doesn't want to pay the cost of a polyfill.
/** @type {!Array<string>} */
const ALLOWED_SCHEMES = ['data:', 'http:', 'https:', 'mailto:', 'ftp:'];
/**
 * A pattern that blocks javascript: URLs. Matches
 * (a) Urls with an explicit scheme that is not javascript and that only has
 *     alphanumeric or [.-+_] characters; or
 * (b) Urls with no explicit scheme. The pattern allows the first colon
 *     (`:`) character to appear after one of  the `/` `?` or `#` characters,
 *     which means the colon appears in path, query or fragment part of the URL.
 * @type {!RegExp}
 */
exports.IS_NOT_JAVASCRIPT_URL_PATTERN = /^\s*(?!javascript:)(?:[\w+.-]+:|[^:/?#]*(?:[/?#]|$))/i;
/**
 * Checks whether a urls has a `javascript:` scheme.
 * If the url has a `javascript:` scheme, reports it and returns true.
 * Otherwise, returns false.
 * @param {string} url
 * @return {boolean}
 */
function reportJavaScriptUrl(url) {
    /** @type {boolean} */
    const hasJavascriptUrlScheme = !exports.IS_NOT_JAVASCRIPT_URL_PATTERN.test(url);
    if (hasJavascriptUrlScheme) {
        // BEGIN-EXTERNAL
        // if (DEV_MODE) {
        //   console.error(`A URL with content '${url}' was sanitized away.`);
        // }
        // END-EXTERNAL
        triggerCallbacks(url); // LINE-INTERNAL
    }
    return hasJavascriptUrlScheme;
}
exports.reportJavaScriptUrl = reportJavaScriptUrl;
/**
 * Checks that the URL scheme is not javascript.
 * The URL parsing relies on the URL API in browsers that support it.
 * @param {string} url The URL to sanitize for a SafeUrl sink.
 * @return {(undefined|string)} undefined if url has a javascript: scheme, the original URL
 *     otherwise.
 */
function sanitizeJavaScriptUrl(url) {
    if (reportJavaScriptUrl(url)) {
        return undefined;
    }
    return url;
}
exports.sanitizeJavaScriptUrl = sanitizeJavaScriptUrl;
/**
 * Type alias for URLs passed to DOM sink wrappers.
 * @typedef {(string|!tsickle_url_impl_5.SafeUrl)}
 */
exports.Url;
// END-INTERNAL
// BEGIN-EXTERNAL
// /**
//  * Type alias for URLs passed to DOM sink wrappers.
//  */
// export type Url = string;
// END-EXTERNAL
// BEGIN-EXTERNAL
// /**
//  * Adapter to sanitize string URLs in DOM sink wrappers.
//  * @return undefined if the URL was sanitized.
//  */
// END-EXTERNAL
// BEGIN-INTERNAL
/**
 * Adapter to support string and SafeUrl in DOM sink wrappers.
 * @param {(string|!tsickle_url_impl_5.SafeUrl)} url
 * @return {(undefined|string)} undefined if the URL was sanitized.
 */
// END-INTERNAL
function unwrapUrlOrSanitize(url) {
    // BEGIN-INTERNAL
    return url instanceof url_impl_1.SafeUrl ? (0, url_impl_1.unwrapUrl)(url) : sanitizeJavaScriptUrl(url);
    // END-INTERNAL
    // LINE-EXTERNAL return sanitizeJavaScriptUrl(url);
}
exports.unwrapUrlOrSanitize = unwrapUrlOrSanitize;
/**
 * Sanitizes a URL restrictively.
 * This sanitizer protects against XSS and potentially other uncommon and
 * undesirable schemes that an attacker could use e.g. phishing (tel:, callto:
 * ssh: etc schemes). This sanitizer is primarily meant to be used by the HTML
 * sanitizer.
 * @param {string} url
 * @return {string}
 */
function restrictivelySanitizeUrl(url) {
    /** @type {(undefined|string)} */
    const parsedScheme = extractScheme(url);
    if (parsedScheme !== undefined &&
        ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {
        return url;
    }
    // BEGIN-INTERNAL
    // The sanitizer used to sanitize URLs with SafeUrl's sanitizeUrl which
    // returns this innocuous URL. We need to keep this behavior here because some
    // golden tests still expect this value.
    // TODO(b/238861489): return a short innocuous URL
    // END-INTERNAL
    return 'about:invalid#zClosurez';
}
exports.restrictivelySanitizeUrl = restrictivelySanitizeUrl;
// BEGIN-INTERNAL
// We need to avoid using ES6 Sets here to avoid the expenssive ES5 polyfill.
// This is acceptable anyway because this array should have only few elements.
/** @type {!Array<function(string): void>} */
const sanitizationCallbacks = [];
// This callback is re-defined when a new callback is registered/removed.
// When no callback is registered, there are no references to the
// sanitizationCallbacks array, which make it possible for the compiler to
// optimize it away.
/** @type {function(string): void} */
let triggerCallbacks = (/**
 * @param {string} url
 * @return {void}
 */
(url) => { });
if (dev_1.DEV_MODE) {
    addJavaScriptUrlSanitizationCallback((/**
     * @param {string} url
     * @return {void}
     */
    (url) => {
        console.warn(`A URL with content '${url}' was sanitized away.`);
    }));
}
/**
 * Registers a sanitization callback that is called whenever a javascript: URL
 * is sanitized away.
 * @param {function(string): void} callback
 * @return {void}
 */
function addJavaScriptUrlSanitizationCallback(callback) {
    if (sanitizationCallbacks.indexOf(callback) === -1) {
        sanitizationCallbacks.push(callback);
    }
    triggerCallbacks = (/**
     * @param {string} url
     * @return {void}
     */
    (url) => {
        sanitizationCallbacks.forEach((/**
         * @param {function(string): void} callback
         * @return {void}
         */
        (callback) => {
            callback(url);
        }));
    });
}
exports.addJavaScriptUrlSanitizationCallback = addJavaScriptUrlSanitizationCallback;
/**
 * Unregister the JavaScript URL sanitization callback.
 * @param {function(string): void} callback
 * @return {void}
 */
function removeJavaScriptUrlSanitizationCallback(callback) {
    /** @type {number} */
    const callbackIndex = sanitizationCallbacks.indexOf(callback);
    if (callbackIndex !== -1) {
        sanitizationCallbacks.splice(callbackIndex, 1);
    }
}
exports.removeJavaScriptUrlSanitizationCallback = removeJavaScriptUrlSanitizationCallback;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsX2J1aWxkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2J1aWxkZXJzL3VybF9idWlsZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHdGQUE0Qzs7QUFHNUMsd0ZBQXVDO0FBQ3ZDLGtIQUd3QztBQUN4Qyw0R0FBbUU7QUFDbkUsZ0dBTStCOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCL0IsU0FBUyxjQUFjLENBQUMsUUFBZ0I7O1VBQ2hDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLHlDQUF5QyxDQUFDO0lBQ3ZFLE9BQU8sQ0FDTCxLQUFLLEVBQUUsTUFBTSxLQUFLLENBQUM7UUFDbkIsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUIsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdCLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoQyxDQUFDO0FBQ0osQ0FBQzs7Ozs7QUFFRCxTQUFTLG1CQUFtQixDQUFDLFFBQWdCO0lBQzNDLE9BQU8sNkVBQTZFLENBQUMsSUFBSSxDQUN2RixRQUFRLENBQ1QsQ0FBQztBQUNKLENBQUM7Ozs7O0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxRQUFnQjtJQUMzQyxPQUFPLCtEQUErRCxDQUFDLElBQUksQ0FDekUsUUFBUSxDQUNULENBQUM7QUFDSixDQUFDOzs7OztBQUVELFNBQVMsbUJBQW1CLENBQUMsUUFBZ0I7SUFDM0MsT0FBTyxxR0FBcUcsQ0FBQyxJQUFJLENBQy9HLFFBQVEsQ0FDVCxDQUFDO0FBQ0osQ0FBQzs7Ozs7QUFFRCxTQUFTLGtCQUFrQixDQUFDLFFB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R0FBRSxDQUFDLENBQUE7QUFDakUsSUFBSSxjQUFRLEVBQUUsQ0FBQztJQUNiLG9DQUFvQzs7OztJQUFDLENBQUMsR0FBVyxFQUFFLEVBQUU7UUFDbkQsT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsR0FBRyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2xFLENBQUMsRUFBQyxDQUFDO0FBQ0wsQ0FBQzs7Ozs7OztBQU1ELFNBQWdCLG9DQUFvQyxDQUNsRCxRQUEyQztJQUUzQyxJQUFJLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ25ELHFCQUFxQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBQ0QsZ0JBQWdCOzs7O0lBQUcsQ0FBQyxHQUFXLEVBQUUsRUFBRTtRQUNqQyxxQkFBcUIsQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUN6QyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEIsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDLENBQUEsQ0FBQztBQUNKLENBQUM7QUFYRCxvRkFXQzs7Ozs7O0FBS0QsU0FBZ0IsdUNBQXVDLENBQ3JELFFBQTJDOztVQUVyQyxhQUFhLEdBQUcscUJBQXFCLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUM3RCxJQUFJLGFBQWEsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3pCLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztBQUNILENBQUM7QUFQRCwwRkFPQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtERVZfTU9ERX0gZnJvbSAnLi4vZW52aXJvbm1lbnQvZGV2JztcblxuLy8gQkVHSU4tSU5URVJOQUxcbmltcG9ydCB7cHVyZX0gZnJvbSAnLi4vaW50ZXJuYWxzL3B1cmUnO1xuaW1wb3J0IHtcbiAgVHJ1c3RlZFJlc291cmNlVXJsLFxuICB1bndyYXBSZXNvdXJjZVVybCxcbn0gZnJvbSAnLi4vaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsJztcbmltcG9ydCB7YXNzZXJ0SXNUZW1wbGF0ZU9iamVjdH0gZnJvbSAnLi4vaW50ZXJuYWxzL3N0cmluZ19saXRlcmFsJztcbmltcG9ydCB7XG4gIElOTk9DVU9VU19VUkwsXG4gIFNhZmVVcmwsXG4gIGNyZWF0ZVVybEludGVybmFsLFxuICBpc1VybCxcbiAgdW53cmFwVXJsLFxufSBmcm9tICcuLi9pbnRlcm5hbHMvdXJsX2ltcGwnO1xuLy8gRU5ELUlOVEVSTkFMXG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBNSU1FIHR5cGVzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpb1xuICogdHlwZXMsIHdpdGggc29tZSBwYXJhbWV0ZXIgc3VwcG9ydCAobW9zdCBub3RhYmx5LCB3ZSBoYXZlbid0IGltcGxlbWVudGVkIHRoZVxuICogbW9yZSBjb21wbGV4IHBhcnRzIGxpa2UgJS1lbmNvZGVkIGNoYXJhY3RlcnMgb3Igbm9uLWFscGhhbnVtZXJpY2FsIG9uZXMgZm9yXG4gKiBzaW1wbGljaXR5J3Mgc2FrZSkuIEFsc28sIHRoZSBzcGVjcyBhcmUgZmFpcmx5IGNvbXBsZXgsIGFuZCB0aGV5IGRvbid0XG4gKiBuZWNlc3NhcmlseSBhZ3JlZSB3aXRoIENocm9tZSBvbiBzb21lIGFzcGVjdHMsIGFuZCBzbyB3ZSBzZXR0bGVkIG9uIGEgc3Vic2V0XG4gKiB3aGVyZSB0aGUgYmVoYXZpb3IgbWFrZXMgc2Vuc2UgdG8gYWxsIHBhcnRpZXMgaW52b2x2ZWQuXG4gKlxuICogVGhlIHNwZWMgaXMgYXZhaWxhYmxlIGF0IGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8gKGFuZCBzZWVcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzk3IGZvciBkYXRhOiB1cmxzLCB3aGljaCBvdmVycmlkZSBzb21lIG9mXG4gKiBpdCkuXG4gKi9cbmZ1bmN0aW9uIGlzU2FmZU1pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgbWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvXihbXjtdKykoPzo7XFx3Kz0oPzpcXHcrfFwiW1xcdzssPSBdK1wiKSkqJC9pKTtcbiAgcmV0dXJuIChcbiAgICBtYXRjaD8ubGVuZ3RoID09PSAyICYmXG4gICAgKGlzU2FmZUltYWdlTWltZVR5cGUobWF0Y2hbMV0pIHx8XG4gICAgICBpc1NhZmVWaWRlb01pbWVUeXBlKG1hdGNoWzFdKSB8fFxuICAgICAgaXNTYWZlQXVkaW9NaW1lVHlwZShtYXRjaFsxXSkgfHxcbiAgICAgIGlzU2FmZUZvbnRNaW1lVHlwZShtYXRjaFsxXSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU2FmZUltYWdlTWltZVR5cGUobWltZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL15pbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicHx4LWljb258aGVpY3xoZWlmfGF2aWZ8eC1tcy1ibXApJC9pLnRlc3QoXG4gICAgbWltZVR5cGUsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU2FmZVZpZGVvTWltZVR5cGUobWltZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL152aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtfHgtbWF0cm9za2F8cXVpY2t0aW1lfHgtbXMtd212KSQvaS50ZXN0KFxuICAgIG1pbWVUeXBlLFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1NhZmVBdWRpb01pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eYXVkaW9cXC8oPzozZ3BwMnwzZ3BwfGFhY3xhbXJ8TDE2fG1pZGl8bXAzfG1wNHxtcGVnfG9nYXxvZ2d8b3B1c3x4LW00YXx4LW1hdHJvc2thfHgtd2F2fHdhdnx3ZWJtKSQvaS50ZXN0KFxuICAgIG1pbWVUeXBlLFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1NhZmVGb250TWltZVR5cGUobWltZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL15mb250XFwvXFx3Ky9pLnRlc3QobWltZVR5cGUpO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSByZXByZXNlbnRpbmcgYSBzY2hlbWUgdGhhdCBzYW5pdGl6ZVVybCBjYW4gb3B0aW9uYWxseSBhY2NvbW1vZGF0ZS5cbiAqIEV2ZW4gdGhvdWdoIHRoaXMgaW50ZXJmYWNlIGNvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHVzZXIgY29kZSwgdGhlIGNvZGUgd2lsbFxuICogaWdub3JlIGFueSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgY29tZSBmcm9tIHRoaXMgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY2hlbWUge1xuICBpc1ZhbGlkKHVybDogc3RyaW5nKTogYm9vbGVhbjtcbn1cblxuY2xhc3MgU2NoZW1lSW1wbCBpbXBsZW1lbnRzIFNjaGVtZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGlzVmFsaWQ6ICh1cmw6IHN0cmluZykgPT4gYm9vbGVhbikge31cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFNjaGVtZShzY2hlbWU6IFNjaGVtZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2NoZW1lIGluc3RhbmNlb2YgU2NoZW1lSW1wbDtcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2NoZW1lKHNjaGVtZTogc3RyaW5nKTogU2NoZW1lIHtcbiAgcmV0dXJuIG5ldyBTY2hlbWVJbXBsKCh1cmw6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiB1cmwuc3Vic3RyKDAsIHNjaGVtZS5sZW5ndGggKyAxKS50b0xvd2VyQ2FzZSgpID09PSBzY2hlbWUgKyAnOic7XG4gIH0pO1xufVxuXG5jb25zdCBSRUxBVElWRV9TQ0hFTUU6IFNjaGVtZSA9IG5ldyBTY2hlbWVJbXBsKCh1cmw6IHN0cmluZykgPT5cbiAgL15bXjpdKihbLz8jXXwkKS8udGVzdCh1cmwpLFxuKTtcblxuY29uc3QgQ0FMTFRPX1NDSEVNRTogU2NoZW1lID0gbmV3IFNjaGVtZUltcGwoKHVybDogc3RyaW5nKSA9PlxuICAvXmNhbGx0bzpcXCs/XFxkKiQvaS50ZXN0KHVybCksXG4pO1xuXG5jb25zdCBTU0hfU0NIRU1FOiBTY2hlbWUgPSBuZXcgU2NoZW1lSW1wbChcbiAgKHVybDogc3RyaW5nKSA9PiB1cmwuaW5kZXhPZignc3NoOi8vJykgPT09IDAsXG4pO1xuXG5jb25zdCBFWFRFTlNJT05fU0NIRU1FOiBTY2hlbWUgPSBuZXcgU2NoZW1lSW1wbCgodXJsOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIChcbiAgICB1cmwuaW5kZXhPZignY2hyb21lLWV4dGVuc2lvbjovLycpID09PSAwIHx8XG4gICAgdXJsLmluZGV4T2YoJ21vei1leHRlbnNpb246Ly8nKSA9PT0gMCB8fFxuICAgIHVybC5pbmRleE9mKCdtcy1icm93c2VyLWV4dGVuc2lvbjovLycpID09PSAwXG4gICk7XG59KTtcblxuY29uc3QgU0lQX1NDSEVNRTogU2NoZW1lID0gbmV3IFNjaGVtZUltcGwoKHVybDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiB1cmwuaW5kZXhPZignc2lwOicpID09PSAwIHx8IHVybC5pbmRleE9mKCdzaXBzOicpID09PSAwO1xufSk7XG5cbi8vIFRoaXMgdXNlZCB0byBiZSBhbiBlbnVtLCB3ZSBwcmVzZXJ2ZWQgdGhlIG5hbWUgYXZvaWQgY2hhbmdpbmcgdGhlIEFQSS5cbi8vIHRzbGludDpkaXNhYmxlOmVuZm9yY2UtbmFtZS1jYXNpbmdcbi8qKiBUaGUgbGlzdCBvZiBzY2hlbWVzIHNhbml0aXplVXJsIGNhbiBvcHRpb25hbGx5IGFjY29tbW9kYXRlLiAqL1xuZXhwb3J0IGNvbnN0IFNhbml0aXphYmxlVXJsU2NoZW1lID0ge1xuICBURUw6IHNpbXBsZVNjaGVtZSgndGVsJyksXG4gIENBTExUTzogQ0FMTFRPX1NDSEVNRSxcbiAgU1NIOiBTU0hfU0NIRU1FLFxuICBSVFNQOiBzaW1wbGVTY2hlbWUoJ3J0c3AnKSxcbiAgREFUQTogc2ltcGxlU2NoZW1lKCdkYXRhJyksXG4gIEhUVFA6IHNpbXBsZVNjaGVtZSgnaHR0cCcpLFxuICBIVFRQUzogc2ltcGxlU2NoZW1lKCdodHRwcycpLFxuICBFWFRFTlNJT046IEVYVEVOU0lPTl9TQ0hFTUUsXG4gIEZUUDogc2ltcGxlU2NoZW1lKCdmdHAnKSxcbiAgUkVMQVRJVkU6IFJFTEFUSVZFX1NDSEVNRSxcbiAgTUFJTFRPOiBzaW1wbGVTY2hlbWUoJ21haWx0bycpLFxuICBJTlRFTlQ6IHNpbXBsZVNjaGVtZSgnaW50ZW50JyksXG4gIE1BUktFVDogc2ltcGxlU2NoZW1lKCdtYXJrZXQnKSxcbiAgSVRNUzogc2ltcGxlU2NoZW1lKCdpdG1zJyksXG4gIElUTVNfQVBQU1M6IHNpbXBsZVNjaGVtZSgnaXRtcy1hcHBzcycpLFxuICBJVE1TX1NFUlZJQ0VTOiBzaW1wbGVTY2hlbWUoJ2l0bXMtc2VydmljZXMnKSxcbiAgRkFDRUJPT0tfTUVTU0VOR0VSOiBzaW1wbGVTY2hlbWUoJ2ZiLW1lc3NlbmdlcicpLFxuICBXSEFUU0FQUDogc2ltcGxlU2NoZW1lKCd3aGF0c2FwcCcpLFxuICBTSVA6IFNJUF9TQ0hFTUUsXG4gIFNNUzogc2ltcGxlU2NoZW1lKCdzbXMnKSxcbiAgVk5EX1lPVVRVQkU6IHNpbXBsZVNjaGVtZSgndm5kLnlvdXR1YmUnKSxcbn07XG4vLyB0c2xpbnQ6ZW5hYmxlOmVuZm9yY2UtbmFtZS1jYXNpbmdcblxuLyoqIExpc3Qgb2Ygc2NoZW1lcyB1c2VkIGJ5IGRlZmF1bHQuICovXG5jb25zdCBERUZBVUxUX1NDSEVNRVMgPSBbXG4gIFNhbml0aXphYmxlVXJsU2NoZW1lLkRBVEEsXG4gIFNhbml0aXphYmxlVXJsU2NoZW1lLkhUVFAsXG4gIFNhbml0aXphYmxlVXJsU2NoZW1lLkhUVFBTLFxuICBTYW5pdGl6YWJsZVVybFNjaGVtZS5NQUlMVE8sXG4gIFNhbml0aXphYmxlVXJsU2NoZW1lLkZUUCxcbiAgU2FuaXRpemFibGVVcmxTY2hlbWUuUkVMQVRJVkUsXG5dO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlVXJsIG9iamVjdCBmcm9tIGEgc3RyaW5nIGB1cmxgIGJ5IHNhbml0aXppbmcgaXQuXG4gKlxuICogTm90ZTogSWYgeW91ciB1cmwgaXMgcGFydGlhbGx5IGtub3duIHN0YXRpY2FsbHksIHlvdSBzaG91bGQgcHJlZmVyIHVzaW5nIHRoZVxuICogYHNhZmVVcmxgIGZ1bmN0aW9uIGRpcmVjdGx5LlxuICpcbiAqIFRoZSBpbnB1dCBzdHJpbmcgaXMgdmFsaWRhdGVkIGFnYWluc3QgdGhlIHNldCBvZiBgYWxsb3dlZFNjaGVtZXNgLCB3aGljaFxuICogZGVmYXVsdHMgdG8gYSBzZXQgb2YgY29tbW9ubHkgdXNlZCBzYWZlIFVSTCBzY2hlbWVzLiBJZiB2YWxpZGF0aW9uIGZhaWxzLFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgbm8gYGFsbG93ZWRTY2hlbWVzYCBhcmUgcGFzc2VkLCB0aGUgYHVybGAgbWF5IHVzZSB0aGUgaHR0cCwgaHR0cHMsIG1haWx0byxcbiAqIGZ0cCBvciBkYXRhIHNjaGVtZXMsIG9yIGEgcmVsYXRpdmUgVVJMIChpLmUuLCBhIFVSTCB3aXRob3V0IGEgc2NoZW1lO1xuICogc3BlY2lmaWNhbGx5LCBhIHNjaGVtZS1yZWxhdGl2ZSwgYWJzb2x1dGUtcGF0aC1yZWxhdGl2ZSwgb3IgcGF0aC1yZWxhdGl2ZVxuICogVVJMKS5cbiAqXG4gKiBPdGhlciBzdXBwb3J0ZWQgc2NoZW1lcyBkb24ndCBoYXZlIGRpcmVjdCBzZWN1cml0eSBpc3N1ZXMgKGkuZS4gbm8gSlNcbiAqIGV4ZWN1dGlvbiksIGJ1dCB0aGVpciBpbmhlcmVudCBjYXBhYmlsaXRpZXMgYXJlIG5vdCB0b3VjaGVkOiBmb3IgaW5zdGFuY2UsIGlmXG4gKiB5b3UgYWxsb3cgVEVMIG9ubHksIHlvdSB3b24ndCBnZXQgamF2YXNjcmlwdCBleGVjdXRpb24sIGJ1dCB0aGUgcmVzdWx0aW5nXG4gKiBsaW5rIGNvdWxkIHN0aWxsIHBvdGVudGlhbGx5IGJlIHVzZWQgdG8gY2FsbCB0b2xsIG51bWJlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlTYW5pdGl6ZVVybChcbiAgdXJsOiBzdHJpbmcgfCBTYWZlVXJsLFxuICBhbGxvd2VkU2NoZW1lczogcmVhZG9ubHkgU2NoZW1lW10gPSBERUZBVUxUX1NDSEVNRVMsXG4pOiBTYWZlVXJsIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGlzVXJsKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIFVzaW5nIHNpbXBsZSBpdGVyYXRpb24gYmVjYXVzZSB0aGUgY29tcGlsZXIgZG9lc24ndCBvcHRpbWl6ZSB0aGlzIHdlbGwgZm9yXG4gIC8vIGVzNS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxvd2VkU2NoZW1lcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHNjaGVtZSA9IGFsbG93ZWRTY2hlbWVzW2ldO1xuICAgIGlmIChpc1ZhbGlkU2NoZW1lKHNjaGVtZSkgJiYgc2NoZW1lLmlzVmFsaWQodXJsKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVVybEludGVybmFsKHVybCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNhZmVVcmwgb2JqZWN0IGZyb20gYSBzdHJpbmcgYHVybGAgYnkgc2FuaXRpemluZyBpdC5cbiAqXG4gKiBXb3JrcyB0aGUgc2FtZSB3YXkgYXMgYHRyeVNhbml0aXplVXJsYCwgYnV0IHJldHVybnMgYW4gaW5ub2N1b3VzIHVybCBpbnN0ZWFkXG4gKiBvZiBgdW5kZWZpbmVkYC5cbiAqIFRyaWdnZXJzIHRoZSBzYW5pdGl6YXRpb24gY2FsbGJhY2tzIGlmIHRoZSB1cmwgaXMgc2FuaXRpemVkIGF3YXkgKHNlZVxuICogYWRkSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplVXJsKFxuICB1cmw6IHN0cmluZyB8IFNhZmVVcmwsXG4gIGFsbG93ZWRTY2hlbWVzOiByZWFkb25seSBTY2hlbWVbXSA9IERFRkFVTFRfU0NIRU1FUyxcbik6IFNhZmVVcmwge1xuICBjb25zdCBzYW5pdGl6ZWRVcmwgPSB0cnlTYW5pdGl6ZVVybCh1cmwsIGFsbG93ZWRTY2hlbWVzKTtcbiAgaWYgKHNhbml0aXplZFVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJpZ2dlckNhbGxiYWNrcyh1cmwudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIHNhbml0aXplZFVybCB8fCBJTk5PQ1VPVVNfVVJMO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlVXJsIG9iamVjdCBmcm9tIGEgQmxvYiBvciBNZWRpYVNvdXJjZS4gRm9yIGJsb2JzLCB0aGUgZnVuY3Rpb25cbiAqIHZhbGlkYXRlcyB0aGF0IHRoZSBCbG9iJ3MgdHlwZSBpcyBhbW9uZ3N0IHRoZSBzYWZlIE1JTUUgdHlwZXMsIGFuZCB0aHJvd3MgaWZcbiAqIHRoYXQncyBub3QgdGhlIGNhc2UuXG4gKlxuICogQ2FsbGVyIG11c3QgY2FsbCBgVVJMLnJldm9rZU9iamVjdFVybCgpYCBvbiB0aGUgc3RyaW5naWZpZWQgdXJsIHRvXG4gKiByZWxlYXNlIHRoZSB1bmRlcmx5aW5nIGBCbG9iYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdFVybEZyb21TYWZlU291cmNlKHNvdXJjZTogQmxvYiB8IE1lZGlhU291cmNlKTogU2FmZVVybCB7XG4gIC8vIE1lZGlhU291cmNlIHN1cHBvcnQgaW4gU2FmYXJpIGlzIGxpbWl0ZWRcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIE1lZGlhU291cmNlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBNZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBjcmVhdGVVcmxJbnRlcm5hbChVUkwuY3JlYXRlT2JqZWN0VVJMKHNvdXJjZSkpO1xuICB9XG4gIGNvbnN0IGJsb2IgPSBzb3VyY2UgYXMgQmxvYjtcbiAgaWYgKCFpc1NhZmVNaW1lVHlwZShibG9iLnR5cGUpKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIG1lc3NhZ2UgPSBgdW5zYWZlIGJsb2IgTUlNRSB0eXBlOiAke2Jsb2IudHlwZX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVVybEludGVybmFsKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlVXJsIG9iamVjdCBmcm9tIGEgTWVkaWFTb3VyY2UuXG4gKiBAZGVwcmVjYXRlZCBVc2Ugb2JqZWN0VXJsRnJvbVNhZmVTb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWVkaWFTb3VyY2UobWVkaWE6IE1lZGlhU291cmNlKTogU2FmZVVybCB7XG4gIC8vIE1lZGlhU291cmNlIHN1cHBvcnQgaW4gU2FmYXJpIGlzIGxpbWl0ZWRcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIE1lZGlhU291cmNlICE9PSAndW5kZWZpbmVkJyAmJiBtZWRpYSBpbnN0YW5jZW9mIE1lZGlhU291cmNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVVybEludGVybmFsKFVSTC5jcmVhdGVPYmplY3RVUkwobWVkaWEpKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9ICcnO1xuICBpZiAoREVWX01PREUpIHtcbiAgICBtZXNzYWdlID0gYGZyb21NZWRpYVNvdXJjZSBvbmx5IGFjY2VwdHMgTWVkaWFTb3VyY2UgaW5zdGFuY2VzLCBidXQgd2FzIGNhbGxlZCB3aXRoICR7bWVkaWF9LmA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBTYWZlVXJsIG9iamVjdCBmcm9tIGEgVHJ1c3RlZFJlc291cmNlVXJsLiBUaGlzIGlzIHNhZmUgYmVjYXVzZVxuICogVHJ1c3RlZFJlc291cmNlVXJsIGlzIG1vcmUgdGlnaHRseSByZXN0cmljdGVkIHRoYW4gU2FmZVVybC5cbiAqIEBkZXByZWNhdGVkIFVud3JhcCB0byBzdHJpbmcgaW5zdGVhZC4gU2FmZVVybCBzaW5rcyBhY2NlcHQgc3RyaW5nIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcnVzdGVkUmVzb3VyY2VVcmwodXJsOiBUcnVzdGVkUmVzb3VyY2VVcmwpIHtcbiAgcmV0dXJuIGNyZWF0ZVVybEludGVybmFsKHVud3JhcFJlc291cmNlVXJsKHVybCkudG9TdHJpbmcoKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhpcyB1cmwgcHJlZml4IGNvbnRhaW5zOlxuICogIC0gYSBmdWxseSBzcGVjaWZpZWQgYW5kIHZhbGlkIHNjaGVtZVxuICogIC0gYSBjaGFyYWN0ZXIgZm9yY2luZyBpdCB0byBiZSBhIHJlbGF0aXZlIHVybFxuICpcbiAqIFNpbmNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgd2l0aCBjb21waWxlLXRpbWUgY29uc3RhbnRzLCB3ZSBkb24ndCBuZWVkXG4gKiB0byBiZSBhcyBjYXJlZnVsIGFzIGluIGBzYW5pdGl6ZVVybGAgYW5kIHdlIGNhbiBqdXN0IGNoZWNrIHRoYXQgdGhlIHNjaGVtZSBpc1xuICogdmFsaWQgYW5kIG5vbi0namF2YXNjcmlwdDonLiBJZiB3ZSBkaXNjb3ZlciBvdGhlciBkYW5nZXJvdXMgc2NoZW1lcyB3ZSB3YW50XG4gKiB0byBwcmV2ZW50LCB3ZSBjYW4gc3RhdGljYWxseSBmaW5kIGFsbCBpbnN0YW5jZXMgYW5kIHJlZmFjdG9yIHRoZW0uIFNlZVxuICogaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtc2NoZW1lLXN0cmluZyBmb3Igc2NoZW1lIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGlzU2FmZVVybFByZWZpeChwcmVmaXg6IHN0cmluZywgaXNXaG9sZVVybDogYm9vbGVhbik6IGJvb2xlYW4ge1xuICBjb25zdCBtYXJrZXJJZHggPSBwcmVmaXguc2VhcmNoKC9bOi8/I10vKTtcbiAgaWYgKG1hcmtlcklkeCA8IDApIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIGEgbWFya2VyLCBidXQgdGhlcmUgaXMgbm8gaW50ZXJwb2xhdGlvbiwgdGhlIHVybCBpc1xuICAgIC8vIHJlbGF0aXZlXG4gICAgcmV0dXJuIGlzV2hvbGVVcmw7XG4gIH1cbiAgaWYgKHByZWZpeC5jaGFyQXQobWFya2VySWR4KSAhPT0gJzonKSB7XG4gICAgLy8gUmVsYXRpdmUgVVJMXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBzY2hlbWUgPSBwcmVmaXguc3Vic3RyaW5nKDAsIG1hcmtlcklkeCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIC9eW2Etel1bYS16XFxkKy4tXSokLy50ZXN0KHNjaGVtZSkgJiYgc2NoZW1lICE9PSAnamF2YXNjcmlwdCc7XG59XG5cbi8qKlxuICogQnVpbGRzIGEgU2FmZVVybCBmcm9tIGEgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpZiB5b3VyIHVybCBoYXMgYSBzdGF0aWMgcHJlZml4IGNvbnRhaW5pbmcgdGhlIHdob2xlIHNjaGVtZVxuICogb2YgdGhlIHVybC5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZyBmdW5jdGlvbi4gSXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG4gKiBhIHRlbXBsYXRlIGxpdGVyYWwsIHdpdGggb3Igd2l0aG91dCBlbWJlZGRlZCBleHByZXNzaW9ucy4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICAgICAgICAgIHNhZmVVcmxgLi9zb21lcGF0aC5odG1sYDtcbiAqIG9yXG4gKiAgICAgICAgICAgICAgIHNhZmVVcmxgZGF0YTp0ZXh0L2h0bWw7YmFzZTY0LCR7YnRvYSgnPGRpdj48L2Rpdj4nKX1gO1xuICpcbiAqIFRvIGJlIHN1Y2Nlc3NmdWxseSBidWlsdCwgd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgc2NoZW1lIGlzIGNvcnJlY3RseSBkZWZpbmVkXG4gKiBhbmQgbm90IGRhbmdlcm91cy4gSW4gcHJhY3RpY2UgdGhpcyBtZWFucyB0aGUgZmlyc3QgY2h1bmsgb2YgdGhlIHRlbXBsYXRlXG4gKiBtdXN0IHNhdGlzZnkgb25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIC0gU3RhcnQgd2l0aCBhbiBleHBsaWNpdCBzY2hlbWUgdGhhdCBpcyB2YWxpZCBhbmQgaXMgbm90IGBqYXZhc2NyaXB0YFxuICogICAgKGUuZy4gc2FmZVVybGBodHRwczokey4uLn1gKVxuICogLSBTdGFydCB3aXRoIGEgcHJlZml4IHRoYXQgZW5zdXJlcyB0aGUgdXJsIGlzIHJlbGF0aXZlXG4gKiAgICAoZS5nLiBzYWZlVXJsYC4vJHsuLi59YCBvciBzYWZlVXJsYCMkey4uLn1gKVxuICogRW1iZWRkZWQgZXhwcmVzc2lvbnMgYXJlIGludGVycG9sYXRlZCBhcy1pcyBhbmQgbm8gVVJMIGVuY29kaW5nIGlzIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlVXJsKHRlbXBsYXRlT2JqOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIGFzc2VydElzVGVtcGxhdGVPYmplY3QodGVtcGxhdGVPYmosIHJlc3QubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IHRlbXBsYXRlT2JqWzBdO1xuICBpZiAoREVWX01PREUpIHtcbiAgICBpZiAoIWlzU2FmZVVybFByZWZpeChwcmVmaXgsIHJlc3QubGVuZ3RoID09PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJ5aW5nIHRvIGludGVycG9sYXRlIHdpdGggdW5zdXBwb3J0ZWQgcHJlZml4OiAke3ByZWZpeH1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB1cmxQYXJ0cyA9IFtwcmVmaXhdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3QubGVuZ3RoOyBpKyspIHtcbiAgICB1cmxQYXJ0cy5wdXNoKFN0cmluZyhyZXN0W2ldKSk7XG4gICAgdXJsUGFydHMucHVzaCh0ZW1wbGF0ZU9ialtpICsgMV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVVcmxJbnRlcm5hbCh1cmxQYXJ0cy5qb2luKCcnKSk7XG59XG5cbi8qKlxuICogQGRlZmluZVxuICovXG5jb25zdCBBU1NVTUVfSU1QTEVNRU5UU19VUkxfQVBJID0gZ29vZy5kZWZpbmUoXG4gICdBU1NVTUVfSU1QTEVNRU5UU19VUkxfQVBJJyxcbiAgLy8gVE9ETyhiLzE1NDg0NTMyNykgbmFycm93IHRoaXMgZG93biBpZiBlYXJsaWVyIGZlYXR1cmVzZXQgeWVhcnMgYWxsb3csXG4gIC8vIGlmIHRoZXkgZ2V0IGRlZmluZWQuIEZZMjAyMCBkb2VzIE5PVCBpbmNsdWRlIEVkZ2UgKEVkZ2VIVE1MKSwgd2hpY2ggaXNcbiAgLy8gZ29vZCBhcyB3b3JrYXJvdW5kcyBhcmUgbmVlZGVkIGZvciBzcGVjIGNvbXBsaWFuY2UgYW5kIGEgc2VhcmNoUGFyYW1zXG4gIC8vIHBvbHlmaWxsLlxuICBnb29nLkZFQVRVUkVTRVRfWUVBUiA+PSAyMDIwLFxuKTtcblxuLy8gVGVzdHMgZm9yIFVSTCBicm93c2VyIEFQSSBzdXBwb3J0LiBlLmcuIElFIGRvZXNuJ3Qgc3VwcG9ydCBpdC5cbmNvbnN0IHN1cHBvcnRzVVJMQVBJID0gcHVyZSgoKSA9PiB7XG4gIC8vIFRPRE8oYi8xNTUxMDYyMTApIERvZXMgdGhpcyB3b3JrIHdpdGhvdXQgSlNDb21waWxlcj9cbiAgaWYgKEFTU1VNRV9JTVBMRU1FTlRTX1VSTF9BUEkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJztcbn0pO1xuXG5mdW5jdGlvbiBsZWdhY3lFeHRyYWN0U2NoZW1lKHVybDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgYVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgdHJ5IHtcbiAgICAvLyBXZSBkb24ndCB1c2UgdGhlIHNhZmUgd3JhcHBlciBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBzYW5pdGl6ZSB0aGVcbiAgICAvLyBVUkwgKHdoaWNoIHdvdWxkIGxlYWQgdG8gYSBkZXBlbmRlbmN5IGxvb3AgYW55d2F5KS4gVGhpcyBpcyBzYWZlIGJlY2F1c2VcbiAgICAvLyB0aGlzIG5vZGUgaXMgTkVWRVIgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICBhVGFnLmhyZWYgPSB1cmw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIENocm9tZSBhbmQgRmlyZWZveCByZXNvbHZlIHJlbGF0aXZlIHNjaGVtZSB0byBodHRwcyBkaXJlY3RseSxcbiAgLy8gd2hpbGUgSUUga2VlcHMgYSAnOicgb3IgZW1wdHkgc3RyaW5nIHByb3RvY29sLlxuICBjb25zdCBwcm90b2NvbCA9IGFUYWcucHJvdG9jb2w7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJzonIHx8IHByb3RvY29sID09PSAnJyA/ICdodHRwczonIDogcHJvdG9jb2w7XG59XG5cbnR5cGUgSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrID0gKHVybDogc3RyaW5nKSA9PiB2b2lkO1xuLy8gRU5ELUlOVEVSTkFMXG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIHNjaGVtZSBmcm9tIHRoZSBnaXZlbiBVUkwuIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIGh0dHBzOiBpc1xuICogYXNzdW1lZC5cbiAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBleHRyYWN0IHRoZSBzY2hlbWUgZnJvbS5cbiAqIEByZXR1cm4gdGhlIFVSTCBzY2hlbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2NoZW1lKHVybDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gQkVHSU4tSU5URVJOQUxcbiAgLy8gV2UgZGVmZXIgdG8gdGhlIGJyb3dzZXIgVVJMIHBhcnNpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSB0byBkZXRlY3RcbiAgLy8gamF2YXNjcmlwdDogc2NoZW1lcy4gSG93ZXZlciwgb2xkIGJyb3dzZXJzIGxpa2UgSUUgZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgaWYgKCFzdXBwb3J0c1VSTEFQSSkge1xuICAgIHJldHVybiBsZWdhY3lFeHRyYWN0U2NoZW1lKHVybCk7XG4gIH1cbiAgLy8gRU5ELUlOVEVSTkFMXG4gIGxldCBwYXJzZWRVcmw7XG4gIHRyeSB7XG4gICAgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uc3RydWN0b3JzLCB0aGUgVVJMXG4gICAgLy8gY29uc3RydWN0b3Igd2l0aCBvbmUgcGFyYW1ldGVyIHRocm93cyBpZiBgdXJsYCBpcyBub3QgYWJzb2x1dGUuIEluIHRoaXNcbiAgICAvLyBjYXNlLCB3ZSBhcmUgc3VyZSB0aGF0IG5vIGV4cGxpY2l0IHNjaGVtZSAoamF2YXNjcmlwdDogKSBpcyBzZXQuXG4gICAgLy8gVGhpcyBjYW4gYWxzbyBiZSBhIFVSTCBwYXJzaW5nIGVycm9yLCBidXQgaW4gdGhpcyBjYXNlIHRoZSBVUkwgd29uJ3QgYmVcbiAgICAvLyBydW4gYW55d2F5LlxuICAgIHJldHVybiAnaHR0cHM6JztcbiAgfVxuICByZXR1cm4gcGFyc2VkVXJsLnByb3RvY29sO1xufVxuXG4vLyBXZSBjYW4ndCB1c2UgYW4gRVM2IFNldCBoZXJlIGJlY2F1c2UgZ3dzIHNvbWVob3cgZGVwZW5kcyBvbiB0aGlzIGNvZGUgYW5kXG4vLyBkb2Vzbid0IHdhbnQgdG8gcGF5IHRoZSBjb3N0IG9mIGEgcG9seWZpbGwuXG5jb25zdCBBTExPV0VEX1NDSEVNRVMgPSBbJ2RhdGE6JywgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JywgJ2Z0cDonXTtcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCBibG9ja3MgamF2YXNjcmlwdDogVVJMcy4gTWF0Y2hlc1xuICogKGEpIFVybHMgd2l0aCBhbiBleHBsaWNpdCBzY2hlbWUgdGhhdCBpcyBub3QgamF2YXNjcmlwdCBhbmQgdGhhdCBvbmx5IGhhc1xuICogICAgIGFscGhhbnVtZXJpYyBvciBbLi0rX10gY2hhcmFjdGVyczsgb3JcbiAqIChiKSBVcmxzIHdpdGggbm8gZXhwbGljaXQgc2NoZW1lLiBUaGUgcGF0dGVybiBhbGxvd3MgdGhlIGZpcnN0IGNvbG9uXG4gKiAgICAgKGA6YCkgY2hhcmFjdGVyIHRvIGFwcGVhciBhZnRlciBvbmUgb2YgIHRoZSBgL2AgYD9gIG9yIGAjYCBjaGFyYWN0ZXJzLFxuICogICAgIHdoaWNoIG1lYW5zIHRoZSBjb2xvbiBhcHBlYXJzIGluIHBhdGgsIHF1ZXJ5IG9yIGZyYWdtZW50IHBhcnQgb2YgdGhlIFVSTC5cbiAqL1xuZXhwb3J0IGNvbnN0IElTX05PVF9KQVZBU0NSSVBUX1VSTF9QQVRURVJOID1cbiAgL15cXHMqKD8hamF2YXNjcmlwdDopKD86W1xcdysuLV0rOnxbXjovPyNdKig/OlsvPyNdfCQpKS9pO1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdXJscyBoYXMgYSBgamF2YXNjcmlwdDpgIHNjaGVtZS5cbiAqIElmIHRoZSB1cmwgaGFzIGEgYGphdmFzY3JpcHQ6YCBzY2hlbWUsIHJlcG9ydHMgaXQgYW5kIHJldHVybnMgdHJ1ZS5cbiAqIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEphdmFTY3JpcHRVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgaGFzSmF2YXNjcmlwdFVybFNjaGVtZSA9ICFJU19OT1RfSkFWQVNDUklQVF9VUkxfUEFUVEVSTi50ZXN0KHVybCk7XG4gIGlmIChoYXNKYXZhc2NyaXB0VXJsU2NoZW1lKSB7XG4gICAgLy8gQkVHSU4tRVhURVJOQUxcbiAgICAvLyBpZiAoREVWX01PREUpIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IoYEEgVVJMIHdpdGggY29udGVudCAnJHt1cmx9JyB3YXMgc2FuaXRpemVkIGF3YXkuYCk7XG4gICAgLy8gfVxuICAgIC8vIEVORC1FWFRFUk5BTFxuICAgIHRyaWdnZXJDYWxsYmFja3ModXJsKTsgLy8gTElORS1JTlRFUk5BTFxuICB9XG4gIHJldHVybiBoYXNKYXZhc2NyaXB0VXJsU2NoZW1lO1xufVxuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBVUkwgc2NoZW1lIGlzIG5vdCBqYXZhc2NyaXB0LlxuICogVGhlIFVSTCBwYXJzaW5nIHJlbGllcyBvbiB0aGUgVVJMIEFQSSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG4gKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gc2FuaXRpemUgZm9yIGEgU2FmZVVybCBzaW5rLlxuICogQHJldHVybiB1bmRlZmluZWQgaWYgdXJsIGhhcyBhIGphdmFzY3JpcHQ6IHNjaGVtZSwgdGhlIG9yaWdpbmFsIFVSTFxuICogICAgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplSmF2YVNjcmlwdFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChyZXBvcnRKYXZhU2NyaXB0VXJsKHVybCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIFR5cGUgYWxpYXMgZm9yIFVSTHMgcGFzc2VkIHRvIERPTSBzaW5rIHdyYXBwZXJzLlxuICovXG5leHBvcnQgdHlwZSBVcmwgPSBzdHJpbmcgfCBTYWZlVXJsO1xuLy8gRU5ELUlOVEVSTkFMXG4vLyBCRUdJTi1FWFRFUk5BTFxuLy8gLyoqXG4vLyAgKiBUeXBlIGFsaWFzIGZvciBVUkxzIHBhc3NlZCB0byBET00gc2luayB3cmFwcGVycy5cbi8vICAqL1xuLy8gZXhwb3J0IHR5cGUgVXJsID0gc3RyaW5nO1xuLy8gRU5ELUVYVEVSTkFMXG5cbi8vIEJFR0lOLUVYVEVSTkFMXG4vLyAvKipcbi8vICAqIEFkYXB0ZXIgdG8gc2FuaXRpemUgc3RyaW5nIFVSTHMgaW4gRE9NIHNpbmsgd3JhcHBlcnMuXG4vLyAgKiBAcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgVVJMIHdhcyBzYW5pdGl6ZWQuXG4vLyAgKi9cbi8vIEVORC1FWFRFUk5BTFxuLy8gQkVHSU4tSU5URVJOQUxcbi8qKlxuICogQWRhcHRlciB0byBzdXBwb3J0IHN0cmluZyBhbmQgU2FmZVVybCBpbiBET00gc2luayB3cmFwcGVycy5cbiAqIEByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBVUkwgd2FzIHNhbml0aXplZC5cbiAqL1xuLy8gRU5ELUlOVEVSTkFMXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwVXJsT3JTYW5pdGl6ZSh1cmw6IFVybCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIHJldHVybiB1cmwgaW5zdGFuY2VvZiBTYWZlVXJsID8gdW53cmFwVXJsKHVybCkgOiBzYW5pdGl6ZUphdmFTY3JpcHRVcmwodXJsKTtcbiAgLy8gRU5ELUlOVEVSTkFMXG4gIC8vIExJTkUtRVhURVJOQUwgcmV0dXJuIHNhbml0aXplSmF2YVNjcmlwdFVybCh1cmwpO1xufVxuXG4vKipcbiAqIFNhbml0aXplcyBhIFVSTCByZXN0cmljdGl2ZWx5LlxuICogVGhpcyBzYW5pdGl6ZXIgcHJvdGVjdHMgYWdhaW5zdCBYU1MgYW5kIHBvdGVudGlhbGx5IG90aGVyIHVuY29tbW9uIGFuZFxuICogdW5kZXNpcmFibGUgc2NoZW1lcyB0aGF0IGFuIGF0dGFja2VyIGNvdWxkIHVzZSBlLmcuIHBoaXNoaW5nICh0ZWw6LCBjYWxsdG86XG4gKiBzc2g6IGV0YyBzY2hlbWVzKS4gVGhpcyBzYW5pdGl6ZXIgaXMgcHJpbWFyaWx5IG1lYW50IHRvIGJlIHVzZWQgYnkgdGhlIEhUTUxcbiAqIHNhbml0aXplci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RyaWN0aXZlbHlTYW5pdGl6ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnNlZFNjaGVtZSA9IGV4dHJhY3RTY2hlbWUodXJsKTtcbiAgaWYgKFxuICAgIHBhcnNlZFNjaGVtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgQUxMT1dFRF9TQ0hFTUVTLmluZGV4T2YocGFyc2VkU2NoZW1lLnRvTG93ZXJDYXNlKCkpICE9PSAtMVxuICApIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIC8vIFRoZSBzYW5pdGl6ZXIgdXNlZCB0byBzYW5pdGl6ZSBVUkxzIHdpdGggU2FmZVVybCdzIHNhbml0aXplVXJsIHdoaWNoXG4gIC8vIHJldHVybnMgdGhpcyBpbm5vY3VvdXMgVVJMLiBXZSBuZWVkIHRvIGtlZXAgdGhpcyBiZWhhdmlvciBoZXJlIGJlY2F1c2Ugc29tZVxuICAvLyBnb2xkZW4gdGVzdHMgc3RpbGwgZXhwZWN0IHRoaXMgdmFsdWUuXG4gIC8vIFRPRE8oYi8yMzg4NjE0ODkpOiByZXR1cm4gYSBzaG9ydCBpbm5vY3VvdXMgVVJMXG4gIC8vIEVORC1JTlRFUk5BTFxuICByZXR1cm4gJ2Fib3V0OmludmFsaWQjekNsb3N1cmV6Jztcbn1cblxuLy8gQkVHSU4tSU5URVJOQUxcblxuLy8gV2UgbmVlZCB0byBhdm9pZCB1c2luZyBFUzYgU2V0cyBoZXJlIHRvIGF2b2lkIHRoZSBleHBlbnNzaXZlIEVTNSBwb2x5ZmlsbC5cbi8vIFRoaXMgaXMgYWNjZXB0YWJsZSBhbnl3YXkgYmVjYXVzZSB0aGlzIGFycmF5IHNob3VsZCBoYXZlIG9ubHkgZmV3IGVsZW1lbnRzLlxuY29uc3Qgc2FuaXRpemF0aW9uQ2FsbGJhY2tzOiBKYXZhU2NyaXB0VXJsU2FuaXRpemF0aW9uQ2FsbGJhY2tbXSA9IFtdO1xuXG4vLyBUaGlzIGNhbGxiYWNrIGlzIHJlLWRlZmluZWQgd2hlbiBhIG5ldyBjYWxsYmFjayBpcyByZWdpc3RlcmVkL3JlbW92ZWQuXG4vLyBXaGVuIG5vIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQsIHRoZXJlIGFyZSBubyByZWZlcmVuY2VzIHRvIHRoZVxuLy8gc2FuaXRpemF0aW9uQ2FsbGJhY2tzIGFycmF5LCB3aGljaCBtYWtlIGl0IHBvc3NpYmxlIGZvciB0aGUgY29tcGlsZXIgdG9cbi8vIG9wdGltaXplIGl0IGF3YXkuXG5sZXQgdHJpZ2dlckNhbGxiYWNrczogKHVybDogc3RyaW5nKSA9PiB2b2lkID0gKHVybDogc3RyaW5nKSA9PiB7fTtcbmlmIChERVZfTU9ERSkge1xuICBhZGRKYXZhU2NyaXB0VXJsU2FuaXRpemF0aW9uQ2FsbGJhY2soKHVybDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBBIFVSTCB3aXRoIGNvbnRlbnQgJyR7dXJsfScgd2FzIHNhbml0aXplZCBhd2F5LmApO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBzYW5pdGl6YXRpb24gY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBqYXZhc2NyaXB0OiBVUkxcbiAqIGlzIHNhbml0aXplZCBhd2F5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrKFxuICBjYWxsYmFjazogSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrLFxuKTogdm9pZCB7XG4gIGlmIChzYW5pdGl6YXRpb25DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgc2FuaXRpemF0aW9uQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9XG4gIHRyaWdnZXJDYWxsYmFja3MgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICBzYW5pdGl6YXRpb25DYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKHVybCk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogVW5yZWdpc3RlciB0aGUgSmF2YVNjcmlwdCBVUkwgc2FuaXRpemF0aW9uIGNhbGxiYWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrKFxuICBjYWxsYmFjazogSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrLFxuKTogdm9pZCB7XG4gIGNvbnN0IGNhbGxiYWNrSW5kZXggPSBzYW5pdGl6YXRpb25DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gIGlmIChjYWxsYmFja0luZGV4ICE9PSAtMSkge1xuICAgIHNhbml0aXphdGlvbkNhbGxiYWNrcy5zcGxpY2UoY2FsbGJhY2tJbmRleCwgMSk7XG4gIH1cbn1cbi8vIEVORC1JTlRFUk5BTFxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/anchor.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/anchor.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.anchor');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/anchor.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * Sets the Href attribute from the given Url.
 * @param {!HTMLAnchorElement} anchor
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setHref(anchor, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        anchor.href = sanitizedUrl;
    }
}
exports.setHref = setHref;
// BEGIN-INTERNAL
/**
 * Same as the function above, but with the smallest amount of code.
 * This function will replace the one above once we have confirmed that it
 * doen't break any tests potentially mocking the underlying DOM APIs.
 * @param {!HTMLAnchorElement} anchor
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setHrefLite(anchor, url) {
    // Here we rely on the fact that `SafeUrl` will automatically stringify to
    // it's value when checked with a Regex and/or used in a DOM API.
    if (!(0, url_builders_1.reportJavaScriptUrl)((/** @type {string} */ ((/** @type {*} */ (url)))))) {
        anchor.href = (/** @type {string} */ ((/** @type {*} */ (url))));
    }
}
exports.setHrefLite = setHrefLite;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5jaG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9hbmNob3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHVHQUlxQzs7Ozs7OztBQUtyQyxTQUFnQixPQUFPLENBQUMsTUFBeUIsRUFBRSxHQUFROztVQUNuRCxZQUFZLEdBQUcsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUM7SUFDN0MsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDL0IsTUFBTSxDQUFDLElBQUksR0FBRyxZQUFZLENBQUM7SUFDN0IsQ0FBQztBQUNILENBQUM7QUFMRCwwQkFLQzs7Ozs7Ozs7OztBQVFELFNBQWdCLFdBQVcsQ0FBQyxNQUF5QixFQUFFLEdBQVE7SUFDN0QsMEVBQTBFO0lBQzFFLGlFQUFpRTtJQUNqRSxJQUFJLENBQUMsSUFBQSxrQ0FBbUIsRUFBQyx3QkFBQSxtQkFBQSxHQUFHLEVBQVcsRUFBVSxDQUFDLEVBQUUsQ0FBQztRQUNuRCxNQUFNLENBQUMsSUFBSSxHQUFHLHdCQUFBLG1CQUFBLEdBQUcsRUFBVyxFQUFVLENBQUM7SUFDekMsQ0FBQztBQUNILENBQUM7QUFORCxrQ0FNQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtcbiAgcmVwb3J0SmF2YVNjcmlwdFVybCwgLy8gTElORS1JTlRFUk5BTFxuICB1bndyYXBVcmxPclNhbml0aXplLFxuICBVcmwsXG59IGZyb20gJy4uLy4uL2J1aWxkZXJzL3VybF9idWlsZGVycyc7XG5cbi8qKlxuICogU2V0cyB0aGUgSHJlZiBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gVXJsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SHJlZihhbmNob3I6IEhUTUxBbmNob3JFbGVtZW50LCB1cmw6IFVybCkge1xuICBjb25zdCBzYW5pdGl6ZWRVcmwgPSB1bndyYXBVcmxPclNhbml0aXplKHVybCk7XG4gIGlmIChzYW5pdGl6ZWRVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFuY2hvci5ocmVmID0gc2FuaXRpemVkVXJsO1xuICB9XG59XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIFNhbWUgYXMgdGhlIGZ1bmN0aW9uIGFib3ZlLCBidXQgd2l0aCB0aGUgc21hbGxlc3QgYW1vdW50IG9mIGNvZGUuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVwbGFjZSB0aGUgb25lIGFib3ZlIG9uY2Ugd2UgaGF2ZSBjb25maXJtZWQgdGhhdCBpdFxuICogZG9lbid0IGJyZWFrIGFueSB0ZXN0cyBwb3RlbnRpYWxseSBtb2NraW5nIHRoZSB1bmRlcmx5aW5nIERPTSBBUElzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SHJlZkxpdGUoYW5jaG9yOiBIVE1MQW5jaG9yRWxlbWVudCwgdXJsOiBVcmwpIHtcbiAgLy8gSGVyZSB3ZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgYFNhZmVVcmxgIHdpbGwgYXV0b21hdGljYWxseSBzdHJpbmdpZnkgdG9cbiAgLy8gaXQncyB2YWx1ZSB3aGVuIGNoZWNrZWQgd2l0aCBhIFJlZ2V4IGFuZC9vciB1c2VkIGluIGEgRE9NIEFQSS5cbiAgaWYgKCFyZXBvcnRKYXZhU2NyaXB0VXJsKHVybCBhcyB1bmtub3duIGFzIHN0cmluZykpIHtcbiAgICBhbmNob3IuaHJlZiA9IHVybCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgfVxufVxuLy8gRU5ELUlOVEVSTkFMXG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/elements/area.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/area.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.area');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/area.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * Sets the Href attribute from the given Url.
 * @param {!HTMLAreaElement} area
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setHref(area, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        area.href = sanitizedUrl;
    }
}
exports.setHref = setHref;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJlYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvYXJlYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsdUdBQXFFOzs7Ozs7O0FBS3JFLFNBQWdCLE9BQU8sQ0FBQyxJQUFxQixFQUFFLEdBQVE7O1VBQy9DLFlBQVksR0FBRyxJQUFBLGtDQUFtQixFQUFDLEdBQUcsQ0FBQztJQUM3QyxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQztJQUMzQixDQUFDO0FBQ0gsQ0FBQztBQUxELDBCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge3Vud3JhcFVybE9yU2FuaXRpemUsIFVybH0gZnJvbSAnLi4vLi4vYnVpbGRlcnMvdXJsX2J1aWxkZXJzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBIcmVmIGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBVcmwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRIcmVmKGFyZWE6IEhUTUxBcmVhRWxlbWVudCwgdXJsOiBVcmwpIHtcbiAgY29uc3Qgc2FuaXRpemVkVXJsID0gdW53cmFwVXJsT3JTYW5pdGl6ZSh1cmwpO1xuICBpZiAoc2FuaXRpemVkVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcmVhLmhyZWYgPSBzYW5pdGl6ZWRVcmw7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/elements/base.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/base.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.base');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/base.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_2 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/**
 * Sets the Href attribute from the given TrustedResourceUrl.
 * @param {!HTMLBaseElement} baseEl
 * @param {!tsickle_TrustedResourceUrl_2} url
 * @return {void}
 */
function setHref(baseEl, url) {
    baseEl.href = (/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(url)));
}
exports.setHref = setHref;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esa0hBRzJDOzs7Ozs7O0FBSzNDLFNBQWdCLE9BQU8sQ0FBQyxNQUF1QixFQUFFLEdBQXVCO0lBQ3RFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsd0JBQUEsSUFBQSxxQ0FBaUIsRUFBQyxHQUFHLENBQUMsRUFBVSxDQUFDO0FBQ2pELENBQUM7QUFGRCwwQkFFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtcbiAgVHJ1c3RlZFJlc291cmNlVXJsLFxuICB1bndyYXBSZXNvdXJjZVVybCxcbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsJztcblxuLyoqXG4gKiBTZXRzIHRoZSBIcmVmIGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBUcnVzdGVkUmVzb3VyY2VVcmwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRIcmVmKGJhc2VFbDogSFRNTEJhc2VFbGVtZW50LCB1cmw6IFRydXN0ZWRSZXNvdXJjZVVybCkge1xuICBiYXNlRWwuaHJlZiA9IHVud3JhcFJlc291cmNlVXJsKHVybCkgYXMgc3RyaW5nO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/button.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/button.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.button');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/button.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * Sets the Formaction attribute from the given Url.
 * @param {!HTMLButtonElement} button
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setFormaction(button, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        button.formAction = sanitizedUrl;
    }
}
exports.setFormaction = setFormaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9idXR0b24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHVHQUFxRTs7Ozs7OztBQUtyRSxTQUFnQixhQUFhLENBQUMsTUFBeUIsRUFBRSxHQUFROztVQUN6RCxZQUFZLEdBQUcsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUM7SUFDN0MsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDL0IsTUFBTSxDQUFDLFVBQVUsR0FBRyxZQUFZLENBQUM7SUFDbkMsQ0FBQztBQUNILENBQUM7QUFMRCxzQ0FLQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHt1bndyYXBVcmxPclNhbml0aXplLCBVcmx9IGZyb20gJy4uLy4uL2J1aWxkZXJzL3VybF9idWlsZGVycyc7XG5cbi8qKlxuICogU2V0cyB0aGUgRm9ybWFjdGlvbiBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gVXJsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Rm9ybWFjdGlvbihidXR0b246IEhUTUxCdXR0b25FbGVtZW50LCB1cmw6IFVybCkge1xuICBjb25zdCBzYW5pdGl6ZWRVcmwgPSB1bndyYXBVcmxPclNhbml0aXplKHVybCk7XG4gIGlmIChzYW5pdGl6ZWRVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgIGJ1dHRvbi5mb3JtQWN0aW9uID0gc2FuaXRpemVkVXJsO1xuICB9XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/internals/attribute_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Internal implementations of SafeAttributePrefix.
 * Generated from: third_party/javascript/safevalues/internals/attribute_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.attribute_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/attribute_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_secrets_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.secrets");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const secrets_1 = goog.require('google3.third_party.javascript.safevalues.internals.secrets');
/**
 * A prefix with which an attribute is safe to set using plain strings.
 */
class SafeAttributePrefix {
    /**
     * @private
     * @param {!Object} token
     * @param {string} value
     */
    constructor(token, value) {
        if (dev_1.DEV_MODE) {
            (0, secrets_1.ensureTokenIsValid)(token);
        }
        this.privateDoNotAccessOrElseWrappedAttributePrefix = value;
    }
    /**
     * @public
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedAttributePrefix;
    }
}
exports.SafeAttributePrefix = SafeAttributePrefix;
/* istanbul ignore if */
if (false) {
    /**
     * @const {string}
     * @private
     */
    SafeAttributePrefix.prototype.privateDoNotAccessOrElseWrappedAttributePrefix;
}
// WARNING: interface has both a type and a value, skipping emit
/** @type {function(new:SafeAttributePrefix, !Object, string)} */
const AttributePrefixImpl = (/** @type {function(new:SafeAttributePrefix, !Object, string)} */ (SafeAttributePrefix));
/**
 * Builds a new `SafeAttributePrefix` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} value
 * @return {!SafeAttributePrefix}
 */
function createAttributePrefixInternal(value) {
    return new AttributePrefixImpl(secrets_1.secretToken, value);
}
exports.createAttributePrefixInternal = createAttributePrefixInternal;
/**
 * Checks if the given value is a `SafeAttributePrefix` instance.
 * @param {*} value
 * @return {boolean}
 */
function isAttributePrefix(value) {
    return value instanceof SafeAttributePrefix;
}
exports.isAttributePrefix = isAttributePrefix;
/**
 * Returns the string value of the passed `SafeAttributePrefix` object while
 * ensuring it has the correct type.
 * @param {!SafeAttributePrefix} value
 * @return {string}
 */
function unwrapAttributePrefix(value) {
    if (isAttributePrefix(value)) {
        return ((/** @type {?} */ ((/** @type {*} */ (value)))))
            .privateDoNotAccessOrElseWrappedAttributePrefix;
    }
    /** @type {string} */
    let message = '';
    if (dev_1.DEV_MODE) {
        message = `Unexpected type when unwrapping SafeAttributePrefix, got '${value}' of type '${typeof value}'`;
    }
    throw new Error(message);
}
exports.unwrapAttributePrefix = unwrapAttributePrefix;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXR0cmlidXRlX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW50ZXJuYWxzL2F0dHJpYnV0ZV9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQSx3RkFBNEM7QUFFNUMsOEZBQTBEOzs7O0FBSzFELE1BQWEsbUJBQW1COzs7Ozs7SUFHOUIsWUFBb0IsS0FBYSxFQUFFLEtBQWE7UUFDOUMsSUFBSSxjQUFRLEVBQUUsQ0FBQztZQUNiLElBQUEsNEJBQWtCLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUVELElBQUksQ0FBQyw4Q0FBOEMsR0FBRyxLQUFLLENBQUM7SUFDOUQsQ0FBQzs7Ozs7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsOENBQThDLENBQUM7SUFDN0QsQ0FBQztDQUNGO0FBZEQsa0RBY0M7Ozs7Ozs7SUFiQyw2RUFBd0U7Ozs7TUFrQnBFLG1CQUFtQixHQUFHLG9FQUFBLG1CQUFtQixFQUU5Qzs7Ozs7Ozs7QUFPRCxTQUFnQiw2QkFBNkIsQ0FDM0MsS0FBYTtJQUViLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxxQkFBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUFKRCxzRUFJQzs7Ozs7O0FBS0QsU0FBZ0IsaUJBQWlCLENBQy9CLEtBQWM7SUFFZCxPQUFPLEtBQUssWUFBWSxtQkFBbUIsQ0FBQztBQUM5QyxDQUFDO0FBSkQsOENBSUM7Ozs7Ozs7QUFNRCxTQUFnQixxQkFBcUIsQ0FBQyxLQUEwQjtJQUM5RCxJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDN0IsT0FBTyxDQUFDLG1CQUFBLG1CQUFBLEtBQUssRUFBVyxFQUF1QixDQUFDO2FBQzdDLDhDQUE4QyxDQUFDO0lBQ3BELENBQUM7O1FBQ0csT0FBTyxHQUFHLEVBQUU7SUFDaEIsSUFBSSxjQUFRLEVBQUUsQ0FBQztRQUNiLE9BQU8sR0FBRyw2REFBNkQsS0FBSyxjQUFjLE9BQU8sS0FBSyxHQUFHLENBQUM7SUFDNUcsQ0FBQztJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQVZELHNEQVVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKiogQGZpbGVvdmVydmlldyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbnMgb2YgU2FmZUF0dHJpYnV0ZVByZWZpeC4gKi9cblxuaW1wb3J0IHtERVZfTU9ERX0gZnJvbSAnLi4vZW52aXJvbm1lbnQvZGV2JztcblxuaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuXG4vKipcbiAqIEEgcHJlZml4IHdpdGggd2hpY2ggYW4gYXR0cmlidXRlIGlzIHNhZmUgdG8gc2V0IHVzaW5nIHBsYWluIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYWZlQXR0cmlidXRlUHJlZml4IHtcbiAgcHJpdmF0ZSByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkQXR0cmlidXRlUHJlZml4OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih0b2tlbjogb2JqZWN0LCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICBlbnN1cmVUb2tlbklzVmFsaWQodG9rZW4pO1xuICAgIH1cblxuICAgIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZEF0dHJpYnV0ZVByZWZpeCA9IHZhbHVlO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkQXR0cmlidXRlUHJlZml4O1xuICB9XG59XG5cbmludGVyZmFjZSBBdHRyaWJ1dGVQcmVmaXhJbXBsIHtcbiAgcHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZEF0dHJpYnV0ZVByZWZpeDogc3RyaW5nO1xufVxuY29uc3QgQXR0cmlidXRlUHJlZml4SW1wbCA9IFNhZmVBdHRyaWJ1dGVQcmVmaXggYXMge1xuICBuZXcgKHRva2VuOiBvYmplY3QsIHZhbHVlOiBzdHJpbmcpOiBTYWZlQXR0cmlidXRlUHJlZml4O1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBuZXcgYFNhZmVBdHRyaWJ1dGVQcmVmaXhgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZVByZWZpeEludGVybmFsKFxuICB2YWx1ZTogc3RyaW5nLFxuKTogU2FmZUF0dHJpYnV0ZVByZWZpeCB7XG4gIHJldHVybiBuZXcgQXR0cmlidXRlUHJlZml4SW1wbChzZWNyZXRUb2tlbiwgdmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBgU2FmZUF0dHJpYnV0ZVByZWZpeGAgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0F0dHJpYnV0ZVByZWZpeChcbiAgdmFsdWU6IHVua25vd24sXG4pOiB2YWx1ZSBpcyBTYWZlQXR0cmlidXRlUHJlZml4IHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2FmZUF0dHJpYnV0ZVByZWZpeDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIHBhc3NlZCBgU2FmZUF0dHJpYnV0ZVByZWZpeGAgb2JqZWN0IHdoaWxlXG4gKiBlbnN1cmluZyBpdCBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcEF0dHJpYnV0ZVByZWZpeCh2YWx1ZTogU2FmZUF0dHJpYnV0ZVByZWZpeCk6IHN0cmluZyB7XG4gIGlmIChpc0F0dHJpYnV0ZVByZWZpeCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gKHZhbHVlIGFzIHVua25vd24gYXMgQXR0cmlidXRlUHJlZml4SW1wbClcbiAgICAgIC5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkQXR0cmlidXRlUHJlZml4O1xuICB9XG4gIGxldCBtZXNzYWdlID0gJyc7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIG1lc3NhZ2UgPSBgVW5leHBlY3RlZCB0eXBlIHdoZW4gdW53cmFwcGluZyBTYWZlQXR0cmlidXRlUHJlZml4LCBnb3QgJyR7dmFsdWV9JyBvZiB0eXBlICcke3R5cGVvZiB2YWx1ZX0nYDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/closure/array/array.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for manipulating arrays.
 */


goog.module('goog.array');
goog.module.declareLegacyNamespace();

const asserts = goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.NATIVE_ARRAY_PROTOTYPES =
    goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., `Array#filter`) and remove the
 * unused pure JS implementation.
 */
const ASSUME_NATIVE_FUNCTIONS = goog.define(
    'goog.array.ASSUME_NATIVE_FUNCTIONS', goog.FEATURESET_YEAR > 2012);
exports.ASSUME_NATIVE_FUNCTIONS = ASSUME_NATIVE_FUNCTIONS;


/**
 * Returns the last element in an array without removing it.
 * Same as {@link goog.array.last}.
 * @param {IArrayLike<T>|string} array The array.
 * @return {T} Last item in array.
 * @template T
 */
function peek(array) {
  return array[array.length - 1];
}
exports.peek = peek;


/**
 * Returns the last element in an array without removing it.
 * Same as {@link goog.array.peek}.
 * @param {IArrayLike<T>|string} array The array.
 * @return {T} Last item in array.
 * @template T
 */
exports.last = peek;

// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {IArrayLike<T>|string} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
const indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ?
    function(arr, obj, opt_fromIndex) {
      asserts.assert(arr.length != null);

      return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      const fromIndex = opt_fromIndex == null ?
          0 :
          (opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) :
                               opt_fromIndex);

      if (typeof arr === 'string') {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (typeof obj !== 'string' || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (let i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj) return i;
      }
      return -1;
    };
exports.indexOf = indexOf;


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!IArrayLike<T>|string} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
const lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ?
    function(arr, obj, opt_fromIndex) {
      asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      const fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      let fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (typeof arr === 'string') {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (typeof obj !== 'string' || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (let i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj) return i;
      }
      return -1;
    };
exports.lastIndexOf = lastIndexOf;


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {IArrayLike<T>|string} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
const forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      Array.prototype.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
        }
      }
    };
exports.forEach = forEach;


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
function forEachRight(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
    }
  }
}
exports.forEachRight = forEachRight;


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
const filter = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const res = [];
      let resLength = 0;
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          const val = arr2[i];  // in case f mutates arr2
          if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };
exports.filter = filter;


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {IArrayLike<VALUE>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
 *     for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return something. The result will be
 *     inserted into a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array<RESULT>} a new array with the results from f.
 * @template THIS, VALUE, RESULT
 */
const map = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const res = new Array(l);
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
        }
      }
      return res;
    };
exports.map = map;


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 * Note that this implementation differs from the native Array.prototype.reduce
 * in that the initial value is assumed to be defined (the MDN docs linked above
 * recommend not omitting this parameter, although it is technically optional).
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
const reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ?
    function(arr, f, val, opt_obj) {
      asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return Array.prototype.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      let rval = val;
      forEach(arr, function(val, index) {
        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
      });
      return rval;
    };
exports.reduce = reduce;


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
const reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ?
    function(arr, f, val, opt_obj) {
      asserts.assert(arr.length != null);
      asserts.assert(f != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return Array.prototype.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      let rval = val;
      forEachRight(arr, function(val, index) {
        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
      });
      return rval;
    };
exports.reduceRight = reduceRight;


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
const some = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };
exports.some = some;


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
const every = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2 && !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };
exports.every = every;


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!IArrayLike<T>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
function count(arr, f, opt_obj) {
  let count = 0;
  forEach(arr, function(element, index, arr) {
    if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
}
exports.count = count;


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
function find(arr, f, opt_obj) {
  const i = findIndex(arr, f, opt_obj);
  return i < 0 ? null : typeof arr === 'string' ? arr.charAt(i) : arr[i];
}
exports.find = find;


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
function findIndex(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = 0; i < l; i++) {
    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
exports.findIndex = findIndex;


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
function findRight(arr, f, opt_obj) {
  const i = findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : typeof arr === 'string' ? arr.charAt(i) : arr[i];
}
exports.findRight = findRight;


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
function findIndexRight(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
exports.findIndexRight = findIndexRight;


/**
 * Whether the array contains the given object.
 * @param {IArrayLike<?>|string} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
function contains(arr, obj) {
  return indexOf(arr, obj) >= 0;
}
exports.contains = contains;


/**
 * Whether the array is empty.
 * @param {IArrayLike<?>|string} arr The array to test.
 * @return {boolean} true if empty.
 */
function isEmpty(arr) {
  return arr.length == 0;
}
exports.isEmpty = isEmpty;


/**
 * Clears the array.
 * @param {IArrayLike<?>} arr Array or array like object to clear.
 */
function clear(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!Array.isArray(arr)) {
    for (let i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
}
exports.clear = clear;


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
function insert(arr, obj) {
  if (!contains(arr, obj)) {
    arr.push(obj);
  }
}
exports.insert = insert;


/**
 * Inserts an object at the given index of the array.
 * @param {IArrayLike<?>} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
function insertAt(arr, obj, opt_i) {
  splice(arr, opt_i, 0, obj);
}
exports.insertAt = insertAt;


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {IArrayLike<?>} arr The array to modify.
 * @param {IArrayLike<?>} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
function insertArrayAt(arr, elementsToAdd, opt_i) {
  goog.partial(splice, arr, opt_i, 0).apply(null, elementsToAdd);
}
exports.insertArrayAt = insertArrayAt;


/**
 * Inserts an object into an array before a specified object.
 * @param {Array<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
function insertBefore(arr, obj, opt_obj2) {
  let i;
  if (arguments.length == 2 || (i = indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    insertAt(arr, obj, i);
  }
}
exports.insertBefore = insertBefore;


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {IArrayLike<T>} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
function remove(arr, obj) {
  const i = indexOf(arr, obj);
  let rv;
  if ((rv = i >= 0)) {
    removeAt(arr, i);
  }
  return rv;
}
exports.remove = remove;


/**
 * Removes the last occurrence of a particular value from an array.
 * @param {!IArrayLike<T>} arr Array from which to remove value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
function removeLast(arr, obj) {
  const i = lastIndexOf(arr, obj);
  if (i >= 0) {
    removeAt(arr, i);
    return true;
  }
  return false;
}
exports.removeLast = removeLast;


/**
 * Removes from an array the element at index i
 * @param {IArrayLike<?>} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
function removeAt(arr, i) {
  asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return Array.prototype.splice.call(arr, i, 1).length == 1;
}
exports.removeAt = removeAt;


/**
 * Removes the first value that satisfies the given condition.
 * @param {IArrayLike<T>} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
function removeIf(arr, f, opt_obj) {
  const i = findIndex(arr, f, opt_obj);
  if (i >= 0) {
    removeAt(arr, i);
    return true;
  }
  return false;
}
exports.removeIf = removeIf;


/**
 * Removes all values that satisfy the given condition.
 * @param {IArrayLike<T>} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The number of items removed
 * @template T,S
 */
function removeAllIf(arr, f, opt_obj) {
  let removedCount = 0;
  forEachRight(arr, function(val, index) {
    if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {
      if (removeAt(arr, index)) {
        removedCount++;
      }
    }
  });
  return removedCount;
}
exports.removeAllIf = removeAllIf;


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * concat(0, [1, 2]) -> [0, 1, 2]
 * concat([1, 2], null) -> [1, 2, null]
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array<?>} The new resultant array.
 */
function concat(var_args) {
  return Array.prototype.concat.apply([], arguments);
}
exports.concat = concat;


/**
 * Returns a new array that contains the contents of all the arrays passed.
 * @param {...!Array<T>} var_args
 * @return {!Array<T>}
 * @template T
 */
function join(var_args) {
  return Array.prototype.concat.apply([], arguments);
}
exports.join = join;


/**
 * Converts an object to an array.
 * @param {IArrayLike<T>|string} object  The object to convert to an
 *     array.
 * @return {!Array<T>} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 * @template T
 */
function toArray(object) {
  const length = object.length;

  // If length is not a number the following is false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    const rv = new Array(length);
    for (let i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
}
exports.toArray = toArray;


/**
 * Does a shallow copy of an array.
 * @param {IArrayLike<T>|string} arr  Array or array-like object to
 *     clone.
 * @return {!Array<T>} Clone of the input array.
 * @template T
 */
const clone = toArray;
exports.clone = clone;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * extend(a, [0, 1]);
 * a; // [0, 1]
 * extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array<VALUE>} arr1  The array to modify.
 * @param {...(IArrayLike<VALUE>|VALUE)} var_args The elements or arrays of
 *     elements to add to arr1.
 * @template VALUE
 */
function extend(arr1, var_args) {
  for (let i = 1; i < arguments.length; i++) {
    const arr2 = arguments[i];
    if (goog.isArrayLike(arr2)) {
      const len1 = arr1.length || 0;
      const len2 = arr2.length || 0;
      arr1.length = len1 + len2;
      for (let j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
}
exports.extend = extend;


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {IArrayLike<T>} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array<T>} the removed elements.
 * @template T
 */
function splice(arr, index, howMany, var_args) {
  asserts.assert(arr.length != null);

  return Array.prototype.splice.apply(arr, slice(arguments, 1));
}
exports.splice = splice;


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {IArrayLike<T>|string} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
function slice(arr, start, opt_end) {
  asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return Array.prototype.slice.call(arr, start);
  } else {
    return Array.prototype.slice.call(arr, start, opt_end);
  }
}
exports.slice = slice;


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {IArrayLike<T>} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
function removeDuplicates(arr, opt_rv, opt_hashFn) {
  const returnArray = opt_rv || arr;
  const defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(item) ? 'o' + goog.getUid(item) :
                                 (typeof item).charAt(0) + item;
  };
  const hashFn = opt_hashFn || defaultHashFn;

  let cursorInsert = 0;
  let cursorRead = 0;
  const seen = {};

  while (cursorRead < arr.length) {
    const current = arr[cursorRead++];
    const key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
}
exports.removeDuplicates = removeDuplicates;


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, the
 * left-most instance will be found.
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<VALUE>} arr The array to be searched.
 * @param {TARGET} target The sought value.
 * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, the target value and an element from your array, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template TARGET, VALUE
 */
function binarySearch(arr, target, opt_compareFn) {
  return binarySearch_(
      arr, opt_compareFn || defaultCompare, false /* isEvaluator */, target);
}
exports.binarySearch = binarySearch;


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * map(map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<VALUE>} arr The array to be searched.
 * @param {function(this:THIS, VALUE, number, ?): number} evaluator
 *     Evaluator function that receives 3 arguments (the element, the index and
 *     the array). Should return a negative number, zero, or a positive number
 *     depending on whether the desired index is before, at, or after the
 *     element passed to it.
 * @param {THIS=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 * @template THIS, VALUE
 */
function binarySelect(arr, evaluator, opt_obj) {
  return binarySearch_(
      arr, evaluator, true /* isEvaluator */, undefined /* opt_target */,
      opt_obj);
}
exports.binarySelect = binarySelect;


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<?>} arr The array to be searched.
 * @param {function(?, ?, ?): number | function(?, ?): number} compareFn
 *     Either an evaluator or a comparison function, as defined by binarySearch
 *     and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {?=} opt_target If the function is a comparison function, then
 *     this is the target to binary search for.
 * @param {Object=} opt_selfObj If the function is an evaluator, this is an
 *     optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @private
 */
function binarySearch_(arr, compareFn, isEvaluator, opt_target, opt_selfObj) {
  let left = 0;            // inclusive
  let right = arr.length;  // exclusive
  let found;
  while (left < right) {
    const middle = left + ((right - left) >>> 1);
    let compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      // NOTE(dimvar): To avoid this cast, we'd have to use function overloading
      // for the type of binarySearch_, which the type system can't express yet.
      compareResult = /** @type {function(?, ?): number} */ (compareFn)(
          opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // Avoiding bitwise not operator, as that causes a loss in precision for array
  // indexes outside the bounds of a 32-bit signed integer.  Array indexes have
  // a maximum value of 2^32-2 https://tc39.es/ecma262/#array-index
  return found ? left : -left - 1;
}


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogeneous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as `Array.prototype.sort`
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
function sort(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  arr.sort(opt_compareFn || defaultCompare);
}
exports.sort = sort;


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as `Array.prototype.sort`, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
function stableSort(arr, opt_compareFn) {
  const compArr = new Array(arr.length);
  for (let i = 0; i < arr.length; i++) {
    compArr[i] = {index: i, value: arr[i]};
  }
  const valueCompareFn = opt_compareFn || defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  }
  sort(compArr, stableCompareFn);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = compArr[i].value;
  }
}
exports.stableSort = stableSort;


/**
 * Sort the specified array into ascending order based on item keys
 * returned by the specified key function.
 * If no opt_compareFn is specified, the keys are compared in ascending order
 * using <code>defaultCompare</code>.
 *
 * Runtime: O(S(f(n)), where S is runtime of <code>sort</code>
 * and f(n) is runtime of the key function.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {function(T): K} keyFn Function taking array element and returning
 *     a key used for sorting this element.
 * @param {?function(K, K): number=} opt_compareFn Optional comparison function
 *     by which the keys are to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T,K
 */
function sortByKey(arr, keyFn, opt_compareFn) {
  const keyCompareFn = opt_compareFn || defaultCompare;
  sort(arr, function(a, b) {
    return keyCompareFn(keyFn(a), keyFn(b));
  });
}
exports.sortByKey = sortByKey;


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
function sortObjectsByKey(arr, key, opt_compareFn) {
  sortByKey(arr, function(obj) {
    return obj[key];
  }, opt_compareFn);
}
exports.sortObjectsByKey = sortObjectsByKey;


/**
 * Tells if the array is sorted.
 * @param {!IArrayLike<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
function isSorted(arr, opt_compareFn, opt_strict) {
  const compare = opt_compareFn || defaultCompare;
  for (let i = 1; i < arr.length; i++) {
    const compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
}
exports.isSorted = isSorted;


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {IArrayLike<A>} arr1 The first array to compare.
 * @param {IArrayLike<B>} arr2 The second array to compare.
 * @param {?function(A,B):boolean=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 * @template A
 * @template B
 */
function equals(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  const l = arr1.length;
  const equalsFn = opt_equalsFn || defaultCompareEquality;
  for (let i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
exports.equals = equals;


/**
 * 3-way array compare function.
 * @param {!IArrayLike<VALUE>} arr1 The first array to
 *     compare.
 * @param {!IArrayLike<VALUE>} arr2 The second array to
 *     compare.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is to be ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template VALUE
 */
function compare3(arr1, arr2, opt_compareFn) {
  const compare = opt_compareFn || defaultCompare;
  const l = Math.min(arr1.length, arr2.length);
  for (let i = 0; i < l; i++) {
    const result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return defaultCompare(arr1.length, arr2.length);
}
exports.compare3 = compare3;


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second,
 *     respectively.
 * @template VALUE
 */
function defaultCompare(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
exports.defaultCompare = defaultCompare;


/**
 * Compares its two arguments for inverse order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second,
 *     respectively.
 * @template VALUE
 */
function inverseDefaultCompare(a, b) {
  return -defaultCompare(a, b);
}
exports.inverseDefaultCompare = inverseDefaultCompare;


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
function defaultCompareEquality(a, b) {
  return a === b;
}
exports.defaultCompareEquality = defaultCompareEquality;


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {IArrayLike<VALUE>} array The array to modify.
 * @param {VALUE} value The object to insert.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template VALUE
 */
function binaryInsert(array, value, opt_compareFn) {
  const index = binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
}
exports.binaryInsert = binaryInsert;


/**
 * Removes a value from a sorted array.
 * @param {!IArrayLike<VALUE>} array The array to modify.
 * @param {VALUE} value The object to remove.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was removed.
 * @template VALUE
 */
function binaryRemove(array, value, opt_compareFn) {
  const index = binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? removeAt(array, index) : false;
}
exports.binaryRemove = binaryRemove;


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {IArrayLike<T>} array The array.
 * @param {function(this:S, T, number, !IArrayLike<T>):?} sorter Function to
 *     call for every element.  This takes 3 arguments (the element, the index
 *     and the array) and must return a valid object key (a string, number,
 *     etc), or undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object<!Array<T>>} An object, with keys being all of the unique
 *     return values of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
function bucket(array, sorter, opt_obj) {
  const buckets = {};

  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    const key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);
    if (key !== undefined) {
      // Push the value to the right bucket, creating it if necessary.
      const bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
}
exports.bucket = bucket;


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {!IArrayLike<V>} array The array.
 * @param {function(V, number, !IArrayLike<V>):(K|undefined)} sorter Function to
 *     call for every element.  This takes 3 arguments (the element, the index,
 *     and the array) and must return a value to use as a key, or undefined, if
 *     that object should not be placed in a bucket.
 * @return {!Map<K, !Array<V>>} A map, with keys being all of the unique
 *     return values of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template K,V
 */
function bucketToMap(array, sorter) {
  const /** !Map<K, !Array<V>> */ buckets = new Map();

  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    const key = sorter(value, i, array);
    if (key !== undefined) {
      // Push the value to the right bucket, creating it if necessary.
      let bucket = buckets.get(key);
      if (!bucket) {
        bucket = [];
        buckets.set(key, bucket);
      }
      bucket.push(value);
    }
  }

  return buckets;
}
exports.bucketToMap = bucketToMap;


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {IArrayLike<T>} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object<T>} The new object.
 * @template T,S
 */
function toObject(arr, keyFunc, opt_obj) {
  const ret = {};
  forEach(arr, function(element, index) {
    ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =
        element;
  });
  return ret;
}
exports.toObject = toObject;


/**
 * Creates a new ES6 Map built from the provided array and the key-generation
 * function.
 * @param {!IArrayLike<V>} arr Array or array like object over which to iterate
 *     whose elements will be the values in the new object.
 * @param {?function(V, number, ?) : K} keyFunc The function to call for every
 *     element. This function takes 3 arguments (the element, the index, and the
 *     array) and should return a value that will be used as the key for the
 *     element in the new object. If the function returns the same key for more
 *     than one element, the value for that key is implementation-defined.
 * @return {!Map<K, V>} The new map.
 * @template K,V
 */
function toMap(arr, keyFunc) {
  const /** !Map<K, V> */ map = new Map();

  for (let i = 0; i < arr.length; i++) {
    const element = arr[i];
    map.set(keyFunc(element, i, arr), element);
  }

  return map;
}
exports.toMap = toMap;


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
function range(startOrEnd, opt_end, opt_step) {
  const array = [];
  let start = 0;
  let end = startOrEnd;
  const step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (let i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (let i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
}
exports.range = range;


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {VALUE} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array<VALUE>} An array with the repeated value.
 * @template VALUE
 */
function repeat(value, n) {
  const array = [];
  for (let i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
}
exports.repeat = repeat;


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array<?>} An array containing the flattened values.
 */
function flatten(var_args) {
  const CHUNK_SIZE = 8192;

  const result = [];
  for (let i = 0; i < arguments.length; i++) {
    const element = arguments[i];
    if (Array.isArray(element)) {
      for (let c = 0; c < element.length; c += CHUNK_SIZE) {
        const chunk = slice(element, c, c + CHUNK_SIZE);
        const recurseResult = flatten.apply(null, chunk);
        for (let r = 0; r < recurseResult.length; r++) {
          result.push(recurseResult[r]);
        }
      }
    } else {
      result.push(element);
    }
  }
  return result;
}
exports.flatten = flatten;


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array<T>} The array.
 * @template T
 */
function rotate(array, n) {
  asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      Array.prototype.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      Array.prototype.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
}
exports.rotate = rotate;


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!IArrayLike<?>} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     `arr.length - 1`.
 * @param {number} toIndex Target index between 0 and `arr.length - 1`.
 */
function moveItem(arr, fromIndex, toIndex) {
  asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  const removedItems = Array.prototype.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
}
exports.moveItem = moveItem;


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!IArrayLike<?>} var_args Arrays to be combined.
 * @return {!Array<!Array<?>>} A new array of arrays created from
 *     provided arrays.
 */
function zip(var_args) {
  if (!arguments.length) {
    return [];
  }
  const result = [];
  let minLen = arguments[0].length;
  for (let i = 1; i < arguments.length; i++) {
    if (arguments[i].length < minLen) {
      minLen = arguments[i].length;
    }
  }
  for (let i = 0; i < minLen; i++) {
    const value = [];
    for (let j = 0; j < arguments.length; j++) {
      value.push(arguments[j][i]);
    }
    result.push(value);
  }
  return result;
}
exports.zip = zip;


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array<?>} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
function shuffle(arr, opt_randFn) {
  const randFn = opt_randFn || Math.random;

  for (let i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    const j = Math.floor(randFn() * (i + 1));

    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
}
exports.shuffle = shuffle;


/**
 * Returns a new array of elements from arr, based on the indexes of elements
 * provided by index_arr. For example, the result of index copying
 * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].
 *
 * @param {!IArrayLike<T>} arr The array to get a indexed copy from.
 * @param {!IArrayLike<number>} index_arr An array of indexes to get from arr.
 * @return {!Array<T>} A new array of elements from arr in index_arr order.
 * @template T
 */
function copyByIndex(arr, index_arr) {
  const result = [];
  forEach(index_arr, function(index) {
    result.push(arr[index]);
  });
  return result;
}
exports.copyByIndex = copyByIndex;


/**
 * Maps each element of the input array into zero or more elements of the output
 * array.
 *
 * @param {!IArrayLike<VALUE>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): !Array<RESULT>} f The function
 *     to call for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return an array. The result will be
 *     used to extend a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array<RESULT>} a new array with the concatenation of all arrays
 *     returned from f.
 * @template THIS, VALUE, RESULT
 */
function concatMap(arr, f, opt_obj) {
  return concat.apply([], map(arr, f, opt_obj));
}
exports.concatMap = concatMap;

;return exports;});

//third_party/javascript/closure/dom/htmlelement.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.dom.HtmlElement');



/**
 * This subclass of HTMLElement is used when only a HTMLElement is possible and
 * not any of its subclasses. Normally, a type can refer to an instance of
 * itself or an instance of any subtype. More concretely, if HTMLElement is used
 * then the compiler must assume that it might still be e.g. HTMLScriptElement.
 * With this, the type check knows that it couldn't be any special element.
 *
 * @constructor
 * @extends {HTMLElement}
 */
goog.dom.HtmlElement = function() {};

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

//third_party/javascript/closure/dom/tagname.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines the goog.dom.TagName class. Its constants enumerate
 * all HTML tag names specified in either the W3C HTML 4.01 index of elements
 * or the HTML5.1 specification.
 *
 * References:
 * https://www.w3.org/TR/html401/index/elements.html
 * https://www.w3.org/TR/html51/dom.html#elements
 */
goog.provide('goog.dom.TagName');

goog.require('goog.dom.HtmlElement');

/**
 * A tag name for an HTML element.
 *
 * This type is a lie. All instances are actually strings. Do not implement it.
 *
 * It exists because we need an object type to host the template type parameter,
 * and that's not possible with literal or enum types. It is a record type so
 * that runtime type checks don't try to validate the lie.
 *
 * @template T
 * @record
 */
goog.dom.TagName = class {
  /**
   * Cast a string into the tagname for the associated constructor.
   *
   * @template T
   * @param {string} name
   * @param {function(new:T, ...?)} type
   * @return {!goog.dom.TagName<T>}
   */
  static cast(name, type) {
    return /** @type {?} */ (name);
  }

  /** @suppress {unusedPrivateMembers} */
  constructor() {
    /** @private {null} */
    this.googDomTagName_doNotImplementThisTypeOrElse_;

    /** @private {T} */
    this.ensureTypeScriptRemembersTypeT_;
  }

  /**
   * Appease the compiler that instances are stringafiable for the
   * purpose of being a dictionary key.
   *
   * Never implemented; always backed by `String::toString`.
   *
   * @override
   * @return {string}
   */
  toString() {}
};



/** @const {!goog.dom.TagName<!HTMLAnchorElement>} */
goog.dom.TagName.A = /** @type {?} */ ('A');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ABBR = /** @type {?} */ ('ABBR');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ACRONYM = /** @type {?} */ ('ACRONYM');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ADDRESS = /** @type {?} */ ('ADDRESS');

/** @const {!goog.dom.TagName<!HTMLAppletElement>} */
goog.dom.TagName.APPLET = /** @type {?} */ ('APPLET');

/** @const {!goog.dom.TagName<!HTMLAreaElement>} */
goog.dom.TagName.AREA = /** @type {?} */ ('AREA');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ARTICLE = /** @type {?} */ ('ARTICLE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ASIDE = /** @type {?} */ ('ASIDE');

/** @const {!goog.dom.TagName<!HTMLAudioElement>} */
goog.dom.TagName.AUDIO = /** @type {?} */ ('AUDIO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.B = /** @type {?} */ ('B');

/** @const {!goog.dom.TagName<!HTMLBaseElement>} */
goog.dom.TagName.BASE = /** @type {?} */ ('BASE');

/** @const {!goog.dom.TagName<!HTMLBaseFontElement>} */
goog.dom.TagName.BASEFONT = /** @type {?} */ ('BASEFONT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BDI = /** @type {?} */ ('BDI');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BDO = /** @type {?} */ ('BDO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BIG = /** @type {?} */ ('BIG');

/** @const {!goog.dom.TagName<!HTMLQuoteElement>} */
goog.dom.TagName.BLOCKQUOTE = /** @type {?} */ ('BLOCKQUOTE');

/** @const {!goog.dom.TagName<!HTMLBodyElement>} */
goog.dom.TagName.BODY = /** @type {?} */ ('BODY');

/** @const {!goog.dom.TagName<!HTMLBRElement>} */
goog.dom.TagName.BR = /** @type {?} */ ('BR');

/** @const {!goog.dom.TagName<!HTMLButtonElement>} */
goog.dom.TagName.BUTTON = /** @type {?} */ ('BUTTON');

/** @const {!goog.dom.TagName<!HTMLCanvasElement>} */
goog.dom.TagName.CANVAS = /** @type {?} */ ('CANVAS');

/** @const {!goog.dom.TagName<!HTMLTableCaptionElement>} */
goog.dom.TagName.CAPTION = /** @type {?} */ ('CAPTION');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CENTER = /** @type {?} */ ('CENTER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CITE = /** @type {?} */ ('CITE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CODE = /** @type {?} */ ('CODE');

/** @const {!goog.dom.TagName<!HTMLTableColElement>} */
goog.dom.TagName.COL = /** @type {?} */ ('COL');

/** @const {!goog.dom.TagName<!HTMLTableColElement>} */
goog.dom.TagName.COLGROUP = /** @type {?} */ ('COLGROUP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.COMMAND = /** @type {?} */ ('COMMAND');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DATA = /** @type {?} */ ('DATA');

/** @const {!goog.dom.TagName<!HTMLDataListElement>} */
goog.dom.TagName.DATALIST = /** @type {?} */ ('DATALIST');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DD = /** @type {?} */ ('DD');

/** @const {!goog.dom.TagName<!HTMLModElement>} */
goog.dom.TagName.DEL = /** @type {?} */ ('DEL');

/** @const {!goog.dom.TagName<!HTMLDetailsElement>} */
goog.dom.TagName.DETAILS = /** @type {?} */ ('DETAILS');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DFN = /** @type {?} */ ('DFN');

/** @const {!goog.dom.TagName<!HTMLDialogElement>} */
goog.dom.TagName.DIALOG = /** @type {?} */ ('DIALOG');

/** @const {!goog.dom.TagName<!HTMLDirectoryElement>} */
goog.dom.TagName.DIR = /** @type {?} */ ('DIR');

/** @const {!goog.dom.TagName<!HTMLDivElement>} */
goog.dom.TagName.DIV = /** @type {?} */ ('DIV');

/** @const {!goog.dom.TagName<!HTMLDListElement>} */
goog.dom.TagName.DL = /** @type {?} */ ('DL');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DT = /** @type {?} */ ('DT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.EM = /** @type {?} */ ('EM');

/** @const {!goog.dom.TagName<!HTMLEmbedElement>} */
goog.dom.TagName.EMBED = /** @type {?} */ ('EMBED');

/** @const {!goog.dom.TagName<!HTMLFieldSetElement>} */
goog.dom.TagName.FIELDSET = /** @type {?} */ ('FIELDSET');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FIGCAPTION = /** @type {?} */ ('FIGCAPTION');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FIGURE = /** @type {?} */ ('FIGURE');

/** @const {!goog.dom.TagName<!HTMLFontElement>} */
goog.dom.TagName.FONT = /** @type {?} */ ('FONT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FOOTER = /** @type {?} */ ('FOOTER');

/** @const {!goog.dom.TagName<!HTMLFormElement>} */
goog.dom.TagName.FORM = /** @type {?} */ ('FORM');

/** @const {!goog.dom.TagName<!HTMLFrameElement>} */
goog.dom.TagName.FRAME = /** @type {?} */ ('FRAME');

/** @const {!goog.dom.TagName<!HTMLFrameSetElement>} */
goog.dom.TagName.FRAMESET = /** @type {?} */ ('FRAMESET');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H1 = /** @type {?} */ ('H1');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H2 = /** @type {?} */ ('H2');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H3 = /** @type {?} */ ('H3');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H4 = /** @type {?} */ ('H4');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H5 = /** @type {?} */ ('H5');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H6 = /** @type {?} */ ('H6');

/** @const {!goog.dom.TagName<!HTMLHeadElement>} */
goog.dom.TagName.HEAD = /** @type {?} */ ('HEAD');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.HEADER = /** @type {?} */ ('HEADER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.HGROUP = /** @type {?} */ ('HGROUP');

/** @const {!goog.dom.TagName<!HTMLHRElement>} */
goog.dom.TagName.HR = /** @type {?} */ ('HR');

/** @const {!goog.dom.TagName<!HTMLHtmlElement>} */
goog.dom.TagName.HTML = /** @type {?} */ ('HTML');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.I = /** @type {?} */ ('I');

/** @const {!goog.dom.TagName<!HTMLIFrameElement>} */
goog.dom.TagName.IFRAME = /** @type {?} */ ('IFRAME');

/** @const {!goog.dom.TagName<!HTMLImageElement>} */
goog.dom.TagName.IMG = /** @type {?} */ ('IMG');

/** @const {!goog.dom.TagName<!HTMLInputElement>} */
goog.dom.TagName.INPUT = /** @type {?} */ ('INPUT');

/** @const {!goog.dom.TagName<!HTMLModElement>} */
goog.dom.TagName.INS = /** @type {?} */ ('INS');

/** @const {!goog.dom.TagName<!HTMLIsIndexElement>} */
goog.dom.TagName.ISINDEX = /** @type {?} */ ('ISINDEX');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.KBD = /** @type {?} */ ('KBD');

// HTMLKeygenElement is deprecated.
/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.KEYGEN = /** @type {?} */ ('KEYGEN');

/** @const {!goog.dom.TagName<!HTMLLabelElement>} */
goog.dom.TagName.LABEL = /** @type {?} */ ('LABEL');

/** @const {!goog.dom.TagName<!HTMLLegendElement>} */
goog.dom.TagName.LEGEND = /** @type {?} */ ('LEGEND');

/** @const {!goog.dom.TagName<!HTMLLIElement>} */
goog.dom.TagName.LI = /** @type {?} */ ('LI');

/** @const {!goog.dom.TagName<!HTMLLinkElement>} */
goog.dom.TagName.LINK = /** @type {?} */ ('LINK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MAIN = /** @type {?} */ ('MAIN');

/** @const {!goog.dom.TagName<!HTMLMapElement>} */
goog.dom.TagName.MAP = /** @type {?} */ ('MAP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MARK = /** @type {?} */ ('MARK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MATH = /** @type {?} */ ('MATH');

/** @const {!goog.dom.TagName<!HTMLMenuElement>} */
goog.dom.TagName.MENU = /** @type {?} */ ('MENU');

/** @const {!goog.dom.TagName<!HTMLMenuItemElement>} */
goog.dom.TagName.MENUITEM = /** @type {?} */ ('MENUITEM');

/** @const {!goog.dom.TagName<!HTMLMetaElement>} */
goog.dom.TagName.META = /** @type {?} */ ('META');

/** @const {!goog.dom.TagName<!HTMLMeterElement>} */
goog.dom.TagName.METER = /** @type {?} */ ('METER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NAV = /** @type {?} */ ('NAV');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NOFRAMES = /** @type {?} */ ('NOFRAMES');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NOSCRIPT = /** @type {?} */ ('NOSCRIPT');

/** @const {!goog.dom.TagName<!HTMLObjectElement>} */
goog.dom.TagName.OBJECT = /** @type {?} */ ('OBJECT');

/** @const {!goog.dom.TagName<!HTMLOListElement>} */
goog.dom.TagName.OL = /** @type {?} */ ('OL');

/** @const {!goog.dom.TagName<!HTMLOptGroupElement>} */
goog.dom.TagName.OPTGROUP = /** @type {?} */ ('OPTGROUP');

/** @const {!goog.dom.TagName<!HTMLOptionElement>} */
goog.dom.TagName.OPTION = /** @type {?} */ ('OPTION');

/** @const {!goog.dom.TagName<!HTMLOutputElement>} */
goog.dom.TagName.OUTPUT = /** @type {?} */ ('OUTPUT');

/** @const {!goog.dom.TagName<!HTMLParagraphElement>} */
goog.dom.TagName.P = /** @type {?} */ ('P');

/** @const {!goog.dom.TagName<!HTMLParamElement>} */
goog.dom.TagName.PARAM = /** @type {?} */ ('PARAM');

/** @const {!goog.dom.TagName<!HTMLPictureElement>} */
goog.dom.TagName.PICTURE = /** @type {?} */ ('PICTURE');

/** @const {!goog.dom.TagName<!HTMLPreElement>} */
goog.dom.TagName.PRE = /** @type {?} */ ('PRE');

/** @const {!goog.dom.TagName<!HTMLProgressElement>} */
goog.dom.TagName.PROGRESS = /** @type {?} */ ('PROGRESS');

/** @const {!goog.dom.TagName<!HTMLQuoteElement>} */
goog.dom.TagName.Q = /** @type {?} */ ('Q');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RP = /** @type {?} */ ('RP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RT = /** @type {?} */ ('RT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RTC = /** @type {?} */ ('RTC');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RUBY = /** @type {?} */ ('RUBY');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.S = /** @type {?} */ ('S');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SAMP = /** @type {?} */ ('SAMP');

/** @const {!goog.dom.TagName<!HTMLScriptElement>} */
goog.dom.TagName.SCRIPT = /** @type {?} */ ('SCRIPT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SECTION = /** @type {?} */ ('SECTION');

/** @const {!goog.dom.TagName<!HTMLSelectElement>} */
goog.dom.TagName.SELECT = /** @type {?} */ ('SELECT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SMALL = /** @type {?} */ ('SMALL');

/** @const {!goog.dom.TagName<!HTMLSourceElement>} */
goog.dom.TagName.SOURCE = /** @type {?} */ ('SOURCE');

/** @const {!goog.dom.TagName<!HTMLSpanElement>} */
goog.dom.TagName.SPAN = /** @type {?} */ ('SPAN');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.STRIKE = /** @type {?} */ ('STRIKE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.STRONG = /** @type {?} */ ('STRONG');

/** @const {!goog.dom.TagName<!HTMLStyleElement>} */
goog.dom.TagName.STYLE = /** @type {?} */ ('STYLE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUB = /** @type {?} */ ('SUB');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUMMARY = /** @type {?} */ ('SUMMARY');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUP = /** @type {?} */ ('SUP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SVG = /** @type {?} */ ('SVG');

/** @const {!goog.dom.TagName<!HTMLTableElement>} */
goog.dom.TagName.TABLE = /** @type {?} */ ('TABLE');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.TBODY = /** @type {?} */ ('TBODY');

/** @const {!goog.dom.TagName<!HTMLTableCellElement>} */
goog.dom.TagName.TD = /** @type {?} */ ('TD');

/** @const {!goog.dom.TagName<!HTMLTemplateElement>} */
goog.dom.TagName.TEMPLATE = /** @type {?} */ ('TEMPLATE');

/** @const {!goog.dom.TagName<!HTMLTextAreaElement>} */
goog.dom.TagName.TEXTAREA = /** @type {?} */ ('TEXTAREA');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.TFOOT = /** @type {?} */ ('TFOOT');

/** @const {!goog.dom.TagName<!HTMLTableCellElement>} */
goog.dom.TagName.TH = /** @type {?} */ ('TH');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.THEAD = /** @type {?} */ ('THEAD');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.TIME = /** @type {?} */ ('TIME');

/** @const {!goog.dom.TagName<!HTMLTitleElement>} */
goog.dom.TagName.TITLE = /** @type {?} */ ('TITLE');

/** @const {!goog.dom.TagName<!HTMLTableRowElement>} */
goog.dom.TagName.TR = /** @type {?} */ ('TR');

/** @const {!goog.dom.TagName<!HTMLTrackElement>} */
goog.dom.TagName.TRACK = /** @type {?} */ ('TRACK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.TT = /** @type {?} */ ('TT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.U = /** @type {?} */ ('U');

/** @const {!goog.dom.TagName<!HTMLUListElement>} */
goog.dom.TagName.UL = /** @type {?} */ ('UL');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.VAR = /** @type {?} */ ('VAR');

/** @const {!goog.dom.TagName<!HTMLVideoElement>} */
goog.dom.TagName.VIDEO = /** @type {?} */ ('VIDEO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.WBR = /** @type {?} */ ('WBR');

//third_party/javascript/closure/object/object.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */
goog.module('goog.object');
goog.module.declareLegacyNamespace();

/**
 * Calls a function for each element in an object/map/hash.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):?} f The function to call for every
 *     element. This function takes 3 arguments (the value, the key and the
 *     object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {void}
 * @template T,K,V
 */
function forEach(obj, f, opt_obj) {
  for (const key in obj) {
    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
  }
}

/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):boolean} f The function to call for
 *     every element. This function takes 3 arguments (the value, the key and
 *     the object) and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the element is not
 *     included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
function filter(obj, f, opt_obj) {
  const res = {};
  for (const key in obj) {
    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
}

/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):R} f The function to call for every
 *     element. This function takes 3 arguments (the value, the key and the
 *     object) and should return something. The result will be inserted into a
 *     new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
function map(obj, f, opt_obj) {
  const res = {};
  for (const key in obj) {
    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
  }
  return res;
}

/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 * @param {?Object<K,V>} obj The object to check.
 * @param {function(this:T,V,?,?Object<K,V>):boolean} f The function to call for
 *     every element. This function takes 3 arguments (the value, the key and
 *     the object) and should return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
function some(obj, f, opt_obj) {
  for (const key in obj) {
    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      return true;
    }
  }
  return false;
}

/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 * @param {?Object<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,?Object<K,V>):boolean} f The function to call
 *     for every element. This function takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
function every(obj, f, opt_obj) {
  for (const key in obj) {
    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      return false;
    }
  }
  return true;
}

/**
 * Returns the number of key-value pairs in the object map.
 * @param {?Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
function getCount(obj) {
  let rv = 0;
  for (const key in obj) {
    rv++;
  }
  return rv;
}

/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 * @param {?Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
function getAnyKey(obj) {
  for (const key in obj) {
    return key;
  }
}

/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 * @param {?Object<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
function getAnyValue(obj) {
  for (const key in obj) {
    return obj[key];
  }
}

/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for containsValue(obj, val).
 * @param {?Object<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
function contains(obj, val) {
  return containsValue(obj, val);
}

/**
 * Returns the values of the object/map/hash.
 * @param {?Object<K,V>} obj The object from which to get the values.
 * @return {!Array<V>} The values in the object/map/hash.
 * @template K,V
 */
function getValues(obj) {
  const res = [];
  let i = 0;
  for (const key in obj) {
    res[i++] = obj[key];
  }
  return res;
}

/**
 * Returns the keys of the object/map/hash.
 * @param {?Object} obj The object from which to get the keys.
 * @return {!Array<string>} Array of property keys.
 */
function getKeys(obj) {
  const res = [];
  let i = 0;
  for (const key in obj) {
    res[i++] = key;
  }
  return res;
}

/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 * @param {?Object} obj An object to get the value from. Can be array-like.
 * @param {...(string|number|!IArrayLike<number|string>)} var_args A number of
 *     keys (as strings, or numbers, for array-like objects). Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value. If, at any point, the value for a key in the
 *     current object is null or undefined, returns undefined.
 */
function getValueByKeys(obj, var_args) {
  const isArrayLike = goog.isArrayLike(var_args);
  const keys = isArrayLike ?
      /** @type {!IArrayLike<number|string>} */ (var_args) :
      arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (let i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    if (obj == null) return undefined;
    obj = obj[keys[i]];
  }

  return obj;
}

/**
 * Whether the object/map/hash contains the given key.
 * @param {?Object} obj The object in which to look for key.
 * @param {?} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
function containsKey(obj, key) {
  return obj !== null && key in obj;
}

/**
 * Whether the object/map/hash contains the given value. This is O(n).
 * @param {?Object<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
function containsValue(obj, val) {
  for (const key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
}

/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {?Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,?Object<K,V>):boolean} f The function to
 *     call for every element. Takes 3 arguments (the value, the key and the
 *     object) and should return a boolean.
 * @param {T=} thisObj An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
function findKey(obj, f, thisObj = undefined) {
  for (const key in obj) {
    if (f.call(/** @type {?} */ (thisObj), obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
}

/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {?Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,?Object<K,V>):boolean} f The function to
 *     call for every element. Takes 3 arguments (the value, the key and the
 *     object) and should return a boolean.
 * @param {T=} thisObj An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
function findValue(obj, f, thisObj = undefined) {
  const key = findKey(obj, f, thisObj);
  return key && obj[key];
}

/**
 * Whether the object/map/hash is empty.
 * @param {?Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
function isEmpty(obj) {
  for (const key in obj) {
    return false;
  }
  return true;
}

/**
 * Removes all key value pairs from the object/map/hash.
 * @param {?Object} obj The object to clear.
 * @return {void}
 */
function clear(obj) {
  for (const i in obj) {
    delete obj[i];
  }
}

/**
 * Removes a key-value pair based on the key.
 * @param {?Object} obj The object from which to remove the key.
 * @param {?} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
function remove(obj, key) {
  let rv;
  if (rv = key in /** @type {!Object} */ (obj)) {
    delete obj[key];
  }
  return rv;
}

/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @return {void}
 * @template K,V
 */
function add(obj, key, val) {
  if (obj !== null && key in obj) {
    throw new Error(`The object already contains the key "${key}"`);
  }
  set(obj, key, val);
}

/**
 * Returns the value for the given key.
 * @param {?Object<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} val The value to return if no item is found for the given key
 *     (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
function get(obj, key, val = undefined) {
  if (obj !== null && key in obj) {
    return obj[key];
  }
  return val;
}

/**
 * Adds a key-value pair to the object/map/hash.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 * @return {void}
 */
function set(obj, key, value) {
  obj[key] = value;
}

/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
function setIfUndefined(obj, key, value) {
  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);
}

/**
 * Sets a key and value to an object if the key is not set. The value will be
 * the return value of the given function. If the key already exists, the
 * object will not be changed and the function will not be called (the function
 * will be lazily evaluated -- only called if necessary).
 * This function is particularly useful when used with an `Object` which is
 * acting as a cache.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {function():V} f The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
function setWithReturnValueIfNotSet(obj, key, f) {
  if (key in obj) {
    return obj[key];
  }

  const val = f();
  obj[key] = val;
  return val;
}

/**
 * Compares two objects for equality using === on the values.
 * @param {!Object<K,V>} a
 * @param {!Object<K,V>} b
 * @return {boolean}
 * @template K,V
 */
function equals(a, b) {
  for (const k in a) {
    if (!(k in b) || a[k] !== b[k]) {
      return false;
    }
  }
  for (const k in b) {
    if (!(k in a)) {
      return false;
    }
  }
  return true;
}

/**
 * Returns a shallow clone of the object.
 * @param {?Object<K,V>} obj Object to clone.
 * @return {!Object<K,V>} Clone of the input object.
 * @template K,V
 */
function clone(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key];
  }
  return res;
}

/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 * WARNINGS:
 * <code>unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 * <code>unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 * @param {T} obj The value to clone.
 * @return {T} A clone of the input value.
 * @template T
 */
function unsafeClone(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  if (typeof obj.clone === 'function') return obj.clone();
  if (typeof Map !== 'undefined' && obj instanceof Map) {
    return new Map(obj);
  } else if (typeof Set !== 'undefined' && obj instanceof Set) {
    return new Set(obj);
  } else if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  const clone = Array.isArray(obj) ? [] :
      typeof ArrayBuffer === 'function' &&
          typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj) &&
          !(obj instanceof DataView) ?
                                     new obj.constructor(obj.length) :
                                     {};
  for (const key in obj) {
    clone[key] = unsafeClone(obj[key]);
  }
  return clone;
}

/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 * @param {?Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
function transpose(obj) {
  const transposed = {};
  for (const key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
}

/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 */
const PROTOTYPE_FIELDS = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf',
];

/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 * Example:
 * var o = {};
 * extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * extend(o, {b: 2, c: 3});
 * o; // {a: 0, b: 2, c: 3}
 * @param {?Object} target The object to modify. Existing properties will be
 *     overwritten if they are also present in one of the objects in `var_args`.
 * @param {...(?Object|undefined)} var_args The objects from which values
 *     will be copied.
 * @return {void}
 * @deprecated Prefer Object.assign
 */
function extend(target, var_args) {
  let key;
  let source;
  for (let i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (let j = 0; j < PROTOTYPE_FIELDS.length; j++) {
      key = PROTOTYPE_FIELDS[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
}

/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments, otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {!Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
function create(var_args) {
  const argLength = arguments.length;
  if (argLength == 1 && Array.isArray(arguments[0])) {
    return create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw new Error('Uneven number of arguments');
  }

  const rv = {};
  for (let i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
}

/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments, otherwise the arguments are used as
 *     the property names.
 * @return {!Object} The new object.
 */
function createSet(var_args) {
  const argLength = arguments.length;
  if (argLength == 1 && Array.isArray(arguments[0])) {
    return createSet.apply(null, arguments[0]);
  }

  const rv = {};
  for (let i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
}

/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 * @param {!Object<K,V>} obj An object.
 * @return {!Object<K,V>} An immutable view of that object, or the original
 *     object if this browser does not support immutables.
 * @template K,V
 */
function createImmutableView(obj) {
  let result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
}

/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
function isImmutableView(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
}

/**
 * Get all properties names on a given Object regardless of enumerability.
 * <p> If the browser does not support `Object.getOwnPropertyNames` nor
 * `Object.getPrototypeOf` then this is equivalent to using
 * `getKeys`
 * @param {?Object} obj The object to get the properties of.
 * @param {boolean=} includeObjectPrototype Whether properties defined on
 *     `Object.prototype` should be included in the result.
 * @param {boolean=} includeFunctionPrototype Whether properties defined on
 *     `Function.prototype` should be included in the result.
 * @return {!Array<string>}
 * @public
 */
function getAllPropertyNames(
    obj, includeObjectPrototype = undefined,
    includeFunctionPrototype = undefined) {
  if (!obj) {
    return [];
  }

  // Naively use a for..in loop to get the property names if the browser doesn't
  // support any other APIs for getting it.
  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
    return getKeys(obj);
  }

  const visitedSet = {};

  // Traverse the prototype chain and add all properties to the visited set.
  let proto = obj;
  while (proto && (proto !== Object.prototype || !!includeObjectPrototype) &&
         (proto !== Function.prototype || !!includeFunctionPrototype)) {
    const names = Object.getOwnPropertyNames(proto);
    for (let i = 0; i < names.length; i++) {
      visitedSet[names[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return getKeys(visitedSet);
}

/**
 * Given a ES5 or ES6 class reference, return its super class / super
 * constructor.
 * This should be used in rare cases where you need to walk up the inheritance
 * tree (this is generally a bad idea). But this work with ES5 and ES6 classes,
 * unlike relying on the superClass_ property.
 * Note: To start walking up the hierarchy from an instance call this with its
 * `constructor` property; e.g. `getSuperClass(instance.constructor)`.
 * @param {function(new: ?)} constructor
 * @return {?Object}
 */
function getSuperClass(constructor) {
  const proto = Object.getPrototypeOf(constructor.prototype);
  return proto && proto.constructor;
}

exports = {
  add,
  clear,
  clone,
  contains,
  containsKey,
  containsValue,
  create,
  createImmutableView,
  createSet,
  equals,
  every,
  extend,
  filter,
  findKey,
  findValue,
  forEach,
  get,
  getAllPropertyNames,
  getAnyKey,
  getAnyValue,
  getCount,
  getKeys,
  getSuperClass,
  getValueByKeys,
  getValues,
  isEmpty,
  isImmutableView,
  map,
  remove,
  set,
  setIfUndefined,
  setWithReturnValueIfNotSet,
  some,
  transpose,
  unsafeClone,
};

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

;return exports;});

//third_party/javascript/closure/dom/tags.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for HTML element tag names.
 */
goog.provide('goog.dom.tags');

goog.require('goog.object');


/**
 * The void elements specified by
 * http://www.w3.org/TR/html-markup/syntax.html#void-elements.
 * @const @private {!Object<string, boolean>}
 */
goog.dom.tags.VOID_TAGS_ = goog.object.createSet(
    'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input',
    'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr');


/**
 * Checks whether the tag is void (with no contents allowed and no legal end
 * tag), for example 'br'.
 * @param {string} tagName The tag name in lower case.
 * @return {boolean}
 */
goog.dom.tags.isVoidTag = function(tagName) {
  'use strict';
  return goog.dom.tags.VOID_TAGS_[tagName] === true;
};

//third_party/javascript/closure/string/internal.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview String functions called from Closure packages that couldn't
 * depend on each other. Outside Closure, use goog.string function which
 * delegate to these.
 */


goog.provide('goog.string.internal');


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of `str`.
 * @return {boolean} True if `str` begins with `prefix`.
 * @see goog.string.startsWith
 */
goog.string.internal.startsWith = function(str, prefix) {
  'use strict';
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix`.
 * @see goog.string.endsWith
 */
goog.string.internal.endsWith = function(str, suffix) {
  'use strict';
  const l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of `str`.
 * @return {boolean} True if `str` begins with `prefix` (ignoring
 *     case).
 * @see goog.string.caseInsensitiveStartsWith
 */
goog.string.internal.caseInsensitiveStartsWith = function(str, prefix) {
  'use strict';
  return (
      goog.string.internal.caseInsensitiveCompare(
          prefix, str.slice(0, prefix.length)) == 0);
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix` (ignoring
 *     case).
 * @see goog.string.caseInsensitiveEndsWith
 */
goog.string.internal.caseInsensitiveEndsWith = function(str, suffix) {
  'use strict';
  return (
      goog.string.internal.caseInsensitiveCompare(
          suffix, str.slice(str.length - suffix.length)) == 0);
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if `str1` and `str2` are the same string,
 *     ignoring case.
 * @see goog.string.caseInsensitiveEquals
 */
goog.string.internal.caseInsensitiveEquals = function(str1, str2) {
  'use strict';
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} Whether `str` is empty or whitespace only.
 * @see goog.string.isEmptyOrWhitespace
 */
goog.string.internal.isEmptyOrWhitespace = function(str) {
  'use strict';
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of `str`.
 */
goog.string.internal.trim =
    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {
      'use strict';
      return str.trim();
    } : function(str) {
      'use strict';
      // Since IE doesn't include non-breaking-space (0xa0) in their \s
      // character class (as required by section 7.2 of the ECMAScript spec),
      // we explicitly include it in the regexp to enforce consistent
      // cross-browser behavior.
      // NOTE: We don't use String#replace because it might have side effects
      // causing this function to not compile to 0 bytes.
      return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(str)[1];
    };


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare `str1` to.
 * @return {number} The comparator result, as described above.
 * @see goog.string.caseInsensitiveCompare
 */
goog.string.internal.caseInsensitiveCompare = function(str1, str2) {
  'use strict';
  const test1 = String(str1).toLowerCase();
  const test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of `str` with converted newlines.
 * @see goog.string.newLineToBr
 */
goog.string.internal.newLineToBr = function(str, opt_xml) {
  'use strict';
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars
 * @return {string} An escaped copy of `str`.
 * @see goog.string.htmlEscape
 */
goog.string.internal.htmlEscape = function(
    str, opt_isLikelyToContainHtmlChars) {
  'use strict';
  if (opt_isLikelyToContainHtmlChars) {
    str = str.replace(goog.string.internal.AMP_RE_, '&amp;')
              .replace(goog.string.internal.LT_RE_, '&lt;')
              .replace(goog.string.internal.GT_RE_, '&gt;')
              .replace(goog.string.internal.QUOT_RE_, '&quot;')
              .replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;')
              .replace(goog.string.internal.NULL_RE_, '&#0;');
    return str;

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.internal.ALL_RE_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.internal.AMP_RE_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.internal.LT_RE_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.internal.GT_RE_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.internal.QUOT_RE_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;');
    }
    if (str.indexOf('\x00') != -1) {
      str = str.replace(goog.string.internal.NULL_RE_, '&#0;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.AMP_RE_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.LT_RE_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.GT_RE_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.QUOT_RE_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.SINGLE_QUOTE_RE_ = /'/g;


/**
 * Regular expression that matches null character, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.NULL_RE_ = /\x00/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.ALL_RE_ = /[\x00&<>"']/;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of `str`.
 * @see goog.string.whitespaceEscape
 */
goog.string.internal.whitespaceEscape = function(str, opt_xml) {
  'use strict';
  // This doesn't use goog.string.preserveSpaces for backwards compatibility.
  return goog.string.internal.newLineToBr(
      str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Determines whether a string contains a substring.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 * @see goog.string.contains
 */
goog.string.internal.contains = function(str, subString) {
  'use strict';
  return str.indexOf(subString) != -1;
};


/**
 * Determines whether a string contains a substring, ignoring case.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 * @see goog.string.caseInsensitiveContains
 */
goog.string.internal.caseInsensitiveContains = function(str, subString) {
  'use strict';
  return goog.string.internal.contains(
      str.toLowerCase(), subString.toLowerCase());
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if `version1` is higher.
 *                   0 if arguments are equal.
 *                  -1 if `version2` is higher.
 * @see goog.string.compareVersions
 */
goog.string.internal.compareVersions = function(version1, version2) {
  'use strict';
  let order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  const v1Subs = goog.string.internal.trim(String(version1)).split('.');
  const v2Subs = goog.string.internal.trim(String(version2)).split('.');
  const subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (let subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    let v1Sub = v1Subs[subIdx] || '';
    let v2Sub = v2Subs[subIdx] || '';

    do {
      // Split the subversions into pairs of numbers and qualifiers (like 'b').
      // Two different RegExp objects are use to make it clear the code
      // is side-effect free
      const v1Comp = /(\d*)(\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];
      const v2Comp = /(\d*)(\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      const v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      const v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.internal.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.internal.compareElements_(
              v1Comp[2].length == 0, v2Comp[2].length == 0) ||
          goog.string.internal.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.

      v1Sub = v1Comp[3];
      v2Sub = v2Comp[3];
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if `left` is higher.
 *                   0 if arguments are equal.
 *                  -1 if `right` is higher.
 * @private
 */
goog.string.internal.compareElements_ = function(left, right) {
  'use strict';
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

//third_party/javascript/safevalues/for_closure/index.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Re-exports some functions from safevalues that the Closure Safe
 * type that are not migrated yet need. These types can't import these functions
 * directly from safevalues because it would create a cyclic dependency.
 * Generated from: third_party/javascript/safevalues/for_closure/index.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.for_closure.index');
var module = module || { id: 'third_party/javascript/safevalues/for_closure/index.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
exports.sanitizeUrl = url_builders_1.sanitizeUrl;
const url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.url_impl');
exports.SafeUrl = url_impl_1.SafeUrl;
exports.unwrapUrl = url_impl_1.unwrapUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZm9yX2Nsb3N1cmUvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV0EsdUdBQXFEO0FBQTdDLHFDQUFBLFdBQVcsQ0FBQTtBQUNuQixnR0FBeUQ7QUFBakQsNkJBQUEsT0FBTyxDQUFBO0FBQUUsK0JBQUEsU0FBUyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmUtZXhwb3J0cyBzb21lIGZ1bmN0aW9ucyBmcm9tIHNhZmV2YWx1ZXMgdGhhdCB0aGUgQ2xvc3VyZSBTYWZlXG4gKiB0eXBlIHRoYXQgYXJlIG5vdCBtaWdyYXRlZCB5ZXQgbmVlZC4gVGhlc2UgdHlwZXMgY2FuJ3QgaW1wb3J0IHRoZXNlIGZ1bmN0aW9uc1xuICogZGlyZWN0bHkgZnJvbSBzYWZldmFsdWVzIGJlY2F1c2UgaXQgd291bGQgY3JlYXRlIGEgY3ljbGljIGRlcGVuZGVuY3kuXG4gKi9cblxuZXhwb3J0IHtzYW5pdGl6ZVVybH0gZnJvbSAnLi4vYnVpbGRlcnMvdXJsX2J1aWxkZXJzJztcbmV4cG9ydCB7U2FmZVVybCwgdW53cmFwVXJsfSBmcm9tICcuLi9pbnRlcm5hbHMvdXJsX2ltcGwnO1xuXG5nb29nLnRzTWlncmF0aW9uTmFtZWRFeHBvcnRzU2hpbSgnc2FmZXZhbHVlcy5mb3JfY2xvc3VyZScpO1xuIl19
;return exports;});

//third_party/javascript/safevalues/for_closure/index.tsmes.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview generator:ts_migration_exports_shim.ts
 * original_file:third_party/javascript/safevalues/for_closure/index.ts
 * pintomodule absent in original_file
 * modName absent in original_file
 */
goog.module('safevalues.for_closure');
var mainModule = goog.require('google3.third_party.javascript.safevalues.for_closure.index');
exports.sanitizeUrl = mainModule.sanitizeUrl;
exports.SafeUrl = mainModule.SafeUrl;
exports.unwrapUrl = mainModule.unwrapUrl;

;return exports;});

//third_party/javascript/closure/html/safestyle.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeStyle type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeStyle');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const {AssertionError, assert, fail} = goog.require('goog.asserts');
const {SafeUrl, sanitizeUrl: safevaluesSanitizeUrl} = goog.require('safevalues.for_closure');
const {contains, endsWith} = goog.require('goog.string.internal');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @type {!Object}
 * @const
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string-like object which represents a sequence of CSS declarations
 * (`propertyName1: propertyvalue1; propertyName2: propertyValue2; ...`)
 * and that carries the security type contract that its value, as a string,
 * will not cause untrusted script execution (XSS) when evaluated as CSS in a
 * browser.
 *
 * Instances of this type must be created via the factory methods
 * (`SafeStyle.create` or `SafeStyle.fromConstant`)
 * and not by invoking its constructor. The constructor intentionally takes an
 * extra parameter that cannot be constructed outside of this file and the type
 * is immutable; hence only a default instance corresponding to the empty string
 * can be obtained via constructor invocation.
 *
 * SafeStyle's string representation can safely be:
 * <ul>
 *   <li>Interpolated as the content of a *quoted* HTML style attribute.
 *       However, the SafeStyle string *must be HTML-attribute-escaped* before
 *       interpolation.
 *   <li>Interpolated as the content of a {}-wrapped block within a stylesheet.
 *       '<' characters in the SafeStyle string *must be CSS-escaped* before
 *       interpolation. The SafeStyle string is also guaranteed not to be able
 *       to introduce new properties or elide existing ones.
 *   <li>Interpolated as the content of a {}-wrapped block within an HTML
 *       &lt;style&gt; element. '<' characters in the SafeStyle string
 *       *must be CSS-escaped* before interpolation.
 *   <li>Assigned to the style property of a DOM node. The SafeStyle string
 *       should not be escaped before being assigned to the property.
 * </ul>
 *
 * A SafeStyle may never contain literal angle brackets. Otherwise, it could
 * be unsafe to place a SafeStyle into a &lt;style&gt; tag (where it can't
 * be HTML escaped). For example, if the SafeStyle containing
 * `font: 'foo &lt;style/&gt;&lt;script&gt;evil&lt;/script&gt;'` were
 * interpolated within a &lt;style&gt; tag, this would then break out of the
 * style context into HTML.
 *
 * A SafeStyle may contain literal single or double quotes, and as such the
 * entire style string must be escaped when used in a style attribute (if
 * this were not the case, the string could contain a matching quote that
 * would escape from the style attribute).
 *
 * Values of this type must be composable, i.e. for any two values
 * `style1` and `style2` of this type,
 * `SafeStyle.unwrap(style1) +
 * SafeStyle.unwrap(style2)` must itself be a value that satisfies
 * the SafeStyle type constraint. This requirement implies that for any value
 * `style` of this type, `SafeStyle.unwrap(style)` must
 * not end in a "property value" or "property name" context. For example,
 * a value of `background:url("` or `font-` would not satisfy the
 * SafeStyle contract. This is because concatenating such strings with a
 * second value that itself does not contain unsafe CSS can result in an
 * overall string that does. For example, if `javascript:evil())"` is
 * appended to `background:url("}, the resulting string may result in
 * the execution of a malicious script.
 *
 * TODO(mlourenco): Consider whether we should implement UTF-8 interchange
 * validity checks and blacklisting of newlines (including Unicode ones) and
 * other whitespace characters (\t, \f). Document here if so and also update
 * SafeStyle.fromConstant().
 *
 * The following example values comply with this type's contract:
 * <ul>
 *   <li><pre>width: 1em;</pre>
 *   <li><pre>height:1em;</pre>
 *   <li><pre>width: 1em;height: 1em;</pre>
 *   <li><pre>background:url('http://url');</pre>
 * </ul>
 * In addition, the empty string is safe for use in a CSS attribute.
 *
 * The following example values do NOT comply with this type's contract:
 * <ul>
 *   <li><pre>background: red</pre> (missing a trailing semi-colon)
 *   <li><pre>background:</pre> (missing a value and a trailing semi-colon)
 *   <li><pre>1em</pre> (missing an attribute name, which provides context for
 *       the value)
 * </ul>
 *
 * @see SafeStyle#create
 * @see SafeStyle#fromConstant
 * @see http://www.w3.org/TR/css3-syntax/
 * @final
 * @struct
 */
class SafeStyle {
  /**
   * @param {string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    if (goog.DEBUG && token !== CONSTRUCTOR_TOKEN_PRIVATE) {
      throw Error('SafeStyle is not meant to be built directly');
    }

    /**
     * The contained value of this SafeStyle.  The field has a purposely
     * ugly name to make (non-compiled) code that attempts to directly access
     * this field stand out.
     * @const
     * @private {string}
     */
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = value;
  }


  /**
   * Creates a SafeStyle object from a compile-time constant string.
   *
   * `style` should be in the format
   * `name: value; [name: value; ...]` and must not have any < or >
   * characters in it. This is so that SafeStyle's contract is preserved,
   * allowing the SafeStyle to correctly be interpreted as a sequence of CSS
   * declarations and without affecting the syntactic structure of any
   * surrounding CSS and HTML.
   *
   * This method performs basic sanity checks on the format of `style`
   * but does not constrain the format of `name` and `value`, except
   * for disallowing tag characters.
   *
   * @param {!Const} style A compile-time-constant string from which
   *     to create a SafeStyle.
   * @return {!SafeStyle} A SafeStyle object initialized to
   *     `style`.
   * MOE:begin_intracomment_strip
   * @deprecated Use `safevalues.safeStyle` instead.
   * MOE:end_intracomment_strip
   */
  static fromConstant(style) {
    const styleString = Const.unwrap(style);
    if (styleString.length === 0) {
      return SafeStyle.EMPTY;
    }
    assert(
        endsWith(styleString, ';'),
        `Last character of style string is not ';': ${styleString}`);
    assert(
        contains(styleString, ':'),
        'Style string must contain at least one \':\', to ' +
            'specify a "name: value" pair: ' + styleString);
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(
        styleString);
  };


  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a SafeStyle, use
   * `SafeStyle.unwrap`.
   *
   * @return {string}
   * @see SafeStyle#unwrap
   * @override
   */
  toString() {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_.toString();
  }


  /**
   * Performs a runtime check that the provided object is indeed a
   * SafeStyle object, and returns its value.
   *
   * @param {!SafeStyle} safeStyle The object to extract from.
   * @return {string} The safeStyle object's contained string, unless
   *     the run-time type check fails. In that case, `unwrap` returns an
   *     innocuous string, or, if assertions are enabled, throws
   *     `AssertionError`.
   * MOE:begin_intracomment_strip
   * @deprecated Use `safevalues.unwrapStyle` instead.
   * MOE:end_intracomment_strip
   */
  static unwrap(safeStyle) {
    // Perform additional Run-time type-checking to ensure that
    // safeStyle is indeed an instance of the expected type.  This
    // provides some additional protection against security bugs due to
    // application code that disables type checks.
    // Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeStyle instanceof SafeStyle && safeStyle.constructor === SafeStyle) {
      return safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_;
    } else {
      fail(
          `expected object of type SafeStyle, got '${safeStyle}` +
          '\' of type ' + goog.typeOf(safeStyle));
      return 'type_error:SafeStyle';
    }
  }


  /**
   * Package-internal utility method to create SafeStyle instances.
   *
   * @param {string} style The string to initialize the SafeStyle object with.
   * @return {!SafeStyle} The initialized SafeStyle object.
   * @package
   */
  static createSafeStyleSecurityPrivateDoNotAccessOrElse(style) {
    return new SafeStyle(style, CONSTRUCTOR_TOKEN_PRIVATE);
  }

  /**
   * Creates a new SafeStyle object from the properties specified in the map.
   * @param {!SafeStyle.PropertyMap} map Mapping of property names to
   *     their values, for example {'margin': '1px'}. Names must consist of
   *     [-_a-zA-Z0-9]. Values might be strings consisting of
   *     [-,.'"%_!# a-zA-Z0-9[\]], where ", ', and [] must be properly balanced.
   *     We also allow simple functions like rgb() and url() which sanitizes its
   *     contents. Other values must be wrapped in Const. URLs might
   *     be passed as SafeUrl which will be wrapped into url(""). We
   *     also support array whose elements are joined with ' '. Null value
   * causes skipping the property.
   * @return {!SafeStyle}
   * @throws {!Error} If invalid name is provided.
   * @throws {!AssertionError} If invalid value is provided. With
   *     disabled assertions, invalid value is replaced by
   *     SafeStyle.INNOCUOUS_STRING.
   * MOE:begin_intracomment_strip
   * @deprecated Use `safevalues.safeStyle` instead.
   * MOE:end_intracomment_strip
   */
  static create(map) {
    let style = '';
    for (let name in map) {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
      if (Object.prototype.hasOwnProperty.call(map, name)) {
        if (!/^[-_a-zA-Z0-9]+$/.test(name)) {
          throw new Error(`Name allows only [-_a-zA-Z0-9], got: ${name}`);
        }
        let value = map[name];
        if (value == null) {
          continue;
        }
        if (Array.isArray(value)) {
          value = value.map(sanitizePropertyValue).join(' ');
        } else {
          value = sanitizePropertyValue(value);
        }
        style += `${name}:${value};`;
      }
    }
    if (!style) {
      return SafeStyle.EMPTY;
    }
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
  };

  /**
   * Creates a new SafeStyle object by concatenating the values.
   * @param {...(!SafeStyle|!Array<!SafeStyle>)} var_args
   *     SafeStyles to concatenate.
   * @return {!SafeStyle}
   * MOE:begin_intracomment_strip
   * @deprecated Use `safevalues.concatStyles` instead.
   * MOE:end_intracomment_strip
   */
  static concat(var_args) {
    let style = '';

    /**
     * @param {!SafeStyle|!Array<!SafeStyle>} argument
     */
    const addArgument = argument => {
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        style += SafeStyle.unwrap(argument);
      }
    };

    Array.prototype.forEach.call(arguments, addArgument);
    if (!style) {
      return SafeStyle.EMPTY;
    }
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
  };
}

/**
 * A SafeStyle instance corresponding to the empty string.
 * @const {!SafeStyle}
 * MOE:begin_intracomment_strip
 * @deprecated Use `safevalues.safeStyle` instead.
 * MOE:end_intracomment_strip
 */
SafeStyle.EMPTY = SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse('');


/**
 * The innocuous string generated by SafeStyle.create when passed
 * an unsafe value.
 * @const {string}
 */
SafeStyle.INNOCUOUS_STRING = 'zClosurez';


/**
 * A single property value.
 * @typedef {string|!Const|!SafeUrl}
 * MOE:begin_intracomment_strip
 * @deprecated Use an explicit type instead.
 * MOE:end_intracomment_strip
 */
SafeStyle.PropertyValue;


/**
 * Mapping of property names to their values.
 * We don't support numbers even though some values might be numbers (e.g.
 * line-height or 0 for any length). The reason is that most numeric values need
 * units (e.g. '1px') and allowing numbers could cause users forgetting about
 * them.
 * @typedef {!Object<string, ?SafeStyle.PropertyValue|
 *     ?Array<!SafeStyle.PropertyValue>>}
 * MOE:begin_intracomment_strip
 * @deprecated Use an explicit type instead.
 * MOE:end_intracomment_strip
 */
SafeStyle.PropertyMap;



/**
 * Checks and converts value to string.
 * @param {!SafeStyle.PropertyValue} value
 * @return {string}
 */
function sanitizePropertyValue(value) {
  if (value instanceof SafeUrl) {
    const url = value.toString();
    return 'url("' + url.replace(/</g, '%3c').replace(/[\\"]/g, '\\$&') + '")';
  }
  const result = value instanceof Const ?
      Const.unwrap(value) :
      sanitizePropertyValueString(String(value));
  // These characters can be used to change context and we don't want that even
  // with const values.
  if (/[{;}]/.test(result)) {
    throw new AssertionError('Value does not allow [{;}], got: %s.', [result]);
  }
  return result;
}


/**
 * Checks string value.
 * @param {string} value
 * @return {string}
 */
function sanitizePropertyValueString(value) {
  // Some CSS property values permit nested functions. We allow one level of
  // nesting, and all nested functions must also be in the FUNCTIONS_RE_ list.
  const valueWithoutFunctions = value.replace(FUNCTIONS_RE, '$1')
                                    .replace(FUNCTIONS_RE, '$1')
                                    .replace(URL_RE, 'url');
  if (!VALUE_RE.test(valueWithoutFunctions)) {
    fail(
        `String value allows only ${VALUE_ALLOWED_CHARS}` +
        ' and simple functions, got: ' + value);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (COMMENT_RE.test(value)) {
    fail(`String value disallows comments, got: ${value}`);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (!hasBalancedQuotes(value)) {
    fail(`String value requires balanced quotes, got: ${value}`);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (!hasBalancedSquareBrackets(value)) {
    fail(
        'String value requires balanced square brackets and one' +
        ' identifier per pair of brackets, got: ' + value);
    return SafeStyle.INNOCUOUS_STRING;
  }
  return sanitizeUrl(value);
}


/**
 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
 * that neither escape (\) nor any other character that could result in
 * breaking out of a string parsing context are allowed;
 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
 * @param {string} value Untrusted CSS property value.
 * @return {boolean} True if property value is safe with respect to quote
 *     balancedness.
 */
function hasBalancedQuotes(value) {
  let outsideSingle = true;
  let outsideDouble = true;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c == '\'' && outsideDouble) {
      outsideSingle = !outsideSingle;
    } else if (c == '"' && outsideSingle) {
      outsideDouble = !outsideDouble;
    }
  }
  return outsideSingle && outsideDouble;
}


/**
 * Checks that square brackets ([ and ]) are properly balanced inside a string,
 * and that the content in the square brackets is one ident-token;
 * see https://www.w3.org/TR/css-syntax-3/#ident-token-diagram.
 * For practicality, and in line with other restrictions posed on SafeStyle
 * strings, we restrict the character set allowable in the ident-token to
 * [-_a-zA-Z0-9].
 * @param {string} value Untrusted CSS property value.
 * @return {boolean} True if property value is safe with respect to square
 *     bracket balancedness.
 */
function hasBalancedSquareBrackets(value) {
  let outside = true;
  const tokenRe = /^[-_a-zA-Z0-9]$/;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c == ']') {
      if (outside) return false;  // Unbalanced ].
      outside = true;
    } else if (c == '[') {
      if (!outside) return false;  // No nesting.
      outside = false;
    } else if (!outside && !tokenRe.test(c)) {
      return false;
    }
  }
  return outside;
}


/**
 * Characters allowed in VALUE_RE.
 * @type {string}
 */
const VALUE_ALLOWED_CHARS = '[-+,."\'%_!#/ a-zA-Z0-9\\[\\]]';


/**
 * Regular expression for safe values.
 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure
 * they're balanced.
 * Square brackets ([ and ]) are allowed, but a check must be done elsewhere
 * to ensure they're balanced. The content inside a pair of square brackets must
 * be one alphanumeric identifier.
 * ',' allows multiple values to be assigned to the same property
 * (e.g. background-attachment or font-family) and hence could allow
 * multiple values to get injected, but that should pose no risk of XSS.
 * The expression checks only for XSS safety, not for CSS validity.
 * @const {!RegExp}
 */
const VALUE_RE = new RegExp(`^${VALUE_ALLOWED_CHARS}+\$`);


/**
 * Regular expression for url(). We support URLs allowed by
 * https://www.w3.org/TR/css-syntax-3/#url-token-diagram without using escape
 * sequences. Use percent-encoding if you need to use special characters like
 * backslash.
 * @const {!RegExp}
 */
const URL_RE = new RegExp(
    '\\b(url\\([ \t\n]*)(' +
        '\'[ -&(-\\[\\]-~]*\'' +  // Printable characters except ' and \.
        '|"[ !#-\\[\\]-~]*"' +    // Printable characters except " and \.
        '|[!#-&*-\\[\\]-~]*' +    // Printable characters except [ "'()\\].
        ')([ \t\n]*\\))',
    'g');

/**
 * Names of functions allowed in FUNCTIONS_RE.
 * @const {!Array<string>}
 */
const ALLOWED_FUNCTIONS = [
  'calc',
  'cubic-bezier',
  'fit-content',
  'hsl',
  'hsla',
  'linear-gradient',
  'matrix',
  'minmax',
  'radial-gradient',
  'repeat',
  'rgb',
  'rgba',
  '(rotate|scale|translate)(X|Y|Z|3d)?',
  'steps',
  'var',
];


/**
 * Regular expression for simple functions.
 * @const {!RegExp}
 */
const FUNCTIONS_RE = new RegExp(
    '\\b(' + ALLOWED_FUNCTIONS.join('|') + ')' +
        '\\([-+*/0-9a-zA-Z.%#\\[\\], ]+\\)',
    'g');


/**
 * Regular expression for comments. These are disallowed in CSS property values.
 * @const {!RegExp}
 */
const COMMENT_RE = /\/\*/;


/**
 * Sanitize URLs inside url().
 * NOTE: We could also consider using CSS.escape once that's available in the
 * browsers. However, loosely matching URL e.g. with url\(.*\) and then escaping
 * the contents would result in a slightly different language than CSS leading
 * to confusion of users. E.g. url(")") is valid in CSS but it would be invalid
 * as seen by our parser. On the other hand, url(\) is invalid in CSS but our
 * parser would be fine with it.
 * @param {string} value Untrusted CSS property value.
 * @return {string}
 */
function sanitizeUrl(value) {
  return value.replace(URL_RE, (match, before, url, after) => {
    let quote = '';
    url = url.replace(/^(['"])(.*)\1$/, (match, start, inside) => {
      quote = start;
      return inside;
    });
    const sanitized = safevaluesSanitizeUrl(url).toString();
    return before + quote + sanitized + quote + after;
  });
}


exports = SafeStyle;

;return exports;});

//third_party/javascript/closure/html/safestylesheet.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeStyleSheet type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeStyleSheet');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const SafeStyle = goog.require('goog.html.SafeStyle');
const googObject = goog.require('goog.object');
const {assert, fail} = goog.require('goog.asserts');
const {contains} = goog.require('goog.string.internal');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @const {!Object}
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string-like object which represents a CSS style sheet and that carries the
 * security type contract that its value, as a string, will not cause untrusted
 * script execution (XSS) when evaluated as CSS in a browser.
 *
 * Instances of this type must be created via the factory method
 * `SafeStyleSheet.fromConstant` and not by invoking its constructor. The
 * constructor intentionally takes an extra parameter that cannot be constructed
 * outside of this file and the type is immutable; hence only a default instance
 * corresponding to the empty string can be obtained via constructor invocation.
 *
 * A SafeStyleSheet's string representation can safely be interpolated as the
 * content of a style element within HTML. The SafeStyleSheet string should
 * not be escaped before interpolation.
 *
 * Values of this type must be composable, i.e. for any two values
 * `styleSheet1` and `styleSheet2` of this type,
 * `SafeStyleSheet.unwrap(styleSheet1) + SafeStyleSheet.unwrap(styleSheet2)`
 * must itself be a value that satisfies the SafeStyleSheet type constraint.
 * This requirement implies that for any value `styleSheet` of this type,
 * `SafeStyleSheet.unwrap(styleSheet1)` must end in
 * "beginning of rule" context.
 *
 * A SafeStyleSheet can be constructed via security-reviewed unchecked
 * conversions. In this case producers of SafeStyleSheet must ensure themselves
 * that the SafeStyleSheet does not contain unsafe script. Note in particular
 * that `&lt;` is dangerous, even when inside CSS strings, and so should
 * always be forbidden or CSS-escaped in user controlled input. For example, if
 * `&lt;/style&gt;&lt;script&gt;evil&lt;/script&gt;"` were interpolated
 * inside a CSS string, it would break out of the context of the original
 * style element and `evil` would execute. Also note that within an HTML
 * style (raw text) element, HTML character references, such as
 * `&amp;lt;`, are not allowed. See
 * http://www.w3.org/TR/html5/scripting-1.html#restrictions-for-contents-of-script-elements
 * (similar considerations apply to the style element).
 *
 * @see SafeStyleSheet#fromConstant
 * @final
 */
class SafeStyleSheet {
  /**
   * @param {string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    if (goog.DEBUG && token !== CONSTRUCTOR_TOKEN_PRIVATE) {
      throw Error('SafeStyleSheet is not meant to be built directly');
    }

    /**
     * The contained value of this SafeStyleSheet.  The field has a purposely
     * ugly name to make (non-compiled) code that attempts to directly access
     * this field stand out.
     * @const
     * @private {string}
     */
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = value;
  }

  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a SafeStyleSheet, use
   * `SafeStyleSheet.unwrap`.
   *
   * @return {string}
   * @see SafeStyleSheet#unwrap
   * @override
   */
  toString() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_.toString();
  }

  /**
   * Creates a style sheet consisting of one selector and one style definition.
   * Use {@link SafeStyleSheet.concat} to create longer style sheets.
   * This function doesn't support @import, @media and similar constructs.
   * @param {string} selector CSS selector, e.g. '#id' or 'tag .class, #id'. We
   *     support CSS3 selectors: https://w3.org/TR/css3-selectors/#selectors.
   * @param {!SafeStyle.PropertyMap|!SafeStyle} style Style
   *     definition associated with the selector.
   * @return {!SafeStyleSheet}
   * @throws {!Error} If invalid selector is provided.
   * @deprecated Use `safevalues.safeStyleSheet` or `safevalues.safeStyleRule`
   *     instead.
   */
  static createRule(selector, style) {
    if (contains(selector, '<')) {
      throw new Error(`Selector does not allow '<', got: ${selector}`);
    }

    // Remove strings.
    const selectorToCheck =
        selector.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, '');

    // Check characters allowed in CSS3 selectors.
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=\\^$|]+$/.test(selectorToCheck)) {
      throw new Error(
          'Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=\\^$|] and ' +
          'strings, got: ' + selector);
    }

    // Check balanced () and [].
    if (!SafeStyleSheet.hasBalancedBrackets_(selectorToCheck)) {
      throw new Error(
          '() and [] in selector must be balanced, got: ' + selector);
    }

    if (!(style instanceof SafeStyle)) {
      style = SafeStyle.create(style);
    }
    const styleSheet =
        `${selector}{` + SafeStyle.unwrap(style).replace(/</g, '\\3C ') + '}';
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        styleSheet);
  }

  /**
   * Checks if a string has balanced () and [] brackets.
   * @param {string} s String to check.
   * @return {boolean}
   * @private
   */
  static hasBalancedBrackets_(s) {
    const brackets = {'(': ')', '[': ']'};
    const expectedBrackets = [];
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (brackets[ch]) {
        expectedBrackets.push(brackets[ch]);
      } else if (googObject.contains(brackets, ch)) {
        if (expectedBrackets.pop() != ch) {
          return false;
        }
      }
    }
    return expectedBrackets.length == 0;
  }

  /**
   * Creates a new SafeStyleSheet object by concatenating values.
   * @param {...(!SafeStyleSheet|!Array<!SafeStyleSheet>)}
   *     var_args Values to concatenate.
   * @return {!SafeStyleSheet}
   * @deprecated Use `safevalues.concatStyleSheets` instead.
   */
  static concat(var_args) {
    let result = '';

    /**
     * @param {!SafeStyleSheet|!Array<!SafeStyleSheet>}
     *     argument
     */
    const addArgument = argument => {
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        result += SafeStyleSheet.unwrap(argument);
      }
    };

    Array.prototype.forEach.call(arguments, addArgument);
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        result);
  }

  /**
   * Creates a SafeStyleSheet object from a compile-time constant string.
   *
   * `styleSheet` must not have any &lt; characters in it, so that
   * the syntactic structure of the surrounding HTML is not affected.
   *
   * @param {!Const} styleSheet A compile-time-constant string from
   *     which to create a SafeStyleSheet.
   * @return {!SafeStyleSheet} A SafeStyleSheet object initialized to
   *     `styleSheet`.
   * @deprecated Use `safevalues.safeStyleSheet` instead.
   */
  static fromConstant(styleSheet) {
    const styleSheetString = Const.unwrap(styleSheet);
    if (styleSheetString.length === 0) {
      return SafeStyleSheet.EMPTY;
    }
    // > is a valid character in CSS selectors and there's no strict need to
    // block it if we already block <.
    assert(
        !contains(styleSheetString, '<'),
        `Forbidden '<' character in style sheet string: ${styleSheetString}`);
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        styleSheetString);
  }

  /**
   * Performs a runtime check that the provided object is indeed a
   * SafeStyleSheet object, and returns its value.
   *
   * @param {!SafeStyleSheet} safeStyleSheet The object to extract from.
   * @return {string} The safeStyleSheet object's contained string, unless
   *     the run-time type check fails. In that case, `unwrap` returns an
   *     innocuous string, or, if assertions are enabled, throws
   *     `asserts.AssertionError`.
   * @deprecated Use `safevalues.unwrapStyleSheet` combined with `toString()`
   *     instead.
   */
  static unwrap(safeStyleSheet) {
    // Perform additional Run-time type-checking to ensure that
    // safeStyleSheet is indeed an instance of the expected type.  This
    // provides some additional protection against security bugs due to
    // application code that disables type checks.
    // Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeStyleSheet instanceof SafeStyleSheet &&
        safeStyleSheet.constructor === SafeStyleSheet) {
      return safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
    } else {
      fail(
          'expected object of type SafeStyleSheet, got \'' + safeStyleSheet +
          '\' of type ' + goog.typeOf(safeStyleSheet));
      return 'type_error:SafeStyleSheet';
    }
  }

  /**
   * Package-internal utility method to create SafeStyleSheet instances.
   *
   * @param {string} styleSheet The string to initialize the SafeStyleSheet
   *     object with.
   * @return {!SafeStyleSheet} The initialized SafeStyleSheet object.
   * @package
   */
  static createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet) {
    return new SafeStyleSheet(styleSheet, CONSTRUCTOR_TOKEN_PRIVATE);
  }
}

/**
 * A SafeStyleSheet instance corresponding to the empty string.
 * @const {!SafeStyleSheet}
 * @deprecated Use `safevalues.safeStyleSheet` instead.
 */
SafeStyleSheet.EMPTY =
    SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse('');


exports = SafeStyleSheet;

;return exports;});

//third_party/javascript/closure/html/safehtml.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview The SafeHtml type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeHtml');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const SafeStyle = goog.require('goog.html.SafeStyle');
const SafeStyleSheet = goog.require('goog.html.SafeStyleSheet');
const TagName = goog.require('goog.dom.TagName');
const TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');
const asserts = goog.require('goog.asserts');
const googArray = goog.require('goog.array');
const googObject = goog.require('goog.object');
const internal = goog.require('goog.string.internal');
const tags = goog.require('goog.dom.tags');
const trustedtypes = goog.require('goog.html.trustedtypes');
const {SafeUrl, sanitizeUrl, unwrapUrl} = goog.require('safevalues.for_closure');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @type {!Object}
 * @const
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string that is safe to use in HTML context in DOM APIs and HTML documents.
 *
 * A SafeHtml is a string-like object that carries the security type contract
 * that its value as a string will not cause untrusted script execution when
 * evaluated as HTML in a browser.
 *
 * Values of this type are guaranteed to be safe to use in HTML contexts,
 * such as, assignment to the innerHTML DOM property, or interpolation into
 * a HTML template in HTML PC_DATA context, in the sense that the use will not
 * result in a Cross-Site-Scripting vulnerability.
 *
 * Instances of this type must be created via the factory methods
 * (`SafeHtml.create`, `SafeHtml.htmlEscape`),
 * etc and not by invoking its constructor. The constructor intentionally takes
 * an extra parameter that cannot be constructed outside of this file and the
 * type is immutable; hence only a default instance corresponding to the empty
 * string can be obtained via constructor invocation.
 *
 * Creating SafeHtml objects HAS SIDE-EFFECTS due to calling Trusted Types Web
 * API.
 *
 * Note that there is no `SafeHtml.fromConstant`. The reason is that
 * the following code would create an unsafe HTML:
 *
 * ```
 * SafeHtml.concat(
 *     SafeHtml.fromConstant(Const.from('<script>')),
 *     SafeHtml.htmlEscape(userInput),
 *     SafeHtml.fromConstant(Const.from('<\/script>')));
 * ```
 *
 * There's `goog.dom.constHtmlToNode` to create a node from constant strings
 * only.
 *
 * @see SafeHtml.create
 * @see SafeHtml.htmlEscape
 * @final
 * @struct
 */
class SafeHtml {
  /**
   * @private
   * @param {!TrustedHTML|string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    if (goog.DEBUG && token !== CONSTRUCTOR_TOKEN_PRIVATE) {
      throw Error('SafeHtml is not meant to be built directly');
    }

    /**
     * The contained value of this SafeHtml.  The field has a purposely ugly
     * name to make (non-compiled) code that attempts to directly access this
     * field stand out.
     * @const
     * @private {!TrustedHTML|string}
     */
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = value;
  }


  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a SafeHtml, use
   * `SafeHtml.unwrap`.
   *
   * @return {string}
   * @see SafeHtml.unwrap
   * @override
   */
  toString() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }

  /**
   * Performs a runtime check that the provided object is indeed a SafeHtml
   * object, and returns its value.
   * @param {!SafeHtml} safeHtml The object to extract from.
   * @return {string} The SafeHtml object's contained string, unless the
   *     run-time type check fails. In that case, `unwrap` returns an innocuous
   *     string, or, if assertions are enabled, throws
   *     `asserts.AssertionError`.
   * @deprecated Use `safevalues.unwrapHtml` combined with `toString()` instead.
   */
  static unwrap(safeHtml) {
    return SafeHtml.unwrapTrustedHTML(safeHtml).toString();
  }


  /**
   * Unwraps value as TrustedHTML if supported or as a string if not.
   * @param {!SafeHtml} safeHtml
   * @return {!TrustedHTML|string}
   * @see SafeHtml.unwrap
   * @deprecated Use `safevalues.unwrapHtml` instead.
   */
  static unwrapTrustedHTML(safeHtml) {
    // Perform additional run-time type-checking to ensure that safeHtml is
    // indeed an instance of the expected type.  This provides some additional
    // protection against security bugs due to application code that disables
    // type checks. Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeHtml instanceof SafeHtml && safeHtml.constructor === SafeHtml) {
      return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
    } else {
      asserts.fail(
          `expected object of type SafeHtml, got '${safeHtml}' of type ` +
          goog.typeOf(safeHtml));
      return 'type_error:SafeHtml';
    }
  }

  /**
   * Returns HTML-escaped text as a SafeHtml object.
   *
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   * @deprecated Use `safevalues.htmlEscape` instead.
   */
  static htmlEscape(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.htmlEscape(String(textOrHtml)));
  }


  /**
   * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
   * &lt;br&gt;.
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   * @deprecated Use `safevalues.htmlEscape` instead.
   */
  static htmlEscapePreservingNewlines(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    const html = SafeHtml.htmlEscape(textOrHtml);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.newLineToBr(SafeHtml.unwrap(html)));
  }


  /**
   * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
   * &lt;br&gt; and escaping whitespace to preserve spatial formatting.
   * Character entity #160 is used to make it safer for XML.
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   * @deprecated Use `safevalues.htmlEscape` instead.
   */
  static htmlEscapePreservingNewlinesAndSpaces(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    const html = SafeHtml.htmlEscape(textOrHtml);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.whitespaceEscape(SafeHtml.unwrap(html)));
  }

  /**
   * Creates a SafeHtml content consisting of a tag with optional attributes and
   * optional content.
   *
   * For convenience tag names and attribute names are accepted as regular
   * strings, instead of Const. Nevertheless, you should not pass
   * user-controlled values to these parameters. Note that these parameters are
   * syntactically validated at runtime, and invalid values will result in
   * an exception.
   *
   * Example usage:
   *
   * SafeHtml.create('br');
   * SafeHtml.create('div', {'class': 'a'});
   * SafeHtml.create('p', {}, 'a');
   * SafeHtml.create('p', {}, SafeHtml.create('br'));
   *
   * SafeHtml.create('span', {
   *   'style': {'margin': '0'}
   * });
   *
   * To guarantee SafeHtml's type contract is upheld there are restrictions on
   * attribute values and tag names.
   *
   * - For attributes which contain script code (on*), a Const is
   *   required.
   * - For attributes which contain style (style), a SafeStyle or a
   *   SafeStyle.PropertyMap is required.
   * - For attributes which are interpreted as URLs (e.g. src, href) a
   *   SafeUrl, Const or string is required. If a string
   *   is passed, it will be sanitized with sanitizeUrl().
   * - For tags which can load code or set security relevant page metadata,
   *   more specific SafeHtml.create*() functions must be used. Tags
   *   which are not supported by this function are applet, base, embed, iframe,
   *   link, math, meta, object, script, style, svg, and template.
   *
   * @param {!TagName|string} tagName The name of the tag. Only tag names
   *     consisting of [a-zA-Z0-9-] are allowed. Tag names documented above are
   *     disallowed.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. This must be empty for void tags like <br>. Array elements
   * are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided.
   * @throws {!asserts.AssertionError} If content for void tag is provided.
   * @deprecated For large HTML chunks, use a recommended templating system like
   *     Lit. For small chunks that are immediately rendered as HTML elements,
   *     use native DOM APIs. For the rest, use `safevalues.createHtml`.
   * More information:
   *     go/goog.html-readme // LINE-INTERNAL
   */
  static create(tagName, attributes = undefined, content = undefined) {
    SafeHtml.verifyTagName(String(tagName));
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        String(tagName), attributes, content);
  }


  /**
   * Verifies if the tag name is valid and if it doesn't change the context.
   * E.g. STRONG is fine but SCRIPT throws because it changes context. See
   * SafeHtml.create for an explanation of allowed tags.
   * @param {string} tagName
   * @return {void}
   * @throws {!Error} If invalid tag name is provided.
   * @package
   */
  static verifyTagName(tagName) {
    if (!VALID_NAMES_IN_TAG.test(tagName)) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ? `Invalid tag name <${tagName}>.` :
                                           '');
    }
    if (tagName.toUpperCase() in NOT_ALLOWED_TAG_NAMES) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?

              `Tag name <${tagName}> is not allowed for SafeHtml.` :
              '');
    }
  }


  /**
   * Creates a SafeHtml representing an iframe tag.
   *
   * This by default restricts the iframe as much as possible by setting the
   * sandbox attribute to the empty string. If the iframe requires less
   * restrictions, set the sandbox attribute as tight as possible, but do not
   * rely on the sandbox as a security feature because it is not supported by
   * older browsers. If a sandbox is essential to security (e.g. for third-party
   * frames), use createSandboxIframe which checks for browser support.
   *
   * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
   *
   * @param {?TrustedResourceUrl=} src The value of the src
   *     attribute. If null or undefined src will not be set.
   * @param {?SafeHtml=} srcdoc The value of the srcdoc attribute.
   *     If null or undefined srcdoc will not be set.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. Array elements are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided. If attributes
   * contains the src or srcdoc attributes.
   */
  static createIframe(
      src = undefined, srcdoc = undefined, attributes = undefined,
      content = undefined) {
    if (src) {
      // Check whether this is really TrustedResourceUrl.
      TrustedResourceUrl.unwrap(src);
    }

    const fixedAttributes = {};
    fixedAttributes['src'] = src || null;
    fixedAttributes['srcdoc'] = srcdoc && SafeHtml.unwrap(srcdoc);
    const defaultAttributes = {'sandbox': ''};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'iframe', combinedAttrs, content);
  }


  /**
   * Creates a SafeHtml representing a sandboxed iframe tag.
   *
   * The sandbox attribute is enforced in its most restrictive mode, an empty
   * string. Consequently, the security requirements for the src and srcdoc
   * attributes are relaxed compared to SafeHtml.createIframe. This function
   * will throw on browsers that do not support the sandbox attribute, as
   * determined by SafeHtml.canUseSandboxIframe.
   *
   * The SafeHtml returned by this function can trigger downloads with no
   * user interaction on Chrome (though only a few, further attempts are
   * blocked). Firefox and IE will block all downloads from the sandbox.
   *
   * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
   * @see https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Feb/0112.html
   *
   * @param {string|!SafeUrl=} src The value of the src
   *     attribute. If null or undefined src will not be set.
   * @param {string=} srcdoc The value of the srcdoc attribute.
   *     If null or undefined srcdoc will not be set. Will not be sanitized.
   * @param {!Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. Array elements are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided. If attributes
   * contains the src, srcdoc or sandbox attributes. If browser does not support
   * the sandbox attribute on iframe.
   */
  static createSandboxIframe(
      src = undefined, srcdoc = undefined, attributes = undefined,
      content = undefined) {
    if (!SafeHtml.canUseSandboxIframe()) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?
              'The browser does not support sandboxed iframes.' :
              '');
    }

    const fixedAttributes = {};
    if (src) {
      // Note that sanitize is a no-op on SafeUrl.
      fixedAttributes['src'] = unwrapUrl(sanitizeUrl(src));
    } else {
      fixedAttributes['src'] = null;
    }
    fixedAttributes['srcdoc'] = srcdoc || null;
    fixedAttributes['sandbox'] = '';
    const combinedAttrs =
        SafeHtml.combineAttributes(fixedAttributes, {}, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'iframe', combinedAttrs, content);
  }


  /**
   * Checks if the user agent supports sandboxed iframes.
   * @return {boolean}
   */
  static canUseSandboxIframe() {
    return goog.global['HTMLIFrameElement'] &&
        ('sandbox' in goog.global['HTMLIFrameElement'].prototype);
  }


  /**
   * Creates a SafeHtml representing a script tag with the src attribute.
   * @param {!TrustedResourceUrl} src The value of the src
   * attribute.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=}
   * attributes
   *     Mapping from attribute names to their values. Only attribute names
   *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined
   *     causes the attribute to be omitted.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid attribute name or value is provided. If
   *     attributes  contains the
   * src attribute.
   * @deprecated Use `safevalues.scriptUrlToHtml` instead.
   */
  static createScriptSrc(src, attributes = undefined) {
    // TODO(mlourenco): The charset attribute should probably be blocked. If
    // its value is attacker controlled, the script contains attacker controlled
    // sub-strings (even if properly escaped) and the server does not set
    // charset then XSS is likely possible.
    // https://html.spec.whatwg.org/multipage/scripting.html#dom-script-charset

    // Check whether this is really TrustedResourceUrl.
    TrustedResourceUrl.unwrap(src);

    const fixedAttributes = {'src': src};
    const defaultAttributes = {};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'script', combinedAttrs);
  }


  /**
   * Creates a SafeHtml representing a style tag. The type attribute is set
   * to "text/css".
   * @param {!SafeStyleSheet|!Array<!SafeStyleSheet>}
   *     styleSheet Content to put inside the tag. Array elements are
   *     concatenated.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid attribute name or attribute value is provided.
   *     If attributes  contains the
   *     type attribute.
   */
  static createStyle(styleSheet, attributes = undefined) {
    const fixedAttributes = {'type': 'text/css'};
    const defaultAttributes = {};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);

    let content = '';
    styleSheet = googArray.concat(styleSheet);
    for (let i = 0; i < styleSheet.length; i++) {
      content += SafeStyleSheet.unwrap(styleSheet[i]);
    }
    // Convert to SafeHtml so that it's not HTML-escaped. This is safe because
    // as part of its contract, SafeStyleSheet should have no dangerous '<'.
    const htmlContent =
        SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'style', combinedAttrs, htmlContent);
  }


  /**
   * Creates a SafeHtml representing a meta refresh tag.
   * @param {!SafeUrl|string} url Where to redirect. If a string is
   *     passed, it will be sanitized with sanitizeUrl().
   * @param {number=} secs Number of seconds until the page should be
   *     reloaded. Will be set to 0 if unspecified.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   */
  static createMetaRefresh(url, secs = undefined) {
    // Note that sanitize is a no-op on SafeUrl.
    let unwrappedUrl = unwrapUrl(sanitizeUrl(url));

    const attributes = {
      'http-equiv': 'refresh',
      'content': (secs || 0) + '; url=' + unwrappedUrl,
    };

    // This function will handle the HTML escaping for attributes.
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'meta', attributes);
  }

  /**
   * Creates a new SafeHtml object by joining the parts with separator.
   * @param {!SafeHtml.TextOrHtml_} separator
   * @param {!Array<!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>>} parts Parts to join. If a part
   *     contains an array then each member of this array is also joined with
   * the separator.
   * @return {!SafeHtml}
   * @deprecated Use `safevalues.joinHtmls` instead.
   */
  static join(separator, parts) {
    const separatorHtml = SafeHtml.htmlEscape(separator);
    const content = [];

    /**
     * @param {!SafeHtml.TextOrHtml_|
     *     !Array<!SafeHtml.TextOrHtml_>} argument
     */
    const addArgument = (argument) => {
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        const html = SafeHtml.htmlEscape(argument);
        content.push(SafeHtml.unwrap(html));
      }
    };

    parts.forEach(addArgument);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        content.join(SafeHtml.unwrap(separatorHtml)));
  }


  /**
   * Creates a new SafeHtml object by concatenating values.
   * @param {...(!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>)} var_args Values to concatenate.
   * @return {!SafeHtml}
   * @deprecated Use `safevalues.concatHtmls` instead.
   */
  static concat(var_args) {
    return SafeHtml.join(SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
  }

  /**
   * Package-internal utility method to create SafeHtml instances.
   *
   * @param {string} html The string to initialize the SafeHtml object with.
   * @return {!SafeHtml} The initialized SafeHtml object.
   * @package
   */
  static createSafeHtmlSecurityPrivateDoNotAccessOrElse(html) {
    /** @noinline */
    const noinlineHtml = html;
    const policy = trustedtypes.getPolicyPrivateDoNotAccessOrElse();
    const trustedHtml = policy ? policy.createHTML(noinlineHtml) : noinlineHtml;
    return new SafeHtml(trustedHtml, CONSTRUCTOR_TOKEN_PRIVATE);
  }


  /**
   * Like create() but does not restrict which tags can be constructed.
   *
   * @param {string} tagName Tag name. Set or validated by caller.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes
   * @param {(!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>)=} content
   * @return {!SafeHtml}
   * @throws {!Error} If invalid or unsafe attribute name or value is provided.
   * @throws {!asserts.AssertionError} If content for void tag is provided.
   * @package
   */
  static createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
      tagName, attributes = undefined, content = undefined) {
    let result = `<${tagName}`;
    result += SafeHtml.stringifyAttributes(tagName, attributes);

    if (content == null) {
      content = [];
    } else if (!Array.isArray(content)) {
      content = [content];
    }

    if (tags.isVoidTag(tagName.toLowerCase())) {
      asserts.assert(
          !content.length, `Void tag <${tagName}> does not allow content.`);
      result += '>';
    } else {
      const html = SafeHtml.concat(content);
      result += '>' + SafeHtml.unwrap(html) + '</' + tagName + '>';
    }

    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(result);
  }


  /**
   * Creates a string with attributes to insert after tagName.
   * @param {string} tagName
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes
   * @return {string} Returns an empty string if there are no attributes,
   *     returns a string starting with a space otherwise.
   * @throws {!Error} If attribute value is unsafe for the given tag and
   *     attribute.
   * @package
   */
  static stringifyAttributes(tagName, attributes = undefined) {
    let result = '';
    if (attributes) {
      for (let name in attributes) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
        if (Object.prototype.hasOwnProperty.call(attributes, name)) {
          if (!VALID_NAMES_IN_TAG.test(name)) {
            throw new Error(
                SafeHtml.ENABLE_ERROR_MESSAGES ?
                    `Invalid attribute name "${name}".` :
                    '');
          }
          const value = attributes[name];
          if (value == null) {
            continue;
          }
          result += ' ' + getAttrNameAndValue(tagName, name, value);
        }
      }
    }
    return result;
  }


  /**
   * @param {!Object<string, ?SafeHtml.AttributeValue>} fixedAttributes
   * @param {!Object<string, string>} defaultAttributes
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Optional
   *     attributes passed to create*().
   * @return {!Object<string, ?SafeHtml.AttributeValue>}
   * @throws {!Error} If attributes contains an attribute with the same name as
   *     an attribute in fixedAttributes.
   * @package
   */
  static combineAttributes(
      fixedAttributes, defaultAttributes, attributes = undefined) {
    const combinedAttributes = {};

    for (const name in fixedAttributes) {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
      if (Object.prototype.hasOwnProperty.call(fixedAttributes, name)) {
        asserts.assert(name.toLowerCase() == name, 'Must be lower case');
        combinedAttributes[name] = fixedAttributes[name];
      }
    }
    for (const name in defaultAttributes) {
      if (Object.prototype.hasOwnProperty.call(defaultAttributes, name)) {
        asserts.assert(name.toLowerCase() == name, 'Must be lower case');
        combinedAttributes[name] = defaultAttributes[name];
      }
    }

    if (attributes) {
      for (const name in attributes) {
        if (Object.prototype.hasOwnProperty.call(attributes, name)) {
          const nameLower = name.toLowerCase();
          if (nameLower in fixedAttributes) {
            throw new Error(
                SafeHtml.ENABLE_ERROR_MESSAGES ?
                    `Cannot override "${nameLower}" attribute, got "` + name +
                        '" with value "' + attributes[name] + '"' :
                    '');
          }
          if (nameLower in defaultAttributes) {
            delete combinedAttributes[nameLower];
          }
          combinedAttributes[name] = attributes[name];
        }
      }
    }

    return combinedAttributes;
  }
}


/**
 * @define {boolean} Whether to strip out error messages or to leave them in.
 */
SafeHtml.ENABLE_ERROR_MESSAGES =
    goog.define('goog.html.SafeHtml.ENABLE_ERROR_MESSAGES', goog.DEBUG);


/**
 * Whether the `style` attribute is supported. Set to false to avoid the byte
 * weight of `SafeStyle` where unneeded. An error will be thrown if
 * the `style` attribute is used.
 * @define {boolean}
 */
SafeHtml.SUPPORT_STYLE_ATTRIBUTE =
    goog.define('goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE', true);


/**
 * Shorthand for union of types that can sensibly be converted to strings
 * or might already be SafeHtml.
 * @private
 * @typedef {string|number|boolean|!SafeHtml|!Const}
 * @deprecated Use an explicit type instead.
 */
SafeHtml.TextOrHtml_;


/**
 * Coerces an arbitrary object into a SafeHtml object.
 *
 * If `textOrHtml` is already of type `SafeHtml`, the same
 * object is returned. Otherwise, `textOrHtml` is coerced to string, and
 * HTML-escaped.
 *
 * @param {!SafeHtml.TextOrHtml_} textOrHtml The text or SafeHtml to
 *     coerce.
 * @return {!SafeHtml} The resulting SafeHtml object.
 * @deprecated Use SafeHtml.htmlEscape.
 */
SafeHtml.from = SafeHtml.htmlEscape;


/**
 * @const
 */
const VALID_NAMES_IN_TAG = /^[a-zA-Z0-9-]+$/;


/**
 * Set of attributes containing URL as defined at
 * http://www.w3.org/TR/html5/index.html#attributes-1.
 * @const {!Object<string,boolean>}
 */
const URL_ATTRIBUTES = googObject.createSet(
    'action', 'cite', 'data', 'formaction', 'href', 'manifest', 'poster',
    'src');


/**
 * Tags which are unsupported via create(). They might be supported via a
 * tag-specific create method. These are tags which might require a
 * TrustedResourceUrl in one of their attributes or a restricted type for
 * their content.
 * @const {!Object<string,boolean>}
 */
const NOT_ALLOWED_TAG_NAMES = googObject.createSet(
    TagName.APPLET, TagName.BASE, TagName.EMBED, TagName.IFRAME, TagName.LINK,
    TagName.MATH, TagName.META, TagName.OBJECT, TagName.SCRIPT, TagName.STYLE,
    TagName.SVG, TagName.TEMPLATE);


/**
 * @typedef {string|number|
 *     !SafeUrl|!SafeStyle|!Const|!TrustedResourceUrl|!SafeHtml|
 *     !SafeStyle.PropertyMap|undefined|null}
 * @deprecated Use an explicit type instead.
 */
SafeHtml.AttributeValue;


/**
 * @param {string} tagName The tag name.
 * @param {string} name The attribute name.
 * @param {!SafeHtml.AttributeValue} value The attribute value.
 * @return {string} A "name=value" string.
 * @throws {!Error} If attribute value is unsafe for the given tag and
 *     attribute.
 * @private
 */
function getAttrNameAndValue(tagName, name, value) {
  // If it's goog.string.Const, allow any valid attribute name.
  if (value instanceof Const) {
    value = Const.unwrap(value);
  } else if (name.toLowerCase() == 'style') {
    if (SafeHtml.SUPPORT_STYLE_ATTRIBUTE) {
      value = getStyleValue(value);
    } else {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' :
                                           '');
    }
  } else if (/^on/i.test(name)) {
    // TODO(jakubvrana): Disallow more attributes with a special meaning.
    throw new Error(
        SafeHtml.ENABLE_ERROR_MESSAGES ? `Attribute "${name}` +
                '" requires goog.string.Const value, "' + value + '" given.' :
                                         '');
    // URL attributes handled differently according to tag.
  } else if (name.toLowerCase() in URL_ATTRIBUTES) {
    if (value instanceof TrustedResourceUrl) {
      value = TrustedResourceUrl.unwrap(value);
    } else if (value instanceof SafeUrl) {
      value = unwrapUrl(value);
    } else if (typeof value === 'string') {
      value = sanitizeUrl(value).toString();
    } else {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?
              `Attribute "${name}" on tag "${tagName}` +
                  '" requires safevalues.SafeUrl, goog.string.Const, or' +
                  ' string, value "' + value + '" given.' :
              '');
    }
  }

  asserts.assert(
      value instanceof SafeUrl || value instanceof TrustedResourceUrl ||
          value instanceof SafeStyle || value instanceof SafeHtml ||
          typeof value === 'string' || typeof value === 'number',
      'String or number value expected, got ' + (typeof value) +
          ' with value: ' + value);
  return `${name}="` + internal.htmlEscape(String(value)) + '"';
}


/**
 * Gets value allowed in "style" attribute.
 * @param {!SafeHtml.AttributeValue} value It could be SafeStyle or a
 *     map which will be passed to SafeStyle.create.
 * @return {string} Unwrapped value.
 * @throws {!Error} If string value is given.
 * @private
 */
function getStyleValue(value) {
  if (!goog.isObject(value)) {
    throw new Error(
        SafeHtml.ENABLE_ERROR_MESSAGES ?
            'The "style" attribute requires goog.html.SafeStyle or map ' +
                'of style properties, ' + (typeof value) + ' given: ' + value :
            '');
  }
  if (!(value instanceof SafeStyle)) {
    // Process the property bag into a style object.
    value = SafeStyle.create(value);
  }
  return SafeStyle.unwrap(value);
}


/**
 * A SafeHtml instance corresponding to the HTML doctype: "<!DOCTYPE html>".
 * @const {!SafeHtml}
 */
SafeHtml.DOCTYPE_HTML = /** @type {!SafeHtml} */ ({
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // SafeHtml creation (due to calling trustedTypes.createPolicy) from the
  // compiler so that the entire call can be removed if the result is not used.
  // MOE:begin_strip
  // TODO(b/155299094): Refactor after adding compiler support.
  // MOE:end_strip
  valueOf: function() {
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        '<!DOCTYPE html>');
  },
}.valueOf());

/**
 * A SafeHtml instance corresponding to the empty string.
 * @const {!SafeHtml}
 * @deprecated Use `safevalues.EMPTY_HTML` instead.
 */
SafeHtml.EMPTY = new SafeHtml(
    (goog.global.trustedTypes && goog.global.trustedTypes.emptyHTML) || '',
    CONSTRUCTOR_TOKEN_PRIVATE);

/**
 * A SafeHtml instance corresponding to the <br> tag.
 * @const {!SafeHtml}
 * @deprecated Use `safevalues.createHtml('br')` instead.
 */
SafeHtml.BR = /** @type {!SafeHtml} */ ({
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // SafeHtml creation (due to calling trustedTypes.createPolicy) from the
  // compiler so that the entire call can be removed if the result is not used.
  // MOE:begin_strip
  // TODO(b/155299094): Refactor after adding compiler support.
  // MOE:end_strip
  valueOf: function() {
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse('<br>');
  },
}.valueOf());


exports = SafeHtml;

;return exports;});

//third_party/javascript/closure/html/safehtml_internals_for_safevalues.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview File that re-exports the internals of goog.html.SafeHtml type
 * so that they can be used in safevalues for compatibility purposes.
 * DO NOT OPENSOURCE
 */

goog.module('goog.html.safehtml_internals_for_safevalues');

const SafeHtml = goog.require('goog.html.SafeHtml');

exports.createSafeHtml =
    SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse;

;return exports;});

//third_party/javascript/safevalues/internals/html_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Internal implementations of SafeHtml.
 * DO NOT OPENSOURCE
 * Generated from: third_party/javascript/safevalues/internals/html_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.html_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/html_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safehtml_1 = goog.requireType("goog.html.SafeHtml");
const tsickle_safehtml_internals_for_safevalues_2 = goog.requireType("goog.html.safehtml_internals_for_safevalues");
const safehtml_1 = goog.require('goog.html.SafeHtml');
const safehtml_internals_for_safevalues_1 = goog.require('goog.html.safehtml_internals_for_safevalues');
// tslint:disable:enforce-name-casing
/**
 * Export the object separately to break the use of legacy static functions on
 * the re-export, but preserve instanceof checks.
 *
 * Please have a look at go/safehtml?polygot=ts to see what functions are
 * available in safevalues.
 * @type {function(new:tsickle_safehtml_1, ?)}
 */
exports.SafeHtml = (/** @type {function(new:tsickle_safehtml_1, ?)} */ ((/** @type {*} */ (safehtml_1))));
/**
 * Builds a new `SafeHtml` from the given string, without enforcing safety
 * guarantees. It may cause side effects by creating a Trusted Types policy.
 * This shouldn't be exposed to application developers, and must only be used as
 * a step towards safe builders or safe constants.
 * @param {string} html
 * @return {!tsickle_safehtml_1}
 */
function createHtmlInternal(html) {
    return (0, safehtml_internals_for_safevalues_1.createSafeHtml)(html);
}
exports.createHtmlInternal = createHtmlInternal;
/**
 * An empty `SafeHtml` constant.
 * Unlike the function above, using this will not create a policy.
 * @type {!tsickle_safehtml_1}
 */
exports.EMPTY_HTML = safehtml_1.EMPTY;
/**
 * Checks if the given value is a `SafeHtml` instance.
 * @param {*} value
 * @return {boolean}
 */
function isHtml(value) {
    return value instanceof safehtml_1;
}
exports.isHtml = isHtml;
/**
 * Returns the value of the passed `SafeHtml` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedHTML` or a string if Trusted Types are disabled.
 * @param {!tsickle_safehtml_1} value
 * @return {(string|!TrustedHTML)}
 */
function unwrapHtml(value) {
    return safehtml_1.unwrapTrustedHTML(value);
}
exports.unwrapHtml = unwrapHtml;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF9pbXBsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2ludGVybmFscy9odG1sX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQSxzREFBaUc7QUFDakcsd0dBQTZHOzs7Ozs7Ozs7O0FBYWhHLFFBQUEsUUFBUSxHQUFHLHFEQUFBLCtCQUEwQixFQUVqRDs7Ozs7Ozs7O0FBUUQsU0FBZ0Isa0JBQWtCLENBQUMsSUFBWTtJQUM3QyxPQUFPLElBQUEsa0RBQWMsRUFBQyxJQUFJLENBQUMsQ0FBQztBQUM5QixDQUFDO0FBRkQsZ0RBRUM7Ozs7OztBQU1ZLFFBQUEsVUFBVSxHQUFhLFdBQWdCLEtBQUs7Ozs7OztBQUt6RCxTQUFnQixNQUFNLENBQUMsS0FBYztJQUNuQyxPQUFPLEtBQUssc0JBQTJCLENBQUM7QUFDMUMsQ0FBQztBQUZELHdCQUVDOzs7Ozs7Ozs7QUFRRCxTQUFnQixVQUFVLENBQUMsS0FBZTtJQUN4QyxPQUFPLFdBQWdCLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFGRCxnQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEludGVybmFsIGltcGxlbWVudGF0aW9ucyBvZiBTYWZlSHRtbC5cbiAqIERPIE5PVCBPUEVOU09VUkNFXG4gKi9cblxuaW1wb3J0IHtTYWZlSHRtbCBhcyBDbG9zdXJlU2FmZUh0bWx9IGZyb20gJ2dvb2dsZTMvdGhpcmRfcGFydHkvamF2YXNjcmlwdC9jbG9zdXJlL2h0bWwvc2FmZWh0bWwnO1xuaW1wb3J0IHtjcmVhdGVTYWZlSHRtbH0gZnJvbSAnZ29vZ2xlMy90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L2Nsb3N1cmUvaHRtbC9zYWZlaHRtbF9pbnRlcm5hbHNfZm9yX3NhZmV2YWx1ZXMnO1xuXG4vKiogUmUtZXhwb3J0cyB0aGUgQ2xvc3VyZSB0eXBlIHRvIGVuc3VyZSBib3RoIGNvZGViYXNlcyBhcmUgY29tcGF0aWJsZS4gKi9cbmV4cG9ydCB0eXBlIFNhZmVIdG1sID0gQ2xvc3VyZVNhZmVIdG1sO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTplbmZvcmNlLW5hbWUtY2FzaW5nXG4vKipcbiAqIEV4cG9ydCB0aGUgb2JqZWN0IHNlcGFyYXRlbHkgdG8gYnJlYWsgdGhlIHVzZSBvZiBsZWdhY3kgc3RhdGljIGZ1bmN0aW9ucyBvblxuICogdGhlIHJlLWV4cG9ydCwgYnV0IHByZXNlcnZlIGluc3RhbmNlb2YgY2hlY2tzLlxuICpcbiAqIFBsZWFzZSBoYXZlIGEgbG9vayBhdCBnby9zYWZlaHRtbD9wb2x5Z290PXRzIHRvIHNlZSB3aGF0IGZ1bmN0aW9ucyBhcmVcbiAqIGF2YWlsYWJsZSBpbiBzYWZldmFsdWVzLlxuICovXG5leHBvcnQgY29uc3QgU2FmZUh0bWwgPSBDbG9zdXJlU2FmZUh0bWwgYXMgdW5rbm93biBhcyB7XG4gIG5ldyAoXzogbmV2ZXIpOiBTYWZlSHRtbDtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgbmV3IGBTYWZlSHRtbGAgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCB3aXRob3V0IGVuZm9yY2luZyBzYWZldHlcbiAqIGd1YXJhbnRlZXMuIEl0IG1heSBjYXVzZSBzaWRlIGVmZmVjdHMgYnkgY3JlYXRpbmcgYSBUcnVzdGVkIFR5cGVzIHBvbGljeS5cbiAqIFRoaXMgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8gYXBwbGljYXRpb24gZGV2ZWxvcGVycywgYW5kIG11c3Qgb25seSBiZSB1c2VkIGFzXG4gKiBhIHN0ZXAgdG93YXJkcyBzYWZlIGJ1aWxkZXJzIG9yIHNhZmUgY29uc3RhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSHRtbEludGVybmFsKGh0bWw6IHN0cmluZyk6IFNhZmVIdG1sIHtcbiAgcmV0dXJuIGNyZWF0ZVNhZmVIdG1sKGh0bWwpO1xufVxuXG4vKipcbiAqIEFuIGVtcHR5IGBTYWZlSHRtbGAgY29uc3RhbnQuXG4gKiBVbmxpa2UgdGhlIGZ1bmN0aW9uIGFib3ZlLCB1c2luZyB0aGlzIHdpbGwgbm90IGNyZWF0ZSBhIHBvbGljeS5cbiAqL1xuZXhwb3J0IGNvbnN0IEVNUFRZX0hUTUw6IFNhZmVIdG1sID0gQ2xvc3VyZVNhZmVIdG1sLkVNUFRZO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBgU2FmZUh0bWxgIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIdG1sKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2FmZUh0bWwge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDbG9zdXJlU2FmZUh0bWw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHBhc3NlZCBgU2FmZUh0bWxgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKlxuICogUmV0dXJucyBhIG5hdGl2ZSBgVHJ1c3RlZEhUTUxgIG9yIGEgc3RyaW5nIGlmIFRydXN0ZWQgVHlwZXMgYXJlIGRpc2FibGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwSHRtbCh2YWx1ZTogU2FmZUh0bWwpOiBUcnVzdGVkSFRNTCB8IHN0cmluZyB7XG4gIHJldHVybiBDbG9zdXJlU2FmZUh0bWwudW53cmFwVHJ1c3RlZEhUTUwodmFsdWUpO1xufVxuIl19
;return exports;});

//third_party/javascript/closure/html/safestyle_internals_for_safevalues.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview File that re-exports the internals of goog.html.SafeStyle type
 * so that they can be used in safevalues for compatibility purposes.
 * DO NOT OPENSOURCE
 */

goog.module('goog.html.safestyle_internals_for_safevalues');

const SafeStyle = goog.require('goog.html.SafeStyle');

exports.createSafeStyle =
    SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse;

;return exports;});

//third_party/javascript/safevalues/internals/style_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/internals/style_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.style_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/style_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safestyle_1 = goog.requireType("goog.html.SafeStyle");
const tsickle_safestyle_internals_for_safevalues_2 = goog.requireType("goog.html.safestyle_internals_for_safevalues");
const safestyle_1 = goog.require('goog.html.SafeStyle');
const safestyle_internals_for_safevalues_1 = goog.require('goog.html.safestyle_internals_for_safevalues');
// tslint:disable:enforce-name-casing
/**
 * Export the object separately to break the use of legacy static functions on
 * the re-export, but preserve instanceof checks.
 *
 * Please have a look at go/safehtml?polygot=ts to see what functions are
 * available in safevalues.
 * @type {function(new:tsickle_safestyle_1, ?)}
 */
exports.SafeStyle = (/** @type {function(new:tsickle_safestyle_1, ?)} */ ((/** @type {*} */ (safestyle_1))));
/**
 * Builds a new `SafeStyle` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} style
 * @return {!tsickle_safestyle_1}
 */
function createStyleInternal(style) {
    return (0, safestyle_internals_for_safevalues_1.createSafeStyle)(style);
}
exports.createStyleInternal = createStyleInternal;
/**
 * Checks if the given value is a `SafeStyle` instance.
 * @param {*} value
 * @return {boolean}
 */
function isStyle(value) {
    return value instanceof safestyle_1;
}
exports.isStyle = isStyle;
/**
 * Returns the string value of the passed `SafeStyle` object while ensuring it
 * has the correct type.
 * @param {!tsickle_safestyle_1} value
 * @return {string}
 */
function unwrapStyle(value) {
    return safestyle_1.unwrap(value);
}
exports.unwrapStyle = unwrapStyle;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGVfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9pbnRlcm5hbHMvc3R5bGVfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0RBQW9HO0FBQ3BHLDBHQUErRzs7Ozs7Ozs7OztBQWFsRyxRQUFBLFNBQVMsR0FBRyxzREFBQSxnQ0FBMkIsRUFFbkQ7Ozs7Ozs7O0FBT0QsU0FBZ0IsbUJBQW1CLENBQUMsS0FBYTtJQUMvQyxPQUFPLElBQUEsb0RBQWUsRUFBQyxLQUFLLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRkQsa0RBRUM7Ozs7OztBQUtELFNBQWdCLE9BQU8sQ0FBQyxLQUFjO0lBQ3BDLE9BQU8sS0FBSyx1QkFBNEIsQ0FBQztBQUMzQyxDQUFDO0FBRkQsMEJBRUM7Ozs7Ozs7QUFNRCxTQUFnQixXQUFXLENBQUMsS0FBZ0I7SUFDMUMsT0FBTyxZQUFpQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUZELGtDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge1NhZmVTdHlsZSBhcyBDbG9zdXJlU2FmZVN0eWxlfSBmcm9tICdnb29nbGUzL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvY2xvc3VyZS9odG1sL3NhZmVzdHlsZSc7XG5pbXBvcnQge2NyZWF0ZVNhZmVTdHlsZX0gZnJvbSAnZ29vZ2xlMy90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L2Nsb3N1cmUvaHRtbC9zYWZlc3R5bGVfaW50ZXJuYWxzX2Zvcl9zYWZldmFsdWVzJztcblxuLyoqIFJlLWV4cG9ydHMgdGhlIENsb3N1cmUgdHlwZSB0byBlbnN1cmUgYm90aCBjb2RlYmFzZXMgYXJlIGNvbXBhdGlibGUuICovXG5leHBvcnQgdHlwZSBTYWZlU3R5bGUgPSBDbG9zdXJlU2FmZVN0eWxlO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTplbmZvcmNlLW5hbWUtY2FzaW5nXG4vKipcbiAqIEV4cG9ydCB0aGUgb2JqZWN0IHNlcGFyYXRlbHkgdG8gYnJlYWsgdGhlIHVzZSBvZiBsZWdhY3kgc3RhdGljIGZ1bmN0aW9ucyBvblxuICogdGhlIHJlLWV4cG9ydCwgYnV0IHByZXNlcnZlIGluc3RhbmNlb2YgY2hlY2tzLlxuICpcbiAqIFBsZWFzZSBoYXZlIGEgbG9vayBhdCBnby9zYWZlaHRtbD9wb2x5Z290PXRzIHRvIHNlZSB3aGF0IGZ1bmN0aW9ucyBhcmVcbiAqIGF2YWlsYWJsZSBpbiBzYWZldmFsdWVzLlxuICovXG5leHBvcnQgY29uc3QgU2FmZVN0eWxlID0gQ2xvc3VyZVNhZmVTdHlsZSBhcyB1bmtub3duIGFzIHtcbiAgbmV3IChfOiBuZXZlcik6IFNhZmVTdHlsZTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgbmV3IGBTYWZlU3R5bGVgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlSW50ZXJuYWwoc3R5bGU6IHN0cmluZyk6IFNhZmVTdHlsZSB7XG4gIHJldHVybiBjcmVhdGVTYWZlU3R5bGUoc3R5bGUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBgU2FmZVN0eWxlYCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3R5bGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTYWZlU3R5bGUge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDbG9zdXJlU2FmZVN0eWxlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgcGFzc2VkIGBTYWZlU3R5bGVgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBTdHlsZSh2YWx1ZTogU2FmZVN0eWxlKTogc3RyaW5nIHtcbiAgcmV0dXJuIENsb3N1cmVTYWZlU3R5bGUudW53cmFwKHZhbHVlKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/elements/element.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview This contains safe wrappers for properties that aren't specific
 * to one kind of HTMLElement (like innerHTML), plus other setters and functions
 * that are not tied to elements (like location.href or Worker constructor).
 * Generated from: third_party/javascript/safevalues/dom/elements/element.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.element');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/element.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_attribute_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.attribute_impl");
const tsickle_html_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_style_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_impl");
const tsickle_SafeHtml_5 = goog.requireType("goog.html.SafeHtml");
const tsickle_SafeStyle_6 = goog.requireType("goog.html.SafeStyle");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const attribute_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.attribute_impl');
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const style_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_impl'); // LINE-INTERNAL
// LINE-INTERNAL
/**
 * Safely set {\@link Element.innerHTML} on a given ShadowRoot or Element which
 * may not be a `<script>` element or a `<style>` element.
 * @template T
 * @param {?} elOrRoot
 * @param {!tsickle_SafeHtml_5} v
 * @return {void}
 */
function setInnerHtml(elOrRoot, v) {
    if (isElement(elOrRoot)) {
        throwIfScriptOrStyle(elOrRoot);
    }
    (/** @type {(!Element|!ShadowRoot)} */ (elOrRoot)).innerHTML = (/** @type {string} */ ((0, html_impl_1.unwrapHtml)(v)));
}
exports.setInnerHtml = setInnerHtml;
/**
 * Safely set {\@link Element.outerHTML} for the given Element.
 * @param {!Element} e
 * @param {!tsickle_SafeHtml_5} v
 * @return {void}
 */
function setOuterHtml(e, v) {
    /** @type {(null|!HTMLElement)} */
    const parent = e.parentElement;
    if (parent !== null) {
        throwIfScriptOrStyle(parent);
    }
    e.outerHTML = (/** @type {string} */ ((0, html_impl_1.unwrapHtml)(v)));
}
exports.setOuterHtml = setOuterHtml;
// BEGIN-INTERNAL
/**
 * Set `ElementCSSInlineStyle.cssText` for the given `ElementCSSInlineStyle`.
 *
 * @deprecated Inline styles do not pose a security risk with modern browsers
 *     anymore, so there's no need to use this function. Please use
 *     `HTMLElement.prototype.style.cssText` or other native style properties on
 *     the element directly instead. See go/deleting-safestyle for more
 *     information. Reach out to http://yaqs/ise-web if you have any questions.
 * @param {!ElementCSSInlineStyle} e
 * @param {!tsickle_SafeStyle_6} v
 * @return {void}
 */
function setCssText(e, v) {
    e.style.cssText = (0, style_impl_1.unwrapStyle)(v);
}
exports.setCssText = setCssText;
// END-INTERNAL
/**
 * Safely call {\@link Element.insertAdjacentHTML} for the given Element.
 * @template T
 * @param {?} element
 * @param {string} position
 * @param {!tsickle_SafeHtml_5} v
 * @return {void}
 */
function insertAdjacentHtml(element, position, v) {
    /** @type {(null|!HTMLElement|?)} */
    const tagContext = position === 'beforebegin' || position === 'afterend'
        ? element.parentElement
        : element;
    if (tagContext !== null) {
        throwIfScriptOrStyle(tagContext);
    }
    element.insertAdjacentHTML(position, (/** @type {string} */ ((0, html_impl_1.unwrapHtml)(v))));
}
exports.insertAdjacentHtml = insertAdjacentHtml;
/**
 * Given a set of known-to-be-safe prefixes (e.g., "data-", "aria-", "js"),
 * return a setter function that allows you to set attributes on an element,
 * as long as the names of the attributes to be set has one of the prefixes.
 *
 * The returned setter ensures that setting any dangerous attribute, e.g.,
 * "src", "href" will cause an exception. This is intended to be used as the
 * safe alterantive of `Element#setAttribute`, when applications need to set
 * attributes that do not have security implications and do not have a
 * corresponding DOM property.
 * @param {!tsickle_attribute_impl_2.SafeAttributePrefix} prefix
 * @param {...!tsickle_attribute_impl_2.SafeAttributePrefix} otherPrefixes
 * @return {function(!Element, string, string): void}
 */
function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {
    /** @type {!Array<!tsickle_attribute_impl_2.SafeAttributePrefix>} */
    const prefixes = [prefix, ...otherPrefixes];
    return (/**
     * @param {!Element} e
     * @param {string} attr
     * @param {string} value
     * @return {void}
     */
    (e, attr, value) => {
        setPrefixedAttribute(prefixes, e, attr, value);
    });
}
exports.buildPrefixedAttributeSetter = buildPrefixedAttributeSetter;
/**
 * The safe alternative to Element#setAttribute. The function takes a list of
 * `SafeAttributePrefix`, making developer intention explicit. The attribute
 * to be set must has one of the safe prefixes, otherwise the function throws
 * an Error.
 * @param {!ReadonlyArray<!tsickle_attribute_impl_2.SafeAttributePrefix>} attrPrefixes
 * @param {!Element} e
 * @param {string} attr
 * @param {string} value
 * @return {void}
 */
function setPrefixedAttribute(attrPrefixes, e, attr, value) {
    if (attrPrefixes.length === 0) {
        /** @type {string} */
        let message = '';
        if (dev_1.DEV_MODE) {
            message = 'No prefixes are provided';
        }
        throw new Error(message);
    }
    /** @type {!Array<string>} */
    const prefixes = attrPrefixes.map((/**
     * @param {!tsickle_attribute_impl_2.SafeAttributePrefix} s
     * @return {string}
     */
    (s) => (0, attribute_impl_1.unwrapAttributePrefix)(s)));
    /** @type {string} */
    const attrLower = attr.toLowerCase();
    if (prefixes.every((/**
     * @param {string} p
     * @return {boolean}
     */
    (p) => attrLower.indexOf(p) !== 0))) {
        throw new Error(`Attribute "${attr}" does not match any of the allowed prefixes.`);
    }
    e.setAttribute(attr, value);
}
exports.setPrefixedAttribute = setPrefixedAttribute;
/**
 * @param {!Element} element
 * @return {void}
 */
function throwIfScriptOrStyle(element) {
    /** @type {string} */
    let message = '';
    /** @type {string} */
    const tagName = element.tagName;
    if (tagName === 'SCRIPT' || tagName === 'STYLE') {
        if (dev_1.DEV_MODE) {
            if (tagName === 'SCRIPT') {
                message = 'Use safeScriptEl.setTextContent with a SafeScript.';
            }
            else {
                message = 'Use safeStyleEl.setTextContent with a SafeStyleSheet.';
            }
        }
        throw new Error(message);
    }
}
/**
 * @param {(!Element|!ShadowRoot)} elOrRoot
 * @return {boolean}
 */
function isElement(elOrRoot) {
    return elOrRoot.nodeType === 1; // Node.ELEMENT_NODE
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvZWxlbWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV0Esd0ZBQStDO0FBQy9DLDRHQUd3QztBQUN4QyxrR0FBK0Q7QUFDL0Qsb0dBQWtFLENBQUMsZ0JBQWdCOzs7Ozs7Ozs7O0FBTW5GLFNBQWdCLFlBQVksQ0FDMUIsUUFBMEQsRUFDMUQsQ0FBVztJQUVYLElBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDeEIsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUNELHdDQUFBLFFBQVEsRUFBQSxDQUFDLFNBQVMsR0FBRyx3QkFBQSxJQUFBLHNCQUFVLEVBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FBQztBQUMvQyxDQUFDO0FBUkQsb0NBUUM7Ozs7Ozs7QUFLRCxTQUFnQixZQUFZLENBQUMsQ0FBVSxFQUFFLENBQVc7O1VBQzVDLE1BQU0sR0FBRyxDQUFDLENBQUMsYUFBYTtJQUM5QixJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUNwQixvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBQ0QsQ0FBQyxDQUFDLFNBQVMsR0FBRyx3QkFBQSxJQUFBLHNCQUFVLEVBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FBQztBQUN4QyxDQUFDO0FBTkQsb0NBTUM7Ozs7Ozs7Ozs7Ozs7O0FBWUQsU0FBZ0IsVUFBVSxDQUFDLENBQXdCLEVBQUUsQ0FBWTtJQUMvRCxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFBLHdCQUFXLEVBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUZELGdDQUVDOzs7Ozs7Ozs7O0FBTUQsU0FBZ0Isa0JBQWtCLENBQ2hDLE9BQXlELEVBQ3pELFFBQWlFLEVBQ2pFLENBQVc7O1VBRUwsVUFBVSxHQUNkLFFBQVEsS0FBSyxhQUFhLElBQUksUUFBUSxLQUFLLFVBQVU7UUFDbkQsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhO1FBQ3ZCLENBQUMsQ0FBQyxPQUFPO0lBQ2IsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDeEIsb0JBQW9CLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsd0JBQUEsSUFBQSxzQkFBVSxFQUFDLENBQUMsQ0FBQyxFQUFVLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBYkQsZ0RBYUM7Ozs7Ozs7Ozs7Ozs7OztBQWFELFNBQWdCLDRCQUE0QixDQUMxQyxNQUEyQixFQUMzQixHQUFHLGFBQTZDOztVQUUxQyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxhQUFhLENBQUM7SUFFM0M7Ozs7OztJQUFPLENBQUMsQ0FBVSxFQUFFLElBQVksRUFBRSxLQUFhLEVBQUUsRUFBRTtRQUNqRCxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDLEVBQUM7QUFDSixDQUFDO0FBVEQsb0VBU0M7Ozs7Ozs7Ozs7OztBQVFELFNBQWdCLG9CQUFvQixDQUNsQyxZQUE0QyxFQUM1QyxDQUFVLEVBQ1YsSUFBWSxFQUNaLEtBQWE7SUFFYixJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7O1lBQzFCLE9BQU8sR0FBRyxFQUFFO1FBQ2hCLElBQUksY0FBUSxFQUFFLENBQUM7WUFDYixPQUFPLEdBQUcsMEJBQTBCLENBQUM7UUFDdkMsQ0FBQztRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQzs7VUFDSyxRQUFRLEdBQUcsWUFBWSxDQUFDLEdBQUc7Ozs7SUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBQSxzQ0FBcUIsRUFBQyxDQUFDLENBQUMsRUFBQzs7VUFDNUQsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUU7SUFDcEMsSUFBSSxRQUFRLENBQUMsS0FBSzs7OztJQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBQyxFQUFFLENBQUM7UUFDdEQsTUFBTSxJQUFJLEtBQUssQ0FDYixjQUFjLElBQUksK0NBQStDLENBQ2xFLENBQUM7SUFDSixDQUFDO0lBQ0QsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDOUIsQ0FBQztBQXJCRCxvREFxQkM7Ozs7O0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxPQUFnQjs7UUFDeEMsT0FBTyxHQUFHLEVBQUU7O1VBQ1YsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO0lBQy9CLElBQUksT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLEtBQUssT0FBTyxFQUFFLENBQUM7UUFDaEQsSUFBSSxjQUFRLEVBQUUsQ0FBQztZQUNiLElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRSxDQUFDO2dCQUN6QixPQUFPLEdBQUcsb0RBQW9ELENBQUM7WUFDakUsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLE9BQU8sR0FBRyx1REFBdUQsQ0FBQztZQUNwRSxDQUFDO1FBQ0gsQ0FBQztRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztBQUNILENBQUM7Ozs7O0FBRUQsU0FBUyxTQUFTLENBQUMsUUFBOEI7SUFDL0MsT0FBTyxRQUFRLENBQUMsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtBQUN0RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBjb250YWlucyBzYWZlIHdyYXBwZXJzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlbid0IHNwZWNpZmljXG4gKiB0byBvbmUga2luZCBvZiBIVE1MRWxlbWVudCAobGlrZSBpbm5lckhUTUwpLCBwbHVzIG90aGVyIHNldHRlcnMgYW5kIGZ1bmN0aW9uc1xuICogdGhhdCBhcmUgbm90IHRpZWQgdG8gZWxlbWVudHMgKGxpa2UgbG9jYXRpb24uaHJlZiBvciBXb3JrZXIgY29uc3RydWN0b3IpLlxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2Rldic7XG5pbXBvcnQge1xuICBTYWZlQXR0cmlidXRlUHJlZml4LFxuICB1bndyYXBBdHRyaWJ1dGVQcmVmaXgsXG59IGZyb20gJy4uLy4uL2ludGVybmFscy9hdHRyaWJ1dGVfaW1wbCc7XG5pbXBvcnQge1NhZmVIdG1sLCB1bndyYXBIdG1sfSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvaHRtbF9pbXBsJztcbmltcG9ydCB7U2FmZVN0eWxlLCB1bndyYXBTdHlsZX0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3N0eWxlX2ltcGwnOyAvLyBMSU5FLUlOVEVSTkFMXG5cbi8qKlxuICogU2FmZWx5IHNldCB7QGxpbmsgRWxlbWVudC5pbm5lckhUTUx9IG9uIGEgZ2l2ZW4gU2hhZG93Um9vdCBvciBFbGVtZW50IHdoaWNoXG4gKiBtYXkgbm90IGJlIGEgYDxzY3JpcHQ+YCBlbGVtZW50IG9yIGEgYDxzdHlsZT5gIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbm5lckh0bWw8VCBleHRlbmRzIEVsZW1lbnQgfCBTaGFkb3dSb290PihcbiAgZWxPclJvb3Q6IEV4Y2x1ZGU8VCwgSFRNTFNjcmlwdEVsZW1lbnQgfCBIVE1MU3R5bGVFbGVtZW50PixcbiAgdjogU2FmZUh0bWwsXG4pIHtcbiAgaWYgKGlzRWxlbWVudChlbE9yUm9vdCkpIHtcbiAgICB0aHJvd0lmU2NyaXB0T3JTdHlsZShlbE9yUm9vdCk7XG4gIH1cbiAgZWxPclJvb3QuaW5uZXJIVE1MID0gdW53cmFwSHRtbCh2KSBhcyBzdHJpbmc7XG59XG5cbi8qKlxuICogU2FmZWx5IHNldCB7QGxpbmsgRWxlbWVudC5vdXRlckhUTUx9IGZvciB0aGUgZ2l2ZW4gRWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE91dGVySHRtbChlOiBFbGVtZW50LCB2OiBTYWZlSHRtbCkge1xuICBjb25zdCBwYXJlbnQgPSBlLnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICB0aHJvd0lmU2NyaXB0T3JTdHlsZShwYXJlbnQpO1xuICB9XG4gIGUub3V0ZXJIVE1MID0gdW53cmFwSHRtbCh2KSBhcyBzdHJpbmc7XG59XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIFNldCBgRWxlbWVudENTU0lubGluZVN0eWxlLmNzc1RleHRgIGZvciB0aGUgZ2l2ZW4gYEVsZW1lbnRDU1NJbmxpbmVTdHlsZWAuXG4gKlxuICogQGRlcHJlY2F0ZWQgSW5saW5lIHN0eWxlcyBkbyBub3QgcG9zZSBhIHNlY3VyaXR5IHJpc2sgd2l0aCBtb2Rlcm4gYnJvd3NlcnNcbiAqICAgICBhbnltb3JlLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gdXNlIHRoaXMgZnVuY3Rpb24uIFBsZWFzZSB1c2VcbiAqICAgICBgSFRNTEVsZW1lbnQucHJvdG90eXBlLnN0eWxlLmNzc1RleHRgIG9yIG90aGVyIG5hdGl2ZSBzdHlsZSBwcm9wZXJ0aWVzIG9uXG4gKiAgICAgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW5zdGVhZC4gU2VlIGdvL2RlbGV0aW5nLXNhZmVzdHlsZSBmb3IgbW9yZVxuICogICAgIGluZm9ybWF0aW9uLiBSZWFjaCBvdXQgdG8gaHR0cDovL3lhcXMvaXNlLXdlYiBpZiB5b3UgaGF2ZSBhbnkgcXVlc3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3NzVGV4dChlOiBFbGVtZW50Q1NTSW5saW5lU3R5bGUsIHY6IFNhZmVTdHlsZSkge1xuICBlLnN0eWxlLmNzc1RleHQgPSB1bndyYXBTdHlsZSh2KTtcbn1cbi8vIEVORC1JTlRFUk5BTFxuXG4vKipcbiAqIFNhZmVseSBjYWxsIHtAbGluayBFbGVtZW50Lmluc2VydEFkamFjZW50SFRNTH0gZm9yIHRoZSBnaXZlbiBFbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QWRqYWNlbnRIdG1sPFQgZXh0ZW5kcyBFbGVtZW50PihcbiAgZWxlbWVudDogRXhjbHVkZTxULCBIVE1MU2NyaXB0RWxlbWVudCB8IEhUTUxTdHlsZUVsZW1lbnQ+LFxuICBwb3NpdGlvbjogJ2FmdGVyYmVnaW4nIHwgJ2FmdGVyZW5kJyB8ICdiZWZvcmViZWdpbicgfCAnYmVmb3JlZW5kJyxcbiAgdjogU2FmZUh0bWwsXG4pIHtcbiAgY29uc3QgdGFnQ29udGV4dCA9XG4gICAgcG9zaXRpb24gPT09ICdiZWZvcmViZWdpbicgfHwgcG9zaXRpb24gPT09ICdhZnRlcmVuZCdcbiAgICAgID8gZWxlbWVudC5wYXJlbnRFbGVtZW50XG4gICAgICA6IGVsZW1lbnQ7XG4gIGlmICh0YWdDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgdGhyb3dJZlNjcmlwdE9yU3R5bGUodGFnQ29udGV4dCk7XG4gIH1cbiAgZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwocG9zaXRpb24sIHVud3JhcEh0bWwodikgYXMgc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHNldCBvZiBrbm93bi10by1iZS1zYWZlIHByZWZpeGVzIChlLmcuLCBcImRhdGEtXCIsIFwiYXJpYS1cIiwgXCJqc1wiKSxcbiAqIHJldHVybiBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gc2V0IGF0dHJpYnV0ZXMgb24gYW4gZWxlbWVudCxcbiAqIGFzIGxvbmcgYXMgdGhlIG5hbWVzIG9mIHRoZSBhdHRyaWJ1dGVzIHRvIGJlIHNldCBoYXMgb25lIG9mIHRoZSBwcmVmaXhlcy5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgc2V0dGVyIGVuc3VyZXMgdGhhdCBzZXR0aW5nIGFueSBkYW5nZXJvdXMgYXR0cmlidXRlLCBlLmcuLFxuICogXCJzcmNcIiwgXCJocmVmXCIgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyB0aGVcbiAqIHNhZmUgYWx0ZXJhbnRpdmUgb2YgYEVsZW1lbnQjc2V0QXR0cmlidXRlYCwgd2hlbiBhcHBsaWNhdGlvbnMgbmVlZCB0byBzZXRcbiAqIGF0dHJpYnV0ZXMgdGhhdCBkbyBub3QgaGF2ZSBzZWN1cml0eSBpbXBsaWNhdGlvbnMgYW5kIGRvIG5vdCBoYXZlIGFcbiAqIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcmVmaXhlZEF0dHJpYnV0ZVNldHRlcihcbiAgcHJlZml4OiBTYWZlQXR0cmlidXRlUHJlZml4LFxuICAuLi5vdGhlclByZWZpeGVzOiByZWFkb25seSBTYWZlQXR0cmlidXRlUHJlZml4W11cbikge1xuICBjb25zdCBwcmVmaXhlcyA9IFtwcmVmaXgsIC4uLm90aGVyUHJlZml4ZXNdO1xuXG4gIHJldHVybiAoZTogRWxlbWVudCwgYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0UHJlZml4ZWRBdHRyaWJ1dGUocHJlZml4ZXMsIGUsIGF0dHIsIHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc2FmZSBhbHRlcm5hdGl2ZSB0byBFbGVtZW50I3NldEF0dHJpYnV0ZS4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgbGlzdCBvZlxuICogYFNhZmVBdHRyaWJ1dGVQcmVmaXhgLCBtYWtpbmcgZGV2ZWxvcGVyIGludGVudGlvbiBleHBsaWNpdC4gVGhlIGF0dHJpYnV0ZVxuICogdG8gYmUgc2V0IG11c3QgaGFzIG9uZSBvZiB0aGUgc2FmZSBwcmVmaXhlcywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiB0aHJvd3NcbiAqIGFuIEVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJlZml4ZWRBdHRyaWJ1dGUoXG4gIGF0dHJQcmVmaXhlczogcmVhZG9ubHkgU2FmZUF0dHJpYnV0ZVByZWZpeFtdLFxuICBlOiBFbGVtZW50LFxuICBhdHRyOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG4pIHtcbiAgaWYgKGF0dHJQcmVmaXhlcy5sZW5ndGggPT09IDApIHtcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgbWVzc2FnZSA9ICdObyBwcmVmaXhlcyBhcmUgcHJvdmlkZWQnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgcHJlZml4ZXMgPSBhdHRyUHJlZml4ZXMubWFwKChzKSA9PiB1bndyYXBBdHRyaWJ1dGVQcmVmaXgocykpO1xuICBjb25zdCBhdHRyTG93ZXIgPSBhdHRyLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChwcmVmaXhlcy5ldmVyeSgocCkgPT4gYXR0ckxvd2VyLmluZGV4T2YocCkgIT09IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dHJpYnV0ZSBcIiR7YXR0cn1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgcHJlZml4ZXMuYCxcbiAgICApO1xuICB9XG4gIGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dJZlNjcmlwdE9yU3R5bGUoZWxlbWVudDogRWxlbWVudCk6IHZvaWQge1xuICBsZXQgbWVzc2FnZSA9ICcnO1xuICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lO1xuICBpZiAodGFnTmFtZSA9PT0gJ1NDUklQVCcgfHwgdGFnTmFtZSA9PT0gJ1NUWUxFJykge1xuICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSAnVXNlIHNhZmVTY3JpcHRFbC5zZXRUZXh0Q29udGVudCB3aXRoIGEgU2FmZVNjcmlwdC4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9ICdVc2Ugc2FmZVN0eWxlRWwuc2V0VGV4dENvbnRlbnQgd2l0aCBhIFNhZmVTdHlsZVNoZWV0Lic7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoZWxPclJvb3Q6IEVsZW1lbnQgfCBTaGFkb3dSb290KTogZWxPclJvb3QgaXMgRWxlbWVudCB7XG4gIHJldHVybiBlbE9yUm9vdC5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREVcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/elements/embed.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/embed.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.embed');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/embed.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_2 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/**
 * Sets the Src attribute from the given SafeUrl.
 * @param {!HTMLEmbedElement} embedEl
 * @param {!tsickle_TrustedResourceUrl_2} url
 * @return {void}
 */
function setSrc(embedEl, url) {
    embedEl.src = (/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(url)));
}
exports.setSrc = setSrc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2VsZW1lbnRzL2VtYmVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSxrSEFHMkM7Ozs7Ozs7QUFLM0MsU0FBZ0IsTUFBTSxDQUFDLE9BQXlCLEVBQUUsR0FBdUI7SUFDdkUsT0FBTyxDQUFDLEdBQUcsR0FBRyx3QkFBQSxJQUFBLHFDQUFpQixFQUFDLEdBQUcsQ0FBQyxFQUFVLENBQUM7QUFDakQsQ0FBQztBQUZELHdCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge1xuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuXG4vKipcbiAqIFNldHMgdGhlIFNyYyBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gU2FmZVVybC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNyYyhlbWJlZEVsOiBIVE1MRW1iZWRFbGVtZW50LCB1cmw6IFRydXN0ZWRSZXNvdXJjZVVybCkge1xuICBlbWJlZEVsLnNyYyA9IHVud3JhcFJlc291cmNlVXJsKHVybCkgYXMgc3RyaW5nO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/form.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/form.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.form');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/form.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * Sets the Action attribute from the given Url.
 * @param {!HTMLFormElement} form
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setAction(form, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        form.action = sanitizedUrl;
    }
}
exports.setAction = setAction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsdUdBQXFFOzs7Ozs7O0FBS3JFLFNBQWdCLFNBQVMsQ0FBQyxJQUFxQixFQUFFLEdBQVE7O1VBQ2pELFlBQVksR0FBRyxJQUFBLGtDQUFtQixFQUFDLEdBQUcsQ0FBQztJQUM3QyxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQztJQUM3QixDQUFDO0FBQ0gsQ0FBQztBQUxELDhCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge3Vud3JhcFVybE9yU2FuaXRpemUsIFVybH0gZnJvbSAnLi4vLi4vYnVpbGRlcnMvdXJsX2J1aWxkZXJzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBBY3Rpb24gYXR0cmlidXRlIGZyb20gdGhlIGdpdmVuIFVybC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEFjdGlvbihmb3JtOiBIVE1MRm9ybUVsZW1lbnQsIHVybDogVXJsKSB7XG4gIGNvbnN0IHNhbml0aXplZFVybCA9IHVud3JhcFVybE9yU2FuaXRpemUodXJsKTtcbiAgaWYgKHNhbml0aXplZFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9ybS5hY3Rpb24gPSBzYW5pdGl6ZWRVcmw7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/elements/iframe.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Safe iframe helpers and go/intents-for-iframes-for-closure
 * Generated from: third_party/javascript/safevalues/dom/elements/iframe.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.iframe');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/iframe.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_check_1 = goog.requireType("google3.javascript.typescript.contrib.check");
const tsickle_url_builders_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_html_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_resource_url_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_5 = goog.requireType("goog.html.TrustedResourceUrl");
const tsickle_SafeHtml_6 = goog.requireType("goog.html.SafeHtml");
const tsickle_url_impl_7 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const check_1 = goog.require('google3.javascript.typescript.contrib.check'); // LINE-INTERNAL
// LINE-INTERNAL
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders'); // LINE-INTERNAL
// LINE-INTERNAL
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const html_impl_2 = html_impl_1; // LINE-INTERNAL
// LINE-INTERNAL
/**
 * Sets the Src attribute using a TrustedResourceUrl
 * @param {!HTMLIFrameElement} iframe
 * @param {!tsickle_TrustedResourceUrl_5} v
 * @return {void}
 */
function setSrc(iframe, v) {
    iframe.src = (0, resource_url_impl_1.unwrapResourceUrl)(v).toString();
}
exports.setSrc = setSrc;
/**
 * Sets the Srcdoc attribute using a SafeHtml
 * @param {!HTMLIFrameElement} iframe
 * @param {!tsickle_SafeHtml_6} v
 * @return {void}
 */
function setSrcdoc(iframe, v) {
    iframe.srcdoc = (/** @type {string} */ ((0, html_impl_1.unwrapHtml)(v)));
}
exports.setSrcdoc = setSrcdoc;
/**
 * Intent is an enum of 'embed intents' -- reasons to embed some content that
 * are used for security defaults.
 *
 * @see http://go/iframe-intents
 * @enum {number}
 */
const Intent = {
    /**
     * Rich-text like content formatted with HTML tags, but which does not need to
     * run scripts, forms or other potentially dangerous non-formatting content.
     *
     * Example: a license agreement.
     */
    FORMATTED_HTML_CONTENT: 0,
    /**
     * Embed some content created by Google and its employees.
     *
     * Example: a widget to display some content in our app.
     */
    EMBEDDED_INTERNAL_CONTENT: 1,
    /**
     * Trusted content created outside of Google.
     *
     * Example: a checkin widget for a partner airline
     */
    EMBEDDED_TRUSTED_EXTERNAL_CONTENT: 2,
};
exports.Intent = Intent;
Intent[Intent.FORMATTED_HTML_CONTENT] = 'FORMATTED_HTML_CONTENT';
Intent[Intent.EMBEDDED_INTERNAL_CONTENT] = 'EMBEDDED_INTERNAL_CONTENT';
Intent[Intent.EMBEDDED_TRUSTED_EXTERNAL_CONTENT] = 'EMBEDDED_TRUSTED_EXTERNAL_CONTENT';
/** @enum {string} */
const SandboxDirective = {
    ALLOW_SAME_ORIGIN: "allow-same-origin",
    ALLOW_SCRIPTS: "allow-scripts",
    ALLOW_FORMS: "allow-forms",
    ALLOW_POPUPS: "allow-popups",
    ALLOW_POPUPS_TO_ESCAPE_SANDBOX: "allow-popups-to-escape-sandbox",
    ALLOW_STORAGE_ACCESS_BY_USER_ACTIVATION: "allow-storage-access-by-user-activation",
};
/**
 * setSandboxDirectives sets the given sandbox directives on the given iframe.
 * Deletes any existing directives.
 * @param {!HTMLIFrameElement} ifr iframe element.
 * @param {!ReadonlyArray<!SandboxDirective>} directives list of directives to set
 * @return {void} void.
 */
function setSandboxDirectives(ifr, directives) {
    ifr.setAttribute('sandbox', '');
    // Cannot be a for..of loop due to GWS conformance rule:
    // go/gws-inline-js-conformance#heading=h.cecxx7mh5dc5
    for (let i = 0; i < directives.length; i++) {
        if (!ifr.sandbox.supports || ifr.sandbox.supports(directives[i])) {
            ifr.sandbox.add(directives[i]);
        }
    }
}
/**
 * TypeCannotBeUsedWithIntentError is a type of {\@link Error} that is returned
 * when
 * {\@link setSrcWithIntent} or {\@link setSrcdocWithIntent} is called
 * with parameters of the wrong type.
 * @extends {Error}
 */
class TypeCannotBeUsedWithIntentError extends Error {
    /**
     * @public
     * @param {string} type
     * @param {!Intent} intent
     */
    constructor(type, intent) {
        super(`${type} cannot be used with intent ${Intent[intent]}`);
        this.type = type;
        this.intent = intent;
        this.name = 'TypeCannotBeUsedWithIntentError';
    }
}
exports.TypeCannotBeUsedWithIntentError = TypeCannotBeUsedWithIntentError;
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    TypeCannotBeUsedWithIntentError.prototype.name;
    /**
     * @type {string}
     * @public
     */
    TypeCannotBeUsedWithIntentError.prototype.type;
    /**
     * @type {!Intent}
     * @public
     */
    TypeCannotBeUsedWithIntentError.prototype.intent;
}
/**
 * @param {!HTMLIFrameElement} element
 * @param {!Intent} intent
 * @param {(string|!tsickle_url_impl_7.SafeUrl|!tsickle_TrustedResourceUrl_5)} src
 * @return {void}
 */
function setSrcWithIntent(element, intent, src) {
    // if srcdoc was already set, unset it to prevent using an src policy with
    // an srcdoc
    element.removeAttribute('srcdoc');
    switch (intent) {
        case Intent.FORMATTED_HTML_CONTENT: {
            if (src instanceof resource_url_impl_1.TrustedResourceUrl) {
                throw new TypeCannotBeUsedWithIntentError('TrustedResourceUrl', Intent.FORMATTED_HTML_CONTENT);
            }
            setSandboxDirectives(element, []);
            /** @type {(undefined|string)} */
            const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(src);
            if (sanitizedUrl !== undefined) {
                element.src = sanitizedUrl;
            }
            return;
        }
        case Intent.EMBEDDED_INTERNAL_CONTENT: {
            if (!(src instanceof resource_url_impl_1.TrustedResourceUrl)) {
                throw new TypeCannotBeUsedWithIntentError(typeof src, Intent.EMBEDDED_INTERNAL_CONTENT);
            }
            setSandboxDirectives(element, [
                SandboxDirective.ALLOW_SAME_ORIGIN,
                SandboxDirective.ALLOW_SCRIPTS,
                SandboxDirective.ALLOW_FORMS,
                SandboxDirective.ALLOW_POPUPS,
                SandboxDirective.ALLOW_POPUPS_TO_ESCAPE_SANDBOX,
                SandboxDirective.ALLOW_STORAGE_ACCESS_BY_USER_ACTIVATION,
            ]);
            setSrc(element, src);
            return;
        }
        case Intent.EMBEDDED_TRUSTED_EXTERNAL_CONTENT: {
            if (src instanceof resource_url_impl_1.TrustedResourceUrl) {
                throw new TypeCannotBeUsedWithIntentError('TrustedResourceUrl', Intent.EMBEDDED_TRUSTED_EXTERNAL_CONTENT);
            }
            setSandboxDirectives(element, [
                SandboxDirective.ALLOW_SAME_ORIGIN,
                SandboxDirective.ALLOW_SCRIPTS,
                SandboxDirective.ALLOW_FORMS,
                SandboxDirective.ALLOW_POPUPS,
                SandboxDirective.ALLOW_POPUPS_TO_ESCAPE_SANDBOX,
                SandboxDirective.ALLOW_STORAGE_ACCESS_BY_USER_ACTIVATION,
            ]);
            /** @type {(undefined|string)} */
            const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(src);
            if (sanitizedUrl !== undefined) {
                element.src = sanitizedUrl;
            }
            return;
        }
        default:
            (0, check_1.checkExhaustive)(intent);
    }
}
exports.setSrcWithIntent = setSrcWithIntent;
/**
 * @param {!HTMLIFrameElement} element
 * @param {!Intent} intent
 * @param {(string|!tsickle_SafeHtml_6)} srcdoc
 * @return {void}
 */
function setSrcdocWithIntent(element, intent, srcdoc) {
    // if src was already set, unset it to prevent using an src policy with an
    // srcdoc
    element.removeAttribute('src');
    switch (intent) {
        case Intent.FORMATTED_HTML_CONTENT: {
            if (srcdoc instanceof html_impl_1.SafeHtml) {
                throw new TypeCannotBeUsedWithIntentError('SafeHtml', Intent.FORMATTED_HTML_CONTENT);
            }
            // type assertion required as declare global syntax is pollutive in
            // google3 at the time of writing.
            ((/** @type {?} */ (element))).csp =
                "default-src 'none'";
            setSandboxDirectives(element, []);
            setSrcdoc(element, (0, html_impl_2.createHtmlInternal)(srcdoc));
            return;
        }
        case Intent.EMBEDDED_INTERNAL_CONTENT: {
            if (!(srcdoc instanceof html_impl_1.SafeHtml)) {
                throw new TypeCannotBeUsedWithIntentError('string', Intent.EMBEDDED_INTERNAL_CONTENT);
            }
            setSandboxDirectives(element, [
                SandboxDirective.ALLOW_SAME_ORIGIN,
                SandboxDirective.ALLOW_SCRIPTS,
                SandboxDirective.ALLOW_FORMS,
                SandboxDirective.ALLOW_POPUPS,
                SandboxDirective.ALLOW_POPUPS_TO_ESCAPE_SANDBOX,
                SandboxDirective.ALLOW_STORAGE_ACCESS_BY_USER_ACTIVATION,
            ]);
            setSrcdoc(element, srcdoc);
            return;
        }
        case Intent.EMBEDDED_TRUSTED_EXTERNAL_CONTENT: {
            if (srcdoc instanceof html_impl_1.SafeHtml) {
                throw new TypeCannotBeUsedWithIntentError('SafeHtml', Intent.EMBEDDED_INTERNAL_CONTENT);
            }
            setSandboxDirectives(element, [
                SandboxDirective.ALLOW_SCRIPTS,
                SandboxDirective.ALLOW_FORMS,
                SandboxDirective.ALLOW_POPUPS,
                SandboxDirective.ALLOW_POPUPS_TO_ESCAPE_SANDBOX,
                SandboxDirective.ALLOW_STORAGE_ACCESS_BY_USER_ACTIVATION,
            ]);
            setSrcdoc(element, (0, html_impl_2.createHtmlInternal)(srcdoc));
            return;
        }
        default:
            (0, check_1.checkExhaustive)(intent);
    }
}
exports.setSrcdocWithIntent = setSrcdocWithIntent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWZyYW1lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9pZnJhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0EsNEVBQTRFLENBQUMsZ0JBQWdCOztBQUU3Rix1R0FBcUUsQ0FBQyxnQkFBZ0I7O0FBQ3RGLGtHQUErRDtBQUMvRCxrSEFHMkM7QUFFM0MsZ0NBQStELENBQUMsZ0JBQWdCOzs7Ozs7OztBQUdoRixTQUFnQixNQUFNLENBQUMsTUFBeUIsRUFBRSxDQUFxQjtJQUNyRSxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUEscUNBQWlCLEVBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDL0MsQ0FBQztBQUZELHdCQUVDOzs7Ozs7O0FBR0QsU0FBZ0IsU0FBUyxDQUFDLE1BQXlCLEVBQUUsQ0FBVztJQUM5RCxNQUFNLENBQUMsTUFBTSxHQUFHLHdCQUFBLElBQUEsc0JBQVUsRUFBQyxDQUFDLENBQUMsRUFBVSxDQUFDO0FBQzFDLENBQUM7QUFGRCw4QkFFQzs7Ozs7Ozs7QUFTRCxNQUFZLE1BQU07Ozs7Ozs7SUFPaEIsc0JBQXNCLEdBQUE7Ozs7OztJQU90Qix5QkFBeUIsR0FBQTs7Ozs7O0lBT3pCLGlDQUFpQyxHQUFBO0VBQ2xDOzs7Ozs7QUFFRCxNQUFLLGdCQUFnQjtJQUNuQixpQkFBaUIscUJBQXNCO0lBQ3ZDLGFBQWEsaUJBQWtCO0lBQy9CLFdBQVcsZUFBZ0I7SUFDM0IsWUFBWSxnQkFBaUI7SUFDN0IsOEJBQThCLGtDQUFtQztJQUNqRSx1Q0FBdUMsMkNBQTRDO0VBQ3BGOzs7Ozs7OztBQVNELFNBQVMsb0JBQW9CLENBQ3pCLEdBQXNCLEVBQUUsVUFBdUM7SUFDakUsR0FBRyxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFD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Q0FDdkMsUUFBUSxFQUNSLE1BQU0sQ0FBQyx5QkFBeUIsQ0FDakMsQ0FBQztZQUNKLENBQUM7WUFFRCxvQkFBb0IsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVCLGdCQUFnQixDQUFDLGlCQUFpQjtnQkFDbEMsZ0JBQWdCLENBQUMsYUFBYTtnQkFDOUIsZ0JBQWdCLENBQUMsV0FBVztnQkFDNUIsZ0JBQWdCLENBQUMsWUFBWTtnQkFDN0IsZ0JBQWdCLENBQUMsOEJBQThCO2dCQUMvQyxnQkFBZ0IsQ0FBQyx1Q0FBdUM7YUFDekQsQ0FBQyxDQUFDO1lBQ0gsU0FBUyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUUzQixPQUFPO1FBQ1QsQ0FBQztRQUVELEtBQUssTUFBTSxDQUFDLGlDQUFpQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxJQUFJLE1BQU0sWUFBWSxvQkFBUSxFQUFFLENBQUM7Z0JBQy9CLE1BQU0sSUFBSSwrQkFBK0IsQ0FDdkMsVUFBVSxFQUNWLE1BQU0sQ0FBQyx5QkFBeUIsQ0FDakMsQ0FBQztZQUNKLENBQUM7WUFFRCxvQkFBb0IsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVCLGdCQUFnQixDQUFDLGFBQWE7Z0JBQzlCLGdCQUFnQixDQUFDLFdBQVc7Z0JBQzVCLGdCQUFnQixDQUFDLFlBQVk7Z0JBQzdCLGdCQUFnQixDQUFDLDhCQUE4QjtnQkFDL0MsZ0JBQWdCLENBQUMsdUNBQXVDO2FBQ3pELENBQUMsQ0FBQztZQUNILFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBQSw4QkFBa0IsRUFBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBRS9DLE9BQU87UUFDVCxDQUFDO1FBRUQ7WUFDRSxJQUFBLHVCQUFlLEVBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUIsQ0FBQztBQUNILENBQUM7QUF6RUQsa0RBeUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2FmZSBpZnJhbWUgaGVscGVycyBhbmQgZ28vaW50ZW50cy1mb3ItaWZyYW1lcy1mb3ItY2xvc3VyZVxuICovXG5cbmltcG9ydCB7Y2hlY2tFeGhhdXN0aXZlfSBmcm9tICdnb29nbGUzL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9jb250cmliL2NoZWNrJzsgLy8gTElORS1JTlRFUk5BTFxuXG5pbXBvcnQge3Vud3JhcFVybE9yU2FuaXRpemUsIFVybH0gZnJvbSAnLi4vLi4vYnVpbGRlcnMvdXJsX2J1aWxkZXJzJzsgLy8gTElORS1JTlRFUk5BTFxuaW1wb3J0IHtTYWZlSHRtbCwgdW53cmFwSHRtbH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5pbXBvcnQge1xuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuXG5pbXBvcnQge2NyZWF0ZUh0bWxJbnRlcm5hbH0gZnJvbSAnLi8uLi8uLi9pbnRlcm5hbHMvaHRtbF9pbXBsJzsgLy8gTElORS1JTlRFUk5BTFxuXG4vKiogU2V0cyB0aGUgU3JjIGF0dHJpYnV0ZSB1c2luZyBhIFRydXN0ZWRSZXNvdXJjZVVybCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNyYyhpZnJhbWU6IEhUTUxJRnJhbWVFbGVtZW50LCB2OiBUcnVzdGVkUmVzb3VyY2VVcmwpIHtcbiAgaWZyYW1lLnNyYyA9IHVud3JhcFJlc291cmNlVXJsKHYpLnRvU3RyaW5nKCk7XG59XG5cbi8qKiBTZXRzIHRoZSBTcmNkb2MgYXR0cmlidXRlIHVzaW5nIGEgU2FmZUh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTcmNkb2MoaWZyYW1lOiBIVE1MSUZyYW1lRWxlbWVudCwgdjogU2FmZUh0bWwpIHtcbiAgaWZyYW1lLnNyY2RvYyA9IHVud3JhcEh0bWwodikgYXMgc3RyaW5nO1xufVxuXG4vLyBCRUdJTi1JTlRFUk5BTFxuLyoqXG4gKiBJbnRlbnQgaXMgYW4gZW51bSBvZiAnZW1iZWQgaW50ZW50cycgLS0gcmVhc29ucyB0byBlbWJlZCBzb21lIGNvbnRlbnQgdGhhdFxuICogYXJlIHVzZWQgZm9yIHNlY3VyaXR5IGRlZmF1bHRzLlxuICpcbiAqIEBzZWUgaHR0cDovL2dvL2lmcmFtZS1pbnRlbnRzXG4gKi9cbmV4cG9ydCBlbnVtIEludGVudCB7XG4gIC8qKlxuICAgKiBSaWNoLXRleHQgbGlrZSBjb250ZW50IGZvcm1hdHRlZCB3aXRoIEhUTUwgdGFncywgYnV0IHdoaWNoIGRvZXMgbm90IG5lZWQgdG9cbiAgICogcnVuIHNjcmlwdHMsIGZvcm1zIG9yIG90aGVyIHBvdGVudGlhbGx5IGRhbmdlcm91cyBub24tZm9ybWF0dGluZyBjb250ZW50LlxuICAgKlxuICAgKiBFeGFtcGxlOiBhIGxpY2Vuc2UgYWdyZWVtZW50LlxuICAgKi9cbiAgRk9STUFUVEVEX0hUTUxfQ09OVEVOVCxcblxuICAvKipcbiAgICogRW1iZWQgc29tZSBjb250ZW50IGNyZWF0ZWQgYnkgR29vZ2xlIGFuZCBpdHMgZW1wbG95ZWVzLlxuICAgKlxuICAgKiBFeGFtcGxlOiBhIHdpZGdldCB0byBkaXNwbGF5IHNvbWUgY29udGVudCBpbiBvdXIgYXBwLlxuICAgKi9cbiAgRU1CRURERURfSU5URVJOQUxfQ09OVEVOVCxcblxuICAvKipcbiAgICogVHJ1c3RlZCBjb250ZW50IGNyZWF0ZWQgb3V0c2lkZSBvZiBHb29nbGUuXG4gICAqXG4gICAqIEV4YW1wbGU6IGEgY2hlY2tpbiB3aWRnZXQgZm9yIGEgcGFydG5lciBhaXJsaW5lXG4gICAqL1xuICBFTUJFRERFRF9UUlVTVEVEX0VYVEVSTkFMX0NPTlRFTlQsXG59XG5cbmVudW0gU2FuZGJveERpcmVjdGl2ZSB7XG4gIEFMTE9XX1NBTUVfT1JJR0lOID0gJ2FsbG93LXNhbWUtb3JpZ2luJyxcbiAgQUxMT1dfU0NSSVBUUyA9ICdhbGxvdy1zY3JpcHRzJyxcbiAgQUxMT1dfRk9STVMgPSAnYWxsb3ctZm9ybXMnLFxuICBBTExPV19QT1BVUFMgPSAnYWxsb3ctcG9wdXBzJyxcbiAgQUxMT1dfUE9QVVBTX1RPX0VTQ0FQRV9TQU5EQk9YID0gJ2FsbG93LXBvcHVwcy10by1lc2NhcGUtc2FuZGJveCcsXG4gIEFMTE9XX1NUT1JBR0VfQUNDRVNTX0JZX1VTRVJfQUNUSVZBVElPTiA9ICdhbGxvdy1zdG9yYWdlLWFjY2Vzcy1ieS11c2VyLWFjdGl2YXRpb24nLFxufVxuXG4vKipcbiAqIHNldFNhbmRib3hEaXJlY3RpdmVzIHNldHMgdGhlIGdpdmVuIHNhbmRib3ggZGlyZWN0aXZlcyBvbiB0aGUgZ2l2ZW4gaWZyYW1lLlxuICogRGVsZXRlcyBhbnkgZXhpc3RpbmcgZGlyZWN0aXZlcy5cbiAqIEBwYXJhbSBpZnIgaWZyYW1lIGVsZW1lbnQuXG4gKiBAcGFyYW0gZGlyZWN0aXZlcyBsaXN0IG9mIGRpcmVjdGl2ZXMgdG8gc2V0XG4gKiBAcmV0dXJuIHZvaWQuXG4gKi9cbmZ1bmN0aW9uIHNldFNhbmRib3hEaXJlY3RpdmVzKFxuICAgIGlmcjogSFRNTElGcmFtZUVsZW1lbnQsIGRpcmVjdGl2ZXM6IHJlYWRvbmx5IFNhbmRib3hEaXJlY3RpdmVbXSk6IHZvaWQge1xuICBpZnIuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJycpO1xuXG4gIC8vIENhbm5vdCBiZSBhIGZvci4ub2YgbG9vcCBkdWUgdG8gR1dTIGNvbmZvcm1hbmNlIHJ1bGU6XG4gIC8vIGdvL2d3cy1pbmxpbmUtanMtY29uZm9ybWFuY2UjaGVhZGluZz1oLmNlY3h4N21oNWRjNVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWlmci5zYW5kYm94LnN1cHBvcnRzIHx8IGlmci5zYW5kYm94LnN1cHBvcnRzKGRpcmVjdGl2ZXNbaV0pKSB7XG4gICAgICBpZnIuc2FuZGJveC5hZGQoZGlyZWN0aXZlc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHlwZUNhbm5vdEJlVXNlZFdpdGhJbnRlbnRFcnJvciBpcyBhIHR5cGUgb2Yge0BsaW5rIEVycm9yfSB0aGF0IGlzIHJldHVybmVkXG4gKiB3aGVuXG4gKiB7QGxpbmsgc2V0U3JjV2l0aEludGVudH0gb3Ige0BsaW5rIHNldFNyY2RvY1dpdGhJbnRlbnR9IGlzIGNhbGxlZFxuICogd2l0aCBwYXJhbWV0ZXJzIG9mIHRoZSB3cm9uZyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZUNhbm5vdEJlVXNlZFdpdGhJbnRlbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgb3ZlcnJpZGUgbmFtZSA9ICdUeXBlQ2Fubm90QmVVc2VkV2l0aEludGVudEVycm9yJztcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHR5cGU6IHN0cmluZyxcbiAgICBwdWJsaWMgaW50ZW50OiBJbnRlbnQsXG4gICkge1xuICAgIHN1cGVyKGAke3R5cGV9IGNhbm5vdCBiZSB1c2VkIHdpdGggaW50ZW50ICR7SW50ZW50W2ludGVudF19YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbWJlZCByaWNoLXRleHQgbGlrZSBjb250ZW50IGZvcm1hdHRlZCB3aXRoIEhUTUwgdGFncywgYnV0IHdoaWNoIGRvZXMgbm90XG4gKiBuZWVkIHRvIHJ1biBzY3JpcHRzLCBmb3JtcyBvciBvdGhlciBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY29udGVudC4gSWZcbiAqIGFuIHtAbGluayBIVE1MSUZyYW1lRWxlbWVudC5zcmNkb2N9IGlzIHByZXNlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LCBpdCB3aWxsXG4gKiBiZSByZW1vdmVkLlxuICpcbiAqIEV4YW1wbGU6IEEgbGljZW5zZSBhZ3JlZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNyY1dpdGhJbnRlbnQoXG4gIGVsZW1lbnQ6IEhUTUxJRnJhbWVFbGVtZW50LFxuICBpbnRlbnQ6IEludGVudC5GT1JNQVRURURfSFRNTF9DT05URU5ULFxuICBzcmM6IFVybCxcbik6IHZvaWQ7XG5cbi8qKlxuICogRW1iZWQgdHJ1c3RlZCBjb250ZW50IHRoYXQgd2FzIGNyZWF0ZWQgYnkgR29vZ2xlIG9yIGl0cyBlbXBsb3llZXMuIElmXG4gKiBhbiB7QGxpbmsgSFRNTElGcmFtZUVsZW1lbnQuc3JjZG9jfSBpcyBwcmVzZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudCwgaXQgd2lsbFxuICogYmUgcmVtb3ZlZC5cbiAqXG4gKiBFeGFtcGxlOiBBIHdpZGdldCB0byBkaXNwbGF5IHNvbWUgY29udGVudCBpbiBvdXIgYXBwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3JjV2l0aEludGVudChcbiAgZWxlbWVudDogSFRNTElGcmFtZUVsZW1lbnQsXG4gIGludGVudDogSW50ZW50LkVNQkVEREVEX0lOVEVSTkFMX0NPTlRFTlQsXG4gIHNyYzogVHJ1c3RlZFJlc291cmNlVXJsLFxuKTogdm9pZDtcblxuLyoqXG4gKiBFbWJlZCB0cnVzdGVkIGNvbnRlbnQgdGhhdCB3YXMgY3JlYXRlZCBvdXRzaWRlIG9mIEdvb2dsZS4gSWYgYW4ge0BsaW5rXG4gKiBIVE1MSUZyYW1lRWxlbWVudC5zcmNkb2N9IGlzIHByZXNlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LCBpdCB3aWxsIGJlXG4gKiByZW1vdmVkLlxuICpcbiAqIEV4YW1wbGU6IEEgY2hlY2tpbiB3aWRnZXQgZm9yIGFuIGFpcmxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNyY1dpdGhJbnRlbnQoXG4gIGVsZW1lbnQ6IEhUTUxJRnJhbWVFbGVtZW50LFxuICBpbnRlbnQ6IEludGVudC5FTUJFRERFRF9UUlVTVEVEX0VYVEVSTkFMX0NPTlRFTlQsXG4gIHNyYzogVXJsLFxuKTogdm9pZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNyY1dpdGhJbnRlbnQoXG4gIGVsZW1lbnQ6IEhUTUxJRnJhbWVFbGVtZW50LFxuICBpbnRlbnQ6IEludGVudCxcbiAgc3JjOiBVcmwgfCBUcnVzdGVkUmVzb3VyY2VVcmwsXG4pOiB2b2lkIHtcbiAgLy8gaWYgc3JjZG9jIHdhcyBhbHJlYWR5IHNldCwgdW5zZXQgaXQgdG8gcHJldmVudCB1c2luZyBhbiBzcmMgcG9saWN5IHdpdGhcbiAgLy8gYW4gc3JjZG9jXG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmNkb2MnKTtcblxuICBzd2l0Y2ggKGludGVudCkge1xuICAgIGNhc2UgSW50ZW50LkZPUk1BVFRFRF9IVE1MX0NPTlRFTlQ6IHtcbiAgICAgIGlmIChzcmMgaW5zdGFuY2VvZiBUcnVzdGVkUmVzb3VyY2VVcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDYW5ub3RCZVVzZWRXaXRoSW50ZW50RXJyb3IoXG4gICAgICAgICAgJ1RydXN0ZWRSZXNvdXJjZVVybCcsXG4gICAgICAgICAgSW50ZW50LkZPUk1BVFRFRF9IVE1MX0NPTlRFTlQsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHNldFNhbmRib3hEaXJlY3RpdmVzKGVsZW1lbnQsIFtdKTtcbiAgICAgIGNvbnN0IHNhbml0aXplZFVybCA9IHVud3JhcFVybE9yU2FuaXRpemUoc3JjKTtcbiAgICAgIGlmIChzYW5pdGl6ZWRVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50LnNyYyA9IHNhbml0aXplZFVybDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhc2UgSW50ZW50LkVNQkVEREVEX0lOVEVSTkFMX0NPTlRFTlQ6IHtcbiAgICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIFRydXN0ZWRSZXNvdXJjZVVybCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVDYW5ub3RCZVVzZWRXaXRoSW50ZW50RXJyb3IoXG4gICAgICAgICAgdHlwZW9mIHNyYyxcbiAgICAgICAgICBJbnRlbnQuRU1CRURERURfSU5URVJOQUxfQ09OVEVOVCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgc2V0U2FuZGJveERpcmVjdGl2ZXMoZWxlbWVudCwgW1xuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1NBTUVfT1JJR0lOLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1NDUklQVFMsXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfRk9STVMsXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfUE9QVVBTLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1BPUFVQU19UT19FU0NBUEVfU0FOREJPWCxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19TVE9SQUdFX0FDQ0VTU19CWV9VU0VSX0FDVElWQVRJT04sXG4gICAgICBdKTtcbiAgICAgIHNldFNyYyhlbGVtZW50LCBzcmMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FzZSBJbnRlbnQuRU1CRURERURfVFJVU1RFRF9FWFRFUk5BTF9DT05URU5UOiB7XG4gICAgICBpZiAoc3JjIGluc3RhbmNlb2YgVHJ1c3RlZFJlc291cmNlVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2Fubm90QmVVc2VkV2l0aEludGVudEVycm9yKFxuICAgICAgICAgICdUcnVzdGVkUmVzb3VyY2VVcmwnLFxuICAgICAgICAgIEludGVudC5FTUJFRERFRF9UUlVTVEVEX0VYVEVSTkFMX0NPTlRFTlQsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHNldFNhbmRib3hEaXJlY3RpdmVzKGVsZW1lbnQsIFtcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19TQU1FX09SSUdJTixcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19TQ1JJUFRTLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX0ZPUk1TLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1BPUFVQUyxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19QT1BVUFNfVE9fRVNDQVBFX1NBTkRCT1gsXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfU1RPUkFHRV9BQ0NFU1NfQllfVVNFUl9BQ1RJVkFUSU9OLFxuICAgICAgXSk7XG4gICAgICBjb25zdCBzYW5pdGl6ZWRVcmwgPSB1bndyYXBVcmxPclNhbml0aXplKHNyYyk7XG4gICAgICBpZiAoc2FuaXRpemVkVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC5zcmMgPSBzYW5pdGl6ZWRVcmw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY2hlY2tFeGhhdXN0aXZlKGludGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbWJlZCByaWNoLXRleHQgbGlrZSBjb250ZW50IGZvcm1hdHRlZCB3aXRoIEhUTUwgdGFncywgYnV0IHdoaWNoIGRvZXMgbm90XG4gKiBuZWVkIHRvIHJ1biBzY3JpcHRzLCBmb3JtcyBvciBvdGhlciBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY29udGVudC4gSWZcbiAqIGFuIHtAbGluayBIVE1MSUZyYW1lRWxlbWVudC5zcmN9IGlzIHByZXNlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LCBpdCB3aWxsIGJlXG4gKiByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3JjZG9jV2l0aEludGVudChcbiAgZWxlbWVudDogSFRNTElGcmFtZUVsZW1lbnQsXG4gIGludGVudDogSW50ZW50LkZPUk1BVFRFRF9IVE1MX0NPTlRFTlQsXG4gIHNyY2RvYzogc3RyaW5nLFxuKTogdm9pZDtcblxuLyoqXG4gKiBFbWJlZCB0cnVzdGVkIGNvbnRlbnQgdGhhdCB3YXMgY3JlYXRlZCBieSBHb29nbGUgb3IgaXRzIGVtcGxveWVlcy4gSWZcbiAqIGFuIHtAbGluayBIVE1MSUZyYW1lRWxlbWVudC5zcmN9IGlzIHByZXNlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LCBpdCB3aWxsIGJlXG4gKiByZW1vdmVkLlxuICpcbiAqIEV4YW1wbGU6IEEgd2lkZ2V0IHRvIGRpc3BsYXkgc29tZSBjb250ZW50IGluIG91ciBhcHAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTcmNkb2NXaXRoSW50ZW50KFxuICBlbGVtZW50OiBIVE1MSUZyYW1lRWxlbWVudCxcbiAgaW50ZW50OiBJbnRlbnQuRU1CRURERURfSU5URVJOQUxfQ09OVEVOVCxcbiAgc3JjZG9jOiBTYWZlSHRtbCxcbik6IHZvaWQ7XG5cbi8qKlxuICogRW1iZWQgdHJ1c3RlZCBjb250ZW50IHRoYXQgd2FzIGNyZWF0ZWQgb3V0c2lkZSBvZiBHb29nbGUuIElmIGFuXG4gKiB7QGxpbmsgSFRNTElGcmFtZUVsZW1lbnQuc3JjfSBpcyBwcmVzZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudCwgaXQgd2lsbCBiZVxuICogcmVtb3ZlZC5cbiAqXG4gKiBFeGFtcGxlOiBBIGNoZWNraW4gd2lkZ2V0IGZvciBhbiBhaXJsaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTcmNkb2NXaXRoSW50ZW50KFxuICBlbGVtZW50OiBIVE1MSUZyYW1lRWxlbWVudCxcbiAgaW50ZW50OiBJbnRlbnQuRU1CRURERURfVFJVU1RFRF9FWFRFUk5BTF9DT05URU5ULFxuICBzcmNkb2M6IHN0cmluZyxcbik6IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTcmNkb2NXaXRoSW50ZW50KFxuICBlbGVtZW50OiBIVE1MSUZyYW1lRWxlbWVudCxcbiAgaW50ZW50OiBJbnRlbnQsXG4gIHNyY2RvYzogc3RyaW5nIHwgU2FmZUh0bWwsXG4pIHtcbiAgLy8gaWYgc3JjIHdhcyBhbHJlYWR5IHNldCwgdW5zZXQgaXQgdG8gcHJldmVudCB1c2luZyBhbiBzcmMgcG9saWN5IHdpdGggYW5cbiAgLy8gc3JjZG9jXG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICBzd2l0Y2ggKGludGVudCkge1xuICAgIGNhc2UgSW50ZW50LkZPUk1BVFRFRF9IVE1MX0NPTlRFTlQ6IHtcbiAgICAgIGlmIChzcmNkb2MgaW5zdGFuY2VvZiBTYWZlSHRtbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNhbm5vdEJlVXNlZFdpdGhJbnRlbnRFcnJvcihcbiAgICAgICAgICAnU2FmZUh0bWwnLFxuICAgICAgICAgIEludGVudC5GT1JNQVRURURfSFRNTF9DT05URU5ULFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIGFzc2VydGlvbiByZXF1aXJlZCBhcyBkZWNsYXJlIGdsb2JhbCBzeW50YXggaXMgcG9sbHV0aXZlIGluXG4gICAgICAvLyBnb29nbGUzIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcuXG4gICAgICAoZWxlbWVudCBhcyBIVE1MSUZyYW1lRWxlbWVudCAmIHtjc3A/OiBzdHJpbmd9KS5jc3AgPVxuICAgICAgICBcImRlZmF1bHQtc3JjICdub25lJ1wiO1xuXG4gICAgICBzZXRTYW5kYm94RGlyZWN0aXZlcyhlbGVtZW50LCBbXSk7XG4gICAgICBzZXRTcmNkb2MoZWxlbWVudCwgY3JlYXRlSHRtbEludGVybmFsKHNyY2RvYykpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FzZSBJbnRlbnQuRU1CRURERURfSU5URVJOQUxfQ09OVEVOVDoge1xuICAgICAgaWYgKCEoc3JjZG9jIGluc3RhbmNlb2YgU2FmZUh0bWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlQ2Fubm90QmVVc2VkV2l0aEludGVudEVycm9yKFxuICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgIEludGVudC5FTUJFRERFRF9JTlRFUk5BTF9DT05URU5ULFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzZXRTYW5kYm94RGlyZWN0aXZlcyhlbGVtZW50LCBbXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfU0FNRV9PUklHSU4sXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfU0NSSVBUUyxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19GT1JNUyxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19QT1BVUFMsXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfUE9QVVBTX1RPX0VTQ0FQRV9TQU5EQk9YLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1NUT1JBR0VfQUNDRVNTX0JZX1VTRVJfQUNUSVZBVElPTixcbiAgICAgIF0pO1xuICAgICAgc2V0U3JjZG9jKGVsZW1lbnQsIHNyY2RvYyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYXNlIEludGVudC5FTUJFRERFRF9UUlVTVEVEX0VYVEVSTkFMX0NPTlRFTlQ6IHtcbiAgICAgIGlmIChzcmNkb2MgaW5zdGFuY2VvZiBTYWZlSHRtbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUNhbm5vdEJlVXNlZFdpdGhJbnRlbnRFcnJvcihcbiAgICAgICAgICAnU2FmZUh0bWwnLFxuICAgICAgICAgIEludGVudC5FTUJFRERFRF9JTlRFUk5BTF9DT05URU5ULFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzZXRTYW5kYm94RGlyZWN0aXZlcyhlbGVtZW50LCBbXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfU0NSSVBUUyxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19GT1JNUyxcbiAgICAgICAgU2FuZGJveERpcmVjdGl2ZS5BTExPV19QT1BVUFMsXG4gICAgICAgIFNhbmRib3hEaXJlY3RpdmUuQUxMT1dfUE9QVVBTX1RPX0VTQ0FQRV9TQU5EQk9YLFxuICAgICAgICBTYW5kYm94RGlyZWN0aXZlLkFMTE9XX1NUT1JBR0VfQUNDRVNTX0JZX1VTRVJfQUNUSVZBVElPTixcbiAgICAgIF0pO1xuICAgICAgc2V0U3JjZG9jKGVsZW1lbnQsIGNyZWF0ZUh0bWxJbnRlcm5hbChzcmNkb2MpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICBjaGVja0V4aGF1c3RpdmUoaW50ZW50KTtcbiAgfVxufVxuLy8gRU5ELUlOVEVSTkFMXG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/elements/input.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/input.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.input');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/input.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * Sets the Formaction attribute from the given Url.
 * @param {!HTMLInputElement} input
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setFormaction(input, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        input.formAction = sanitizedUrl;
    }
}
exports.setFormaction = setFormaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2VsZW1lbnRzL2lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx1R0FBcUU7Ozs7Ozs7QUFLckUsU0FBZ0IsYUFBYSxDQUFDLEtBQXVCLEVBQUUsR0FBUTs7VUFDdkQsWUFBWSxHQUFHLElBQUEsa0NBQW1CLEVBQUMsR0FBRyxDQUFDO0lBQzdDLElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQy9CLEtBQUssQ0FBQyxVQUFVLEdBQUcsWUFBWSxDQUFDO0lBQ2xDLENBQUM7QUFDSCxDQUFDO0FBTEQsc0NBS0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7dW53cmFwVXJsT3JTYW5pdGl6ZSwgVXJsfSBmcm9tICcuLi8uLi9idWlsZGVycy91cmxfYnVpbGRlcnMnO1xuXG4vKipcbiAqIFNldHMgdGhlIEZvcm1hY3Rpb24gYXR0cmlidXRlIGZyb20gdGhlIGdpdmVuIFVybC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZvcm1hY3Rpb24oaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIHVybDogVXJsKSB7XG4gIGNvbnN0IHNhbml0aXplZFVybCA9IHVud3JhcFVybE9yU2FuaXRpemUodXJsKTtcbiAgaWYgKHNhbml0aXplZFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5wdXQuZm9ybUFjdGlvbiA9IHNhbml0aXplZFVybDtcbiAgfVxufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/link.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/link.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.link');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/link.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_resource_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_url_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_TrustedResourceUrl_4 = goog.requireType("goog.html.TrustedResourceUrl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/* Values from google3/webutil/html/types/codegen/html5_contract.textpb */ 
// LINE-INTERNAL
/** @type {!Array<?>} */
const SAFE_URL_REL_VALUES = (/** @type {!Array<?>} */ ([
    'alternate',
    'author',
    'bookmark',
    'canonical',
    'cite',
    'help',
    'icon',
    'license',
    'modulepreload',
    'next',
    'prefetch',
    'dns-prefetch',
    'prerender',
    'preconnect',
    'preload',
    'prev',
    'search',
    'subresource',
]));
/**
 * Values of the "rel" attribute when "href" should accept `SafeUrl` instead of
 * `TrustedResourceUrl`.
 * @typedef {string}
 */
exports.SafeUrlRelTypes;
/**
 * Values of the "rel" attribute when "href" should accept a
 * `TrustedResourceUrl`. Note that this list is not exhaustive and is here just
 * for better documentation, any unknown "rel" values will also require passing
 * a `TrustedResourceUrl` "href".
 * @typedef {string}
 */
exports.TrustedResourecUrlRelTypes;
/**
 * @param {!HTMLLinkElement} link
 * @param {(string|!tsickle_url_impl_3.SafeUrl|!tsickle_TrustedResourceUrl_4)} url
 * @param {string} rel
 * @return {void}
 */
function setHrefAndRel(link, url, rel) {
    if ((0, resource_url_impl_1.isResourceUrl)(url)) {
        link.href = (0, resource_url_impl_1.unwrapResourceUrl)(url).toString();
    }
    else {
        if (((/** @type {!ReadonlyArray<string>} */ (SAFE_URL_REL_VALUES))).indexOf(rel) === -1) {
            throw new Error(`TrustedResourceUrl href attribute required with rel="${rel}"`);
        }
        /** @type {(undefined|string)} */
        const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
        if (sanitizedUrl === undefined) {
            return;
        }
        link.href = sanitizedUrl;
    }
    link.rel = rel;
}
exports.setHrefAndRel = setHrefAndRel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvbGluay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx1R0FBcUU7QUFDckUsa0hBSTJDOzs7O01BR3JDLG1CQUFtQixHQUFHLDJCQUFBO0lBQzFCLFdBQVc7SUFDWCxRQUFRO0lBQ1IsVUFBVTtJQUNWLFdBQVc7SUFDWCxNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixTQUFTO0lBQ1QsZUFBZTtJQUNmLE1BQU07SUFDTixVQUFVO0lBQ1YsY0FBYztJQUNkLFdBQVc7SUFDWCxZQUFZO0lBQ1osU0FBUztJQUNULE1BQU07SUFDTixRQUFRO0lBQ1IsYUFBYTtDQUNkLEVBQVM7Ozs7OztBQU1WLHdCQUFtRTs7Ozs7Ozs7QUFRbkUsbUNBQW1FOzs7Ozs7O0FBK0JuRSxTQUFnQixhQUFhLENBQzNCLElBQXFCLEVBQ3JCLEdBQTZCLEVBQzdCLEdBQVc7SUFFWCxJQUFJLElBQUEsaUNBQWEsRUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBQSxxQ0FBaUIsRUFBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNoRCxDQUFDO1NBQU0sQ0FBQztRQUNOLElBQUksQ0FBQyx3Q0FBQSxtQkFBbUIsRUFBcUIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ25FLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0RBQXdELEdBQUcsR0FBRyxDQUMvRCxDQUFDO1FBQ0osQ0FBQzs7Y0FDSyxZQUFZLEdBQUcsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUM7UUFDN0MsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDL0IsT0FBTztRQUNULENBQUM7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDakIsQ0FBQztBQXBCRCxzQ0FvQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7dW53cmFwVXJsT3JTYW5pdGl6ZSwgVXJsfSBmcm9tICcuLi8uLi9idWlsZGVycy91cmxfYnVpbGRlcnMnO1xuaW1wb3J0IHtcbiAgaXNSZXNvdXJjZVVybCxcbiAgVHJ1c3RlZFJlc291cmNlVXJsLFxuICB1bndyYXBSZXNvdXJjZVVybCxcbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsJztcblxuLyogVmFsdWVzIGZyb20gZ29vZ2xlMy93ZWJ1dGlsL2h0bWwvdHlwZXMvY29kZWdlbi9odG1sNV9jb250cmFjdC50ZXh0cGIgKi8gLy8gTElORS1JTlRFUk5BTFxuY29uc3QgU0FGRV9VUkxfUkVMX1ZBTFVFUyA9IFtcbiAgJ2FsdGVybmF0ZScsXG4gICdhdXRob3InLFxuICAnYm9va21hcmsnLFxuICAnY2Fub25pY2FsJyxcbiAgJ2NpdGUnLFxuICAnaGVscCcsXG4gICdpY29uJyxcbiAgJ2xpY2Vuc2UnLFxuICAnbW9kdWxlcHJlbG9hZCcsXG4gICduZXh0JyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2Rucy1wcmVmZXRjaCcsXG4gICdwcmVyZW5kZXInLFxuICAncHJlY29ubmVjdCcsXG4gICdwcmVsb2FkJyxcbiAgJ3ByZXYnLFxuICAnc2VhcmNoJyxcbiAgJ3N1YnJlc291cmNlJyxcbl0gYXMgY29uc3Q7XG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBcInJlbFwiIGF0dHJpYnV0ZSB3aGVuIFwiaHJlZlwiIHNob3VsZCBhY2NlcHQgYFNhZmVVcmxgIGluc3RlYWQgb2ZcbiAqIGBUcnVzdGVkUmVzb3VyY2VVcmxgLlxuICovXG5leHBvcnQgdHlwZSBTYWZlVXJsUmVsVHlwZXMgPSAodHlwZW9mIFNBRkVfVVJMX1JFTF9WQUxVRVMpW251bWJlcl07XG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBcInJlbFwiIGF0dHJpYnV0ZSB3aGVuIFwiaHJlZlwiIHNob3VsZCBhY2NlcHQgYVxuICogYFRydXN0ZWRSZXNvdXJjZVVybGAuIE5vdGUgdGhhdCB0aGlzIGxpc3QgaXMgbm90IGV4aGF1c3RpdmUgYW5kIGlzIGhlcmUganVzdFxuICogZm9yIGJldHRlciBkb2N1bWVudGF0aW9uLCBhbnkgdW5rbm93biBcInJlbFwiIHZhbHVlcyB3aWxsIGFsc28gcmVxdWlyZSBwYXNzaW5nXG4gKiBhIGBUcnVzdGVkUmVzb3VyY2VVcmxgIFwiaHJlZlwiLlxuICovXG5leHBvcnQgdHlwZSBUcnVzdGVkUmVzb3VyZWNVcmxSZWxUeXBlcyA9ICdzdHlsZXNoZWV0JyB8ICdtYW5pZmVzdCc7XG5cbi8qKlxuICogU2FmZWx5IHNldHMgYSBsaW5rIGVsZW1lbnQncyBcImhyZWZcIiBwcm9wZXJ0eSB1c2luZyBhIHNlbnNpdGl2ZSBcInJlbFwiIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SHJlZkFuZFJlbChcbiAgbGluazogSFRNTExpbmtFbGVtZW50LFxuICB1cmw6IFRydXN0ZWRSZXNvdXJjZVVybCxcbiAgcmVsOiBUcnVzdGVkUmVzb3VyZWNVcmxSZWxUeXBlcyxcbik6IHZvaWQ7XG5cbi8qKlxuICogU2FmZWx5IHNldHMgYSBsaW5rIGVsZW1lbnQncyBcImhyZWZcIiBwcm9wZXJ0eSB1c2luZyBhIG5vbi1zZW5zaXRpdmUgXCJyZWxcIlxuICogdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRIcmVmQW5kUmVsKFxuICBsaW5rOiBIVE1MTGlua0VsZW1lbnQsXG4gIHVybDogVXJsLFxuICByZWw6IFNhZmVVcmxSZWxUeXBlcyxcbik6IHZvaWQ7XG5cbi8qKlxuICogU2FmZWx5IHNldHMgYSBsaW5rIGVsZW1lbnQncyBcImhyZWZcIiBwcm9wZXJ0eSB1c2luZyBhbiBhcmJpdHJhcnkgXCJyZWxcIlxuICogdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRIcmVmQW5kUmVsKFxuICBsaW5rOiBIVE1MTGlua0VsZW1lbnQsXG4gIHVybDogVHJ1c3RlZFJlc291cmNlVXJsLFxuICByZWw6IHN0cmluZyxcbik6IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRIcmVmQW5kUmVsKFxuICBsaW5rOiBIVE1MTGlua0VsZW1lbnQsXG4gIHVybDogVHJ1c3RlZFJlc291cmNlVXJsIHwgVXJsLFxuICByZWw6IHN0cmluZyxcbikge1xuICBpZiAoaXNSZXNvdXJjZVVybCh1cmwpKSB7XG4gICAgbGluay5ocmVmID0gdW53cmFwUmVzb3VyY2VVcmwodXJsKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGlmICgoU0FGRV9VUkxfUkVMX1ZBTFVFUyBhcyByZWFkb25seSBzdHJpbmdbXSkuaW5kZXhPZihyZWwpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJ1c3RlZFJlc291cmNlVXJsIGhyZWYgYXR0cmlidXRlIHJlcXVpcmVkIHdpdGggcmVsPVwiJHtyZWx9XCJgLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2FuaXRpemVkVXJsID0gdW53cmFwVXJsT3JTYW5pdGl6ZSh1cmwpO1xuICAgIGlmIChzYW5pdGl6ZWRVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLmhyZWYgPSBzYW5pdGl6ZWRVcmw7XG4gIH1cbiAgbGluay5yZWwgPSByZWw7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/elements/object.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/object.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.object');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/object.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_2 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/**
 * Sets the data attribute using a TrustedResourceUrl
 * @param {!HTMLObjectElement} obj
 * @param {!tsickle_TrustedResourceUrl_2} v
 * @return {void}
 */
function setData(obj, v) {
    obj.data = (/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(v)));
}
exports.setData = setData;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9vYmplY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLGtIQUcyQzs7Ozs7OztBQUczQyxTQUFnQixPQUFPLENBQUMsR0FBc0IsRUFBRSxDQUFxQjtJQUNuRSxHQUFHLENBQUMsSUFBSSxHQUFHLHdCQUFBLElBQUEscUNBQWlCLEVBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FBQztBQUM1QyxDQUFDO0FBRkQsMEJBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7XG4gIFRydXN0ZWRSZXNvdXJjZVVybCxcbiAgdW53cmFwUmVzb3VyY2VVcmwsXG59IGZyb20gJy4uLy4uL2ludGVybmFscy9yZXNvdXJjZV91cmxfaW1wbCc7XG5cbi8qKiBTZXRzIHRoZSBkYXRhIGF0dHJpYnV0ZSB1c2luZyBhIFRydXN0ZWRSZXNvdXJjZVVybCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERhdGEob2JqOiBIVE1MT2JqZWN0RWxlbWVudCwgdjogVHJ1c3RlZFJlc291cmNlVXJsKSB7XG4gIG9iai5kYXRhID0gdW53cmFwUmVzb3VyY2VVcmwodikgYXMgc3RyaW5nO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/window.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/window.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.window');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/window.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * open calls {\@link Window.open} on the given {\@link Window}, given a
 * target {\@link Url}.
 * @param {!Window} win
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @param {(undefined|string)=} target
 * @param {(undefined|string)=} features
 * @return {(null|!Window)}
 */
function open(win, url, target, features) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        return win.open(sanitizedUrl, target, features);
    }
    return null;
}
exports.open = open;
/**
 * Returns CSP nonce, if set for any script tag.
 * @param {!Window} win
 * @return {string}
 */
function getScriptNonce(win) {
    return getNonceFor('script', win);
}
exports.getScriptNonce = getScriptNonce;
/**
 * Returns CSP nonce, if set for any style tag.
 * @param {!Window} win
 * @return {string}
 */
function getStyleNonce(win) {
    return getNonceFor('style', win);
}
exports.getStyleNonce = getStyleNonce;
/**
 * @param {string} elementName
 * @param {!Window} win
 * @return {string}
 */
function getNonceFor(elementName, win) {
    /** @type {!Document} */
    const doc = win.document;
    // document.querySelector can be undefined in non-browser environments.
    /** @type {(null|!HTMLScriptElement|!HTMLStyleElement)} */
    const el = doc.querySelector?.(`${elementName}[nonce]`);
    if (el) {
        // Try to get the nonce from the IDL property first, because browsers that
        // implement additional nonce protection features (currently only Chrome) to
        // prevent nonce stealing via CSS do not expose the nonce via attributes.
        // See https://github.com/whatwg/html/issues/2369
        return el['nonce'] || el.getAttribute('nonce') || '';
    }
    return '';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2luZG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9nbG9iYWxzL3dpbmRvdy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsdUdBQXFFOzs7Ozs7Ozs7O0FBTXJFLFNBQWdCLElBQUksQ0FDbEIsR0FBVyxFQUNYLEdBQVEsRUFDUixNQUFlLEVBQ2YsUUFBaUI7O1VBRVgsWUFBWSxHQUFHLElBQUEsa0NBQW1CLEVBQUMsR0FBRyxDQUFDO0lBQzdDLElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQy9CLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFYRCxvQkFXQzs7Ozs7O0FBR0QsU0FBZ0IsY0FBYyxDQUFDLEdBQVc7SUFDeEMsT0FBTyxXQUFXLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFGRCx3Q0FFQzs7Ozs7O0FBR0QsU0FBZ0IsYUFBYSxDQUFDLEdBQVc7SUFDdkMsT0FBTyxXQUFXLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCxzQ0FFQzs7Ozs7O0FBRUQsU0FBUyxXQUFXLENBQUMsV0FBK0IsRUFBRSxHQUFXOztVQUN6RCxHQUFHLEdBQUcsR0FBRyxDQUFDLFFBQVE7OztVQUVsQixFQUFFLEdBQUcsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUM1QixHQUFHLFdBQVcsU0FBUyxDQUN4QjtJQUNELElBQUksRUFBRSxFQUFFLENBQUM7UUFDUCwwRUFBMEU7UUFDMUUsNEVBQTRFO1FBQzVFLHlFQUF5RTtRQUN6RSxpREFBaUQ7UUFDakQsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDdkQsQ0FBQztJQUNELE9BQU8sRUFBRSxDQUFDO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHt1bndyYXBVcmxPclNhbml0aXplLCBVcmx9IGZyb20gJy4uLy4uL2J1aWxkZXJzL3VybF9idWlsZGVycyc7XG5cbi8qKlxuICogb3BlbiBjYWxscyB7QGxpbmsgV2luZG93Lm9wZW59IG9uIHRoZSBnaXZlbiB7QGxpbmsgV2luZG93fSwgZ2l2ZW4gYVxuICogdGFyZ2V0IHtAbGluayBVcmx9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3BlbihcbiAgd2luOiBXaW5kb3csXG4gIHVybDogVXJsLFxuICB0YXJnZXQ/OiBzdHJpbmcsXG4gIGZlYXR1cmVzPzogc3RyaW5nLFxuKTogV2luZG93IHwgbnVsbCB7XG4gIGNvbnN0IHNhbml0aXplZFVybCA9IHVud3JhcFVybE9yU2FuaXRpemUodXJsKTtcbiAgaWYgKHNhbml0aXplZFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdpbi5vcGVuKHNhbml0aXplZFVybCwgdGFyZ2V0LCBmZWF0dXJlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKiBSZXR1cm5zIENTUCBub25jZSwgaWYgc2V0IGZvciBhbnkgc2NyaXB0IHRhZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JpcHROb25jZSh3aW46IFdpbmRvdyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXROb25jZUZvcignc2NyaXB0Jywgd2luKTtcbn1cblxuLyoqIFJldHVybnMgQ1NQIG5vbmNlLCBpZiBzZXQgZm9yIGFueSBzdHlsZSB0YWcuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGVOb25jZSh3aW46IFdpbmRvdyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXROb25jZUZvcignc3R5bGUnLCB3aW4pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZUZvcihlbGVtZW50TmFtZTogJ3NjcmlwdCcgfCAnc3R5bGUnLCB3aW46IFdpbmRvdyk6IHN0cmluZyB7XG4gIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgLy8gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBjYW4gYmUgdW5kZWZpbmVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgY29uc3QgZWwgPSBkb2MucXVlcnlTZWxlY3Rvcj8uPEhUTUxTY3JpcHRFbGVtZW50IHwgSFRNTFN0eWxlRWxlbWVudD4oXG4gICAgYCR7ZWxlbWVudE5hbWV9W25vbmNlXWAsXG4gICk7XG4gIGlmIChlbCkge1xuICAgIC8vIFRyeSB0byBnZXQgdGhlIG5vbmNlIGZyb20gdGhlIElETCBwcm9wZXJ0eSBmaXJzdCwgYmVjYXVzZSBicm93c2VycyB0aGF0XG4gICAgLy8gaW1wbGVtZW50IGFkZGl0aW9uYWwgbm9uY2UgcHJvdGVjdGlvbiBmZWF0dXJlcyAoY3VycmVudGx5IG9ubHkgQ2hyb21lKSB0b1xuICAgIC8vIHByZXZlbnQgbm9uY2Ugc3RlYWxpbmcgdmlhIENTUyBkbyBub3QgZXhwb3NlIHRoZSBub25jZSB2aWEgYXR0cmlidXRlcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG4gICAgcmV0dXJuIGVsWydub25jZSddIHx8IGVsLmdldEF0dHJpYnV0ZSgnbm9uY2UnKSB8fCAnJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/internals/script_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Internal implementations of SafeScript.
 * Generated from: third_party/javascript/safevalues/internals/script_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.script_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/script_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_trustedtypes_1 = goog.requireType("goog.html.trustedtypes");
const tsickle_dev_2 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_pure_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.pure");
const tsickle_secrets_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.secrets");
const trustedtypes_1 = goog.require('goog.html.trustedtypes');
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const pure_1 = goog.require('google3.third_party.javascript.safevalues.internals.pure');
const secrets_1 = goog.require('google3.third_party.javascript.safevalues.internals.secrets');
/** @type {?} */
const trustedTypes = goog.global.trustedTypes;
/**
 * JavaScript code that is safe to evaluate and use as the content of an HTML
 * script element.
 */
class SafeScript {
    /**
     * @private
     * @param {!Object} token
     * @param {(string|!TrustedScript)} value
     */
    constructor(token, value) {
        if (dev_1.DEV_MODE) {
            (0, secrets_1.ensureTokenIsValid)(token);
        }
        this.privateDoNotAccessOrElseWrappedScript = value;
    }
    /**
     * @public
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedScript.toString();
    }
}
exports.SafeScript = SafeScript;
/* istanbul ignore if */
if (false) {
    /**
     * @const {(string|!TrustedScript)}
     * @private
     */
    SafeScript.prototype.privateDoNotAccessOrElseWrappedScript;
}
// WARNING: interface has both a type and a value, skipping emit
/** @type {function(new:SafeScript, !Object, (string|!TrustedScript))} */
const ScriptImpl = (/** @type {function(new:SafeScript, !Object, (string|!TrustedScript))} */ (SafeScript));
/**
 * @param {(string|!TrustedScript)} value
 * @return {!SafeScript}
 */
function constructScript(value) {
    return new ScriptImpl(secrets_1.secretToken, value);
}
/**
 * Builds a new `SafeScript` from the given string, without enforcing
 * safety guarantees. It may cause side effects by creating a Trusted Types
 * policy. This shouldn't be exposed to application developers, and must only be
 * used as a step towards safe builders or safe constants.
 * @param {string} value
 * @return {!SafeScript}
 */
function createScriptInternal(value) {
    /**
     * @noinline
     * @type {string}
     */
    const noinlineValue = value;
    /** @type {(null|!TrustedTypePolicy<!TrustedTypePolicyOptions>)} */
    const policy = (0, trustedtypes_1.getPolicyPrivateDoNotAccessOrElse)();
    return constructScript(policy ? policy.createScript(noinlineValue) : noinlineValue);
}
exports.createScriptInternal = createScriptInternal;
/**
 * An empty `SafeScript` constant.
 * Unlike the functions above, using this will not create a policy.
 * @type {!SafeScript}
 */
exports.EMPTY_SCRIPT = (0, pure_1.pure)((/**
 * @return {!SafeScript}
 */
() => constructScript(trustedTypes ? trustedTypes.emptyScript : '')));
/**
 * Checks if the given value is a `SafeScript` instance
 * @param {*} value
 * @return {boolean}
 */
function isScript(value) {
    return value instanceof SafeScript;
}
exports.isScript = isScript;
/**
 * Returns the value of the passed `SafeScript` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedScript` or a string if Trusted Types are disabled.
 * @param {!SafeScript} value
 * @return {(string|!TrustedScript)}
 */
function unwrapScript(value) {
    if (isScript(value)) {
        return ((/** @type {?} */ ((/** @type {*} */ (value)))))
            .privateDoNotAccessOrElseWrappedScript;
    }
    else {
        /** @type {string} */
        let message = '';
        if (dev_1.DEV_MODE) {
            message = 'Unexpected type when unwrapping SafeScript';
        }
        throw new Error(message);
    }
}
exports.unwrapScript = unwrapScript;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NyaXB0X2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW50ZXJuYWxzL3NjcmlwdF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9BLDhEQUEyRztBQUUzRyx3RkFBNEM7QUFFNUMsd0ZBQTRCO0FBQzVCLDhGQUEwRDs7TUFFcEQsWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWTs7Ozs7QUFNN0MsTUFBYSxVQUFVOzs7Ozs7SUFLckIsWUFBb0IsS0FBYSxFQUFFLEtBQTZCO1FBQzlELElBQUksY0FBUSxFQUFFLENBQUM7WUFDYixJQUFBLDRCQUFrQixFQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVCLENBQUM7UUFFRCxJQUFJLENBQUMscUNBQXFDLEdBQUcsS0FBSyxDQUFDO0lBQ3JELENBQUM7Ozs7O0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLHFDQUFxQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9ELENBQUM7Q0FDRjtBQWhCRCxnQ0FnQkM7Ozs7Ozs7SUFmQywyREFFVzs7OztNQWtCUCxVQUFVLEdBQUcsNEVBQUEsVUFBVSxFQUU1Qjs7Ozs7QUFFRCxTQUFTLGVBQWUsQ0FBQyxLQUE2QjtJQUNwRCxPQUFPLElBQUksVUFBVSxDQUFDLHFCQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDNUMsQ0FBQzs7Ozs7Ozs7O0FBUUQsU0FBZ0Isb0JBQW9CLENBQUMsS0FBYTs7Ozs7VUFFMUMsYUFBYSxHQUFHLEtBQUs7O1VBQ3JCLE1BQU0sR0FBRyxJQUFBLGdEQUFpQyxHQUFFO0lBQ2xELE9BQU8sZUFBZSxDQUNwQixNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FDNUQsQ0FBQztBQUNKLENBQUM7QUFQRCxvREFPQzs7Ozs7O0FBTVksUUFBQSxZQUFZLEdBQWUsSUFBQSxXQUFJOzs7QUFBQyxHQUFHLEVBQUUsQ0FDaEQsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQzlEOzs7Ozs7QUFHRCxTQUFnQixRQUFRLENBQUMsS0FBYztJQUNyQyxPQUFPLEtBQUssWUFBWSxVQUFVLENBQUM7QUFDckMsQ0FBQztBQUZELDRCQUVDOzs7Ozs7Ozs7QUFRRCxTQUFnQixZQUFZLENBQUMsS0FBaUI7SUFDNUMsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsbUJBQUEsbUJBQUEsS0FBSyxFQUFXLEVBQWMsQ0FBQzthQUNwQyxxQ0FBcUMsQ0FBQztJQUMzQyxDQUFDO1NBQU0sQ0FBQzs7WUFDRixPQUFPLEdBQUcsRUFBRTtRQUNoQixJQUFJLGNBQVEsRUFBRSxDQUFDO1lBQ2IsT0FBTyxHQUFHLDRDQUE0QyxDQUFDO1FBQ3pELENBQUM7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7QUFDSCxDQUFDO0FBWEQsb0NBV0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qKiBAZmlsZW92ZXJ2aWV3IEludGVybmFsIGltcGxlbWVudGF0aW9ucyBvZiBTYWZlU2NyaXB0LiAqL1xuXG5pbXBvcnQge2dldFBvbGljeVByaXZhdGVEb05vdEFjY2Vzc09yRWxzZX0gZnJvbSAnZ29vZ2xlMy90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L2Nsb3N1cmUvaHRtbC90cnVzdGVkdHlwZXMnO1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi9lbnZpcm9ubWVudC9kZXYnO1xuXG5pbXBvcnQge3B1cmV9IGZyb20gJy4vcHVyZSc7XG5pbXBvcnQge2Vuc3VyZVRva2VuSXNWYWxpZCwgc2VjcmV0VG9rZW59IGZyb20gJy4vc2VjcmV0cyc7XG5cbmNvbnN0IHRydXN0ZWRUeXBlcyA9IGdvb2cuZ2xvYmFsLnRydXN0ZWRUeXBlcztcblxuLyoqXG4gKiBKYXZhU2NyaXB0IGNvZGUgdGhhdCBpcyBzYWZlIHRvIGV2YWx1YXRlIGFuZCB1c2UgYXMgdGhlIGNvbnRlbnQgb2YgYW4gSFRNTFxuICogc2NyaXB0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYWZlU2NyaXB0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU2NyaXB0OlxuICAgIHwgVHJ1c3RlZFNjcmlwdFxuICAgIHwgc3RyaW5nO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IodG9rZW46IG9iamVjdCwgdmFsdWU6IFRydXN0ZWRTY3JpcHQgfCBzdHJpbmcpIHtcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIGVuc3VyZVRva2VuSXNWYWxpZCh0b2tlbik7XG4gICAgfVxuXG4gICAgdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU2NyaXB0ID0gdmFsdWU7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRTY3JpcHQudG9TdHJpbmcoKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NyaXB0SW1wbCB7XG4gIHByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRTY3JpcHQ6IFRydXN0ZWRTY3JpcHQgfCBzdHJpbmc7XG59XG5jb25zdCBTY3JpcHRJbXBsID0gU2FmZVNjcmlwdCBhcyB7XG4gIG5ldyAodG9rZW46IG9iamVjdCwgdmFsdWU6IFRydXN0ZWRTY3JpcHQgfCBzdHJpbmcpOiBTYWZlU2NyaXB0O1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0U2NyaXB0KHZhbHVlOiBUcnVzdGVkU2NyaXB0IHwgc3RyaW5nKTogU2FmZVNjcmlwdCB7XG4gIHJldHVybiBuZXcgU2NyaXB0SW1wbChzZWNyZXRUb2tlbiwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBgU2FmZVNjcmlwdGAgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCB3aXRob3V0IGVuZm9yY2luZ1xuICogc2FmZXR5IGd1YXJhbnRlZXMuIEl0IG1heSBjYXVzZSBzaWRlIGVmZmVjdHMgYnkgY3JlYXRpbmcgYSBUcnVzdGVkIFR5cGVzXG4gKiBwb2xpY3kuIFRoaXMgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8gYXBwbGljYXRpb24gZGV2ZWxvcGVycywgYW5kIG11c3Qgb25seSBiZVxuICogdXNlZCBhcyBhIHN0ZXAgdG93YXJkcyBzYWZlIGJ1aWxkZXJzIG9yIHNhZmUgY29uc3RhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NyaXB0SW50ZXJuYWwodmFsdWU6IHN0cmluZyk6IFNhZmVTY3JpcHQge1xuICAvKiogQG5vaW5saW5lICovXG4gIGNvbnN0IG5vaW5saW5lVmFsdWUgPSB2YWx1ZTtcbiAgY29uc3QgcG9saWN5ID0gZ2V0UG9saWN5UHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlKCk7XG4gIHJldHVybiBjb25zdHJ1Y3RTY3JpcHQoXG4gICAgcG9saWN5ID8gcG9saWN5LmNyZWF0ZVNjcmlwdChub2lubGluZVZhbHVlKSA6IG5vaW5saW5lVmFsdWUsXG4gICk7XG59XG5cbi8qKlxuICogQW4gZW1wdHkgYFNhZmVTY3JpcHRgIGNvbnN0YW50LlxuICogVW5saWtlIHRoZSBmdW5jdGlvbnMgYWJvdmUsIHVzaW5nIHRoaXMgd2lsbCBub3QgY3JlYXRlIGEgcG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgRU1QVFlfU0NSSVBUOiBTYWZlU2NyaXB0ID0gcHVyZSgoKSA9PlxuICBjb25zdHJ1Y3RTY3JpcHQodHJ1c3RlZFR5cGVzID8gdHJ1c3RlZFR5cGVzLmVtcHR5U2NyaXB0IDogJycpLFxuKTtcblxuLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBgU2FmZVNjcmlwdGAgaW5zdGFuY2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NjcmlwdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFNhZmVTY3JpcHQge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTYWZlU2NyaXB0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFNhZmVTY3JpcHRgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKlxuICogUmV0dXJucyBhIG5hdGl2ZSBgVHJ1c3RlZFNjcmlwdGAgb3IgYSBzdHJpbmcgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgZGlzYWJsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBTY3JpcHQodmFsdWU6IFNhZmVTY3JpcHQpOiBUcnVzdGVkU2NyaXB0IHwgc3RyaW5nIHtcbiAgaWYgKGlzU2NyaXB0KHZhbHVlKSkge1xuICAgIHJldHVybiAodmFsdWUgYXMgdW5rbm93biBhcyBTY3JpcHRJbXBsKVxuICAgICAgLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRTY3JpcHQ7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIG1lc3NhZ2UgPSAnVW5leHBlY3RlZCB0eXBlIHdoZW4gdW53cmFwcGluZyBTYWZlU2NyaXB0JztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/elements/script.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/script.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.script');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/script.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_script_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_window_3 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.window");
const tsickle_TrustedResourceUrl_4 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const window_1 = goog.require('google3.third_party.javascript.safevalues.dom.globals.window');
/**
 * Propagates CSP nonce to dynamically created scripts.
 * @param {!HTMLScriptElement} script
 * @return {void}
 */
function setNonceForScriptElement(script) {
    /** @type {(null|?)} */
    const win = script.ownerDocument && script.ownerDocument.defaultView;
    /** @type {string} */
    const nonce = (0, window_1.getScriptNonce)(win || window);
    if (nonce) {
        script.setAttribute('nonce', nonce);
    }
}
/**
 * Sets textContent from the given SafeScript.
 * @param {!HTMLScriptElement} script
 * @param {!tsickle_script_impl_2.SafeScript} v
 * @param {(undefined|{omitNonce: (undefined|boolean)})=} options
 * @return {void}
 */
function setTextContent(script, v, options) {
    script.textContent = (/** @type {string} */ ((0, script_impl_1.unwrapScript)(v)));
    if (options?.omitNonce)
        return;
    setNonceForScriptElement(script);
}
exports.setTextContent = setTextContent;
/**
 * Sets the Src attribute using a TrustedResourceUrl
 * @param {!HTMLScriptElement} script
 * @param {!tsickle_TrustedResourceUrl_4} v
 * @param {(undefined|{omitNonce: (undefined|boolean)})=} options
 * @return {void}
 */
function setSrc(script, v, options) {
    script.src = (/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(v)));
    if (options?.omitNonce)
        return;
    setNonceForScriptElement(script);
}
exports.setSrc = setSrc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NyaXB0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9zY3JpcHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esa0hBRzJDO0FBQzNDLHNHQUFxRTtBQUNyRSw4RkFBaUQ7Ozs7OztBQUdqRCxTQUFTLHdCQUF3QixDQUFDLE1BQXlCOztVQUNuRCxHQUFHLEdBQUcsTUFBTSxDQUFDLGFBQWEsSUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLFdBQVc7O1VBQzlELEtBQUssR0FBRyxJQUFBLHVCQUFjLEVBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQztJQUMzQyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ1YsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQztBQUNILENBQUM7Ozs7Ozs7O0FBR0QsU0FBZ0IsY0FBYyxDQUM1QixNQUF5QixFQUN6QixDQUFhLEVBQ2IsT0FBK0I7SUFFL0IsTUFBTSxDQUFDLFdBQVcsR0FBRyx3QkFBQSxJQUFBLDBCQUFZLEVBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FBQztJQUMvQyxJQUFJLE9BQU8sRUFBRSxTQUFTO1FBQUUsT0FBTztJQUMvQix3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBUkQsd0NBUUM7Ozs7Ozs7O0FBR0QsU0FBZ0IsTUFBTSxDQUNwQixNQUF5QixFQUN6QixDQUFxQixFQUNyQixPQUErQjtJQUUvQixNQUFNLENBQUMsR0FBRyxHQUFHLHdCQUFBLElBQUEscUNBQWlCLEVBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FBQztJQUM1QyxJQUFJLE9BQU8sRUFBRSxTQUFTO1FBQUUsT0FBTztJQUMvQix3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBUkQsd0JBUUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7XG4gIFRydXN0ZWRSZXNvdXJjZVVybCxcbiAgdW53cmFwUmVzb3VyY2VVcmwsXG59IGZyb20gJy4uLy4uL2ludGVybmFscy9yZXNvdXJjZV91cmxfaW1wbCc7XG5pbXBvcnQge1NhZmVTY3JpcHQsIHVud3JhcFNjcmlwdH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3NjcmlwdF9pbXBsJztcbmltcG9ydCB7Z2V0U2NyaXB0Tm9uY2V9IGZyb20gJy4uL2dsb2JhbHMvd2luZG93JztcblxuLyoqIFByb3BhZ2F0ZXMgQ1NQIG5vbmNlIHRvIGR5bmFtaWNhbGx5IGNyZWF0ZWQgc2NyaXB0cy4gKi9cbmZ1bmN0aW9uIHNldE5vbmNlRm9yU2NyaXB0RWxlbWVudChzY3JpcHQ6IEhUTUxTY3JpcHRFbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IHNjcmlwdC5vd25lckRvY3VtZW50ICYmIHNjcmlwdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBub25jZSA9IGdldFNjcmlwdE5vbmNlKHdpbiB8fCB3aW5kb3cpO1xuICBpZiAobm9uY2UpIHtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxufVxuXG4vKiogU2V0cyB0ZXh0Q29udGVudCBmcm9tIHRoZSBnaXZlbiBTYWZlU2NyaXB0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KFxuICBzY3JpcHQ6IEhUTUxTY3JpcHRFbGVtZW50LFxuICB2OiBTYWZlU2NyaXB0LFxuICBvcHRpb25zPzoge29taXROb25jZT86IGJvb2xlYW59LFxuKSB7XG4gIHNjcmlwdC50ZXh0Q29udGVudCA9IHVud3JhcFNjcmlwdCh2KSBhcyBzdHJpbmc7XG4gIGlmIChvcHRpb25zPy5vbWl0Tm9uY2UpIHJldHVybjtcbiAgc2V0Tm9uY2VGb3JTY3JpcHRFbGVtZW50KHNjcmlwdCk7XG59XG5cbi8qKiBTZXRzIHRoZSBTcmMgYXR0cmlidXRlIHVzaW5nIGEgVHJ1c3RlZFJlc291cmNlVXJsICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3JjKFxuICBzY3JpcHQ6IEhUTUxTY3JpcHRFbGVtZW50LFxuICB2OiBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIG9wdGlvbnM/OiB7b21pdE5vbmNlPzogYm9vbGVhbn0sXG4pIHtcbiAgc2NyaXB0LnNyYyA9IHVud3JhcFJlc291cmNlVXJsKHYpIGFzIHN0cmluZztcbiAgaWYgKG9wdGlvbnM/Lm9taXROb25jZSkgcmV0dXJuO1xuICBzZXROb25jZUZvclNjcmlwdEVsZW1lbnQoc2NyaXB0KTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/closure/html/safestylesheet_internals_for_safevalues.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview File that re-exports the internals of goog.html.SafeStyleSheet
 * type so that they can be used in safevalues for compatibility purposes.
 * DO NOT OPENSOURCE
 */

goog.module('goog.html.safestylesheet_internals_for_safevalues');

const SafeStyleSheet = goog.require('goog.html.SafeStyleSheet');

exports.createSafeStyleSheet =
    SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse;

;return exports;});

//third_party/javascript/safevalues/internals/style_sheet_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/internals/style_sheet_impl.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.internals.style_sheet_impl');
var module = module || { id: 'third_party/javascript/safevalues/internals/style_sheet_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safestylesheet_1 = goog.requireType("goog.html.SafeStyleSheet");
const tsickle_safestylesheet_internals_for_safevalues_2 = goog.requireType("goog.html.safestylesheet_internals_for_safevalues");
const safestylesheet_1 = goog.require('goog.html.SafeStyleSheet');
const safestylesheet_internals_for_safevalues_1 = goog.require('goog.html.safestylesheet_internals_for_safevalues');
// tslint:disable:enforce-name-casing
/**
 * Export the object separately to break the use of legacy static functions on
 * the re-export, but preserve instanceof checks.
 *
 * Please have a look at go/safehtml?polygot=ts to see what functions are
 * available in safevalues.
 * @type {function(new:tsickle_safestylesheet_1, ?)}
 */
exports.SafeStyleSheet = (/** @type {function(new:tsickle_safestylesheet_1, ?)} */ ((/** @type {*} */ (safestylesheet_1))));
/**
 * Builds a new `SafeStyleSheet` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} styleSheet
 * @return {!tsickle_safestylesheet_1}
 */
function createStyleSheetInternal(styleSheet) {
    return (0, safestylesheet_internals_for_safevalues_1.createSafeStyleSheet)(styleSheet);
}
exports.createStyleSheetInternal = createStyleSheetInternal;
/**
 * Checks if the given value is a `SafeStyleSheet` instance.
 * @param {*} value
 * @return {boolean}
 */
function isStyleSheet(value) {
    return value instanceof safestylesheet_1;
}
exports.isStyleSheet = isStyleSheet;
/**
 * Returns the string value of the passed `SafeStyleSheet` object while
 * ensuring it has the correct type.
 * @param {!tsickle_safestylesheet_1} value
 * @return {string}
 */
function unwrapStyleSheet(value) {
    return safestylesheet_1.unwrap(value);
}
exports.unwrapStyleSheet = unwrapStyleSheet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGVfc2hlZXRfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9pbnRlcm5hbHMvc3R5bGVfc2hlZXRfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esa0VBQW1IO0FBQ25ILG9IQUF5SDs7Ozs7Ozs7OztBQWE1RyxRQUFBLGNBQWMsR0FBRywyREFBQSxxQ0FBZ0MsRUFFN0Q7Ozs7Ozs7O0FBT0QsU0FBZ0Isd0JBQXdCLENBQUMsVUFBa0I7SUFDekQsT0FBTyxJQUFBLDhEQUFvQixFQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFGRCw0REFFQzs7Ozs7O0FBS0QsU0FBZ0IsWUFBWSxDQUFDLEtBQWM7SUFDekMsT0FBTyxLQUFLLDRCQUFpQyxDQUFDO0FBQ2hELENBQUM7QUFGRCxvQ0FFQzs7Ozs7OztBQU1ELFNBQWdCLGdCQUFnQixDQUFDLEtBQXFCO0lBQ3BELE9BQU8saUJBQXNCLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM3QyxDQUFDO0FBRkQsNENBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7U2FmZVN0eWxlU2hlZXQgYXMgQ2xvc3VyZVNhZmVTdHlsZVNoZWV0fSBmcm9tICdnb29nbGUzL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvY2xvc3VyZS9odG1sL3NhZmVzdHlsZXNoZWV0JztcbmltcG9ydCB7Y3JlYXRlU2FmZVN0eWxlU2hlZXR9IGZyb20gJ2dvb2dsZTMvdGhpcmRfcGFydHkvamF2YXNjcmlwdC9jbG9zdXJlL2h0bWwvc2FmZXN0eWxlc2hlZXRfaW50ZXJuYWxzX2Zvcl9zYWZldmFsdWVzJztcblxuLyoqIFJlLWV4cG9ydHMgdGhlIENsb3N1cmUgdHlwZSB0byBlbnN1cmUgYm90aCBjb2RlYmFzZXMgYXJlIGNvbXBhdGlibGUuICovXG5leHBvcnQgdHlwZSBTYWZlU3R5bGVTaGVldCA9IENsb3N1cmVTYWZlU3R5bGVTaGVldDtcblxuLy8gdHNsaW50OmRpc2FibGU6ZW5mb3JjZS1uYW1lLWNhc2luZ1xuLyoqXG4gKiBFeHBvcnQgdGhlIG9iamVjdCBzZXBhcmF0ZWx5IHRvIGJyZWFrIHRoZSB1c2Ugb2YgbGVnYWN5IHN0YXRpYyBmdW5jdGlvbnMgb25cbiAqIHRoZSByZS1leHBvcnQsIGJ1dCBwcmVzZXJ2ZSBpbnN0YW5jZW9mIGNoZWNrcy5cbiAqXG4gKiBQbGVhc2UgaGF2ZSBhIGxvb2sgYXQgZ28vc2FmZWh0bWw/cG9seWdvdD10cyB0byBzZWUgd2hhdCBmdW5jdGlvbnMgYXJlXG4gKiBhdmFpbGFibGUgaW4gc2FmZXZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFNhZmVTdHlsZVNoZWV0ID0gQ2xvc3VyZVNhZmVTdHlsZVNoZWV0IGFzIHVua25vd24gYXMge1xuICBuZXcgKF86IG5ldmVyKTogU2FmZVN0eWxlU2hlZXQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBgU2FmZVN0eWxlU2hlZXRgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXRJbnRlcm5hbChzdHlsZVNoZWV0OiBzdHJpbmcpOiBTYWZlU3R5bGVTaGVldCB7XG4gIHJldHVybiBjcmVhdGVTYWZlU3R5bGVTaGVldChzdHlsZVNoZWV0KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYFNhZmVTdHlsZVNoZWV0YCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3R5bGVTaGVldCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFNhZmVTdHlsZVNoZWV0IHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xvc3VyZVNhZmVTdHlsZVNoZWV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgcGFzc2VkIGBTYWZlU3R5bGVTaGVldGAgb2JqZWN0IHdoaWxlXG4gKiBlbnN1cmluZyBpdCBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFN0eWxlU2hlZXQodmFsdWU6IFNhZmVTdHlsZVNoZWV0KTogc3RyaW5nIHtcbiAgcmV0dXJuIENsb3N1cmVTYWZlU3R5bGVTaGVldC51bndyYXAodmFsdWUpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/style.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/style.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.style');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/style.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_style_sheet_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_sheet_impl");
const tsickle_SafeStyleSheet_2 = goog.requireType("goog.html.SafeStyleSheet");
const style_sheet_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_sheet_impl');
/**
 * Safe setters for `HTMLStyleElement`s.
 * @param {!HTMLStyleElement} elem
 * @param {!tsickle_SafeStyleSheet_2} safeStyleSheet
 * @return {void}
 */
function setTextContent(elem, safeStyleSheet) {
    elem.textContent = (0, style_sheet_impl_1.unwrapStyleSheet)(safeStyleSheet);
}
exports.setTextContent = setTextContent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2VsZW1lbnRzL3N0eWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSxnSEFHMEM7Ozs7Ozs7QUFHMUMsU0FBZ0IsY0FBYyxDQUM1QixJQUFzQixFQUN0QixjQUE4QjtJQUU5QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUEsbUNBQWdCLEVBQUMsY0FBYyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUxELHdDQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge1xuICBTYWZlU3R5bGVTaGVldCxcbiAgdW53cmFwU3R5bGVTaGVldCxcbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3N0eWxlX3NoZWV0X2ltcGwnO1xuXG4vKiogU2FmZSBzZXR0ZXJzIGZvciBgSFRNTFN0eWxlRWxlbWVudGBzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KFxuICBlbGVtOiBIVE1MU3R5bGVFbGVtZW50LFxuICBzYWZlU3R5bGVTaGVldDogU2FmZVN0eWxlU2hlZXQsXG4pIHtcbiAgZWxlbS50ZXh0Q29udGVudCA9IHVud3JhcFN0eWxlU2hlZXQoc2FmZVN0eWxlU2hlZXQpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/elements/svg.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/svg.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.svg');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/svg.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
/** @type {!Array<string>} */
const UNSAFE_SVG_ATTRIBUTES = ['href', 'xlink:href'];
/**
 * Set attribute on SVGElement if the attribute doesn't have security
 * implications. If the attribute can potentially cause XSS, throw an error.
 * @param {!SVGElement} svg
 * @param {string} attr
 * @param {string} value
 * @return {void}
 */
function setAttribute(svg, attr, value) {
    /** @type {string} */
    const attrLower = attr.toLowerCase();
    if (UNSAFE_SVG_ATTRIBUTES.indexOf(attrLower) !== -1 ||
        attrLower.indexOf('on') === 0) {
        /** @type {string} */
        let msg = '';
        if (dev_1.DEV_MODE) {
            msg = `Setting the '${attrLower}' attribute on SVG can cause XSS.`;
        }
        throw new Error(msg);
    }
    svg.setAttribute(attr, value);
}
exports.setAttribute = setAttribute;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9lbGVtZW50cy9zdmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0ZBQStDOztNQUV6QyxxQkFBcUIsR0FBRyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUM7Ozs7Ozs7OztBQU1wRCxTQUFnQixZQUFZLENBQUMsR0FBZSxFQUFFLElBQVksRUFBRSxLQUFhOztVQUNqRSxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRTtJQUNwQyxJQUNFLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0MsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQzdCLENBQUM7O1lBQ0csR0FBRyxHQUFHLEVBQUU7UUFDWixJQUFJLGNBQVEsRUFBRSxDQUFDO1lBQ2IsR0FBRyxHQUFHLGdCQUFnQixTQUFTLG1DQUFtQyxDQUFDO1FBQ3JFLENBQUM7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBZEQsb0NBY0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2Rldic7XG5cbmNvbnN0IFVOU0FGRV9TVkdfQVRUUklCVVRFUyA9IFsnaHJlZicsICd4bGluazpocmVmJ107XG5cbi8qKlxuICogU2V0IGF0dHJpYnV0ZSBvbiBTVkdFbGVtZW50IGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBoYXZlIHNlY3VyaXR5XG4gKiBpbXBsaWNhdGlvbnMuIElmIHRoZSBhdHRyaWJ1dGUgY2FuIHBvdGVudGlhbGx5IGNhdXNlIFhTUywgdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoc3ZnOiBTVkdFbGVtZW50LCBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgY29uc3QgYXR0ckxvd2VyID0gYXR0ci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoXG4gICAgVU5TQUZFX1NWR19BVFRSSUJVVEVTLmluZGV4T2YoYXR0ckxvd2VyKSAhPT0gLTEgfHxcbiAgICBhdHRyTG93ZXIuaW5kZXhPZignb24nKSA9PT0gMFxuICApIHtcbiAgICBsZXQgbXNnID0gJyc7XG4gICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICBtc2cgPSBgU2V0dGluZyB0aGUgJyR7YXR0ckxvd2VyfScgYXR0cmlidXRlIG9uIFNWRyBjYW4gY2F1c2UgWFNTLmA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG5cbiAgc3ZnLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/closure/debug/errorcontext.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides methods dealing with context on error objects.
 */

goog.provide('goog.debug.errorcontext');


/**
 * Adds key-value context to the error.
 * @param {!Error} err The error to add context to.
 * @param {string} contextKey Key for the context to be added.
 * @param {string} contextValue Value for the context to be added.
 */
goog.debug.errorcontext.addErrorContext = function(
    err, contextKey, contextValue) {
  'use strict';
  if (!err[goog.debug.errorcontext.CONTEXT_KEY_]) {
    err[goog.debug.errorcontext.CONTEXT_KEY_] = {};
  }
  err[goog.debug.errorcontext.CONTEXT_KEY_][contextKey] = contextValue;
};


/**
 * @param {!Error} err The error to get context from.
 * @return {!Object<string, string>} The context of the provided error.
 */
goog.debug.errorcontext.getErrorContext = function(err) {
  'use strict';
  return err[goog.debug.errorcontext.CONTEXT_KEY_] || {};
};


// TODO(aaronsn): convert this to a Symbol once goog.debug.ErrorReporter is
// able to use ES6.
/** @private @const {string} */
goog.debug.errorcontext.CONTEXT_KEY_ = '__closure__error__context__984382';

// MOE:begin_strip
// Ensure ES2021 inputs. go/transpile-js
null?.(6_6);
// MOE:end_strip

//third_party/javascript/closure/debug/debug.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug');

goog.require('goog.array');
goog.require('goog.debug.errorcontext');


/** @define {boolean} Whether logging should be enabled. */
goog.debug.LOGGING_ENABLED =
    goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);


/** @define {boolean} Whether to force "sloppy" stack building. */
goog.debug.FORCE_SLOPPY_STACKS =
    goog.define('goog.debug.FORCE_SLOPPY_STACKS', false);


/**
 * @define {boolean} TODO(b/159435805): Remove this hack once bug is resolved.
 */
goog.debug.CHECK_FOR_THROWN_EVENT =
    goog.define('goog.debug.CHECK_FOR_THROWN_EVENT', false);



/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 * @suppress {strictMissingProperties} onerror is not defined as a property
 *    on Object.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  'use strict';
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just "Script error.". For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to "" for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    'use strict';
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      lineNumber: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of `obj`.
 */
goog.debug.expose = function(obj, opt_showFn) {
  'use strict';
  if (typeof obj == 'undefined') {
    return 'undefined';
  }
  if (obj == null) {
    return 'NULL';
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn && typeof obj[x] === 'function') {
      continue;
    }
    var s = x + ' = ';

    try {
      s += obj[x];
    } catch (e) {
      s += '*** ' + e + ' ***';
    }
    str.push(s);
  }
  return str.join('\n');
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects. NOTE: The output will include
 * Uids on all objects that were exposed. Any added Uids will be removed before
 * returning.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of `obj`.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  'use strict';
  var str = [];

  // Track any objects where deepExpose added a Uid, so they can be cleaned up
  // before return. We do this globally, rather than only on ancestors so that
  // if the same object appears in the output, you can see it.
  var uidsToCleanup = [];
  var ancestorUids = {};

  var helper = function(obj, space) {
    'use strict';
    var nestspace = space + '  ';

    var indentMultiline = function(str) {
      'use strict';
      return str.replace(/\n/g, '\n' + space);
    };


    try {
      if (obj === undefined) {
        str.push('undefined');
      } else if (obj === null) {
        str.push('NULL');
      } else if (typeof obj === 'string') {
        str.push('"' + indentMultiline(obj) + '"');
      } else if (typeof obj === 'function') {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        // Add a Uid if needed. The struct calls implicitly adds them.
        if (!goog.hasUid(obj)) {
          uidsToCleanup.push(obj);
        }
        var uid = goog.getUid(obj);
        if (ancestorUids[uid]) {
          str.push('*** reference loop detected (id=' + uid + ') ***');
        } else {
          ancestorUids[uid] = true;
          str.push('{');
          for (var x in obj) {
            if (!opt_showFn && typeof obj[x] === 'function') {
              continue;
            }
            str.push('\n');
            str.push(nestspace);
            str.push(x + ' = ');
            helper(obj[x], nestspace);
          }
          str.push('\n' + space + '}');
          delete ancestorUids[uid];
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push('*** ' + e + ' ***');
    }
  };

  helper(obj, '');

  // Cleanup any Uids that were added by the deepExpose.
  for (var i = 0; i < uidsToCleanup.length; i++) {
    goog.removeUid(uidsToCleanup[i]);
  }

  return str.join('');
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array<?>} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  'use strict';
  var str = [];
  for (var i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return '[ ' + str.join(', ') + ' ]';
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {*} err Raw error object.
 * @return {{
 *    message: (?|undefined),
 *    name: (?|undefined),
 *    lineNumber: (?|undefined),
 *    fileName: (?|undefined),
 *    stack: (?|undefined)
 * }} Representation of err as an Object. It will never return err.
 * @suppress {strictMissingProperties} properties not defined on err
 */
goog.debug.normalizeErrorObject = function(err) {
  'use strict';
  var href = goog.getObjectByName('window.location.href');
  if (err == null) {
    err = 'Unknown Error of type "null/undefined"';
  }
  if (typeof err === 'string') {
    return {
      'message': err,
      'name': 'Unknown error',
      'lineNumber': 'Not available',
      'fileName': href,
      'stack': 'Not available'
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || 'Not available';
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing 'lineNumber':
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = 'Not available';
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global['$googDebugFname'] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing 'filename'.
    fileName = 'Not available';
    threwError = true;
  }

  var stack = goog.debug.serializeErrorStack_(err);

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    var message = err.message;
    if (message == null) {
      if (err.constructor && err.constructor instanceof Function) {
        var ctorName = err.constructor.name ?
            err.constructor.name :
            goog.debug.getFunctionName(err.constructor);
        message = 'Unknown Error of type "' + ctorName + '"';
        // TODO(b/159435805): Remove this hack once bug is resolved.
        if (goog.debug.CHECK_FOR_THROWN_EVENT && ctorName == 'Event') {
          try {
            message = message + ' with Event.type "' + (err.type || '') + '"';
          } catch (e) {
            // Just give up on getting more information out of the error object.
          }
        }
      } else {
        message = 'Unknown Error of unknown type';
      }

      // Avoid TypeError since toString could be missing from the instance
      // (e.g. if created Object.create(null)).
      if (typeof err.toString === 'function' &&
          Object.prototype.toString !== err.toString) {
        message += ': ' + err.toString();
      }
    }
    return {
      'message': message,
      'name': err.name || 'UnknownError',
      'lineNumber': lineNumber,
      'fileName': fileName,
      'stack': stack || 'Not available'
    };
  }
  // Standards error object

  // Return non-standard error to allow for consistent result (eg. enumerable).
  return {
    'message': err.message,
    'name': err.name,
    'lineNumber': err.lineNumber,
    'fileName': err.fileName,
    'stack': stack,
  };
};


/**
 * Serialize stack by including the cause chain of the exception if it exists.
 *
 * MOE:begin_intracomment_strip
 * When an OO language is transpiled to JavaScript, it might have the concept of
 * exception chaining, which we emulate here. See go/exception-cause-reporting
 * for more information.
 * MOE:end_intracomment_strip
 *
 * @param {*} e an exception that may have a cause
 * @param {!Object=} seen set of cause that have already been serialized
 * @return {string}
 * @private
 * @suppress {missingProperties} properties not defined on cause and e
 */
goog.debug.serializeErrorStack_ = function(e, seen) {
  'use strict';
  if (!seen) {
    seen = {};
  }
  seen[goog.debug.serializeErrorAsKey_(e)] = true;

  var stack = e['stack'] || '';

  // Add cause if exists.
  var cause = e.cause;
  if (cause && !seen[goog.debug.serializeErrorAsKey_(cause)]) {
    stack += '\nCaused by: ';
    // Some browsers like Chrome add the error message as the first frame of the
    // stack, In this case we don't need to add it. Note: we don't use
    // String.startsWith method because it might have to be polyfilled.
    if (!cause.stack || cause.stack.indexOf(cause.toString()) != 0) {
      stack += (typeof cause === 'string') ? cause : cause.message + '\n';
    }
    stack += goog.debug.serializeErrorStack_(cause, seen);
  }

  return stack;
};

/**
 * Serialize an error to a string key.
 * @param {*} e an exception
 * @return {string}
 * @private
 */
goog.debug.serializeErrorAsKey_ = function(e) {
  'use strict';
  var keyPrefix = '';

  if (typeof e.toString === 'function') {
    keyPrefix = '' + e;
  }

  return keyPrefix + e['stack'];
};


/**
 * Converts an object to an Error using the object's toString if it's not
 * already an Error, adds a stacktrace if there isn't one, and optionally adds
 * an extra message.
 * @param {*} err The original thrown error, object, or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
 *     it is converted to an Error which is enhanced and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  'use strict';
  var error;
  if (!(err instanceof Error)) {
    error = Error(err);
    if (Error.captureStackTrace) {
      // Trim this function off the call stack, if we can.
      Error.captureStackTrace(error, goog.debug.enhanceError);
    }
  } else {
    error = err;
  }

  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
  }
  if (opt_message) {
    // find the first unoccupied 'messageX' property
    var x = 0;
    while (error['message' + x]) {
      ++x;
    }
    error['message' + x] = String(opt_message);
  }
  return error;
};


/**
 * Converts an object to an Error using the object's toString if it's not
 * already an Error, adds a stacktrace if there isn't one, and optionally adds
 * context to the Error, which is reported by the closure error reporter.
 * @param {*} err The original thrown error, object, or string.
 * @param {!Object<string, string>=} opt_context Key-value context to add to the
 *     Error.
 * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
 *     it is converted to an Error which is enhanced and returned.
 */
goog.debug.enhanceErrorWithContext = function(err, opt_context) {
  'use strict';
  var error = goog.debug.enhanceError(err);
  if (opt_context) {
    for (var key in opt_context) {
      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);
    }
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn't worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 * @suppress {es5Strict}
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  'use strict';
  if (!goog.debug.FORCE_SLOPPY_STACKS) {
    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
    if (stack) {
      return stack;
    }
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties.  Fall-through for legacy browser support.
  }

  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn && (!opt_depth || depth < opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push('()\n');

    try {
      fn = fn.caller;
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
      break;
    }
    depth++;
    if (depth >= goog.debug.MAX_STACK_DEPTH) {
      sb.push('[...long stack...]');
      break;
    }
  }
  if (opt_depth && depth >= opt_depth) {
    sb.push('[...reached max depth limit...]');
  } else {
    sb.push('[end]');
  }

  return sb.join('');
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * @param {Function} fn The function to start getting the trace from.
 * @return {?string}
 * @private
 */
goog.debug.getNativeStackTrace_ = function(fn) {
  'use strict';
  var tempErr = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(tempErr, fn);
    return String(tempErr.stack);
  } else {
    // IE10, only adds stack traces when an exception is thrown.
    try {
      throw tempErr;
    } catch (e) {
      tempErr = e;
    }
    var stack = tempErr.stack;
    if (stack) {
      return String(stack);
    }
  }
  return null;
};


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that's currently on the call stack.
 * @param {?Function=} fn If provided, when collecting the stack trace all
 *     frames above the topmost call to this function, including that call,
 *     will be left out of the stack trace.
 * @return {string} Stack trace.
 * @suppress {es5Strict}
 */
goog.debug.getStacktrace = function(fn) {
  'use strict';
  var stack;
  if (!goog.debug.FORCE_SLOPPY_STACKS) {
    // Try to get the stack trace from the environment if it is available.
    var contextFn = fn || goog.debug.getStacktrace;
    stack = goog.debug.getNativeStackTrace_(contextFn);
  }
  if (!stack) {
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties. This function will throw in strict mode.
    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);
  }
  return stack;
};


/**
 * Private helper for getStacktrace().
 * @param {?Function} fn If provided, when collecting the stack trace all
 *     frames above the topmost call to this function, including that call,
 *     will be left out of the stack trace.
 * @param {Array<!Function>} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @suppress {es5Strict}
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  'use strict';
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push('[...circular reference...]');

    // Traverse the call stack until function not found or max depth is reached
  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + '(');
    var args = fn.arguments;
    // Args may be null for some special functions such as host objects or eval.
    for (var i = 0; args && i < args.length; i++) {
      if (i > 0) {
        sb.push(', ');
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case 'object':
          argDesc = arg ? 'object' : 'null';
          break;

        case 'string':
          argDesc = arg;
          break;

        case 'number':
          argDesc = String(arg);
          break;

        case 'boolean':
          argDesc = arg ? 'true' : 'false';
          break;

        case 'function':
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : '[fn]';
          break;

        case 'undefined':
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length > 40) {
        argDesc = argDesc.slice(0, 40) + '...';
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(')\n');

    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
    }

  } else if (fn) {
    sb.push('[...long stack...]');
  } else {
    sb.push('[end]');
  }
  return sb.join('');
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function's name.
 */
goog.debug.getFunctionName = function(fn) {
  'use strict';
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function\s+([^\(]+)/m.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  'use strict';
  return string.replace(/ /g, '[_]')
      .replace(/\f/g, '[f]')
      .replace(/\n/g, '[n]\n')
      .replace(/\r/g, '[r]')
      .replace(/\t/g, '[t]');
};


/**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 *
 * <p>Forked rather than moved from {@link goog.asserts.getType_}
 * to avoid adding a dependency to goog.asserts.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 */
goog.debug.runtimeType = function(value) {
  'use strict';
  if (value instanceof Function) {
    return value.displayName || value.name || 'unknown type name';
  } else if (value instanceof Object) {
    return /** @type {string} */ (value.constructor.displayName) ||
        value.constructor.name || Object.prototype.toString.call(value);
  } else {
    return value === null ? 'null' : typeof value;
  }
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Private internal function to support goog.debug.freeze.
 * @param {T} arg
 * @return {T}
 * @template T
 * @private
 */
goog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {
  'use strict';
  return arg;
};


/**
 * Freezes the given object, but only in debug mode (and in browsers that
 * support it).  Note that this is a shallow freeze, so for deeply nested
 * objects it must be called at every level to ensure deep immutability.
 * @param {T} arg
 * @return {T}
 * @template T
 */
goog.debug.freeze = function(arg) {
  'use strict';
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // freezeInternal_ from the compiler so that the entire call can be
  // removed if the result is not used.
  return {
    valueOf: function() {
      'use strict';
      return goog.debug.freezeInternal_(arg);
    }
  }.valueOf();
};

//third_party/javascript/closure/log/log.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Basic strippable logging definitions.
 * @see http://go/closurelogging
 */

goog.provide('goog.log');
goog.provide('goog.log.Level');
goog.provide('goog.log.LogBuffer');
goog.provide('goog.log.LogRecord');
goog.provide('goog.log.Logger');

goog.require('goog.asserts');
goog.require('goog.debug');


/**
 * A message value that can be handled by a goog.log.Logger.
 *
 * Functions are treated like callbacks, but are only called when the event's
 * log level is enabled. This is useful for logging messages that are expensive
 * to construct.
 *
 * @typedef {string|function(): string}
 */
goog.log.Loggable;

/** @define {boolean} Whether logging is enabled. */
goog.log.ENABLED = goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);

/** @const */
goog.log.ROOT_LOGGER_NAME = '';


// TODO(b/170408987): Make goog.log.Level an enum.
/**
 * The goog.log.Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging goog.log.Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * <p>
 * Clients should normally use the predefined goog.log.Level constants such
 * as goog.log.Level.SEVERE.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (highest value)
 * <li>WARNING
 * <li>INFO
 * <li>CONFIG
 * <li>FINE
 * <li>FINER
 * <li>FINEST  (lowest value)
 * </ul>
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 *
 * @final
 */
goog.log.Level = class Level {
  /**
   * @param {string} name The name of the level.
   * @param {number} value The numeric value of the level.
   */
  constructor(name, value) {
    /**
     * The name of the level
     * @type {string}
     * @const
     */
    this.name = name;

    /**
     * The numeric value of the level
     * @type {number}
     */
    this.value = value;
  }

  /**
   * @return {string} String representation of the logger level.
   * @override
   */
  toString() {
    return this.name;
  }
};


/**
 * OFF is a special level that can be used to turn off logging.
 * This level is initialized to <CODE>Infinity</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.OFF = new goog.log.Level('OFF', Infinity);


/**
 * SHOUT is a message level for extra debugging loudness.
 * This level is initialized to <CODE>1200</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.SHOUT = new goog.log.Level('SHOUT', 1200);


/**
 * SEVERE is a message level indicating a serious failure.
 * This level is initialized to <CODE>1000</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.SEVERE = new goog.log.Level('SEVERE', 1000);


/**
 * WARNING is a message level indicating a potential problem.
 * This level is initialized to <CODE>900</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.WARNING = new goog.log.Level('WARNING', 900);


/**
 * INFO is a message level for informational messages.
 * This level is initialized to <CODE>800</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.INFO = new goog.log.Level('INFO', 800);


/**
 * CONFIG is a message level for static configuration messages.
 * This level is initialized to <CODE>700</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.CONFIG = new goog.log.Level('CONFIG', 700);


/**
 * FINE is a message level providing tracing information.
 * This level is initialized to <CODE>500</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.FINE = new goog.log.Level('FINE', 500);


/**
 * FINER indicates a fairly detailed tracing message.
 * This level is initialized to <CODE>400</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.FINER = new goog.log.Level('FINER', 400);

/**
 * FINEST indicates a highly detailed tracing message.
 * This level is initialized to <CODE>300</CODE>.
 * @type {!goog.log.Level}
 */

goog.log.Level.FINEST = new goog.log.Level('FINEST', 300);


/**
 * ALL indicates that all messages should be logged.
 * This level is initialized to <CODE>0</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.ALL = new goog.log.Level('ALL', 0);


/**
 * The predefined levels.
 * @type {!Array<!goog.log.Level>}
 * @final
 */
goog.log.Level.PREDEFINED_LEVELS = [
  goog.log.Level.OFF, goog.log.Level.SHOUT, goog.log.Level.SEVERE,
  goog.log.Level.WARNING, goog.log.Level.INFO, goog.log.Level.CONFIG,
  goog.log.Level.FINE, goog.log.Level.FINER, goog.log.Level.FINEST,
  goog.log.Level.ALL
];


/**
 * A lookup map used to find the level object based on the name or value of
 * the level object.
 * @type {?Object}
 * @private
 */
goog.log.Level.predefinedLevelsCache_ = null;


/**
 * Creates the predefined levels cache and populates it.
 * @private
 */
goog.log.Level.createPredefinedLevelsCache_ = function() {
  goog.log.Level.predefinedLevelsCache_ = {};
  for (let i = 0, level; level = goog.log.Level.PREDEFINED_LEVELS[i]; i++) {
    goog.log.Level.predefinedLevelsCache_[level.value] = level;
    goog.log.Level.predefinedLevelsCache_[level.name] = level;
  }
};


/**
 * Gets the predefined level with the given name.
 * @param {string} name The name of the level.
 * @return {!goog.log.Level|null} The level, or null if none found.
 */
goog.log.Level.getPredefinedLevel = function(name) {
  if (!goog.log.Level.predefinedLevelsCache_) {
    goog.log.Level.createPredefinedLevelsCache_();
  }

  return goog.log.Level.predefinedLevelsCache_[name] || null;
};


/**
 * Gets the highest predefined level <= #value.
 * @param {number} value goog.log.Level value.
 * @return {!goog.log.Level|null} The level, or null if none found.
 */
goog.log.Level.getPredefinedLevelByValue = function(value) {
  if (!goog.log.Level.predefinedLevelsCache_) {
    goog.log.Level.createPredefinedLevelsCache_();
  }

  if (value in /** @type {!Object} */ (goog.log.Level.predefinedLevelsCache_)) {
    return goog.log.Level.predefinedLevelsCache_[value];
  }

  for (let i = 0; i < goog.log.Level.PREDEFINED_LEVELS.length; ++i) {
    let level = goog.log.Level.PREDEFINED_LEVELS[i];
    if (level.value <= value) {
      return level;
    }
  }
  return null;
};


/** @interface */
goog.log.Logger = class Logger {
  /**
   * Gets the name of the Logger.
   * @return {string}
   * @public
   */
  getName() {}
};


/**
 * Only for compatibility with goog.debug.Logger.Level, which is how many users
 * access Level.
 * TODO(kelvinjin): Remove these definitions.
 * @final
 */
goog.log.Logger.Level = goog.log.Level;


/**
 * A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 * @final
 */
goog.log.LogBuffer = class LogBuffer {
  /**
   * @param {number=} capacity The capacity of this LogBuffer instance.
   */
  constructor(capacity) {
    /**
     * The buffer's capacity.
     * @type {number}
     * @private
     */
    this.capacity_ =
        typeof capacity === 'number' ? capacity : goog.log.LogBuffer.CAPACITY;

    /**
     * The array to store the records.
     * @type {!Array<!goog.log.LogRecord|undefined>}
     * @private
     */
    this.buffer_;

    /**
     * The index of the most recently added record, or -1 if there are no
     * records.
     * @type {number}
     * @private
     */
    this.curIndex_;

    /**
     * Whether the buffer is at capacity.
     * @type {boolean}
     * @private
     */
    this.isFull_;

    this.clear();
  }


  /**
   * Adds a log record to the buffer, possibly overwriting the oldest record.
   * @param {!goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @return {!goog.log.LogRecord} The log record.
   */
  addRecord(level, msg, loggerName) {
    if (!this.isBufferingEnabled()) {
      return new goog.log.LogRecord(level, msg, loggerName);
    }
    const curIndex = (this.curIndex_ + 1) % this.capacity_;
    this.curIndex_ = curIndex;
    if (this.isFull_) {
      const ret = this.buffer_[curIndex];
      ret.reset(level, msg, loggerName);
      return ret;
    }
    this.isFull_ = curIndex == this.capacity_ - 1;
    return this.buffer_[curIndex] =
               new goog.log.LogRecord(level, msg, loggerName);
  }

  /**
   * Calls the given function for each buffered log record, starting with the
   * oldest one.
   * TODO(kelvinjin): Make this a [Symbol.iterator] once all usages of
   * goog.debug.LogBuffer can be deleted.
   * @param {!goog.log.LogRecordHandler} func The function to call.
   */
  forEachRecord(func) {
    const buffer = this.buffer_;
    // Corner case: no records.
    if (!buffer[0]) {
      return;
    }
    const curIndex = this.curIndex_;
    let i = this.isFull_ ? curIndex : -1;
    do {
      i = (i + 1) % this.capacity_;
      func(/** @type {!goog.log.LogRecord} */ (buffer[i]));
    } while (i !== curIndex);
  }

  /**
   * @return {boolean} Whether the log buffer is enabled.
   */
  isBufferingEnabled() {
    return this.capacity_ > 0;
  }

  /**
   * @return {boolean} Return whether the log buffer is full.
   */
  isFull() {
    return this.isFull_;
  }

  /**
   * Removes all buffered log records.
   */
  clear() {
    this.buffer_ = new Array(this.capacity_);
    this.curIndex_ = -1;
    this.isFull_ = false;
  }
};


/**
 * @type {!goog.log.LogBuffer|undefined}
 * @private
 */
goog.log.LogBuffer.instance_;


/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.log.LogBuffer.CAPACITY = goog.define('goog.debug.LogBuffer.CAPACITY', 0);


/**
 * A static method that always returns the same instance of goog.log.LogBuffer.
 * @return {!goog.log.LogBuffer} The goog.log.LogBuffer singleton instance.
 */
goog.log.LogBuffer.getInstance = function() {
  if (!goog.log.LogBuffer.instance_) {
    goog.log.LogBuffer.instance_ =
        new goog.log.LogBuffer(goog.log.LogBuffer.CAPACITY);
  }
  return goog.log.LogBuffer.instance_;
};


/**
 * Whether the log buffer is enabled.
 * @return {boolean}
 */
goog.log.LogBuffer.isBufferingEnabled = function() {
  return goog.log.LogBuffer.getInstance().isBufferingEnabled();
};


/**
 * LogRecord objects are used to pass logging requests between the logging
 * framework and individual log handlers. These objects should not be
 * constructed or reset by application code.
 */
goog.log.LogRecord = class LogRecord {
  /**
   * @param {?goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @param {number=} time Time this log record was created if other than
   *     now. If 0, we use #goog.now.
   * @param {number=} sequenceNumber Sequence number of this log record.
   *     This should only be passed in when restoring a log record from
   *     persistence.
   */
  constructor(level, msg, loggerName, time, sequenceNumber) {
    /**
     * Level of the LogRecord.
     * @type {!goog.log.Level}
     * @private
     */
    this.level_;

    /**
     * Name of the logger that created the record.
     * @type {string}
     * @private
     */
    this.loggerName_;

    /**
     * Message associated with the record
     * @type {string}
     * @private
     */
    this.msg_;

    /**
     * Time the LogRecord was created.
     * @type {number}
     * @private
     */
    this.time_;

    /**
     * Sequence number for the LogRecord. Each record has a unique sequence
     * number that is greater than all log records created before it.
     * @type {number}
     * @private
     */
    this.sequenceNumber_;

    /**
     * Exception associated with the record
     * @type {*}
     * @private
     */
    this.exception_ = undefined;

    this.reset(
        level || goog.log.Level.OFF, msg, loggerName, time, sequenceNumber);
  };

  /**
   * Sets all fields of the log record.
   * @param {!goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @param {number=} time Time this log record was created if other than
   *     now. If 0, we use #goog.now.
   * @param {number=} sequenceNumber Sequence number of this log record.
   *     This should only be passed in when restoring a log record from
   *     persistence.
   */
  reset(level, msg, loggerName, time, sequenceNumber) {
    this.time_ = time || goog.now();
    this.level_ = level;
    this.msg_ = msg;
    this.loggerName_ = loggerName;
    this.exception_ = undefined;
    this.sequenceNumber_ = typeof sequenceNumber === 'number' ?
        sequenceNumber :
        goog.log.LogRecord.nextSequenceNumber_;
  };


  /**
   * Gets the source Logger's name.
   *
   * @return {string} source logger name (may be null).
   */
  getLoggerName() {
    return this.loggerName_;
  };


  /**
   * Sets the source Logger's name.
   *
   * @param {string} name The logger name.
   */
  setLoggerName(name) {
    this.loggerName_ = name;
  };


  /**
   * Gets the exception that is part of the log record.
   *
   * @return {*} the exception.
   */
  getException() {
    return this.exception_;
  };


  /**
   * Sets the exception that is part of the log record.
   * @param {*} exception the exception.
   */
  setException(exception) {
    this.exception_ = exception;
  };


  /**
   * Gets the logging message level, for example Level.SEVERE.
   * @return {!goog.log.Level} the logging message level.
   */
  getLevel() {
    return this.level_;
  };


  /**
   * Sets the logging message level, for example Level.SEVERE.
   * @param {!goog.log.Level} level the logging message level.
   */
  setLevel(level) {
    this.level_ = level;
  };


  /**
   * Gets the "raw" log message, before localization or formatting.
   * @return {string} the raw message string.
   */
  getMessage() {
    return this.msg_;
  };


  /**
   * Sets the "raw" log message, before localization or formatting.
   *
   * @param {string} msg the raw message string.
   */
  setMessage(msg) {
    this.msg_ = msg;
  };


  /**
   * Gets event time in milliseconds since 1970.
   * @return {number} event time in millis since 1970.
   */
  getMillis() {
    return this.time_;
  };


  /**
   * Sets event time in milliseconds since 1970.
   * @param {number} time event time in millis since 1970.
   */
  setMillis(time) {
    this.time_ = time;
  };


  /**
   * Gets the sequence number. Sequence numbers are normally assigned when a
   * LogRecord is constructed or reset in incrementally increasing order.
   * @return {number}
   */
  getSequenceNumber() {
    return this.sequenceNumber_;
  };
};


/**
 * A sequence counter for assigning increasing sequence numbers to LogRecord
 * objects.
 * @type {number}
 * @private
 */
goog.log.LogRecord.nextSequenceNumber_ = 0;


/**
 * A type that describes a function that handles logs.
 * @typedef {function(!goog.log.LogRecord): ?}
 */
goog.log.LogRecordHandler;


/**
 * A LogRegistryEntry_ contains data about a Logger.
 * @final
 */
goog.log.LogRegistryEntry_ = class LogRegistryEntry_ {
  /**
   * @param {string} name
   * @param {!goog.log.LogRegistryEntry_|null=} parent
   */
  constructor(name, parent = null) {
    /**
     * The minimum log level that a message must be for it to be logged by the
     * Logger corresponding to this LogRegistryEntry_. If null, the parent's
     * log level is used instead.
     * @type {?goog.log.Level}
     */
    this.level = null;

    /**
     * A list of functions that will be called when the Logger corresponding to
     * this LogRegistryEntry_ is used to log a message.
     * @type {!Array<!goog.log.LogRecordHandler>}
     */
    this.handlers = [];

    /**
     * A reference to LogRegistryEntry_ objects that correspond to the direct
     * ancestor of the Logger represented by this LogRegistryEntry_ object
     * (via name, treated as a dot-separated namespace).
     * @type {!goog.log.LogRegistryEntry_|null}
     */
    this.parent = parent || null;

    /**
     * A list of references to LogRegistryEntry_ objects that correspond to the
     * direct descendants of the Logger represented by this LogRegistryEntry_
     * object (via name, treated as a dot-separated namespace).
     * @type {!Array<!goog.log.LogRegistryEntry_>}
     */
    this.children = [];

    /**
     * A reference to the Logger itself.
     * @type {!goog.log.Logger}
     */
    this.logger = /** @type {!goog.log.Logger} */ ({getName: () => name});
  }

  /**
   * Returns the effective level of the logger based on its ancestors' levels.
   * @return {!goog.log.Level} The level.
   */
  getEffectiveLevel() {
    if (this.level) {
      return this.level;
    } else if (this.parent) {
      return this.parent.getEffectiveLevel();
    }
    goog.asserts.fail('Root logger has no level set.');
    return goog.log.Level.OFF;
  };

  /**
   * Calls the log handlers associated with this Logger, followed by those of
   * its parents, etc. until the root Logger's associated log handlers are
   * called.
   * @param {!goog.log.LogRecord} logRecord The log record to pass to each
   *     handler.
   */
  publish(logRecord) {
    let target = this;
    while (target) {
      target.handlers.forEach(handler => {
        handler(logRecord);
      });
      target = target.parent;
    }
  }
};


/**
 * A LogRegistry_ owns references to all loggers, and is responsible for storing
 * all the internal state needed for loggers to operate correctly.
 *
 * @final
 */
goog.log.LogRegistry_ = class LogRegistry_ {
  constructor() {
    /**
     * Per-log information retained by this LogRegistry_.
     * @type {!Object<string, !goog.log.LogRegistryEntry_>}
     */
    this.entries = {};

    // The root logger.
    const rootLogRegistryEntry =
        new goog.log.LogRegistryEntry_(goog.log.ROOT_LOGGER_NAME);
    rootLogRegistryEntry.level = goog.log.Level.CONFIG;
    this.entries[goog.log.ROOT_LOGGER_NAME] = rootLogRegistryEntry;
  }

  /**
   * Gets the LogRegistry_ entry under the given name, creating the entry if one
   * doesn't already exist.
   * @param {string} name The name to look up.
   * @param {?goog.log.Level=} level If provided, override the default logging
   *     level of the returned Logger with the provided level.
   * @return {!goog.log.LogRegistryEntry_}
   */
  getLogRegistryEntry(name, level) {
    const entry = this.entries[name];
    if (entry) {
      if (level !== undefined) {
        entry.level = level;
      }
      return entry;
    } else {
      // The logger and its associated registry entry needs to be created.

      // Get its parent first.
      const lastDotIndex = name.lastIndexOf('.');
      const parentName = name.slice(0, Math.max(lastDotIndex, 0));
      const parentLogRegistryEntry = this.getLogRegistryEntry(parentName);

      // Now create the new entry, linking it with its parent.
      const logRegistryEntry =
          new goog.log.LogRegistryEntry_(name, parentLogRegistryEntry);
      this.entries[name] = logRegistryEntry;
      parentLogRegistryEntry.children.push(logRegistryEntry);

      if (level !== undefined) {
        logRegistryEntry.level = level;
      }

      return logRegistryEntry;
    }
  }

  /**
   * Get a list of all loggers.
   * @return {!Array<!goog.log.Logger>}
   */
  getAllLoggers() {
    return Object.keys(this.entries)
        .map(loggerName => this.entries[loggerName].logger);
  }
};

/**
 * A static method that always returns the same instance of LogRegistry_.
 * @return {!goog.log.LogRegistry_} The LogRegistry_ singleton instance.
 */
goog.log.LogRegistry_.getInstance = function() {
  if (!goog.log.LogRegistry_.instance_) {
    goog.log.LogRegistry_.instance_ = new goog.log.LogRegistry_();
  }
  return /** @type {!goog.log.LogRegistry_} */ (
      goog.log.LogRegistry_.instance_);
};

/**
 * @type {!goog.log.LogRegistry_|undefined}
 * @private
 */
goog.log.LogRegistry_.instance_;


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise, a new logger is
 * created. If a new logger is created, it will be configured to send logging
 * output to its parent's handlers.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 *     name and should normally be based on the package name or class name of
 *     the subsystem, such as goog.net.BrowserChannel.
 * @param {?goog.log.Level=} level If provided, override the default logging
 *     level with the provided level. This parameter is deprecated; prefer using
 *     goog.log.setLevel to set the logger's level instead.
 *     TODO(b/170974948): Delete this parameter.
 * @return {!goog.log.Logger|null} The named logger, or null if logging is
 *     disabled.
 */
goog.log.getLogger = function(name, level) {
  if (goog.log.ENABLED) {
    const loggerEntry =
        goog.log.LogRegistry_.getInstance().getLogRegistryEntry(name, level);
    return loggerEntry.logger;
  } else {
    return null;
  }
};


/**
 * Returns the root logger.
 *
 * @return {!goog.log.Logger|null} The root logger, or null if logging is
 *     disabled.
 */
goog.log.getRootLogger = function() {
  // MOE:begin_strip
  // NOTE: This intentionally doesn't call goog.log.getLogger to prevent
  // ROOT_LOGGER_NAME from getting replaced during compilation, as correct
  // behavior hinges on it remaining an empty string.
  // MOE:end_strip
  if (goog.log.ENABLED) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        goog.log.ROOT_LOGGER_NAME);
    return loggerEntry.logger;
  } else {
    return null;
  }
};


// TODO(johnlenz): try to tighten the types to these functions.
/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecordHandler} handler Handler function to
 *     add.
 */
goog.log.addHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.handlers.push(handler);
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecordHandler} handler Handler function to
 *     remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.log.removeHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    const indexOfHandler = loggerEntry.handlers.indexOf(handler);
    if (indexOfHandler !== -1) {
      loggerEntry.handlers.splice(indexOfHandler, 1);
      return true;
    }
  }
  return false;
};


/**
 * Set the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value goog.log.Level.OFF can be used to turn off logging. If the
 * new level is null, it means that this node should inherit its level from its
 * nearest ancestor with a specific (non-null) level value.
 *
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Level|null} level The new level.
 */
goog.log.setLevel = function(logger, level) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.level = level;
  }
};


/**
 * Gets the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value goog.log.Level.OFF can be used to turn off logging. If the
 * level is null, it means that this node should inherit its level from its
 * nearest ancestor with a specific (non-null) level value.
 *
 * @param {?goog.log.Logger} logger
 * @return {!goog.log.Level|null} The level.
 */
goog.log.getLevel = function(logger) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    return loggerEntry.level;
  }
  return null;
};


/**
 * Returns the effective level of the logger based on its ancestors' levels.
 * @param {?goog.log.Logger} logger
 * @return {!goog.log.Level} The level.
 */
goog.log.getEffectiveLevel = function(logger) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    return loggerEntry.getEffectiveLevel();
  }
  return goog.log.Level.OFF;
};


/**
 * Checks if a message of the given level would actually be logged by this
 * logger. This check is based on the goog.log.Loggers effective level, which
 * may be inherited from its parent.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level The level to check.
 * @return {boolean} Whether the message would be logged.
 */
goog.log.isLoggable = function(logger, level) {
  if (goog.log.ENABLED && logger && level) {
    return level.value >= goog.log.getEffectiveLevel(logger).value;
  }
  return false;
};


/**
 * Gets a list of all loggers.
 * @return {!Array<!goog.log.Logger>}
 */
goog.log.getAllLoggers = function() {
  if (goog.log.ENABLED) {
    return goog.log.LogRegistry_.getInstance().getAllLoggers();
  }
  return [];
};


/**
 * Creates a log record. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(kelvinjin): Delete this method from the public API.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level One of the level identifiers.
 * @param {string} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 * @return {!goog.log.LogRecord}
 */
goog.log.getLogRecord = function(logger, level, msg, exception = undefined) {
  const logRecord = goog.log.LogBuffer.getInstance().addRecord(
      level || goog.log.Level.OFF, msg, logger.getName());
  logRecord.setException(exception);
  return logRecord;
};


/**
 * Logs a goog.log.LogRecord. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(kelvinjin): Delete this method from the public API.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecord} logRecord A log record to log.
 */
goog.log.publishLogRecord = function(logger, logRecord) {
  if (goog.log.ENABLED && logger &&
      goog.log.isLoggable(logger, logRecord.getLevel())) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.publish(logRecord);
  }
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(b/170975192): The level parameter should be made required.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level One of the level identifiers.
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 */
goog.log.log = function(logger, level, msg, exception = undefined) {
  if (goog.log.ENABLED && logger && goog.log.isLoggable(logger, level)) {
    level = level || goog.log.Level.OFF;
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    // Message callbacks can be useful when a log message is expensive to build.
    if (typeof msg === 'function') {
      msg = msg();
    }
    const logRecord = goog.log.LogBuffer.getInstance().addRecord(
        level, msg, logger.getName());
    logRecord.setException(exception);
    // Publish logs.
    loggerEntry.publish(logRecord);
  }
};


/**
 * Logs a message at the goog.log.Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 */
goog.log.error = function(logger, msg, exception = undefined) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.SEVERE, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 */
goog.log.warning = function(logger, msg, exception = undefined) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.WARNING, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 */
goog.log.info = function(logger, msg, exception = undefined) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.INFO, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.FINE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {*=} exception An exception associated with the message.
 */
goog.log.fine = function(logger, msg, exception = undefined) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.FINE, msg, exception);
  }
};

//third_party/javascript/safevalues/dom/elements/svg_use.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/elements/svg_use.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.elements.svg_use');
var module = module || { id: 'third_party/javascript/safevalues/dom/elements/svg_use.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_log_1 = goog.requireType("goog.log");
const tsickle_url_builders_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_dev_3 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
// BEGIN-INTERNAL
const log_1 = goog.require('goog.log');
// END-INTERNAL
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
/**
 * Sets the Href attribute from the given URL.
 * javascript: and data: URL are blocked as they can lead to XSS and the <use>
 * element only loads resources same-origin.
 * @param {!SVGUseElement} useEl
 * @param {string} url
 * @return {void}
 */
function setHref(useEl, url) {
    /** @type {(undefined|string)} */
    const scheme = (0, url_builders_1.extractScheme)(url);
    if (scheme === 'javascript:' || scheme === 'data:') {
        if (dev_1.DEV_MODE) {
            /** @type {string} */
            const msg = `A URL with content '${url}' was sanitized away.`;
            // BEGIN-EXTERNAL
            // console.error(msg);
            // END-EXTERNAL
            // BEGIN-INTERNAL
            (0, log_1.warning)((0, log_1.getLogger)('safevalues'), msg);
            // END-INTERNAL
        }
        return;
    }
    // Note that the href property is read-only, so setAttribute must be used.
    useEl.setAttribute('href', url);
}
exports.setHref = setHref;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnX3VzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZWxlbWVudHMvc3ZnX3VzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSx1Q0FHd0Q7O0FBR3hELHVHQUEwRDtBQUMxRCx3RkFBK0M7Ozs7Ozs7OztBQU8vQyxTQUFnQixPQUFPLENBQUMsS0FBb0IsRUFBRSxHQUFXOztVQUNqRCxNQUFNLEdBQUcsSUFBQSw0QkFBYSxFQUFDLEdBQUcsQ0FBQztJQUNqQyxJQUFJLE1BQU0sS0FBSyxhQUFhLElBQUksTUFBTSxLQUFLLE9BQU8sRUFBRSxDQUFDO1FBQ25ELElBQUksY0FBUSxFQUFFLENBQUM7O2tCQUNQLEdBQUcsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7Ozs7O1lBSzdELElBQUEsYUFBTyxFQUFDLElBQUEsZUFBUyxFQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3RDLGVBQWU7UUFDakIsQ0FBQztRQUNELE9BQU87SUFDVCxDQUFDOztJQUdELEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2xDLENBQUM7QUFqQkQsMEJBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vLyBCRUdJTi1JTlRFUk5BTFxuaW1wb3J0IHtcbiAgZ2V0TG9nZ2VyLFxuICB3YXJuaW5nLFxufSBmcm9tICdnb29nbGUzL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvY2xvc3VyZS9sb2cvbG9nJztcbi8vIEVORC1JTlRFUk5BTFxuXG5pbXBvcnQge2V4dHJhY3RTY2hlbWV9IGZyb20gJy4uLy4uL2J1aWxkZXJzL3VybF9idWlsZGVycyc7XG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudC9kZXYnO1xuXG4vKipcbiAqIFNldHMgdGhlIEhyZWYgYXR0cmlidXRlIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAqIGphdmFzY3JpcHQ6IGFuZCBkYXRhOiBVUkwgYXJlIGJsb2NrZWQgYXMgdGhleSBjYW4gbGVhZCB0byBYU1MgYW5kIHRoZSA8dXNlPlxuICogZWxlbWVudCBvbmx5IGxvYWRzIHJlc291cmNlcyBzYW1lLW9yaWdpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEhyZWYodXNlRWw6IFNWR1VzZUVsZW1lbnQsIHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IHNjaGVtZSA9IGV4dHJhY3RTY2hlbWUodXJsKTtcbiAgaWYgKHNjaGVtZSA9PT0gJ2phdmFzY3JpcHQ6JyB8fCBzY2hlbWUgPT09ICdkYXRhOicpIHtcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBBIFVSTCB3aXRoIGNvbnRlbnQgJyR7dXJsfScgd2FzIHNhbml0aXplZCBhd2F5LmA7XG4gICAgICAvLyBCRUdJTi1FWFRFUk5BTFxuICAgICAgLy8gY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgLy8gRU5ELUVYVEVSTkFMXG4gICAgICAvLyBCRUdJTi1JTlRFUk5BTFxuICAgICAgd2FybmluZyhnZXRMb2dnZXIoJ3NhZmV2YWx1ZXMnKSwgbXNnKTtcbiAgICAgIC8vIEVORC1JTlRFUk5BTFxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgdGhlIGhyZWYgcHJvcGVydHkgaXMgcmVhZC1vbmx5LCBzbyBzZXRBdHRyaWJ1dGUgbXVzdCBiZSB1c2VkLlxuICB1c2VFbC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/document.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/document.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.document');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/document.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_html_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_SafeHtml_2 = goog.requireType("goog.html.SafeHtml");
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
/**
 * write safely calls {\@link Document.write} on the given {\@link Document} with
 * the given {\@link SafeHtml}.
 * @param {!Document} doc
 * @param {!tsickle_SafeHtml_2} text
 * @return {void}
 */
function write(doc, text) {
    doc.write((/** @type {string} */ ((0, html_impl_1.unwrapHtml)(text))));
}
exports.write = write;
/** @typedef {?} */
var ValueType;
/**
 * Safely calls {\@link Document.execCommand}. When command is insertHtml, a
 * SafeHtml must be passed in as value.
 * @template Cmd
 * @param {!Document} doc
 * @param {Cmd} command
 * @param {(undefined|?)=} value
 * @return {boolean}
 */
function execCommand(doc, command, value) {
    /** @type {string} */
    const commandString = String(command);
    /** @type {string} */
    let valueArgument = (/** @type {string} */ (value));
    if (commandString.toLowerCase() === 'inserthtml') {
        valueArgument = (/** @type {string} */ ((0, html_impl_1.unwrapHtml)((/** @type {!tsickle_SafeHtml_2} */ (value)))));
    }
    return doc.execCommand(commandString, /* showUi= */ false, valueArgument);
}
exports.execCommand = execCommand;
/**
 * Safely calls {\@link Document.execCommand}('insertHtml').
 * @deprecated Use safeDocument.execCommand.
 * @param {!Document} doc
 * @param {!tsickle_SafeHtml_2} html
 * @return {boolean}
 */
function execCommandInsertHtml(doc, html) {
    return doc.execCommand('insertHTML', 
    /* showUi= */ false, (/** @type {string} */ ((0, html_impl_1.unwrapHtml)(html))));
}
exports.execCommandInsertHtml = execCommandInsertHtml;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2dsb2JhbHMvZG9jdW1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLGtHQUErRDs7Ozs7Ozs7QUFNL0QsU0FBZ0IsS0FBSyxDQUFDLEdBQWEsRUFBRSxJQUFjO0lBQ2pELEdBQUcsQ0FBQyxLQUFLLENBQUMsd0JBQUEsSUFBQSxzQkFBVSxFQUFDLElBQUksQ0FBQyxFQUFVLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRkQsc0JBRUM7O0FBRUQsY0FFc0I7Ozs7Ozs7Ozs7QUFNdEIsU0FBZ0IsV0FBVyxDQUN6QixHQUFhLEVBQ2IsT0FBWSxFQUNaLEtBQXNCOztVQUVoQixhQUFhLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7UUFDakMsYUFBYSxHQUFHLHdCQUFBLEtBQUssRUFBVTtJQUNuQyxJQUFJLGFBQWEsQ0FBQyxXQUFXLEVBQUUsS0FBSyxZQUFZLEVBQUUsQ0FBQztRQUNqRCxhQUFhLEdBQUcsd0JBQUEsSUFBQSxzQkFBVSxFQUFDLHFDQUFBLEtBQUssRUFBWSxDQUFDLEVBQVUsQ0FBQztJQUMxRCxDQUFDO0lBQ0QsT0FBTyxHQUFHLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxhQUFhLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQzVFLENBQUM7QUFYRCxrQ0FXQzs7Ozs7Ozs7QUFNRCxTQUFnQixxQkFBcUIsQ0FBQyxHQUFhLEVBQUUsSUFBYztJQUNqRSxPQUFPLEdBQUcsQ0FBQyxXQUFXLENBQ3BCLFlBQVk7SUFDWixhQUFhLENBQUMsS0FBSyxFQUNuQix3QkFBQSxJQUFBLHNCQUFVLEVBQUMsSUFBSSxDQUFDLEVBQVUsQ0FDM0IsQ0FBQztBQUNKLENBQUM7QUFORCxzREFNQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtTYWZlSHRtbCwgdW53cmFwSHRtbH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5cbi8qKlxuICogd3JpdGUgc2FmZWx5IGNhbGxzIHtAbGluayBEb2N1bWVudC53cml0ZX0gb24gdGhlIGdpdmVuIHtAbGluayBEb2N1bWVudH0gd2l0aFxuICogdGhlIGdpdmVuIHtAbGluayBTYWZlSHRtbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZShkb2M6IERvY3VtZW50LCB0ZXh0OiBTYWZlSHRtbCkge1xuICBkb2Mud3JpdGUodW53cmFwSHRtbCh0ZXh0KSBhcyBzdHJpbmcpO1xufVxuXG50eXBlIFZhbHVlVHlwZTxDbWQgZXh0ZW5kcyBzdHJpbmc+ID0gTG93ZXJjYXNlPENtZD4gZXh0ZW5kcyAnaW5zZXJ0aHRtbCdcbiAgPyBTYWZlSHRtbFxuICA6IFNhZmVIdG1sIHwgc3RyaW5nO1xuXG4vKipcbiAqIFNhZmVseSBjYWxscyB7QGxpbmsgRG9jdW1lbnQuZXhlY0NvbW1hbmR9LiBXaGVuIGNvbW1hbmQgaXMgaW5zZXJ0SHRtbCwgYVxuICogU2FmZUh0bWwgbXVzdCBiZSBwYXNzZWQgaW4gYXMgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjQ29tbWFuZDxDbWQgZXh0ZW5kcyBzdHJpbmc+KFxuICBkb2M6IERvY3VtZW50LFxuICBjb21tYW5kOiBDbWQsXG4gIHZhbHVlPzogVmFsdWVUeXBlPENtZD4sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgY29tbWFuZFN0cmluZyA9IFN0cmluZyhjb21tYW5kKTtcbiAgbGV0IHZhbHVlQXJndW1lbnQgPSB2YWx1ZSBhcyBzdHJpbmc7XG4gIGlmIChjb21tYW5kU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09ICdpbnNlcnRodG1sJykge1xuICAgIHZhbHVlQXJndW1lbnQgPSB1bndyYXBIdG1sKHZhbHVlIGFzIFNhZmVIdG1sKSBhcyBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIGRvYy5leGVjQ29tbWFuZChjb21tYW5kU3RyaW5nLCAvKiBzaG93VWk9ICovIGZhbHNlLCB2YWx1ZUFyZ3VtZW50KTtcbn1cblxuLyoqXG4gKiBTYWZlbHkgY2FsbHMge0BsaW5rIERvY3VtZW50LmV4ZWNDb21tYW5kfSgnaW5zZXJ0SHRtbCcpLlxuICogQGRlcHJlY2F0ZWQgVXNlIHNhZmVEb2N1bWVudC5leGVjQ29tbWFuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNDb21tYW5kSW5zZXJ0SHRtbChkb2M6IERvY3VtZW50LCBodG1sOiBTYWZlSHRtbCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZG9jLmV4ZWNDb21tYW5kKFxuICAgICdpbnNlcnRIVE1MJyxcbiAgICAvKiBzaG93VWk9ICovIGZhbHNlLFxuICAgIHVud3JhcEh0bWwoaHRtbCkgYXMgc3RyaW5nLFxuICApO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/dom_parser.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/dom_parser.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.dom_parser');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/dom_parser.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_SafeHtml_3 = goog.requireType("goog.html.SafeHtml");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
/**
 * Safely parses a string using the HTML parser.
 * @param {!DOMParser} parser
 * @param {!tsickle_SafeHtml_3} html
 * @return {!HTMLDocument}
 */
function parseHtml(parser, html) {
    return parseFromString(parser, html, 'text/html');
}
exports.parseHtml = parseHtml;
/**
 * Safely parses a string using the XML parser. If the XML document is found to
 * contain any elements from the HTML or SVG namespaces, an error is thrown for
 * security reasons.
 * @param {!DOMParser} parser
 * @param {string} xml
 * @return {!XMLDocument}
 */
function parseXml(parser, xml) {
    /** @type {!Document} */
    const doc = parseFromString(parser, (0, html_impl_1.createHtmlInternal)(xml), 'text/xml');
    /** @type {!NodeIterator} */
    const iterator = document.createNodeIterator(doc, NodeFilter.SHOW_ALL, null, 
    // tslint:disable-next-line:ban-ts-suppressions  // LINE-INTERNAL
    // @ts-ignore: error TS2554: Expected 1-3 arguments, but got 4.
    false);
    /** @type {(null|!Node)} */
    let currentNode;
    while ((currentNode = iterator.nextNode())) {
        if (currentNode instanceof HTMLElement ||
            currentNode instanceof SVGElement) {
            /** @type {string} */
            let message = 'unsafe XML';
            if (dev_1.DEV_MODE) {
                message = `attempted to parse an XML document that embeds HTML or SVG content`;
            }
            throw new Error(message);
        }
    }
    return doc;
}
exports.parseXml = parseXml;
/**
 * Safely parses a string using the HTML or XML parser.
 * @param {!DOMParser} parser
 * @param {!tsickle_SafeHtml_3} content
 * @param {string} contentType
 * @return {!Document}
 */
function parseFromString(parser, content, contentType) {
    return parser.parseFromString((/** @type {string} */ ((0, html_impl_1.unwrapHtml)(content))), contentType);
}
exports.parseFromString = parseFromString;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9tX3BhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9kb20vZ2xvYmFscy9kb21fcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0ZBQStDO0FBQy9DLGtHQUltQzs7Ozs7OztBQUduQyxTQUFnQixTQUFTLENBQUMsTUFBaUIsRUFBRSxJQUFjO0lBQ3pELE9BQU8sZUFBZSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUZELDhCQUVDOzs7Ozs7Ozs7QUFPRCxTQUFnQixRQUFRLENBQUMsTUFBaUIsRUFBRSxHQUFXOztVQUMvQyxHQUFHLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxJQUFBLDhCQUFrQixFQUFDLEdBQUcsQ0FBQyxFQUFFLFVBQVUsQ0FBQzs7VUFFbEUsUUFBUSxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FDMUMsR0FBRyxFQUNILFVBQVUsQ0FBQyxRQUFRLEVBQ25CLElBQUk7SUFDSixpRUFBaUU7SUFDakUsK0RBQStEO0lBQy9ELEtBQUssQ0FDTjs7UUFFRyxXQUF3QjtJQUM1QixPQUFPLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDM0MsSUFDRSxXQUFXLFlBQVksV0FBVztZQUNsQyxXQUFXLFlBQVksVUFBVSxFQUNqQyxDQUFDOztnQkFDRyxPQUFPLEdBQUcsWUFBWTtZQUMxQixJQUFJLGNBQVEsRUFBRSxDQUFDO2dCQUNiLE9BQU8sR0FBRyxvRUFBb0UsQ0FBQztZQUNqRixDQUFDO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQTNCRCw0QkEyQkM7Ozs7Ozs7O0FBR0QsU0FBZ0IsZUFBZSxDQUM3QixNQUFpQixFQUNqQixPQUFpQixFQUNqQixXQUFtQztJQUVuQyxPQUFPLE1BQU0sQ0FBQyxlQUFlLENBQUMsd0JBQUEsSUFBQSxzQkFBVSxFQUFDLE9BQU8sQ0FBQyxFQUFVLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDNUUsQ0FBQztBQU5ELDBDQU1DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudC9kZXYnO1xuaW1wb3J0IHtcbiAgY3JlYXRlSHRtbEludGVybmFsLFxuICBTYWZlSHRtbCxcbiAgdW53cmFwSHRtbCxcbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5cbi8qKiBTYWZlbHkgcGFyc2VzIGEgc3RyaW5nIHVzaW5nIHRoZSBIVE1MIHBhcnNlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUh0bWwocGFyc2VyOiBET01QYXJzZXIsIGh0bWw6IFNhZmVIdG1sKTogSFRNTERvY3VtZW50IHtcbiAgcmV0dXJuIHBhcnNlRnJvbVN0cmluZyhwYXJzZXIsIGh0bWwsICd0ZXh0L2h0bWwnKTtcbn1cblxuLyoqXG4gKiBTYWZlbHkgcGFyc2VzIGEgc3RyaW5nIHVzaW5nIHRoZSBYTUwgcGFyc2VyLiBJZiB0aGUgWE1MIGRvY3VtZW50IGlzIGZvdW5kIHRvXG4gKiBjb250YWluIGFueSBlbGVtZW50cyBmcm9tIHRoZSBIVE1MIG9yIFNWRyBuYW1lc3BhY2VzLCBhbiBlcnJvciBpcyB0aHJvd24gZm9yXG4gKiBzZWN1cml0eSByZWFzb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VYbWwocGFyc2VyOiBET01QYXJzZXIsIHhtbDogc3RyaW5nKTogWE1MRG9jdW1lbnQge1xuICBjb25zdCBkb2MgPSBwYXJzZUZyb21TdHJpbmcocGFyc2VyLCBjcmVhdGVIdG1sSW50ZXJuYWwoeG1sKSwgJ3RleHQveG1sJyk7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3IoXG4gICAgZG9jLFxuICAgIE5vZGVGaWx0ZXIuU0hPV19BTEwsXG4gICAgbnVsbCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuLXRzLXN1cHByZXNzaW9ucyAgLy8gTElORS1JTlRFUk5BTFxuICAgIC8vIEB0cy1pZ25vcmU6IGVycm9yIFRTMjU1NDogRXhwZWN0ZWQgMS0zIGFyZ3VtZW50cywgYnV0IGdvdCA0LlxuICAgIGZhbHNlLCAvLyBUaGlzIGlzIHJlcXVpcmVkIGluIElFIGFuZCBpZ25vcmVkIGluIG90aGVyIGJyb3dzZXJzLlxuICApO1xuXG4gIGxldCBjdXJyZW50Tm9kZTogTm9kZSB8IG51bGw7XG4gIHdoaWxlICgoY3VycmVudE5vZGUgPSBpdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgIGlmIChcbiAgICAgIGN1cnJlbnROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICAgIGN1cnJlbnROb2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudFxuICAgICkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSAndW5zYWZlIFhNTCc7XG4gICAgICBpZiAoREVWX01PREUpIHtcbiAgICAgICAgbWVzc2FnZSA9IGBhdHRlbXB0ZWQgdG8gcGFyc2UgYW4gWE1MIGRvY3VtZW50IHRoYXQgZW1iZWRzIEhUTUwgb3IgU1ZHIGNvbnRlbnRgO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2M7XG59XG5cbi8qKiBTYWZlbHkgcGFyc2VzIGEgc3RyaW5nIHVzaW5nIHRoZSBIVE1MIG9yIFhNTCBwYXJzZXIuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tU3RyaW5nKFxuICBwYXJzZXI6IERPTVBhcnNlcixcbiAgY29udGVudDogU2FmZUh0bWwsXG4gIGNvbnRlbnRUeXBlOiBET01QYXJzZXJTdXBwb3J0ZWRUeXBlLFxuKTogRG9jdW1lbnQge1xuICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bndyYXBIdG1sKGNvbnRlbnQpIGFzIHN0cmluZywgY29udGVudFR5cGUpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/fetch.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview
 * Functions which allow fetch() on resourceUrls to be
 * interpreted as SafeHtml or SafeScript.
 * Generated from: third_party/javascript/safevalues/dom/globals/fetch.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.fetch');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/fetch.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_html_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_resource_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_script_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_style_sheet_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_sheet_impl");
const tsickle_SafeHtml_5 = goog.requireType("goog.html.SafeHtml");
const tsickle_SafeStyleSheet_6 = goog.requireType("goog.html.SafeStyleSheet");
const tsickle_TrustedResourceUrl_7 = goog.requireType("goog.html.TrustedResourceUrl");
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const style_sheet_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_sheet_impl');
/**
 * IncorrectTypeError represents an error that can occur with {\@link
 * fetchResourceUrl} when the server responds with a content type that would be
 * unsafe for the type of content requested.
 * @extends {Error}
 */
class IncorrectContentTypeError extends Error {
    /**
     * @public
     * @param {string} url
     * @param {string} typeName
     * @param {string} contentType
     */
    constructor(url, typeName, contentType) {
        super(`${url} was requested as a ${typeName}, but the response Content-Type, "${contentType} is not appropriate for this type of content.`);
        this.url = url;
        this.typeName = typeName;
        this.contentType = contentType;
    }
}
exports.IncorrectContentTypeError = IncorrectContentTypeError;
/* istanbul ignore if */
if (false) {
    /**
     * @const {string}
     * @public
     */
    IncorrectContentTypeError.prototype.url;
    /**
     * @const {string}
     * @public
     */
    IncorrectContentTypeError.prototype.typeName;
    /**
     * @const {string}
     * @public
     */
    IncorrectContentTypeError.prototype.contentType;
}
/**
 * A SafeResponse is the response value of a {\@link fetchResourceUrl} call.
 * @record
 */
function SafeResponse() { }
exports.SafeResponse = SafeResponse;
/* istanbul ignore if */
if (false) {
    /**
     * html returns this {\@link Response} as a SafeHtml, or throws an error.
     * @public
     * @return {!Promise<!tsickle_SafeHtml_5>}
     */
    SafeResponse.prototype.html = function () { };
    /**
     * script returns the fetch response as a {\@link SafeScript}, or returns an
     * error.
     * @public
     * @return {!Promise<!tsickle_script_impl_3.SafeScript>}
     */
    SafeResponse.prototype.script = function () { };
    /**
     * styleSheet returns the fetch response as a {\@link SafeStyleSheet}, or
     * returns an error.
     * @public
     * @return {!Promise<!tsickle_SafeStyleSheet_6>}
     */
    SafeResponse.prototype.styleSheet = function () { };
}
/**
 * This causes the compiler to better optimize `createHtmlInternal` calls, where
 * previously it was building and including the whole module without
 * tree-shaking.
 *
 * TODO(b/254093954) find out why this is and remove this workaround.
 * @param {string} html
 * @return {!tsickle_SafeHtml_5}
 */
function privatecreateHtmlInternal(html) {
    return (0, html_impl_1.createHtmlInternal)(html);
}
/**
 * fetches a given {\@link TrustedResourceUrl},
 * and returns a value which can be turned into a given safe type.
 * @param {!tsickle_TrustedResourceUrl_7} u
 * @param {(undefined|!RequestInit)=} init
 * @return {!Promise<!SafeResponse>}
 */
async function fetchResourceUrl(u, init) {
    /** @type {!Response} */
    const response = await fetch((0, resource_url_impl_1.unwrapResourceUrl)(u).toString(), init);
    /**
     * the content type type of the response, excluding any MIME params
     * @type {(undefined|string)}
     */
    const mimeType = response.headers
        .get('Content-Type')
        ?.split(';', 2)?.[0]
        ?.toLowerCase();
    return {
        /**
         * @public
         * @return {!Promise<!tsickle_SafeHtml_5>}
         */
        async html() {
            if (mimeType !== 'text/html') {
                throw new IncorrectContentTypeError(response.url, 'SafeHtml', 'text/html');
            }
            /** @type {string} */
            const text = await response.text();
            return privatecreateHtmlInternal(text);
        },
        /**
         * @public
         * @return {!Promise<!tsickle_script_impl_3.SafeScript>}
         */
        async script() {
            // see:
            // https://html.spec.whatwg.org/multipage/scripting.html#scriptingLanguages
            if (mimeType !== 'text/javascript' &&
                mimeType !== 'application/javascript') {
                throw new IncorrectContentTypeError(response.url, 'SafeScript', 'text/javascript');
            }
            /** @type {string} */
            const text = await response.text();
            return (0, script_impl_1.createScriptInternal)(text);
        },
        /**
         * @public
         * @return {!Promise<!tsickle_SafeStyleSheet_6>}
         */
        async styleSheet() {
            if (mimeType !== 'text/css') {
                throw new IncorrectContentTypeError(response.url, 'SafeStyleSheet', 'text/css');
            }
            /** @type {string} */
            const text = await response.text();
            return (0, style_sheet_impl_1.createStyleSheetInternal)(text);
        },
    };
}
exports.fetchResourceUrl = fetchResourceUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmV0Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2dsb2JhbHMvZmV0Y2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXQSxrR0FBdUU7QUFDdkUsa0hBRzJDO0FBQzNDLHNHQUE2RTtBQUM3RSxnSEFHMEM7Ozs7Ozs7QUFPMUMsTUFBYSx5QkFBMEIsU0FBUSxLQUFLOzs7Ozs7O0lBQ2xELFlBQ1csR0FBVyxFQUNYLFFBQWdCLEVBQ2hCLFdBQW1CO1FBRTVCLEtBQUssQ0FDSCxHQUFHLEdBQUcsdUJBQXVCLFFBQVEscUNBQXFDLFdBQVcsK0NBQStDLENBQ3JJLENBQUM7UUFOTyxRQUFHLEdBQUgsR0FBRyxDQUFRO1FBQ1gsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUNoQixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtJQUs5QixDQUFDO0NBQ0Y7QUFWRCw4REFVQzs7Ozs7OztJQVJHLHdDQUFvQjs7Ozs7SUFDcEIsNkNBQXlCOzs7OztJQUN6QixnREFBNEI7Ozs7OztBQVdoQywyQkFpQkM7Ozs7Ozs7OztJQWJDLDhDQUEwQjs7Ozs7OztJQU0xQixnREFBOEI7Ozs7Ozs7SUFNOUIsb0RBQXNDOzs7Ozs7Ozs7OztBQVV4QyxTQUFTLHlCQUF5QixDQUFDLElBQVk7SUFDN0MsT0FBTyxJQUFBLDhCQUFrQixFQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xDLENBQUM7Ozs7Ozs7O0FBTU0sS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxDQUFxQixFQUNyQixJQUFrQjs7VUFFWixRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsSUFBQSxxQ0FBaUIsRUFBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUM7Ozs7O1VBSTdELFFBQVEsR0FBRyxRQUFRLENBQUMsT0FBTztTQUM5QixHQUFHLENBQUMsY0FBYyxDQUFDO1FBQ3BCLEVBQUUsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixFQUFFLFdBQVcsRUFBRTtJQUVqQixPQUFPOzs7OztRQUNMLEtBQUssQ0FBQyxJQUFJO1lBQ1IsSUFBSSxRQUFRLEtBQUssV0FBVyxFQUFFLENBQUM7Z0JBQzdCLE1BQU0sSUFBSSx5QkFBeUIsQ0FDakMsUUFBUSxDQUFDLEdBQUcsRUFDWixVQUFVLEVBQ1YsV0FBVyxDQUNaLENBQUM7WUFDSixDQUFDOztrQkFFSyxJQUFJLEdBQUcsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFO1lBQ2xDLE9BQU8seUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsQ0FBQzs7Ozs7UUFFRCxLQUFLLENBQUMsTUFBTTtZQUNWLE9BQU87WUFDUCwyRUFBMkU7WUFDM0UsSUFDRSxRQUFRLEtBQUssaUJBQWlCO2dCQUM5QixRQUFRLEtBQUssd0JBQXdCLEVBQ3JDLENBQUM7Z0JBQ0QsTUFBTSxJQUFJLHlCQUF5QixDQUNqQyxRQUFRLENBQUMsR0FBRyxFQUNaLFlBQVksRUFDWixpQkFBaUIsQ0FDbEIsQ0FBQztZQUNKLENBQUM7O2tCQUVLLElBQUksR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDbEMsT0FBTyxJQUFBLGtDQUFvQixFQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLENBQUM7Ozs7O1FBRUQsS0FBSyxDQUFDLFVBQVU7WUFDZCxJQUFJLFFBQVEsS0FBSyxVQUFVLEVBQUUsQ0FBQztnQkFDNUIsTUFBTSxJQUFJLHlCQUF5QixDQUNqQyxRQUFRLENBQUMsR0FBRyxFQUNaLGdCQUFnQixFQUNoQixVQUFVLENBQ1gsQ0FBQztZQUNKLENBQUM7O2tCQUVLLElBQUksR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDbEMsT0FBTyxJQUFBLDJDQUF3QixFQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQztBQTFERCw0Q0EwREMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogRnVuY3Rpb25zIHdoaWNoIGFsbG93IGZldGNoKCkgb24gcmVzb3VyY2VVcmxzIHRvIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBTYWZlSHRtbCBvciBTYWZlU2NyaXB0LlxuICovXG5cbmltcG9ydCB7Y3JlYXRlSHRtbEludGVybmFsLCBTYWZlSHRtbH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5pbXBvcnQge1xuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuaW1wb3J0IHtjcmVhdGVTY3JpcHRJbnRlcm5hbCwgU2FmZVNjcmlwdH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3NjcmlwdF9pbXBsJztcbmltcG9ydCB7XG4gIGNyZWF0ZVN0eWxlU2hlZXRJbnRlcm5hbCxcbiAgU2FmZVN0eWxlU2hlZXQsXG59IGZyb20gJy4uLy4uL2ludGVybmFscy9zdHlsZV9zaGVldF9pbXBsJztcblxuLyoqXG4gKiBJbmNvcnJlY3RUeXBlRXJyb3IgcmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IGNhbiBvY2N1ciB3aXRoIHtAbGlua1xuICogZmV0Y2hSZXNvdXJjZVVybH0gd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYSBjb250ZW50IHR5cGUgdGhhdCB3b3VsZCBiZVxuICogdW5zYWZlIGZvciB0aGUgdHlwZSBvZiBjb250ZW50IHJlcXVlc3RlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEluY29ycmVjdENvbnRlbnRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IHVybDogc3RyaW5nLFxuICAgIHJlYWRvbmx5IHR5cGVOYW1lOiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgY29udGVudFR5cGU6IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBgJHt1cmx9IHdhcyByZXF1ZXN0ZWQgYXMgYSAke3R5cGVOYW1lfSwgYnV0IHRoZSByZXNwb25zZSBDb250ZW50LVR5cGUsIFwiJHtjb250ZW50VHlwZX0gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIHR5cGUgb2YgY29udGVudC5gLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFNhZmVSZXNwb25zZSBpcyB0aGUgcmVzcG9uc2UgdmFsdWUgb2YgYSB7QGxpbmsgZmV0Y2hSZXNvdXJjZVVybH0gY2FsbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTYWZlUmVzcG9uc2Uge1xuICAvKipcbiAgICogaHRtbCByZXR1cm5zIHRoaXMge0BsaW5rIFJlc3BvbnNlfSBhcyBhIFNhZmVIdG1sLCBvciB0aHJvd3MgYW4gZXJyb3IuXG4gICAqL1xuICBodG1sKCk6IFByb21pc2U8U2FmZUh0bWw+O1xuXG4gIC8qKlxuICAgKiBzY3JpcHQgcmV0dXJucyB0aGUgZmV0Y2ggcmVzcG9uc2UgYXMgYSB7QGxpbmsgU2FmZVNjcmlwdH0sIG9yIHJldHVybnMgYW5cbiAgICogZXJyb3IuXG4gICAqL1xuICBzY3JpcHQoKTogUHJvbWlzZTxTYWZlU2NyaXB0PjtcblxuICAvKipcbiAgICogc3R5bGVTaGVldCByZXR1cm5zIHRoZSBmZXRjaCByZXNwb25zZSBhcyBhIHtAbGluayBTYWZlU3R5bGVTaGVldH0sIG9yXG4gICAqIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBzdHlsZVNoZWV0KCk6IFByb21pc2U8U2FmZVN0eWxlU2hlZXQ+O1xufVxuXG4vKipcbiAqIFRoaXMgY2F1c2VzIHRoZSBjb21waWxlciB0byBiZXR0ZXIgb3B0aW1pemUgYGNyZWF0ZUh0bWxJbnRlcm5hbGAgY2FsbHMsIHdoZXJlXG4gKiBwcmV2aW91c2x5IGl0IHdhcyBidWlsZGluZyBhbmQgaW5jbHVkaW5nIHRoZSB3aG9sZSBtb2R1bGUgd2l0aG91dFxuICogdHJlZS1zaGFraW5nLlxuICpcbiAqIFRPRE8oYi8yNTQwOTM5NTQpIGZpbmQgb3V0IHdoeSB0aGlzIGlzIGFuZCByZW1vdmUgdGhpcyB3b3JrYXJvdW5kLlxuICovXG5mdW5jdGlvbiBwcml2YXRlY3JlYXRlSHRtbEludGVybmFsKGh0bWw6IHN0cmluZyk6IFNhZmVIdG1sIHtcbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChodG1sKTtcbn1cblxuLyoqXG4gKiBmZXRjaGVzIGEgZ2l2ZW4ge0BsaW5rIFRydXN0ZWRSZXNvdXJjZVVybH0sXG4gKiBhbmQgcmV0dXJucyBhIHZhbHVlIHdoaWNoIGNhbiBiZSB0dXJuZWQgaW50byBhIGdpdmVuIHNhZmUgdHlwZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUmVzb3VyY2VVcmwoXG4gIHU6IFRydXN0ZWRSZXNvdXJjZVVybCxcbiAgaW5pdD86IFJlcXVlc3RJbml0LFxuKTogUHJvbWlzZTxTYWZlUmVzcG9uc2U+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1bndyYXBSZXNvdXJjZVVybCh1KS50b1N0cmluZygpLCBpbml0KTtcbiAgLyoqXG4gICAqIHRoZSBjb250ZW50IHR5cGUgdHlwZSBvZiB0aGUgcmVzcG9uc2UsIGV4Y2x1ZGluZyBhbnkgTUlNRSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IG1pbWVUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1xuICAgIC5nZXQoJ0NvbnRlbnQtVHlwZScpXG4gICAgPy5zcGxpdCgnOycsIDIpPy5bMF1cbiAgICA/LnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBhc3luYyBodG1sKCk6IFByb21pc2U8U2FmZUh0bWw+IHtcbiAgICAgIGlmIChtaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEluY29ycmVjdENvbnRlbnRUeXBlRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2UudXJsLFxuICAgICAgICAgICdTYWZlSHRtbCcsXG4gICAgICAgICAgJ3RleHQvaHRtbCcsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gcHJpdmF0ZWNyZWF0ZUh0bWxJbnRlcm5hbCh0ZXh0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgc2NyaXB0KCk6IFByb21pc2U8U2FmZVNjcmlwdD4ge1xuICAgICAgLy8gc2VlOlxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2NyaXB0aW5nTGFuZ3VhZ2VzXG4gICAgICBpZiAoXG4gICAgICAgIG1pbWVUeXBlICE9PSAndGV4dC9qYXZhc2NyaXB0JyAmJlxuICAgICAgICBtaW1lVHlwZSAhPT0gJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEluY29ycmVjdENvbnRlbnRUeXBlRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2UudXJsLFxuICAgICAgICAgICdTYWZlU2NyaXB0JyxcbiAgICAgICAgICAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiBjcmVhdGVTY3JpcHRJbnRlcm5hbCh0ZXh0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgc3R5bGVTaGVldCgpOiBQcm9taXNlPFNhZmVTdHlsZVNoZWV0PiB7XG4gICAgICBpZiAobWltZVR5cGUgIT09ICd0ZXh0L2NzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEluY29ycmVjdENvbnRlbnRUeXBlRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2UudXJsLFxuICAgICAgICAgICdTYWZlU3R5bGVTaGVldCcsXG4gICAgICAgICAgJ3RleHQvY3NzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiBjcmVhdGVTdHlsZVNoZWV0SW50ZXJuYWwodGV4dCk7XG4gICAgfSxcbiAgfTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/globals/global.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/global.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.global');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/global.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_script_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_fetch_2 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.fetch");
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const fetch_1 = goog.require('google3.third_party.javascript.safevalues.dom.globals.fetch');
exports.fetchResourceUrl = fetch_1.fetchResourceUrl;
/** @typedef {!tsickle_fetch_2.SafeResponse} */
exports.SafeResponse; // re-export typedef
/**
 * Evaluates a SafeScript value in the given scope using eval.
 *
 * Strongly consider avoiding this, as eval blocks CSP adoption and does not
 * benefit from compiler optimizations.
 * @param {(?|!Window)} win
 * @param {!tsickle_script_impl_1.SafeScript} script
 * @return {*}
 */
function globalEval(win, script) {
    /** @type {(string|!TrustedScript)} */
    const trustedScript = (0, script_impl_1.unwrapScript)(script);
    /** @type {?} */
    let result = ((/** @type {?} */ (win))).eval((/** @type {string} */ (trustedScript)));
    if (result === trustedScript) {
        // https://crbug.com/1024786 manifesting in workers.
        result = ((/** @type {?} */ (win))).eval(trustedScript.toString());
    }
    return result;
}
exports.globalEval = globalEval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xvYmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9nbG9iYWxzL2dsb2JhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esc0dBQXFFO0FBRXJFLDRGQUE0RDtBQUFwRCxtQ0FBQSxnQkFBZ0IsQ0FBQTs7Ozs7Ozs7Ozs7O0FBUXhCLFNBQWdCLFVBQVUsQ0FDeEIsR0FBK0IsRUFDL0IsTUFBa0I7O1VBRVosYUFBYSxHQUFHLElBQUEsMEJBQVksRUFBQyxNQUFNLENBQUM7O1FBQ3RDLE1BQU0sR0FBRyxDQUFDLG1CQUFBLEdBQUcsRUFBcUIsQ0FBQyxDQUFDLElBQUksQ0FBQyx3QkFBQSxhQUFhLEVBQVUsQ0FBQztJQUNyRSxJQUFJLE1BQU0sS0FBSyxhQUFhLEVBQUUsQ0FBQzs7UUFFN0IsTUFBTSxHQUFHLENBQUMsbUJBQUEsR0FBRyxFQUFxQixDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBWEQsZ0NBV0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7U2FmZVNjcmlwdCwgdW53cmFwU2NyaXB0fSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvc2NyaXB0X2ltcGwnO1xuXG5leHBvcnQge2ZldGNoUmVzb3VyY2VVcmwsIHR5cGUgU2FmZVJlc3BvbnNlfSBmcm9tICcuL2ZldGNoJztcblxuLyoqXG4gKiBFdmFsdWF0ZXMgYSBTYWZlU2NyaXB0IHZhbHVlIGluIHRoZSBnaXZlbiBzY29wZSB1c2luZyBldmFsLlxuICpcbiAqIFN0cm9uZ2x5IGNvbnNpZGVyIGF2b2lkaW5nIHRoaXMsIGFzIGV2YWwgYmxvY2tzIENTUCBhZG9wdGlvbiBhbmQgZG9lcyBub3RcbiAqIGJlbmVmaXQgZnJvbSBjb21waWxlciBvcHRpbWl6YXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2xvYmFsRXZhbChcbiAgd2luOiBXaW5kb3cgfCB0eXBlb2YgZ2xvYmFsVGhpcyxcbiAgc2NyaXB0OiBTYWZlU2NyaXB0LFxuKTogdW5rbm93biB7XG4gIGNvbnN0IHRydXN0ZWRTY3JpcHQgPSB1bndyYXBTY3JpcHQoc2NyaXB0KTtcbiAgbGV0IHJlc3VsdCA9ICh3aW4gYXMgdHlwZW9mIGdsb2JhbFRoaXMpLmV2YWwodHJ1c3RlZFNjcmlwdCBhcyBzdHJpbmcpO1xuICBpZiAocmVzdWx0ID09PSB0cnVzdGVkU2NyaXB0KSB7XG4gICAgLy8gaHR0cHM6Ly9jcmJ1Zy5jb20vMTAyNDc4NiBtYW5pZmVzdGluZyBpbiB3b3JrZXJzLlxuICAgIHJlc3VsdCA9ICh3aW4gYXMgdHlwZW9mIGdsb2JhbFRoaXMpLmV2YWwodHJ1c3RlZFNjcmlwdC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/location.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/location.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.location');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/location.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
/**
 * setHref safely sets {\@link Location.href} on the given {\@link Location} with
 * given {\@link Url}.
 * @param {!Location} loc
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function setHref(loc, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        loc.href = sanitizedUrl;
    }
}
exports.setHref = setHref;
/**
 * replace safely calls {\@link Location.replace} on the given {\@link Location}
 * with given {\@link Url}.
 * @param {!Location} loc
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function replace(loc, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        loc.replace(sanitizedUrl);
    }
}
exports.replace = replace;
/**
 * assign safely calls {\@link Location.assign} on the given {\@link Location}
 * with given {\@link Url}.
 * @param {!Location} loc
 * @param {(string|!tsickle_url_impl_2.SafeUrl)} url
 * @return {void}
 */
function assign(loc, url) {
    /** @type {(undefined|string)} */
    const sanitizedUrl = (0, url_builders_1.unwrapUrlOrSanitize)(url);
    if (sanitizedUrl !== undefined) {
        loc.assign(sanitizedUrl);
    }
}
exports.assign = assign;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2dsb2JhbHMvbG9jYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHVHQUFxRTs7Ozs7Ozs7QUFNckUsU0FBZ0IsT0FBTyxDQUFDLEdBQWEsRUFBRSxHQUFROztVQUN2QyxZQUFZLEdBQUcsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUM7SUFDN0MsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDL0IsR0FBRyxDQUFDLElBQUksR0FBRyxZQUFZLENBQUM7SUFDMUIsQ0FBQztBQUNILENBQUM7QUFMRCwwQkFLQzs7Ozs7Ozs7QUFNRCxTQUFnQixPQUFPLENBQUMsR0FBYSxFQUFFLEdBQVE7O1VBQ3ZDLFlBQVksR0FBRyxJQUFBLGtDQUFtQixFQUFDLEdBQUcsQ0FBQztJQUM3QyxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUMvQixHQUFHLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzVCLENBQUM7QUFDSCxDQUFDO0FBTEQsMEJBS0M7Ozs7Ozs7O0FBTUQsU0FBZ0IsTUFBTSxDQUFDLEdBQWEsRUFBRSxHQUFROztVQUN0QyxZQUFZLEdBQUcsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUM7SUFDN0MsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDL0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMzQixDQUFDO0FBQ0gsQ0FBQztBQUxELHdCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge3Vud3JhcFVybE9yU2FuaXRpemUsIFVybH0gZnJvbSAnLi4vLi4vYnVpbGRlcnMvdXJsX2J1aWxkZXJzJztcblxuLyoqXG4gKiBzZXRIcmVmIHNhZmVseSBzZXRzIHtAbGluayBMb2NhdGlvbi5ocmVmfSBvbiB0aGUgZ2l2ZW4ge0BsaW5rIExvY2F0aW9ufSB3aXRoXG4gKiBnaXZlbiB7QGxpbmsgVXJsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEhyZWYobG9jOiBMb2NhdGlvbiwgdXJsOiBVcmwpIHtcbiAgY29uc3Qgc2FuaXRpemVkVXJsID0gdW53cmFwVXJsT3JTYW5pdGl6ZSh1cmwpO1xuICBpZiAoc2FuaXRpemVkVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICBsb2MuaHJlZiA9IHNhbml0aXplZFVybDtcbiAgfVxufVxuXG4vKipcbiAqIHJlcGxhY2Ugc2FmZWx5IGNhbGxzIHtAbGluayBMb2NhdGlvbi5yZXBsYWNlfSBvbiB0aGUgZ2l2ZW4ge0BsaW5rIExvY2F0aW9ufVxuICogd2l0aCBnaXZlbiB7QGxpbmsgVXJsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2UobG9jOiBMb2NhdGlvbiwgdXJsOiBVcmwpIHtcbiAgY29uc3Qgc2FuaXRpemVkVXJsID0gdW53cmFwVXJsT3JTYW5pdGl6ZSh1cmwpO1xuICBpZiAoc2FuaXRpemVkVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICBsb2MucmVwbGFjZShzYW5pdGl6ZWRVcmwpO1xuICB9XG59XG5cbi8qKlxuICogYXNzaWduIHNhZmVseSBjYWxscyB7QGxpbmsgTG9jYXRpb24uYXNzaWdufSBvbiB0aGUgZ2l2ZW4ge0BsaW5rIExvY2F0aW9ufVxuICogd2l0aCBnaXZlbiB7QGxpbmsgVXJsfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihsb2M6IExvY2F0aW9uLCB1cmw6IFVybCkge1xuICBjb25zdCBzYW5pdGl6ZWRVcmwgPSB1bndyYXBVcmxPclNhbml0aXplKHVybCk7XG4gIGlmIChzYW5pdGl6ZWRVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgIGxvYy5hc3NpZ24oc2FuaXRpemVkVXJsKTtcbiAgfVxufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/globals/range.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/range.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.range');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/range.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_html_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_SafeHtml_2 = goog.requireType("goog.html.SafeHtml");
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
/**
 * Safely creates a contextualFragment.
 * @param {!Range} range
 * @param {!tsickle_SafeHtml_2} html
 * @return {!DocumentFragment}
 */
function createContextualFragment(range, html) {
    return range.createContextualFragment((/** @type {string} */ ((0, html_impl_1.unwrapHtml)(html))));
}
exports.createContextualFragment = createContextualFragment;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2dsb2JhbHMvcmFuZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLGtHQUErRDs7Ozs7OztBQUcvRCxTQUFnQix3QkFBd0IsQ0FDdEMsS0FBWSxFQUNaLElBQWM7SUFFZCxPQUFPLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBQSxJQUFBLHNCQUFVLEVBQUMsSUFBSSxDQUFDLEVBQVUsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFMRCw0REFLQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtTYWZlSHRtbCwgdW53cmFwSHRtbH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5cbi8qKiBTYWZlbHkgY3JlYXRlcyBhIGNvbnRleHR1YWxGcmFnbWVudC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoXG4gIHJhbmdlOiBSYW5nZSxcbiAgaHRtbDogU2FmZUh0bWwsXG4pOiBEb2N1bWVudEZyYWdtZW50IHtcbiAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh1bndyYXBIdG1sKGh0bWwpIGFzIHN0cmluZyk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/globals/service_worker_container.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/service_worker_container.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.service_worker_container');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/service_worker_container.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_2 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/**
 * Safely registers a service worker by URL
 * @param {!ServiceWorkerContainer} container
 * @param {!tsickle_TrustedResourceUrl_2} scriptURL
 * @param {(undefined|!RegistrationOptions)=} options
 * @return {!Promise<!ServiceWorkerRegistration>}
 */
function register(container, scriptURL, options) {
    return container.register((/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(scriptURL))), options);
}
exports.register = register;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZV93b3JrZXJfY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9nbG9iYWxzL3NlcnZpY2Vfd29ya2VyX2NvbnRhaW5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esa0hBRzJDOzs7Ozs7OztBQUczQyxTQUFnQixRQUFRLENBQ3RCLFNBQWlDLEVBQ2pDLFNBQTZCLEVBQzdCLE9BQTZCO0lBRTdCLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyx3QkFBQSxJQUFBLHFDQUFpQixFQUFDLFNBQVMsQ0FBQyxFQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDN0UsQ0FBQztBQU5ELDRCQU1DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge1xuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuXG4vKiogU2FmZWx5IHJlZ2lzdGVycyBhIHNlcnZpY2Ugd29ya2VyIGJ5IFVSTCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKFxuICBjb250YWluZXI6IFNlcnZpY2VXb3JrZXJDb250YWluZXIsXG4gIHNjcmlwdFVSTDogVHJ1c3RlZFJlc291cmNlVXJsLFxuICBvcHRpb25zPzogUmVnaXN0cmF0aW9uT3B0aW9ucyxcbik6IFByb21pc2U8U2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbj4ge1xuICByZXR1cm4gY29udGFpbmVyLnJlZ2lzdGVyKHVud3JhcFJlc291cmNlVXJsKHNjcmlwdFVSTCkgYXMgc3RyaW5nLCBvcHRpb25zKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/dom/globals/url.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/url.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.url');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/url.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_url_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders'); // LINE-INTERNAL
// LINE-INTERNAL
// BEGIN-EXTERNAL
// /**
//  * A pattern that matches safe MIME types. Only matches image, video and audio
//  * types, with some parameter support (most notably, we haven't implemented the
//  * more complex parts like %-encoded characters or non-alphanumerical ones for
//  * simplicity's sake). Also, the specs are fairly complex, and they don't
//  * necessarily agree with Chrome on some aspects, and so we settled on a subset
//  * where the behavior makes sense to all parties involved.
//  *
//  * The spec is available at https://mimesniff.spec.whatwg.org/ (and see
//  * https://tools.ietf.org/html/rfc2397 for data: urls, which override some of
//  * it).
//  */
//  function isSafeMimeType(mimeType: string): boolean {
//   const match = mimeType.match(/^([^;]+)(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i);
//   return match?.length === 2 &&
//       (isSafeImageMimeType(match[1]) || isSafeVideoMimeType(match[1]) ||
//        isSafeAudioMimeType(match[1]));
// }
//
// function isSafeImageMimeType(mimeType: string): boolean {
//   return /^image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon|heic|heif)$/i.test(
//       mimeType);
// }
//
// function isSafeVideoMimeType(mimeType: string): boolean {
//   return /^video\/(?:mpeg|mp4|ogg|webm|x-matroska|quicktime|x-ms-wmv)$/i.test(
//       mimeType);
// }
//
// function isSafeAudioMimeType(mimeType: string): boolean {
//   return /^audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)$/i
//       .test(mimeType);
// }
// END-EXTERNAL
/**
 * Wraps URL.createObjectURL, checking the safety of the source. For blobs, the
 * function validates that the Blob's type is amongst the safe MIME types, and
 * throws if that's not the case. URL.revokeObjectURL should be called on the
 * returned URL to free the resources.
 * @param {(!Blob|!MediaSource)} source
 * @return {string}
 */
function objectUrlFromSafeSource(source) {
    // BEGIN-INTERNAL
    return (0, url_builders_1.objectUrlFromSafeSource)(source).toString();
    // END-INTERNAL
    // BEGIN-EXTERNAL
    // // MediaSource support in Safari is limited
    // // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource#browser_compatibility
    // if (typeof MediaSource !== 'undefined' && source instanceof MediaSource) {
    //   return URL.createObjectURL(source);
    // }
    // const blob = source as Blob;
    // if (!isSafeMimeType(blob.type)) {
    //   let message = '';
    //   if (DEV_MODE) {
    //     message = `unsafe blob MIME type: ${blob.type}`;
    //   }
    //   throw new Error(message);
    // }
    // return URL.createObjectURL(blob);
    // END-EXTERNAL
}
exports.objectUrlFromSafeSource = objectUrlFromSafeSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9nbG9iYWxzL3VybC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx1R0FBc0csQ0FBQyxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDdkgsU0FBZ0IsdUJBQXVCLENBQUMsTUFBMEI7SUFDaEUsaUJBQWlCO0lBQ2pCLE9BQU8sSUFBQSxzQ0FBOEIsRUFBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6RCxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLDhDQUE4QztJQUM5Qyx3RkFBd0Y7SUFDeEYsNkVBQTZFO0lBQzdFLHdDQUF3QztJQUN4QyxJQUFJO0lBQ0osK0JBQStCO0lBQy9CLG9DQUFvQztJQUNwQyxzQkFBc0I7SUFDdEIsb0JBQW9CO0lBQ3BCLHVEQUF1RDtJQUN2RCxNQUFNO0lBQ04sOEJBQThCO0lBQzlCLElBQUk7SUFDSixvQ0FBb0M7SUFDcEMsZUFBZTtBQUNqQixDQUFDO0FBcEJELDBEQW9CQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtvYmplY3RVcmxGcm9tU2FmZVNvdXJjZSBhcyBvYmplY3RVcmxGcm9tU2FmZVNvdXJjZUJ1aWxkZXJ9IGZyb20gJy4uLy4uL2J1aWxkZXJzL3VybF9idWlsZGVycyc7IC8vIExJTkUtSU5URVJOQUxcblxuLy8gQkVHSU4tRVhURVJOQUxcbi8vIC8qKlxuLy8gICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIE1JTUUgdHlwZXMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvXG4vLyAgKiB0eXBlcywgd2l0aCBzb21lIHBhcmFtZXRlciBzdXBwb3J0IChtb3N0IG5vdGFibHksIHdlIGhhdmVuJ3QgaW1wbGVtZW50ZWQgdGhlXG4vLyAgKiBtb3JlIGNvbXBsZXggcGFydHMgbGlrZSAlLWVuY29kZWQgY2hhcmFjdGVycyBvciBub24tYWxwaGFudW1lcmljYWwgb25lcyBmb3Jcbi8vICAqIHNpbXBsaWNpdHkncyBzYWtlKS4gQWxzbywgdGhlIHNwZWNzIGFyZSBmYWlybHkgY29tcGxleCwgYW5kIHRoZXkgZG9uJ3Rcbi8vICAqIG5lY2Vzc2FyaWx5IGFncmVlIHdpdGggQ2hyb21lIG9uIHNvbWUgYXNwZWN0cywgYW5kIHNvIHdlIHNldHRsZWQgb24gYSBzdWJzZXRcbi8vICAqIHdoZXJlIHRoZSBiZWhhdmlvciBtYWtlcyBzZW5zZSB0byBhbGwgcGFydGllcyBpbnZvbHZlZC5cbi8vICAqXG4vLyAgKiBUaGUgc3BlYyBpcyBhdmFpbGFibGUgYXQgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyAoYW5kIHNlZVxuLy8gICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzOTcgZm9yIGRhdGE6IHVybHMsIHdoaWNoIG92ZXJyaWRlIHNvbWUgb2Zcbi8vICAqIGl0KS5cbi8vICAqL1xuLy8gIGZ1bmN0aW9uIGlzU2FmZU1pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbi8vICAgY29uc3QgbWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvXihbXjtdKykoPzo7XFx3Kz0oPzpcXHcrfFwiW1xcdzssPSBdK1wiKSkqJC9pKTtcbi8vICAgcmV0dXJuIG1hdGNoPy5sZW5ndGggPT09IDIgJiZcbi8vICAgICAgIChpc1NhZmVJbWFnZU1pbWVUeXBlKG1hdGNoWzFdKSB8fCBpc1NhZmVWaWRlb01pbWVUeXBlKG1hdGNoWzFdKSB8fFxuLy8gICAgICAgIGlzU2FmZUF1ZGlvTWltZVR5cGUobWF0Y2hbMV0pKTtcbi8vIH1cbi8vXG4vLyBmdW5jdGlvbiBpc1NhZmVJbWFnZU1pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbi8vICAgcmV0dXJuIC9eaW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnB8eC1pY29ufGhlaWN8aGVpZikkL2kudGVzdChcbi8vICAgICAgIG1pbWVUeXBlKTtcbi8vIH1cbi8vXG4vLyBmdW5jdGlvbiBpc1NhZmVWaWRlb01pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbi8vICAgcmV0dXJuIC9edmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibXx4LW1hdHJvc2thfHF1aWNrdGltZXx4LW1zLXdtdikkL2kudGVzdChcbi8vICAgICAgIG1pbWVUeXBlKTtcbi8vIH1cbi8vXG4vLyBmdW5jdGlvbiBpc1NhZmVBdWRpb01pbWVUeXBlKG1pbWVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbi8vICAgcmV0dXJuIC9eYXVkaW9cXC8oPzozZ3BwMnwzZ3BwfGFhY3xMMTZ8bWlkaXxtcDN8bXA0fG1wZWd8b2dhfG9nZ3xvcHVzfHgtbTRhfHgtbWF0cm9za2F8eC13YXZ8d2F2fHdlYm0pJC9pXG4vLyAgICAgICAudGVzdChtaW1lVHlwZSk7XG4vLyB9XG4vLyBFTkQtRVhURVJOQUxcblxuLyoqXG4gKiBXcmFwcyBVUkwuY3JlYXRlT2JqZWN0VVJMLCBjaGVja2luZyB0aGUgc2FmZXR5IG9mIHRoZSBzb3VyY2UuIEZvciBibG9icywgdGhlXG4gKiBmdW5jdGlvbiB2YWxpZGF0ZXMgdGhhdCB0aGUgQmxvYidzIHR5cGUgaXMgYW1vbmdzdCB0aGUgc2FmZSBNSU1FIHR5cGVzLCBhbmRcbiAqIHRocm93cyBpZiB0aGF0J3Mgbm90IHRoZSBjYXNlLiBVUkwucmV2b2tlT2JqZWN0VVJMIHNob3VsZCBiZSBjYWxsZWQgb24gdGhlXG4gKiByZXR1cm5lZCBVUkwgdG8gZnJlZSB0aGUgcmVzb3VyY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0VXJsRnJvbVNhZmVTb3VyY2Uoc291cmNlOiBCbG9iIHwgTWVkaWFTb3VyY2UpOiBzdHJpbmcge1xuICAvLyBCRUdJTi1JTlRFUk5BTFxuICByZXR1cm4gb2JqZWN0VXJsRnJvbVNhZmVTb3VyY2VCdWlsZGVyKHNvdXJjZSkudG9TdHJpbmcoKTtcbiAgLy8gRU5ELUlOVEVSTkFMXG4gIC8vIEJFR0lOLUVYVEVSTkFMXG4gIC8vIC8vIE1lZGlhU291cmNlIHN1cHBvcnQgaW4gU2FmYXJpIGlzIGxpbWl0ZWRcbiAgLy8gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAvLyBpZiAodHlwZW9mIE1lZGlhU291cmNlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBNZWRpYVNvdXJjZSkge1xuICAvLyAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHNvdXJjZSk7XG4gIC8vIH1cbiAgLy8gY29uc3QgYmxvYiA9IHNvdXJjZSBhcyBCbG9iO1xuICAvLyBpZiAoIWlzU2FmZU1pbWVUeXBlKGJsb2IudHlwZSkpIHtcbiAgLy8gICBsZXQgbWVzc2FnZSA9ICcnO1xuICAvLyAgIGlmIChERVZfTU9ERSkge1xuICAvLyAgICAgbWVzc2FnZSA9IGB1bnNhZmUgYmxvYiBNSU1FIHR5cGU6ICR7YmxvYi50eXBlfWA7XG4gIC8vICAgfVxuICAvLyAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgLy8gfVxuICAvLyByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgLy8gRU5ELUVYVEVSTkFMXG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/dom/globals/worker.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/dom/globals/worker.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.globals.worker');
var module = module || { id: 'third_party/javascript/safevalues/dom/globals/worker.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_resource_url_impl_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_TrustedResourceUrl_2 = goog.requireType("goog.html.TrustedResourceUrl");
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
/**
 * ScopeWithImportScripts is an {\@link WindowOrWorkerGlobalScope} that also
 * has {\@link WorkerGlobalScope.importScripts} as {\@link WorkerGlobalScope} in
 * some cases cannot be depended on directly.
 * @record
 * @extends {WindowOrWorkerGlobalScope}
 */
function ScopeWithImportScripts() { }
exports.ScopeWithImportScripts = ScopeWithImportScripts;
/* istanbul ignore if */
if (false) {
    /**
     * @type {function(...string): void}
     * @public
     */
    ScopeWithImportScripts.prototype.importScripts;
}
/**
 * Safely creates a Web Worker.
 *
 * Example usage:
 *   const trustedResourceUrl = trustedResourceUrl`/safe_script.js`;
 *   safedom.safeWorker.create(trustedResourceUrl);
 * which is a safe alternative to
 *   new Worker(url);
 * The latter can result in loading untrusted code.
 * @param {!tsickle_TrustedResourceUrl_2} url
 * @param {(undefined|*)=} options
 * @return {!Worker}
 */
function create(url, options) {
    return new Worker((/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(url))), options);
}
exports.create = create;
/**
 * Safely creates a shared Web Worker.
 * @param {!tsickle_TrustedResourceUrl_2} url
 * @param {(undefined|string|!WorkerOptions)=} options
 * @return {!SharedWorker}
 */
function createShared(url, options) {
    return new SharedWorker((/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(url))), options);
}
exports.createShared = createShared;
/**
 * Safely calls importScripts
 * @param {!ScopeWithImportScripts} scope
 * @param {...!tsickle_TrustedResourceUrl_2} urls
 * @return {void}
 */
function importScripts(scope, ...urls) {
    scope.importScripts(...urls.map((/**
     * @param {!tsickle_TrustedResourceUrl_2} url
     * @return {string}
     */
    (url) => (/** @type {string} */ ((0, resource_url_impl_1.unwrapResourceUrl)(url))))));
}
exports.importScripts = importScripts;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2RvbS9nbG9iYWxzL3dvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esa0hBRzJDOzs7Ozs7OztBQVUzQyxxQ0FFQzs7Ozs7Ozs7SUFEQywrQ0FBMEM7Ozs7Ozs7Ozs7Ozs7OztBQWE1QyxTQUFnQixNQUFNLENBQUMsR0FBdUIsRUFBRSxPQUFZO0lBQzFELE9BQU8sSUFBSSxNQUFNLENBQUMsd0JBQUEsSUFBQSxxQ0FBaUIsRUFBQyxHQUFHLENBQUMsRUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFGRCx3QkFFQzs7Ozs7OztBQUdELFNBQWdCLFlBQVksQ0FDMUIsR0FBdUIsRUFDdkIsT0FBZ0M7SUFFaEMsT0FBTyxJQUFJLFlBQVksQ0FBQyx3QkFBQSxJQUFBLHFDQUFpQixFQUFDLEdBQUcsQ0FBQyxFQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDckUsQ0FBQztBQUxELG9DQUtDOzs7Ozs7O0FBR0QsU0FBZ0IsYUFBYSxDQUMzQixLQUE2QixFQUM3QixHQUFHLElBQTBCO0lBRTdCLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRzs7OztJQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyx3QkFBQSxJQUFBLHFDQUFpQixFQUFDLEdBQUcsQ0FBQyxFQUFVLEVBQUMsQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFMRCxzQ0FLQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtcbiAgVHJ1c3RlZFJlc291cmNlVXJsLFxuICB1bndyYXBSZXNvdXJjZVVybCxcbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsJztcblxuLy8gV2UgY2FuJ3QgZGVwZW5kIG9uIFdvcmtlckdsb2JhbFNjb3BlIGRpcmVjdGx5LCBhcyBsaWIud2Vid29ya2VyLmQudHMgYWx0ZXJzXG4vLyB0aGUgZ2xvYmFsIHNjb3BlIHR5cGluZy5cblxuLyoqXG4gKiBTY29wZVdpdGhJbXBvcnRTY3JpcHRzIGlzIGFuIHtAbGluayBXaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlfSB0aGF0IGFsc29cbiAqIGhhcyB7QGxpbmsgV29ya2VyR2xvYmFsU2NvcGUuaW1wb3J0U2NyaXB0c30gYXMge0BsaW5rIFdvcmtlckdsb2JhbFNjb3BlfSBpblxuICogc29tZSBjYXNlcyBjYW5ub3QgYmUgZGVwZW5kZWQgb24gZGlyZWN0bHkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NvcGVXaXRoSW1wb3J0U2NyaXB0cyBleHRlbmRzIFdpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUge1xuICBpbXBvcnRTY3JpcHRzOiAoLi4udXJsOiBzdHJpbmdbXSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBTYWZlbHkgY3JlYXRlcyBhIFdlYiBXb3JrZXIuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgY29uc3QgdHJ1c3RlZFJlc291cmNlVXJsID0gdHJ1c3RlZFJlc291cmNlVXJsYC9zYWZlX3NjcmlwdC5qc2A7XG4gKiAgIHNhZmVkb20uc2FmZVdvcmtlci5jcmVhdGUodHJ1c3RlZFJlc291cmNlVXJsKTtcbiAqIHdoaWNoIGlzIGEgc2FmZSBhbHRlcm5hdGl2ZSB0b1xuICogICBuZXcgV29ya2VyKHVybCk7XG4gKiBUaGUgbGF0dGVyIGNhbiByZXN1bHQgaW4gbG9hZGluZyB1bnRydXN0ZWQgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh1cmw6IFRydXN0ZWRSZXNvdXJjZVVybCwgb3B0aW9ucz86IHt9KTogV29ya2VyIHtcbiAgcmV0dXJuIG5ldyBXb3JrZXIodW53cmFwUmVzb3VyY2VVcmwodXJsKSBhcyBzdHJpbmcsIG9wdGlvbnMpO1xufVxuXG4vKiogU2FmZWx5IGNyZWF0ZXMgYSBzaGFyZWQgV2ViIFdvcmtlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaGFyZWQoXG4gIHVybDogVHJ1c3RlZFJlc291cmNlVXJsLFxuICBvcHRpb25zPzogc3RyaW5nIHwgV29ya2VyT3B0aW9ucyxcbik6IFNoYXJlZFdvcmtlciB7XG4gIHJldHVybiBuZXcgU2hhcmVkV29ya2VyKHVud3JhcFJlc291cmNlVXJsKHVybCkgYXMgc3RyaW5nLCBvcHRpb25zKTtcbn1cblxuLyoqIFNhZmVseSBjYWxscyBpbXBvcnRTY3JpcHRzICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0U2NyaXB0cyhcbiAgc2NvcGU6IFNjb3BlV2l0aEltcG9ydFNjcmlwdHMsXG4gIC4uLnVybHM6IFRydXN0ZWRSZXNvdXJjZVVybFtdXG4pOiB2b2lkIHtcbiAgc2NvcGUuaW1wb3J0U2NyaXB0cyguLi51cmxzLm1hcCgodXJsKSA9PiB1bndyYXBSZXNvdXJjZVVybCh1cmwpIGFzIHN0cmluZykpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/dom/index.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview This file re-exports all of the wrappers to ensure that we have
 * a clearly defined interface.
 * Generated from: third_party/javascript/safevalues/dom/index.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.dom.index');
var module = module || { id: 'third_party/javascript/safevalues/dom/index.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_anchor_1 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.anchor");
const tsickle_area_2 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.area");
const tsickle_base_3 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.base");
const tsickle_button_4 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.button");
const tsickle_element_5 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.element");
const tsickle_embed_6 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.embed");
const tsickle_form_7 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.form");
const tsickle_iframe_8 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.iframe");
const tsickle_input_9 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.input");
const tsickle_link_10 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.link");
const tsickle_object_11 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.object");
const tsickle_script_12 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.script");
const tsickle_style_13 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.style");
const tsickle_svg_14 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.svg");
const tsickle_svg_use_15 = goog.requireType("google3.third_party.javascript.safevalues.dom.elements.svg_use");
const tsickle_document_16 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.document");
const tsickle_dom_parser_17 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.dom_parser");
const tsickle_global_18 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.global");
const tsickle_location_19 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.location");
const tsickle_range_20 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.range");
const tsickle_service_worker_container_21 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.service_worker_container");
const tsickle_url_22 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.url");
const tsickle_window_23 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.window");
const tsickle_worker_24 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.worker");
const tsickle_module_1_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.anchor');
/** @const */
exports.safeAnchorEl = tsickle_module_1_;
const tsickle_module_2_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.area');
/** @const */
exports.safeAreaEl = tsickle_module_2_;
const tsickle_module_3_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.base');
/** @const */
exports.safeBaseEl = tsickle_module_3_;
const tsickle_module_4_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.button');
/** @const */
exports.safeButtonEl = tsickle_module_4_;
const tsickle_module_5_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.element');
/** @const */
exports.safeElement = tsickle_module_5_;
const tsickle_module_6_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.embed');
/** @const */
exports.safeEmbedEl = tsickle_module_6_;
const tsickle_module_7_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.form');
/** @const */
exports.safeFormEl = tsickle_module_7_;
const tsickle_module_8_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.iframe');
/** @const */
exports.safeIframeEl = tsickle_module_8_;
const tsickle_module_9_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.input');
/** @const */
exports.safeInputEl = tsickle_module_9_;
const tsickle_module_10_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.link');
/** @const */
exports.safeLinkEl = tsickle_module_10_;
const tsickle_module_11_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.object');
/** @const */
exports.safeObjectEl = tsickle_module_11_;
const tsickle_module_12_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.script');
/** @const */
exports.safeScriptEl = tsickle_module_12_;
const tsickle_module_13_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.style');
/** @const */
exports.safeStyleEl = tsickle_module_13_;
const tsickle_module_14_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.svg');
/** @const */
exports.safeSvgEl = tsickle_module_14_;
const tsickle_module_15_ = goog.require('google3.third_party.javascript.safevalues.dom.elements.svg_use');
/** @const */
exports.safeSvgUseEl = tsickle_module_15_;
const tsickle_module_16_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.document');
/** @const */
exports.safeDocument = tsickle_module_16_;
const tsickle_module_17_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.dom_parser');
/** @const */
exports.safeDomParser = tsickle_module_17_;
const tsickle_module_18_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.global');
/** @const */
exports.safeGlobal = tsickle_module_18_;
const tsickle_module_19_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.location');
/** @const */
exports.safeLocation = tsickle_module_19_;
const tsickle_module_20_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.range');
/** @const */
exports.safeRange = tsickle_module_20_;
const tsickle_module_21_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.service_worker_container');
/** @const */
exports.safeServiceWorkerContainer = tsickle_module_21_;
const tsickle_module_22_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.url');
/** @const */
exports.safeUrl = tsickle_module_22_;
const tsickle_module_23_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.window');
/** @const */
exports.safeWindow = tsickle_module_23_;
const tsickle_module_24_ = goog.require('google3.third_party.javascript.safevalues.dom.globals.worker');
/** @const */
exports.safeWorker = tsickle_module_24_;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvZG9tL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVVBLHdHQUFrRDs7QUFBbEQseUNBQWtEO0FBQ2xELHNHQUE4Qzs7QUFBOUMsdUNBQThDO0FBQzlDLHNHQUE4Qzs7QUFBOUMsdUNBQThDO0FBQzlDLHdHQUFrRDs7QUFBbEQseUNBQWtEO0FBQ2xELHlHQUFrRDs7QUFBbEQsd0NBQWtEO0FBQ2xELHVHQUFnRDs7QUFBaEQsd0NBQWdEO0FBQ2hELHNHQUE4Qzs7QUFBOUMsdUNBQThDO0FBQzlDLHdHQUFrRDs7QUFBbEQseUNBQWtEO0FBQ2xELHVHQUFnRDs7QUFBaEQsd0NBQWdEO0FBQ2hELHVHQUE4Qzs7QUFBOUMsd0NBQThDO0FBQzlDLHlHQUFrRDs7QUFBbEQsMENBQWtEO0FBQ2xELHlHQUFrRDs7QUFBbEQsMENBQWtEO0FBQ2xELHdHQUFnRDs7QUFBaEQseUNBQWdEO0FBQ2hELHNHQUE0Qzs7QUFBNUMsdUNBQTRDO0FBQzVDLDBHQUFtRDs7QUFBbkQsMENBQW1EO0FBQ25ELDBHQUFtRDs7QUFBbkQsMENBQW1EO0FBQ25ELDRHQUFzRDs7QUFBdEQsMkNBQXNEO0FBQ3RELHdHQUErQzs7QUFBL0Msd0NBQStDO0FBQy9DLDBHQUFtRDs7QUFBbkQsMENBQW1EO0FBQ25ELHVHQUE2Qzs7QUFBN0MsdUNBQTZDO0FBQzdDLDBIQUFpRjs7QUFBakYsd0RBQWlGO0FBQ2pGLHFHQUF5Qzs7QUFBekMscUNBQXlDO0FBQ3pDLHdHQUErQzs7QUFBL0Msd0NBQStDO0FBQy9DLHdHQUErQzs7QUFBL0Msd0NBQStDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBmaWxlIHJlLWV4cG9ydHMgYWxsIG9mIHRoZSB3cmFwcGVycyB0byBlbnN1cmUgdGhhdCB3ZSBoYXZlXG4gKiBhIGNsZWFybHkgZGVmaW5lZCBpbnRlcmZhY2UuXG4gKi9cblxuZXhwb3J0ICogYXMgc2FmZUFuY2hvckVsIGZyb20gJy4vZWxlbWVudHMvYW5jaG9yJztcbmV4cG9ydCAqIGFzIHNhZmVBcmVhRWwgZnJvbSAnLi9lbGVtZW50cy9hcmVhJztcbmV4cG9ydCAqIGFzIHNhZmVCYXNlRWwgZnJvbSAnLi9lbGVtZW50cy9iYXNlJztcbmV4cG9ydCAqIGFzIHNhZmVCdXR0b25FbCBmcm9tICcuL2VsZW1lbnRzL2J1dHRvbic7XG5leHBvcnQgKiBhcyBzYWZlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL2VsZW1lbnQnO1xuZXhwb3J0ICogYXMgc2FmZUVtYmVkRWwgZnJvbSAnLi9lbGVtZW50cy9lbWJlZCc7XG5leHBvcnQgKiBhcyBzYWZlRm9ybUVsIGZyb20gJy4vZWxlbWVudHMvZm9ybSc7XG5leHBvcnQgKiBhcyBzYWZlSWZyYW1lRWwgZnJvbSAnLi9lbGVtZW50cy9pZnJhbWUnO1xuZXhwb3J0ICogYXMgc2FmZUlucHV0RWwgZnJvbSAnLi9lbGVtZW50cy9pbnB1dCc7XG5leHBvcnQgKiBhcyBzYWZlTGlua0VsIGZyb20gJy4vZWxlbWVudHMvbGluayc7XG5leHBvcnQgKiBhcyBzYWZlT2JqZWN0RWwgZnJvbSAnLi9lbGVtZW50cy9vYmplY3QnO1xuZXhwb3J0ICogYXMgc2FmZVNjcmlwdEVsIGZyb20gJy4vZWxlbWVudHMvc2NyaXB0JztcbmV4cG9ydCAqIGFzIHNhZmVTdHlsZUVsIGZyb20gJy4vZWxlbWVudHMvc3R5bGUnO1xuZXhwb3J0ICogYXMgc2FmZVN2Z0VsIGZyb20gJy4vZWxlbWVudHMvc3ZnJztcbmV4cG9ydCAqIGFzIHNhZmVTdmdVc2VFbCBmcm9tICcuL2VsZW1lbnRzL3N2Z191c2UnO1xuZXhwb3J0ICogYXMgc2FmZURvY3VtZW50IGZyb20gJy4vZ2xvYmFscy9kb2N1bWVudCc7XG5leHBvcnQgKiBhcyBzYWZlRG9tUGFyc2VyIGZyb20gJy4vZ2xvYmFscy9kb21fcGFyc2VyJztcbmV4cG9ydCAqIGFzIHNhZmVHbG9iYWwgZnJvbSAnLi9nbG9iYWxzL2dsb2JhbCc7XG5leHBvcnQgKiBhcyBzYWZlTG9jYXRpb24gZnJvbSAnLi9nbG9iYWxzL2xvY2F0aW9uJztcbmV4cG9ydCAqIGFzIHNhZmVSYW5nZSBmcm9tICcuL2dsb2JhbHMvcmFuZ2UnO1xuZXhwb3J0ICogYXMgc2FmZVNlcnZpY2VXb3JrZXJDb250YWluZXIgZnJvbSAnLi9nbG9iYWxzL3NlcnZpY2Vfd29ya2VyX2NvbnRhaW5lcic7XG5leHBvcnQgKiBhcyBzYWZlVXJsIGZyb20gJy4vZ2xvYmFscy91cmwnO1xuZXhwb3J0ICogYXMgc2FmZVdpbmRvdyBmcm9tICcuL2dsb2JhbHMvd2luZG93JztcbmV4cG9ydCAqIGFzIHNhZmVXb3JrZXIgZnJvbSAnLi9nbG9iYWxzL3dvcmtlcic7XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG5nb29nLnRzTWlncmF0aW9uTmFtZWRFeHBvcnRzU2hpbSgnc2FmZXZhbHVlcy5kb20nKTtcbmdvb2cudHNNaWdyYXRpb25FeHBvcnRzU2hpbURlY2xhcmVMZWdhY3lOYW1lc3BhY2UoKTtcbi8vIEVORC1JTlRFUk5BTFxuIl19
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/utils.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/utils.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/utils.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safevalues_1 = goog.requireType("google3.third_party.javascript.safevalues.index");
const tsickle_dom_2 = goog.requireType("google3.third_party.javascript.safevalues.dom.index");
const tsickle_consts_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts");
const tsickle_model_graph_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_5 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_TrustedResourceUrl_6 = goog.requireType("goog.html.TrustedResourceUrl");
const dom_1 = goog.require('google3.third_party.javascript.safevalues.dom.index');
const consts_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts');
const model_graph_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph');
const types_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types');
/** @type {!OffscreenCanvas} */
const CANVAS = new OffscreenCanvas(300, 300);
/**
 * Cache for label width indexed by label.
 * @type {!Object<string,number>}
 */
const LABEL_WIDTHS = {};
/**
 * Checks whether the given node is an op node.
 * @param {(undefined|!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @return {boolean}
 */
function isOpNode(node) {
    return node?.nodeType === model_graph_1.NodeType.OP_NODE;
}
exports.isOpNode = isOpNode;
/**
 * Checks whether the given node is a group node.
 * @param {(undefined|!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @return {boolean}
 */
function isGroupNode(node) {
    return node?.nodeType === model_graph_1.NodeType.GROUP_NODE;
}
exports.isGroupNode = isGroupNode;
/**
 * Checks whether the given node is a group node and it doesn't have any
 * children nodes.
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @return {boolean}
 */
function isGroupNodeWithoutChildren(node) {
    return isGroupNode(node) && ((/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).nsChildrenIds || []).length === 0;
}
exports.isGroupNodeWithoutChildren = isGroupNodeWithoutChildren;
/**
 * Gets the op node field labels from the given showOnNodeItemTypes.
 * @param {?} showOnNodeItemTypes
 * @return {!Array<!tsickle_types_5.FieldLabel>}
 */
function getOpNodeFieldLabelsFromShowOnNodeItemTypes(showOnNodeItemTypes) {
    /** @type {!Array<!tsickle_types_5.FieldLabel>} */
    const fieldIds = [];
    for (const [itemType__tsickle_destructured_1, itemData__tsickle_destructured_2] of Object.entries(showOnNodeItemTypes)) {
        const itemType = /** @type {string} */ (itemType__tsickle_destructured_1);
        const itemData = /** @type {!tsickle_types_5.ShowOnNodeItemData} */ (itemData__tsickle_destructured_2);
        switch (itemType) {
            case types_1.ShowOnNodeItemType.OP_NODE_ID:
                if (itemData.selected) {
                    fieldIds.push(types_1.FieldLabel.OP_NODE_ID);
                }
                break;
            default:
                break;
        }
    }
    return fieldIds;
}
exports.getOpNodeFieldLabelsFromShowOnNodeItemTypes = getOpNodeFieldLabelsFromShowOnNodeItemTypes;
/**
 * Gets the group node field labels from the given showOnNodeItemTypes.
 * @param {?} showOnNodeItemTypes
 * @return {!Array<!tsickle_types_5.FieldLabel>}
 */
function getGroupNodeFieldLabelsFromShowOnNodeItemTypes(showOnNodeItemTypes) {
    /** @type {!Array<!tsickle_types_5.FieldLabel>} */
    const fieldIds = [];
    for (const [itemType__tsickle_destructured_3, itemData__tsickle_destructured_4] of Object.entries(showOnNodeItemTypes)) {
        const itemType = /** @type {string} */ (itemType__tsickle_destructured_3);
        const itemData = /** @type {!tsickle_types_5.ShowOnNodeItemData} */ (itemData__tsickle_destructured_4);
        switch (itemType) {
            case types_1.ShowOnNodeItemType.LAYER_NODE_CHILDREN_COUNT:
                if (itemData.selected) {
                    fieldIds.push(types_1.FieldLabel.NUMBER_OF_CHILDREN);
                }
                break;
            case types_1.ShowOnNodeItemType.LAYER_NODE_DESCENDANTS_COUNT:
                if (itemData.selected) {
                    fieldIds.push(types_1.FieldLabel.NUMBER_OF_DESCENDANTS);
                }
                break;
            default:
                break;
        }
    }
    return fieldIds;
}
exports.getGroupNodeFieldLabelsFromShowOnNodeItemTypes = getGroupNodeFieldLabelsFromShowOnNodeItemTypes;
/**
 * Gets the value for the given field id of a node's info.
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @param {string} fieldId
 * @return {string}
 */
function getNodeInfoFieldValue(node, fieldId) {
    if (isOpNode(node)) {
        switch (fieldId.toLowerCase()) {
            case types_1.FieldLabel.OP_NODE_ID:
                return (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).id;
            case 'namespace':
                return getNamespaceLabel(node);
            default:
                break;
        }
    }
    else if (isGroupNode(node)) {
        switch (fieldId.toLowerCase()) {
            case 'namespace':
                return getNamespaceLabel(node);
            case types_1.FieldLabel.NUMBER_OF_CHILDREN:
                return String(((/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).nsChildrenIds || []).length);
            case types_1.FieldLabel.NUMBER_OF_DESCENDANTS:
                return String(((/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).descendantsNodeIds || []).length);
            default:
                break;
        }
    }
    return '';
}
exports.getNodeInfoFieldValue = getNodeInfoFieldValue;
/**
 * Gets namespace display label.
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @return {string}
 */
function getNamespaceLabel(node) {
    return node.savedNamespace || node.namespace || '<root>';
}
exports.getNamespaceLabel = getNamespaceLabel;
/**
 * Generates unique id.
 * @return {string}
 */
function genUid() {
    return Math.random().toString(36).slice(-6);
}
exports.genUid = genUid;
/**
 * Gets the deepest expanded group node ids.
 * @param {(undefined|!tsickle_model_graph_4.GroupNode)} root
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {!Array<string>} deepestExpandedGroupNodeIds
 * @return {void}
 */
function getDeepestExpandedGroupNodeIds(root, modelGraph, deepestExpandedGroupNodeIds) {
    /** @type {!Array<string>} */
    let nsChildrenIds = [];
    if (root == null) {
        nsChildrenIds = modelGraph.rootNodes.map((/**
         * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
         * @return {string}
         */
        (node) => node.id));
    }
    else {
        nsChildrenIds = root.nsChildrenIds || [];
    }
    for (const nsChildNodeId of nsChildrenIds) {
        /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
        const childNode = modelGraph.nodesById[nsChildNodeId];
        if (!childNode) {
            continue;
        }
        if (isGroupNode(childNode) && (/** @type {!tsickle_model_graph_4.GroupNode} */ (childNode)).expanded) {
            /** @type {boolean} */
            const isDeepest = ((/** @type {!tsickle_model_graph_4.GroupNode} */ (childNode)).nsChildrenIds || [])
                .filter((/**
             * @param {string} id
             * @return {boolean}
             */
            (id) => isGroupNode(modelGraph.nodesById[id])))
                .every((/**
             * @param {string} id
             * @return {boolean}
             */
            (id) => !((/** @type {!tsickle_model_graph_4.GroupNode} */ (modelGraph.nodesById[id]))).expanded));
            if (isDeepest) {
                deepestExpandedGroupNodeIds.push((/** @type {!tsickle_model_graph_4.GroupNode} */ (childNode)).id);
            }
            getDeepestExpandedGroupNodeIds(childNode, modelGraph, deepestExpandedGroupNodeIds);
        }
    }
}
exports.getDeepestExpandedGroupNodeIds = getDeepestExpandedGroupNodeIds;
/**
 * Gets the points from a smooth curve that go through the given points.
 * @param {!Array<!tsickle_types_5.Point>} points
 * @param {?} d3Line
 * @param {?} d3CurveMonotoneY
 * @param {?} three
 * @return {!Array<!tsickle_types_5.Point>}
 */
function generateCurvePoints(points, 
// tslint:disable-next-line:no-any Allow arbitrary types.
d3Line, 
// tslint:disable-next-line:no-any Allow arbitrary types.
d3CurveMonotoneY, 
// tslint:disable-next-line:no-any Allow arbitrary types.
three) {
    /** @type {!Array<!tsickle_types_5.Point>} */
    let curvePoints = [];
    if (points.length === 2) {
        curvePoints = points;
    }
    else if (points.length === 3 &&
        points[0].x === points[1].x &&
        points[1].x === points[2].x) {
        curvePoints = points;
    }
    else {
        // Check if points are sorted by their Y coordinate.
        /** @type {boolean} */
        let isYSorted = true;
        /** @type {number} */
        let curOrder = 0;
        for (let i = 0; i < points.length - 1; i++) {
            /** @type {!tsickle_types_5.Point} */
            const curPt = points[i];
            /** @type {!tsickle_types_5.Point} */
            const nextPt = points[i + 1];
            /** @type {number} */
            const order = nextPt > curPt ? 1 : -1;
            if (curOrder !== 0 && curOrder !== order) {
                isYSorted = false;
                break;
            }
            curOrder = order;
        }
        // If ys are sorted, use d3's curveMonotoneY to generate curves and
        // convert them to a CurvePath in threejs. curveMonotoneY looks better
        // then catmullrom curves.
        /** @type {?} */
        const vec3 = three['Vector3'];
        if (isYSorted) {
            /** @type {string} */
            const d3Curve = (/** @type {string} */ (d3Line()
                .x((/**
             * @param {!tsickle_types_5.Point} d
             * @return {number}
             */
            (d) => d.x))
                .y((/**
             * @param {!tsickle_types_5.Point} d
             * @return {number}
             */
            (d) => d.y))
                .curve(d3CurveMonotoneY)(points)));
            /** @type {!Array<!Array<number>>} */
            const parts = d3Curve
                .split(/M|C/)
                .filter((/**
             * @param {string} s
             * @return {boolean}
             */
            (s) => s !== ''))
                .map((/**
             * @param {string} s
             * @return {!Array<number>}
             */
            (s) => s.split(',').map((/**
             * @param {string} s
             * @return {number}
             */
            (s) => Number(s)))));
            /** @type {?} */
            let curStartPoint = new vec3(parts[0][0], parts[0][1], 0);
            /** @type {?} */
            const curvePath = new three['CurvePath']();
            for (let i = 1; i < parts.length; i++) {
                /** @type {!Array<number>} */
                const curPart = parts[i];
                if (curPart.length === 6) {
                    /** @type {?} */
                    const ptStart = curStartPoint;
                    /** @type {?} */
                    const c1 = new vec3(curPart[0], curPart[1]);
                    /** @type {?} */
                    const c2 = new vec3(curPart[2], curPart[3]);
                    /** @type {?} */
                    const ptEnd = new vec3(curPart[4], curPart[5]);
                    curStartPoint = ptEnd;
                    /** @type {?} */
                    const curve = new three['CubicBezierCurve3'](ptStart, c1, c2, ptEnd);
                    curvePath.add(curve);
                }
            }
            curvePoints = curvePath['getPoints'](consts_1.WEBGL_CURVE_SEGMENTS);
        }
        // Otherwise, use the catmullrom curve.
        else {
            /** @type {!Array<?>} */
            const v3Points = points.map((/**
             * @param {!tsickle_types_5.Point} point
             * @return {?}
             */
            (point) => new vec3(point.x, point.y, 0)));
            /** @type {?} */
            const curve = new three['CatmullRomCurve3'](v3Points, false, 'catmullrom', consts_1.CATMULLROM_CURVE_TENSION);
            curvePoints = curve['getPoints'](consts_1.WEBGL_CURVE_SEGMENTS);
        }
    }
    return curvePoints;
}
exports.generateCurvePoints = generateCurvePoints;
/**
 * Checks whether the active element is an input element.
 * @return {boolean}
 */
function inInputElement() {
    /** @type {(null|!HTMLElement)} */
    const activeEle = getActiveElement();
    if (!activeEle) {
        return false;
    }
    /** @type {boolean} */
    const isInputElement = activeEle.tagName === 'INPUT' ||
        activeEle.tagName === 'SELECT' ||
        activeEle.tagName === 'TEXTAREA' ||
        activeEle.contentEditable === 'true';
    return isInputElement;
}
exports.inInputElement = inInputElement;
/**
 * @param {(!Document|!ShadowRoot)=} root
 * @return {(null|!HTMLElement)}
 */
function getActiveElement(root = document) {
    /** @type {(null|!HTMLElement)} */
    const activeEl = (/** @type {!HTMLElement} */ (root.activeElement));
    if (!activeEl) {
        return null;
    }
    if (activeEl.shadowRoot) {
        return getActiveElement(activeEl.shadowRoot);
    }
    else {
        return activeEl;
    }
}
/**
 * Gets the label width by measureing its size in canvas.
 * @param {string} label
 * @param {number} fontSize
 * @param {boolean} bold
 * @param {boolean=} saveToCache
 * @return {number}
 */
function getLabelWidth(label, fontSize, bold, saveToCache = true) {
    // Check cache first.
    /** @type {string} */
    const key = `${label}___${fontSize}___${bold}`;
    /** @type {number} */
    let labelWidth = LABEL_WIDTHS[key];
    if (labelWidth == null) {
        // On cache miss, render the text to a offscreen canvas to get its width.
        /** @type {!CanvasRenderingContext2D} */
        const context = (/** @type {!CanvasRenderingContext2D} */ ((/** @type {*} */ ((/** @type {!OffscreenCanvasRenderingContext2D} */ (CANVAS.getContext('2d')))))));
        context.font = `${fontSize}px "Google Sans Text", Arial, Helvetica, sans-serif`;
        if (bold) {
            context.font = `bold ${context.font}`;
        }
        /** @type {!TextMetrics} */
        const metrics = context.measureText(label);
        /** @type {number} */
        const width = metrics.width;
        if (saveToCache) {
            LABEL_WIDTHS[key] = width;
        }
        labelWidth = width;
    }
    return labelWidth;
}
exports.getLabelWidth = getLabelWidth;
/**
 * Gets the input label for the attrs table from the given node.
 * @param {number} index
 * @param {!tsickle_model_graph_4.OpNode} node
 * @param {?} metadata
 * @return {string}
 */
function getInputLabelForAttrsTable(index, node, metadata) {
    /** @type {string} */
    const tensorTag = metadata[consts_1.TENSOR_TAG_METADATA_KEY];
    return tensorTag
        ? `Input${index}:${tensorTag} (${node.label})`
        : `Input${index} (${node.label})`;
}
exports.getInputLabelForAttrsTable = getInputLabelForAttrsTable;
/**
 * Gets the output label for the attrs table from the given node.
 * @param {number} index
 * @param {?} outputMetadata
 * @param {!tsickle_model_graph_4.OpNode} node
 * @return {string}
 */
function getOutputLabelForAttrsTable(index, outputMetadata, node) {
    /** @type {string} */
    let label = `Output${index}`;
    // Special handling for "GraphInputs".
    if (node.label === 'GraphInputs') {
        /** @type {string} */
        const tensorName = outputMetadata['tensor_name'];
        if (tensorName != null) {
            label = `${label} (${tensorName})`;
        }
    }
    else {
        /** @type {string} */
        const tensorTag = outputMetadata[consts_1.TENSOR_TAG_METADATA_KEY];
        if (tensorTag) {
            label = `Output${index}:${tensorTag}`;
        }
    }
    return label;
}
exports.getOutputLabelForAttrsTable = getOutputLabelForAttrsTable;
/**
 * Gets the shape for the attrs table from the given node.
 * @param {(undefined|?)=} items
 * @return {string}
 */
function getShapeForAttrsTable(items) {
    /** @type {string} */
    let shape = ((items || {})['shape'] || '')
        .replace(/ /g, '')
        .replace(/Ã/g, 'x');
    if (shape === '') {
        shape = '?';
    }
    return shape;
}
exports.getShapeForAttrsTable = getShapeForAttrsTable;
/**
 * Gets the key value pairs for the given node's attrs for attrs table.
 * @param {!tsickle_model_graph_4.OpNode} node
 * @param {string=} filterRegex
 * @return {!Array<!tsickle_types_5.KeyValue>}
 */
function getOpNodeAttrsKeyValuePairsForAttrsTable(node, filterRegex = '') {
    /** @type {?} */
    const attrs = node.attrs || {};
    /** @type {!Array<!tsickle_types_5.KeyValue>} */
    const keyValuePairs = [];
    /** @type {!RegExp} */
    const regex = new RegExp(filterRegex, 'i');
    for (const attrId of Object.keys(attrs)) {
        /** @type {string} */
        const key = attrId;
        /** @type {string} */
        const value = attrs[attrId];
        /** @type {!Array<string>} */
        const matchTargets = [`${key}:${value}`, `${key}=${value}`];
        if (filterRegex.trim() === '' ||
            matchTargets.some((/**
             * @param {string} matchTarget
             * @return {boolean}
             */
            (matchTarget) => regex.test(matchTarget)))) {
            // Remove new line chars and spaces.
            /** @type {string} */
            let processedValue = value;
            if (key === consts_1.TENSOR_VALUES_KEY) {
                // For __value attribute, remove all white space chars.
                processedValue = value.replace(/\s/gm, '');
            }
            else {
                // For other attributes, only remove newline chars.
                processedValue = value.replace(/(\r\n|\n|\r)/gm, '');
            }
            keyValuePairs.push({
                key,
                value: processedValue,
            });
        }
    }
    return keyValuePairs;
}
exports.getOpNodeAttrsKeyValuePairsForAttrsTable = getOpNodeAttrsKeyValuePairsForAttrsTable;
/**
 * Gets the key value pairs for the givn node's input for attrs table.
 * @param {!tsickle_model_graph_4.OpNode} node
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @return {!Array<!tsickle_types_5.KeyValue>}
 */
function getOpNodeInputsKeyValuePairsForAttrsTable(node, modelGraph) {
    /** @type {!Array<!tsickle_types_5.IncomingEdge>} */
    const incomingEdges = node.incomingEdges || [];
    /** @type {!Array<!tsickle_types_5.KeyValue>} */
    const keyValuePairs = [];
    for (let i = 0; i < Math.min(consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE, incomingEdges.length); i++) {
        /** @type {!tsickle_types_5.IncomingEdge} */
        const incomingEdge = incomingEdges[i];
        /** @type {string} */
        const sourceNodeId = incomingEdge.sourceNodeId;
        /** @type {!tsickle_model_graph_4.OpNode} */
        const sourceNode = (/** @type {!tsickle_model_graph_4.OpNode} */ (modelGraph.nodesById[sourceNodeId]));
        /** @type {string} */
        const sourceNodeShape = getShapeForAttrsTable((sourceNode.outputsMetadata || {})[incomingEdge.sourceNodeOutputId]);
        /** @type {?} */
        const inputMetadata = (node.inputsMetadata || {})[incomingEdge.targetNodeInputId] || {};
        keyValuePairs.push({
            key: getInputLabelForAttrsTable(i, sourceNode, inputMetadata),
            value: sourceNodeShape,
        });
    }
    if (incomingEdges.length > consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE) {
        /** @type {number} */
        const overMaxCount = incomingEdges.length - consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE;
        keyValuePairs.push({
            key: `(${overMaxCount} more input${overMaxCount === 1 ? '' : 's'} omitted)`,
            value: '...',
        });
    }
    return keyValuePairs;
}
exports.getOpNodeInputsKeyValuePairsForAttrsTable = getOpNodeInputsKeyValuePairsForAttrsTable;
/**
 * Gets the key value pairs for the given node's outputs for attrs table.
 * @param {!tsickle_model_graph_4.OpNode} node
 * @return {!Array<!tsickle_types_5.KeyValue>}
 */
function getOpNodeOutputsKeyValuePairsForAttrsTable(node) {
    /** @type {!Array<!tsickle_types_5.KeyValue>} */
    const keyValuePairs = [];
    /** @type {?} */
    const outputsMetadata = node.outputsMetadata || {};
    /** @type {!Array<?>} */
    const outputDataList = Object.values(outputsMetadata);
    for (let i = 0; i < Math.min(consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE, outputDataList.length); i++) {
        /** @type {?} */
        const outputData = outputDataList[i];
        /** @type {string} */
        const shape = getShapeForAttrsTable(outputData);
        keyValuePairs.push({
            key: getOutputLabelForAttrsTable(i, outputData, node),
            value: shape,
        });
    }
    if (outputDataList.length > consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE) {
        /** @type {number} */
        const overMaxCount = outputDataList.length - consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE;
        keyValuePairs.push({
            key: `(${overMaxCount} more output${overMaxCount === 1 ? '' : 's'} omitted)`,
            value: '...',
        });
    }
    return keyValuePairs;
}
exports.getOpNodeOutputsKeyValuePairsForAttrsTable = getOpNodeOutputsKeyValuePairsForAttrsTable;
/**
 * Gets the key value pairs for the given node's data provider runs.
 * @param {!tsickle_model_graph_4.OpNode} node
 * @param {string} modelGraphId
 * @param {?} showOnNodeItemTypes
 * @param {?} curNodeDataProviderRuns
 * @return {!Array<!tsickle_types_5.KeyValue>}
 */
function getOpNodeDataProviderKeyValuePairsForAttrsTable(node, modelGraphId, showOnNodeItemTypes, curNodeDataProviderRuns) {
    /** @type {!Array<!tsickle_types_5.KeyValue>} */
    const keyValuePairs = [];
    /** @type {!Array<string>} */
    const runNames = Object.keys(showOnNodeItemTypes)
        .filter((/**
     * @param {string} type
     * @return {boolean}
     */
    (type) => showOnNodeItemTypes[type].selected))
        .filter((/**
     * @param {string} itemType
     * @return {boolean}
     */
    (itemType) => itemType.startsWith(consts_1.NODE_DATA_PROVIDER_SHOW_ON_NODE_TYPE_PREFIX)))
        .map((/**
     * @param {string} type
     * @return {string}
     */
    (type) => type.replace(consts_1.NODE_DATA_PROVIDER_SHOW_ON_NODE_TYPE_PREFIX, '')));
    /** @type {!Array<!tsickle_types_5.NodeDataProviderRunData>} */
    const runs = Object.values(curNodeDataProviderRuns).filter((/**
     * @param {!tsickle_types_5.NodeDataProviderRunData} run
     * @return {boolean}
     */
    (run) => runNames.includes(run.runName)));
    for (const run of runs) {
        /** @type {string} */
        const value = (run.results || {})?.[modelGraphId][node.id]?.strValue || '-';
        keyValuePairs.push({ key: run.runName, value });
    }
    return keyValuePairs;
}
exports.getOpNodeDataProviderKeyValuePairsForAttrsTable = getOpNodeDataProviderKeyValuePairsForAttrsTable;
/**
 * Given two namespace strings, e.g. a/b/c/d and a/b/x, returns the common
 * prefix, e.g. a/b.
 * @param {string} ns1
 * @param {string} ns2
 * @return {string}
 */
function findCommonNamespace(ns1, ns2) {
    /** @type {!Array<string>} */
    const ns1Parts = ns1.split('/');
    /** @type {!Array<string>} */
    const ns2Parts = ns2.split('/');
    /** @type {string} */
    let commonPrefix = '';
    for (let i = Math.min(ns1Parts.length, ns2Parts.length); i > 0; i--) {
        /** @type {string} */
        const ns1Prefix = ns1Parts.slice(0, i).join('/');
        /** @type {string} */
        const ns2Prefix = ns2Parts.slice(0, i).join('/');
        if (ns1Prefix === ns2Prefix) {
            commonPrefix = ns2Prefix;
            break;
        }
    }
    return commonPrefix;
}
exports.findCommonNamespace = findCommonNamespace;
/**
 * Gets the next level namespace part right after baseNs up to fullNs.
 * @param {string} baseNs
 * @param {string} fullNs
 * @return {string}
 */
function getNextLevelNsPart(baseNs, fullNs) {
    if (baseNs === fullNs) {
        return '';
    }
    /** @type {!Array<string>} */
    const baseNsParts = baseNs.split('/').filter((/**
     * @param {string} part
     * @return {boolean}
     */
    (part) => part !== ''));
    /** @type {!Array<string>} */
    const fullNsParts = fullNs.split('/').filter((/**
     * @param {string} part
     * @return {boolean}
     */
    (part) => part !== ''));
    if (fullNsParts.length === 0) {
        return '';
    }
    return fullNsParts[baseNsParts.length];
}
exports.getNextLevelNsPart = getNextLevelNsPart;
/**
 * Loads the given trusted script.
 * @param {!tsickle_TrustedResourceUrl_6} trustedScript
 * @return {!Promise<void>}
 */
async function loadTrustedScript(trustedScript) {
    return new Promise((/**
     * @param {function((void|!PromiseLike<void>)): void} resolve
     * @return {void}
     */
    (resolve) => {
        /** @type {!HTMLScriptElement} */
        const script = document.createElement('script');
        dom_1.safeScriptEl.setSrc(script, trustedScript);
        script.onload = (/**
         * @return {void}
         */
        () => {
            script.remove();
            resolve();
        });
        document.body.appendChild(script);
    }));
}
exports.loadTrustedScript = loadTrustedScript;
/**
 * Processes the error message to make it more clear.
 * @param {string} msg
 * @return {string}
 */
function processErrorMessage(msg) {
    if (new RegExp(/Only `SavedModel`s with \d+ MetaGraph are supported. Instead, it has \d+/).test(msg)) {
        return `${msg}. Try using the "TF adapter (direct)" adapter.`;
    }
    return msg;
}
exports.processErrorMessage = processErrorMessage;
/**
 * Gets the search matches for the given node using regex.
 * @param {!Set<string>} shouldMatchTypes
 * @param {!RegExp} regex
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @return {{matches: !Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>, matchTypes: !Set<string>}}
 */
function getRegexMatchesForNode(shouldMatchTypes, regex, node, modelGraph) {
    /** @type {!Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>} */
    const matches = [];
    /** @type {!Set<string>} */
    const matchTypes = new Set();
    // Node label.
    if (shouldMatchTypes.has(types_1.SearchMatchType.NODE_LABEL) &&
        regex.test(node.label)) {
        matches.push({
            type: types_1.SearchMatchType.NODE_LABEL,
        });
        matchTypes.add(types_1.SearchMatchType.NODE_LABEL);
    }
    // Attribute.
    if (shouldMatchTypes.has(types_1.SearchMatchType.ATTRIBUTE)) {
        /** @type {?} */
        const attrs = getAttributesFromNode(node);
        for (const attrId of Object.keys(attrs)) {
            /** @type {string} */
            const value = attrs[attrId];
            /** @type {string} */
            const text1 = `${attrId}:${value}`;
            /** @type {string} */
            const text2 = `${attrId}=${value}`;
            if (regex.test(text1) || regex.test(text2)) {
                matches.push({
                    type: types_1.SearchMatchType.ATTRIBUTE,
                    matchedAttrId: attrId,
                });
                matchTypes.add(types_1.SearchMatchType.ATTRIBUTE);
            }
        }
    }
    // Inputs
    if (shouldMatchTypes.has(types_1.SearchMatchType.INPUT_METADATA) && isOpNode(node)) {
        for (const incomingEdge of (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).incomingEdges || []) {
            // Match source node's label.
            /** @type {!tsickle_model_graph_4.OpNode} */
            const sourceNode = (/** @type {!tsickle_model_graph_4.OpNode} */ (modelGraph.nodesById[incomingEdge.sourceNodeId]));
            if (regex.test(sourceNode.label)) {
                matches.push({
                    type: types_1.SearchMatchType.INPUT_METADATA,
                    matchedText: sourceNode.label,
                });
                matchTypes.add(types_1.SearchMatchType.INPUT_METADATA);
            }
            // Match tensor tag in current node's input metadata.
            /** @type {?} */
            const inputsMetadata = (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).inputsMetadata || {};
            /** @type {string} */
            const tensorTag = (inputsMetadata[incomingEdge.targetNodeInputId] || {})[consts_1.TENSOR_TAG_METADATA_KEY];
            if (tensorTag && regex.test(tensorTag)) {
                matches.push({
                    type: types_1.SearchMatchType.INPUT_METADATA,
                    matchedText: tensorTag,
                });
                matchTypes.add(types_1.SearchMatchType.INPUT_METADATA);
            }
            // Match source node's output metadata.
            /** @type {?} */
            const metadata = (sourceNode.outputsMetadata || {})[incomingEdge.sourceNodeOutputId] ||
                {};
            for (const metadataKey of Object.keys(metadata)) {
                if (metadataKey.startsWith('__')) {
                    continue;
                }
                /** @type {string} */
                const value = metadata[metadataKey];
                /** @type {string} */
                const text1 = `${metadataKey}:${value}`;
                /** @type {string} */
                const text2 = `${metadataKey}=${value}`;
                if (regex.test(value) || regex.test(text1) || regex.test(text2)) {
                    matches.push({
                        type: types_1.SearchMatchType.INPUT_METADATA,
                        matchedText: value,
                    });
                    matchTypes.add(types_1.SearchMatchType.INPUT_METADATA);
                }
            }
            // Match target node's input metadata.
            /** @type {?} */
            const curInputMetadata = inputsMetadata[incomingEdge.targetNodeInputId] || {};
            for (const metadataKey of Object.keys(curInputMetadata)) {
                if (metadataKey.startsWith('__')) {
                    continue;
                }
                /** @type {string} */
                const value = curInputMetadata[metadataKey];
                /** @type {string} */
                const text1 = `${metadataKey}:${value}`;
                /** @type {string} */
                const text2 = `${metadataKey}=${value}`;
                if (regex.test(value) || regex.test(text1) || regex.test(text2)) {
                    matches.push({
                        type: types_1.SearchMatchType.INPUT_METADATA,
                        matchedText: value,
                    });
                    matchTypes.add(types_1.SearchMatchType.INPUT_METADATA);
                }
            }
        }
    }
    // Outputs
    if (shouldMatchTypes.has(types_1.SearchMatchType.OUTPUT_METADATA) && isOpNode(node)) {
        /** @type {?} */
        const outputsMetadata = (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).outputsMetadata || {};
        for (const outgoingEdge of (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).outgoingEdges || []) {
            /** @type {!tsickle_model_graph_4.OpNode} */
            const targetNode = (/** @type {!tsickle_model_graph_4.OpNode} */ (modelGraph.nodesById[outgoingEdge.targetNodeId]));
            if (regex.test(targetNode.label)) {
                matches.push({
                    type: types_1.SearchMatchType.OUTPUT_METADATA,
                    matchedText: targetNode.label,
                });
                matchTypes.add(types_1.SearchMatchType.OUTPUT_METADATA);
            }
            // Match tensor tag in current node's output metadata.
            /** @type {string} */
            const tensorTag = (outputsMetadata[outgoingEdge.sourceNodeOutputId] ||
                {})[consts_1.TENSOR_TAG_METADATA_KEY];
            if (tensorTag && regex.test(tensorTag)) {
                matches.push({
                    type: types_1.SearchMatchType.OUTPUT_METADATA,
                    matchedText: tensorTag,
                });
                matchTypes.add(types_1.SearchMatchType.OUTPUT_METADATA);
            }
        }
        for (const metadata of Object.values(outputsMetadata)) {
            for (const metadataKey of Object.keys(metadata)) {
                if (metadataKey.startsWith('__')) {
                    continue;
                }
                /** @type {string} */
                const value = metadata[metadataKey];
                /** @type {string} */
                const text1 = `${metadataKey}:${value}`;
                /** @type {string} */
                const text2 = `${metadataKey}=${value}`;
                if (regex.test(value) || regex.test(text1) || regex.test(text2)) {
                    matches.push({
                        type: types_1.SearchMatchType.OUTPUT_METADATA,
                        matchedText: value,
                    });
                    matchTypes.add(types_1.SearchMatchType.OUTPUT_METADATA);
                }
            }
        }
    }
    return { matches, matchTypes };
}
exports.getRegexMatchesForNode = getRegexMatchesForNode;
/**
 * Gets the attributes from the given node.
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @return {?}
 */
function getAttributesFromNode(node) {
    /** @type {?} */
    let attrs = {};
    if (isOpNode(node)) {
        attrs = { ...((/** @type {!tsickle_model_graph_4.OpNode} */ (node)).attrs || {}) };
        // Add id to attribute.
        attrs['id'] = (/** @type {!tsickle_model_graph_4.OpNode} */ (node)).id;
    }
    else if (isGroupNode(node)) {
        attrs = {
            '#descendants': `${((/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).descendantsNodeIds || []).length}`,
            '#children': `${((/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).nsChildrenIds || []).length}`,
        };
    }
    return attrs;
}
exports.getAttributesFromNode = getAttributesFromNode;
/**
 * Gets the search matches for the given node using attr value range.
 * @param {string} attrName
 * @param {number} min
 * @param {number} max
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @return {!Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>}
 */
function getAttrValueRangeMatchesForNode(attrName, min, max, node, modelGraph) {
    /** @type {!Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>} */
    const matches = [];
    /** @type {?} */
    const attrs = getAttributesFromNode(node);
    /** @type {string} */
    const value = attrs[attrName];
    if (value != null) {
        /** @type {number} */
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue >= min && numValue <= max) {
            matches.push({
                type: types_1.SearchMatchType.ATTRIBUTE,
                matchedAttrId: attrName,
            });
        }
    }
    return matches;
}
exports.getAttrValueRangeMatchesForNode = getAttrValueRangeMatchesForNode;
/**
 * Checks if the given queries have non-empty queries.
 * @param {!Array<(!tsickle_types_5.NodeRegexQuery|!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery)>} queries
 * @return {boolean}
 */
function hasNonEmptyQueries(queries) {
    for (const query of queries.filter((/**
     * @param {(!tsickle_types_5.NodeRegexQuery|!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery)} query
     * @return {boolean}
     */
    (query) => query.type !== types_1.NodeQueryType.NODE_TYPE))) {
        switch (query.type) {
            case types_1.NodeQueryType.REGEX:
                if ((/** @type {!tsickle_types_5.NodeRegexQuery} */ (query)).queryRegex !== '') {
                    return true;
                }
                break;
            case types_1.NodeQueryType.ATTR_VALUE_RANGE:
                if ((/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).attrName !== '') {
                    return true;
                }
                break;
            default:
                break;
        }
    }
    return false;
}
exports.hasNonEmptyQueries = hasNonEmptyQueries;
/**
 * Processes the given node styler rules.
 * @param {!Array<!tsickle_types_5.NodeStylerRule>} rules
 * @return {!Array<!tsickle_types_5.ProcessedNodeStylerRule>}
 */
function processNodeStylerRules(rules) {
    return rules.map((/**
     * @param {!tsickle_types_5.NodeStylerRule} rule
     * @return {{queries: !Array<(!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)>, nodeType: !tsickle_types_5.SearchNodeType, styles: ?}}
     */
    (rule) => {
        /** @type {!Array<(undefined|!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)>} */
        const processedQueries = rule.queries.map((/**
         * @param {(!tsickle_types_5.NodeRegexQuery|!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery)} query
         * @return {(undefined|!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)}
         */
        (query) => {
            switch (query.type) {
                case types_1.NodeQueryType.REGEX: {
                    /** @type {!RegExp} */
                    let regex = new RegExp('', 'i');
                    try {
                        regex = new RegExp((/** @type {!tsickle_types_5.NodeRegexQuery} */ (query)).queryRegex, 'i');
                    }
                    catch (e) {
                        console.warn('Failed to create regex', e);
                    }
                    /** @type {!tsickle_types_5.ProcessedNodeRegexQuery} */
                    const processedQuery = {
                        type: types_1.NodeQueryType.REGEX,
                        queryRegex: regex,
                        matchTypes: new Set((/** @type {!tsickle_types_5.NodeRegexQuery} */ (query)).matchTypes),
                    };
                    return processedQuery;
                }
                case types_1.NodeQueryType.NODE_TYPE:
                case types_1.NodeQueryType.ATTR_VALUE_RANGE: {
                    return query;
                }
                default:
                    return undefined;
            }
        }));
        return {
            queries: (/** @type {!Array<(!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)>} */ (processedQueries)),
            nodeType: rule.nodeType,
            styles: rule.styles,
        };
    }));
}
exports.processNodeStylerRules = processNodeStylerRules;
/**
 * Checks if the given node matches the given queries.
 * @param {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} node
 * @param {!Array<(!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.NodeTypeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)>} queries
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @return {boolean}
 */
function matchNodeForQueries(node, queries, modelGraph) {
    /** @type {boolean} */
    let matchedAll = true;
    for (const query of queries) {
        if (query.type === types_1.NodeQueryType.NODE_TYPE) {
            /** @type {boolean} */
            let matched = true;
            if ((isOpNode(node) && (/** @type {!tsickle_types_5.NodeTypeQuery} */ (query)).nodeType === types_1.SearchNodeType.LAYER_NODES) ||
                (isGroupNode(node) && (/** @type {!tsickle_types_5.NodeTypeQuery} */ (query)).nodeType === types_1.SearchNodeType.OP_NODES)) {
                matched = false;
            }
            if (!matched) {
                matchedAll = false;
                break;
            }
        }
        else if ((/** @type {(!tsickle_types_5.NodeAttrValueRangeQuery|!tsickle_types_5.ProcessedNodeRegexQuery)} */ (query)).type === types_1.NodeQueryType.REGEX) {
            /** @type {!Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>} */
            const matches = getRegexMatchesForNode((/** @type {!tsickle_types_5.ProcessedNodeRegexQuery} */ (query)).matchTypes, (/** @type {!tsickle_types_5.ProcessedNodeRegexQuery} */ (query)).queryRegex, node, modelGraph).matches;
            if (matches.length === 0) {
                matchedAll = false;
                break;
            }
        }
        else if ((/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).type === types_1.NodeQueryType.ATTR_VALUE_RANGE) {
            if ((/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).attrName !== '') {
                /** @type {!Array<(!tsickle_types_5.SearchMatchNodeLabel|!tsickle_types_5.SearchMatchInputMetadata|!tsickle_types_5.SearchMatchOutputMetadata|!tsickle_types_5.SearchMatchAttr)>} */
                const matches = getAttrValueRangeMatchesForNode((/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).attrName, (/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).min ?? Number.NEGATIVE_INFINITY, (/** @type {!tsickle_types_5.NodeAttrValueRangeQuery} */ (query)).max ?? Number.POSITIVE_INFINITY, node, modelGraph);
                if (matches.length === 0) {
                    matchedAll = false;
                    break;
                }
            }
        }
        else {
            matchedAll = false;
        }
    }
    return matchedAll;
}
exports.matchNodeForQueries = matchNodeForQueries;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL2NvbW1vbi91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0Esa0ZBQTRDO0FBQzVDLHdIQU9rQjtBQUNsQixrSUFNdUI7QUFDdkIsc0hBaUJpQjs7TUFFWCxNQUFNLEdBQUcsSUFBSSxlQUFlLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQzs7Ozs7TUFHdEMsWUFBWSxHQUE4QixFQUFFOzs7Ozs7QUFHbEQsU0FBZ0IsUUFBUSxDQUFDLElBQTJCO0lBQ2xELE9BQU8sSUFBSSxFQUFFLFFBQVEsS0FBSyxzQkFBUSxDQUFDLE9BQU8sQ0FBQztBQUM3QyxDQUFDO0FBRkQsNEJBRUM7Ozs7OztBQUdELFNBQWdCLFdBQVcsQ0FBQyxJQUEyQjtJQUNyRCxPQUFPLElBQUksRUFBRSxRQUFRLEtBQUssc0JBQVEsQ0FBQyxVQUFVLENBQUM7QUFDaEQsQ0FBQztBQUZELGtDQUVDOzs7Ozs7O0FBTUQsU0FBZ0IsMEJBQTBCLENBQUMsSUFBZTtJQUN4RCxPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGtEQUFBLElBQUksRUFBQSxDQUFDLGFBQWEsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQ3RFLENBQUM7QUFGRCxnRUFFQzs7Ozs7O0FBR0QsU0FBZ0IsMkNBQTJDLENBQ3pELG1CQUF1RDs7VUFFakQsUUFBUSxHQUFpQixFQUFFO0lBQ2pDLEtBQUssTUFBTSxDQUFDLGdDQUFRLEVBQUUsZ0NBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsRUFBRSxDQUFDO2NBQTdELFFBQVE7Y0FBRSxRQUFRO1FBQzVC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SUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUN6QixVQUFVLEdBQUcsS0FBSyxDQUFDO2dCQUNuQixNQUFNO1lBQ1IsQ0FBQztRQUNILENBQUM7YUFBTSxJQUFJLDBEQUFBLEtBQUssRUFBQSxDQUFDLElBQUksS0FBSyxxQkFBYSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDekQsSUFBSSwwREFBQSxLQUFLLEVBQUEsQ0FBQyxRQUFRLEtBQUssRUFBRSxFQUFFLENBQUM7O3NCQUNwQixPQUFPLEdBQUcsK0JBQStCLENBQzdDLDBEQUFBLEtBQUssRUFBQSxDQUFDLFFBQVEsRUFDZCwwREFBQSxLQUFLLEVBQUEsQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLGlCQUFpQixFQUNyQywwREFBQSxLQUFLLEVBQUEsQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLGlCQUFpQixFQUNyQyxJQUFJLEVBQ0osVUFBVSxDQUNYO2dCQUNELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDekIsVUFBVSxHQUFHLEtBQUssQ0FBQztvQkFDbkIsTUFBTTtnQkFDUixDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7YUFBTSxDQUFDO1lBQ04sVUFBVSxHQUFHLEtBQUssQ0FBQztRQUNyQixDQUFDO0lBQ0gsQ0FBQztJQUNELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFqREQsa0RBaURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUcnVzdGVkUmVzb3VyY2VVcmx9IGZyb20gJ2dvb2dsZTMvdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzJztcbmltcG9ydCB7c2FmZVNjcmlwdEVsfSBmcm9tICdzYWZldmFsdWVzL2RvbSc7XG5pbXBvcnQge1xuICBDQVRNVUxMUk9NX0NVUlZFX1RFTlNJT04sXG4gIE1BWF9JT19ST1dTX0lOX0FUVFJTX1RBQkxFLFxuICBOT0RFX0RBVEFfUFJPVklERVJfU0hPV19PTl9OT0RFX1RZUEVfUFJFRklYLFxuICBURU5TT1JfVEFHX01FVEFEQVRBX0tFWSxcbiAgVEVOU09SX1ZBTFVFU19LRVksXG4gIFdFQkdMX0NVUlZFX1NFR01FTlRTLFxufSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQge1xuICBHcm91cE5vZGUsXG4gIE1vZGVsR3JhcGgsXG4gIE1vZGVsTm9kZSxcbiAgTm9kZVR5cGUsXG4gIE9wTm9kZSxcbn0gZnJvbSAnLi9tb2RlbF9ncmFwaCc7XG5pbXBvcnQge1xuICBGaWVsZExhYmVsLFxuICBLZXlWYWx1ZUxpc3QsXG4gIEtleVZhbHVlUGFpcnMsXG4gIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhLFxuICBOb2RlUXVlcnksXG4gIE5vZGVRdWVyeVR5cGUsXG4gIE5vZGVTdHlsZXJSdWxlLFxuICBQb2ludCxcbiAgUHJvY2Vzc2VkTm9kZVF1ZXJ5LFxuICBQcm9jZXNzZWROb2RlUmVnZXhRdWVyeSxcbiAgUHJvY2Vzc2VkTm9kZVN0eWxlclJ1bGUsXG4gIFNlYXJjaE1hdGNoLFxuICBTZWFyY2hNYXRjaFR5cGUsXG4gIFNlYXJjaE5vZGVUeXBlLFxuICBTaG93T25Ob2RlSXRlbURhdGEsXG4gIFNob3dPbk5vZGVJdGVtVHlwZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IENBTlZBUyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMzAwLCAzMDApO1xuXG4vKiogQ2FjaGUgZm9yIGxhYmVsIHdpZHRoIGluZGV4ZWQgYnkgbGFiZWwuICovXG5jb25zdCBMQUJFTF9XSURUSFM6IHtbbGFiZWw6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcblxuLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGFuIG9wIG5vZGUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcE5vZGUobm9kZTogTW9kZWxOb2RlIHwgdW5kZWZpbmVkKTogbm9kZSBpcyBPcE5vZGUge1xuICByZXR1cm4gbm9kZT8ubm9kZVR5cGUgPT09IE5vZGVUeXBlLk9QX05PREU7XG59XG5cbi8qKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBpcyBhIGdyb3VwIG5vZGUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNHcm91cE5vZGUobm9kZTogTW9kZWxOb2RlIHwgdW5kZWZpbmVkKTogbm9kZSBpcyBHcm91cE5vZGUge1xuICByZXR1cm4gbm9kZT8ubm9kZVR5cGUgPT09IE5vZGVUeXBlLkdST1VQX05PREU7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgaXMgYSBncm91cCBub2RlIGFuZCBpdCBkb2Vzbid0IGhhdmUgYW55XG4gKiBjaGlsZHJlbiBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBOb2RlV2l0aG91dENoaWxkcmVuKG5vZGU6IE1vZGVsTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNHcm91cE5vZGUobm9kZSkgJiYgKG5vZGUubnNDaGlsZHJlbklkcyB8fCBbXSkubGVuZ3RoID09PSAwO1xufVxuXG4vKiogR2V0cyB0aGUgb3Agbm9kZSBmaWVsZCBsYWJlbHMgZnJvbSB0aGUgZ2l2ZW4gc2hvd09uTm9kZUl0ZW1UeXBlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcE5vZGVGaWVsZExhYmVsc0Zyb21TaG93T25Ob2RlSXRlbVR5cGVzKFxuICBzaG93T25Ob2RlSXRlbVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+LFxuKTogRmllbGRMYWJlbFtdIHtcbiAgY29uc3QgZmllbGRJZHM6IEZpZWxkTGFiZWxbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtpdGVtVHlwZSwgaXRlbURhdGFdIG9mIE9iamVjdC5lbnRyaWVzKHNob3dPbk5vZGVJdGVtVHlwZXMpKSB7XG4gICAgc3dpdGNoIChpdGVtVHlwZSkge1xuICAgICAgY2FzZSBTaG93T25Ob2RlSXRlbVR5cGUuT1BfTk9ERV9JRDpcbiAgICAgICAgaWYgKGl0ZW1EYXRhLnNlbGVjdGVkKSB7XG4gICAgICAgICAgZmllbGRJZHMucHVzaChGaWVsZExhYmVsLk9QX05PREVfSUQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWVsZElkcztcbn1cblxuLyoqIEdldHMgdGhlIGdyb3VwIG5vZGUgZmllbGQgbGFiZWxzIGZyb20gdGhlIGdpdmVuIHNob3dPbk5vZGVJdGVtVHlwZXMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JvdXBOb2RlRmllbGRMYWJlbHNGcm9tU2hvd09uTm9kZUl0ZW1UeXBlcyhcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbik6IEZpZWxkTGFiZWxbXSB7XG4gIGNvbnN0IGZpZWxkSWRzOiBGaWVsZExhYmVsW10gPSBbXTtcbiAgZm9yIChjb25zdCBbaXRlbVR5cGUsIGl0ZW1EYXRhXSBvZiBPYmplY3QuZW50cmllcyhzaG93T25Ob2RlSXRlbVR5cGVzKSkge1xuICAgIHN3aXRjaCAoaXRlbVR5cGUpIHtcbiAgICAgIGNhc2UgU2hvd09uTm9kZUl0ZW1UeXBlLkxBWUVSX05PREVfQ0hJTERSRU5fQ09VTlQ6XG4gICAgICAgIGlmIChpdGVtRGF0YS5zZWxlY3RlZCkge1xuICAgICAgICAgIGZpZWxkSWRzLnB1c2goRmllbGRMYWJlbC5OVU1CRVJfT0ZfQ0hJTERSRU4pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaG93T25Ob2RlSXRlbVR5cGUuTEFZRVJfTk9ERV9ERVNDRU5EQU5UU19DT1VOVDpcbiAgICAgICAgaWYgKGl0ZW1EYXRhLnNlbGVjdGVkKSB7XG4gICAgICAgICAgZmllbGRJZHMucHVzaChGaWVsZExhYmVsLk5VTUJFUl9PRl9ERVNDRU5EQU5UUyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpZWxkSWRzO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gZmllbGQgaWQgb2YgYSBub2RlJ3MgaW5mby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVJbmZvRmllbGRWYWx1ZShcbiAgbm9kZTogTW9kZWxOb2RlLFxuICBmaWVsZElkOiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICBpZiAoaXNPcE5vZGUobm9kZSkpIHtcbiAgICBzd2l0Y2ggKGZpZWxkSWQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBGaWVsZExhYmVsLk9QX05PREVfSUQ6XG4gICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgICAgY2FzZSAnbmFtZXNwYWNlJzpcbiAgICAgICAgcmV0dXJuIGdldE5hbWVzcGFjZUxhYmVsKG5vZGUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzR3JvdXBOb2RlKG5vZGUpKSB7XG4gICAgc3dpdGNoIChmaWVsZElkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ25hbWVzcGFjZSc6XG4gICAgICAgIHJldHVybiBnZXROYW1lc3BhY2VMYWJlbChub2RlKTtcbiAgICAgIGNhc2UgRmllbGRMYWJlbC5OVU1CRVJfT0ZfQ0hJTERSRU46XG4gICAgICAgIHJldHVybiBTdHJpbmcoKG5vZGUubnNDaGlsZHJlbklkcyB8fCBbXSkubGVuZ3RoKTtcbiAgICAgIGNhc2UgRmllbGRMYWJlbC5OVU1CRVJfT0ZfREVTQ0VOREFOVFM6XG4gICAgICAgIHJldHVybiBTdHJpbmcoKG5vZGUuZGVzY2VuZGFudHNOb2RlSWRzIHx8IFtdKS5sZW5ndGgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqIEdldHMgbmFtZXNwYWNlIGRpc3BsYXkgbGFiZWwuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlTGFiZWwobm9kZTogTW9kZWxOb2RlKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5vZGUuc2F2ZWROYW1lc3BhY2UgfHwgbm9kZS5uYW1lc3BhY2UgfHwgJzxyb290Pic7XG59XG5cbi8qKiBHZW5lcmF0ZXMgdW5pcXVlIGlkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlblVpZCgpOiBzdHJpbmcge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoLTYpO1xufVxuXG4vKiogR2V0cyB0aGUgZGVlcGVzdCBleHBhbmRlZCBncm91cCBub2RlIGlkcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMoXG4gIHJvb3Q6IEdyb3VwTm9kZSB8IHVuZGVmaW5lZCxcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbiAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzOiBzdHJpbmdbXSxcbikge1xuICBsZXQgbnNDaGlsZHJlbklkczogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHJvb3QgPT0gbnVsbCkge1xuICAgIG5zQ2hpbGRyZW5JZHMgPSBtb2RlbEdyYXBoLnJvb3ROb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICB9IGVsc2Uge1xuICAgIG5zQ2hpbGRyZW5JZHMgPSByb290Lm5zQ2hpbGRyZW5JZHMgfHwgW107XG4gIH1cbiAgZm9yIChjb25zdCBuc0NoaWxkTm9kZUlkIG9mIG5zQ2hpbGRyZW5JZHMpIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtuc0NoaWxkTm9kZUlkXTtcbiAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc0dyb3VwTm9kZShjaGlsZE5vZGUpICYmIGNoaWxkTm9kZS5leHBhbmRlZCkge1xuICAgICAgY29uc3QgaXNEZWVwZXN0ID0gKGNoaWxkTm9kZS5uc0NoaWxkcmVuSWRzIHx8IFtdKVxuICAgICAgICAuZmlsdGVyKChpZCkgPT4gaXNHcm91cE5vZGUobW9kZWxHcmFwaC5ub2Rlc0J5SWRbaWRdKSlcbiAgICAgICAgLmV2ZXJ5KChpZCkgPT4gIShtb2RlbEdyYXBoLm5vZGVzQnlJZFtpZF0gYXMgR3JvdXBOb2RlKS5leHBhbmRlZCk7XG4gICAgICBpZiAoaXNEZWVwZXN0KSB7XG4gICAgICAgIGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcy5wdXNoKGNoaWxkTm9kZS5pZCk7XG4gICAgICB9XG4gICAgICBnZXREZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMoXG4gICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEdldHMgdGhlIHBvaW50cyBmcm9tIGEgc21vb3RoIGN1cnZlIHRoYXQgZ28gdGhyb3VnaCB0aGUgZ2l2ZW4gcG9pbnRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ3VydmVQb2ludHMoXG4gIHBvaW50czogUG9pbnRbXSxcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBBbGxvdyBhcmJpdHJhcnkgdHlwZXMuXG4gIGQzTGluZTogYW55LFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IEFsbG93IGFyYml0cmFyeSB0eXBlcy5cbiAgZDNDdXJ2ZU1vbm90b25lWTogYW55LFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IEFsbG93IGFyYml0cmFyeSB0eXBlcy5cbiAgdGhyZWU6IGFueSxcbik6IFBvaW50W10ge1xuICBsZXQgY3VydmVQb2ludHM6IFBvaW50W10gPSBbXTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjdXJ2ZVBvaW50cyA9IHBvaW50cztcbiAgfSBlbHNlIGlmIChcbiAgICBwb2ludHMubGVuZ3RoID09PSAzICYmXG4gICAgcG9pbnRzWzBdLnggPT09IHBvaW50c1sxXS54ICYmXG4gICAgcG9pbnRzWzFdLnggPT09IHBvaW50c1syXS54XG4gICkge1xuICAgIGN1cnZlUG9pbnRzID0gcG9pbnRzO1xuICB9IGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHBvaW50cyBhcmUgc29ydGVkIGJ5IHRoZWlyIFkgY29vcmRpbmF0ZS5cbiAgICBsZXQgaXNZU29ydGVkID0gdHJ1ZTtcbiAgICBsZXQgY3VyT3JkZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgY3VyUHQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBuZXh0UHQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgY29uc3Qgb3JkZXIgPSBuZXh0UHQgPiBjdXJQdCA/IDEgOiAtMTtcbiAgICAgIGlmIChjdXJPcmRlciAhPT0gMCAmJiBjdXJPcmRlciAhPT0gb3JkZXIpIHtcbiAgICAgICAgaXNZU29ydGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VyT3JkZXIgPSBvcmRlcjtcbiAgICB9XG5cbiAgICAvLyBJZiB5cyBhcmUgc29ydGVkLCB1c2UgZDMncyBjdXJ2ZU1vbm90b25lWSB0byBnZW5lcmF0ZSBjdXJ2ZXMgYW5kXG4gICAgLy8gY29udmVydCB0aGVtIHRvIGEgQ3VydmVQYXRoIGluIHRocmVlanMuIGN1cnZlTW9ub3RvbmVZIGxvb2tzIGJldHRlclxuICAgIC8vIHRoZW4gY2F0bXVsbHJvbSBjdXJ2ZXMuXG4gICAgY29uc3QgdmVjMyA9IHRocmVlWydWZWN0b3IzJ107XG4gICAgaWYgKGlzWVNvcnRlZCkge1xuICAgICAgY29uc3QgZDNDdXJ2ZSA9IGQzTGluZSgpXG4gICAgICAgIC54KChkOiBQb2ludCkgPT4gZC54KVxuICAgICAgICAueSgoZDogUG9pbnQpID0+IGQueSlcbiAgICAgICAgLmN1cnZlKGQzQ3VydmVNb25vdG9uZVkpKHBvaW50cykgYXMgc3RyaW5nO1xuICAgICAgY29uc3QgcGFydHMgPSBkM0N1cnZlXG4gICAgICAgIC5zcGxpdCgvTXxDLylcbiAgICAgICAgLmZpbHRlcigocykgPT4gcyAhPT0gJycpXG4gICAgICAgIC5tYXAoKHMpID0+IHMuc3BsaXQoJywnKS5tYXAoKHMpID0+IE51bWJlcihzKSkpO1xuICAgICAgbGV0IGN1clN0YXJ0UG9pbnQgPSBuZXcgdmVjMyhwYXJ0c1swXVswXSwgcGFydHNbMF1bMV0sIDApO1xuICAgICAgY29uc3QgY3VydmVQYXRoID0gbmV3IHRocmVlWydDdXJ2ZVBhdGgnXSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJQYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChjdXJQYXJ0Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgIGNvbnN0IHB0U3RhcnQgPSBjdXJTdGFydFBvaW50O1xuICAgICAgICAgIGNvbnN0IGMxID0gbmV3IHZlYzMoY3VyUGFydFswXSwgY3VyUGFydFsxXSk7XG4gICAgICAgICAgY29uc3QgYzIgPSBuZXcgdmVjMyhjdXJQYXJ0WzJdLCBjdXJQYXJ0WzNdKTtcbiAgICAgICAgICBjb25zdCBwdEVuZCA9IG5ldyB2ZWMzKGN1clBhcnRbNF0sIGN1clBhcnRbNV0pO1xuICAgICAgICAgIGN1clN0YXJ0UG9pbnQgPSBwdEVuZDtcbiAgICAgICAgICBjb25zdCBjdXJ2ZSA9IG5ldyB0aHJlZVsnQ3ViaWNCZXppZXJDdXJ2ZTMnXShwdFN0YXJ0LCBjMSwgYzIsIHB0RW5kKTtcbiAgICAgICAgICBjdXJ2ZVBhdGguYWRkKGN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VydmVQb2ludHMgPSBjdXJ2ZVBhdGhbJ2dldFBvaW50cyddKFdFQkdMX0NVUlZFX1NFR01FTlRTKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGNhdG11bGxyb20gY3VydmUuXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB2M1BvaW50cyA9IHBvaW50cy5tYXAoKHBvaW50KSA9PiBuZXcgdmVjMyhwb2ludC54LCBwb2ludC55LCAwKSk7XG4gICAgICBjb25zdCBjdXJ2ZSA9IG5ldyB0aHJlZVsnQ2F0bXVsbFJvbUN1cnZlMyddKFxuICAgICAgICB2M1BvaW50cyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdjYXRtdWxscm9tJyxcbiAgICAgICAgQ0FUTVVMTFJPTV9DVVJWRV9URU5TSU9OLFxuICAgICAgKTtcbiAgICAgIGN1cnZlUG9pbnRzID0gY3VydmVbJ2dldFBvaW50cyddKFdFQkdMX0NVUlZFX1NFR01FTlRTKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnZlUG9pbnRzO1xufVxuXG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGFuIGlucHV0IGVsZW1lbnQuICovXG5leHBvcnQgZnVuY3Rpb24gaW5JbnB1dEVsZW1lbnQoKSB7XG4gIGNvbnN0IGFjdGl2ZUVsZSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgaWYgKCFhY3RpdmVFbGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaXNJbnB1dEVsZW1lbnQgPVxuICAgIGFjdGl2ZUVsZS50YWdOYW1lID09PSAnSU5QVVQnIHx8XG4gICAgYWN0aXZlRWxlLnRhZ05hbWUgPT09ICdTRUxFQ1QnIHx8XG4gICAgYWN0aXZlRWxlLnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHxcbiAgICBhY3RpdmVFbGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG4gIHJldHVybiBpc0lucHV0RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChcbiAgcm9vdDogRG9jdW1lbnQgfCBTaGFkb3dSb290ID0gZG9jdW1lbnQsXG4pOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICBjb25zdCBhY3RpdmVFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gcm9vdC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuICBpZiAoIWFjdGl2ZUVsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGFjdGl2ZUVsLnNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gZ2V0QWN0aXZlRWxlbWVudChhY3RpdmVFbC5zaGFkb3dSb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWN0aXZlRWw7XG4gIH1cbn1cblxuLyoqIEdldHMgdGhlIGxhYmVsIHdpZHRoIGJ5IG1lYXN1cmVpbmcgaXRzIHNpemUgaW4gY2FudmFzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhYmVsV2lkdGgoXG4gIGxhYmVsOiBzdHJpbmcsXG4gIGZvbnRTaXplOiBudW1iZXIsXG4gIGJvbGQ6IGJvb2xlYW4sXG4gIHNhdmVUb0NhY2hlID0gdHJ1ZSxcbik6IG51bWJlciB7XG4gIC8vIENoZWNrIGNhY2hlIGZpcnN0LlxuICBjb25zdCBrZXkgPSBgJHtsYWJlbH1fX18ke2ZvbnRTaXplfV9fXyR7Ym9sZH1gO1xuICBsZXQgbGFiZWxXaWR0aCA9IExBQkVMX1dJRFRIU1trZXldO1xuICBpZiAobGFiZWxXaWR0aCA9PSBudWxsKSB7XG4gICAgLy8gT24gY2FjaGUgbWlzcywgcmVuZGVyIHRoZSB0ZXh0IHRvIGEgb2Zmc2NyZWVuIGNhbnZhcyB0byBnZXQgaXRzIHdpZHRoLlxuICAgIGNvbnN0IGNvbnRleHQgPSBDQU5WQVMuZ2V0Q29udGV4dCgnMmQnKSEgYXMge30gYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIGNvbnRleHQuZm9udCA9IGAke2ZvbnRTaXplfXB4IFwiR29vZ2xlIFNhbnMgVGV4dFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmYDtcbiAgICBpZiAoYm9sZCkge1xuICAgICAgY29udGV4dC5mb250ID0gYGJvbGQgJHtjb250ZXh0LmZvbnR9YDtcbiAgICB9XG4gICAgY29uc3QgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpO1xuICAgIGNvbnN0IHdpZHRoID0gbWV0cmljcy53aWR0aDtcbiAgICBpZiAoc2F2ZVRvQ2FjaGUpIHtcbiAgICAgIExBQkVMX1dJRFRIU1trZXldID0gd2lkdGg7XG4gICAgfVxuICAgIGxhYmVsV2lkdGggPSB3aWR0aDtcbiAgfVxuICByZXR1cm4gbGFiZWxXaWR0aDtcbn1cblxuLyoqIEdldHMgdGhlIGlucHV0IGxhYmVsIGZvciB0aGUgYXR0cnMgdGFibGUgZnJvbSB0aGUgZ2l2ZW4gbm9kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnB1dExhYmVsRm9yQXR0cnNUYWJsZShcbiAgaW5kZXg6IG51bWJlcixcbiAgbm9kZTogT3BOb2RlLFxuICBtZXRhZGF0YTogS2V5VmFsdWVQYWlycyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHRlbnNvclRhZyA9IG1ldGFkYXRhW1RFTlNPUl9UQUdfTUVUQURBVEFfS0VZXTtcbiAgcmV0dXJuIHRlbnNvclRhZ1xuICAgID8gYElucHV0JHtpbmRleH06JHt0ZW5zb3JUYWd9ICgke25vZGUubGFiZWx9KWBcbiAgICA6IGBJbnB1dCR7aW5kZXh9ICgke25vZGUubGFiZWx9KWA7XG59XG5cbi8qKiBHZXRzIHRoZSBvdXRwdXQgbGFiZWwgZm9yIHRoZSBhdHRycyB0YWJsZSBmcm9tIHRoZSBnaXZlbiBub2RlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE91dHB1dExhYmVsRm9yQXR0cnNUYWJsZShcbiAgaW5kZXg6IG51bWJlcixcbiAgb3V0cHV0TWV0YWRhdGE6IEtleVZhbHVlUGFpcnMsXG4gIG5vZGU6IE9wTm9kZSxcbik6IHN0cmluZyB7XG4gIGxldCBsYWJlbCA9IGBPdXRwdXQke2luZGV4fWA7XG4gIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIFwiR3JhcGhJbnB1dHNcIi5cbiAgaWYgKG5vZGUubGFiZWwgPT09ICdHcmFwaElucHV0cycpIHtcbiAgICBjb25zdCB0ZW5zb3JOYW1lID0gb3V0cHV0TWV0YWRhdGFbJ3RlbnNvcl9uYW1lJ107XG4gICAgaWYgKHRlbnNvck5hbWUgIT0gbnVsbCkge1xuICAgICAgbGFiZWwgPSBgJHtsYWJlbH0gKCR7dGVuc29yTmFtZX0pYDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGVuc29yVGFnID0gb3V0cHV0TWV0YWRhdGFbVEVOU09SX1RBR19NRVRBREFUQV9LRVldO1xuICAgIGlmICh0ZW5zb3JUYWcpIHtcbiAgICAgIGxhYmVsID0gYE91dHB1dCR7aW5kZXh9OiR7dGVuc29yVGFnfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYWJlbDtcbn1cblxuLyoqIEdldHMgdGhlIHNoYXBlIGZvciB0aGUgYXR0cnMgdGFibGUgZnJvbSB0aGUgZ2l2ZW4gbm9kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFwZUZvckF0dHJzVGFibGUoaXRlbXM/OiBLZXlWYWx1ZVBhaXJzKTogc3RyaW5nIHtcbiAgbGV0IHNoYXBlID0gKChpdGVtcyB8fCB7fSlbJ3NoYXBlJ10gfHwgJycpXG4gICAgLnJlcGxhY2UoLyAvZywgJycpXG4gICAgLnJlcGxhY2UoL8OXL2csICd4Jyk7XG4gIGlmIChzaGFwZSA9PT0gJycpIHtcbiAgICBzaGFwZSA9ICc/JztcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59XG5cbi8qKiBHZXRzIHRoZSBrZXkgdmFsdWUgcGFpcnMgZm9yIHRoZSBnaXZlbiBub2RlJ3MgYXR0cnMgZm9yIGF0dHJzIHRhYmxlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9wTm9kZUF0dHJzS2V5VmFsdWVQYWlyc0ZvckF0dHJzVGFibGUoXG4gIG5vZGU6IE9wTm9kZSxcbiAgZmlsdGVyUmVnZXggPSAnJyxcbikge1xuICBjb25zdCBhdHRycyA9IG5vZGUuYXR0cnMgfHwge307XG4gIGNvbnN0IGtleVZhbHVlUGFpcnM6IEtleVZhbHVlTGlzdCA9IFtdO1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoZmlsdGVyUmVnZXgsICdpJyk7XG4gIGZvciAoY29uc3QgYXR0cklkIG9mIE9iamVjdC5rZXlzKGF0dHJzKSkge1xuICAgIGNvbnN0IGtleSA9IGF0dHJJZDtcbiAgICBjb25zdCB2YWx1ZSA9IGF0dHJzW2F0dHJJZF07XG4gICAgY29uc3QgbWF0Y2hUYXJnZXRzID0gW2Ake2tleX06JHt2YWx1ZX1gLCBgJHtrZXl9PSR7dmFsdWV9YF07XG4gICAgaWYgKFxuICAgICAgZmlsdGVyUmVnZXgudHJpbSgpID09PSAnJyB8fFxuICAgICAgbWF0Y2hUYXJnZXRzLnNvbWUoKG1hdGNoVGFyZ2V0KSA9PiByZWdleC50ZXN0KG1hdGNoVGFyZ2V0KSlcbiAgICApIHtcbiAgICAgIC8vIFJlbW92ZSBuZXcgbGluZSBjaGFycyBhbmQgc3BhY2VzLlxuICAgICAgbGV0IHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAoa2V5ID09PSBURU5TT1JfVkFMVUVTX0tFWSkge1xuICAgICAgICAvLyBGb3IgX192YWx1ZSBhdHRyaWJ1dGUsIHJlbW92ZSBhbGwgd2hpdGUgc3BhY2UgY2hhcnMuXG4gICAgICAgIHByb2Nlc3NlZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2dtLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgYXR0cmlidXRlcywgb25seSByZW1vdmUgbmV3bGluZSBjaGFycy5cbiAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2dtLCAnJyk7XG4gICAgICB9XG4gICAgICBrZXlWYWx1ZVBhaXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiBwcm9jZXNzZWRWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5VmFsdWVQYWlycztcbn1cblxuLyoqIEdldHMgdGhlIGtleSB2YWx1ZSBwYWlycyBmb3IgdGhlIGdpdm4gbm9kZSdzIGlucHV0IGZvciBhdHRycyB0YWJsZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcE5vZGVJbnB1dHNLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZShcbiAgbm9kZTogT3BOb2RlLFxuICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuKTogS2V5VmFsdWVMaXN0IHtcbiAgY29uc3QgaW5jb21pbmdFZGdlcyA9IG5vZGUuaW5jb21pbmdFZGdlcyB8fCBbXTtcbiAgY29uc3Qga2V5VmFsdWVQYWlyczogS2V5VmFsdWVMaXN0ID0gW107XG4gIGZvciAoXG4gICAgbGV0IGkgPSAwO1xuICAgIGkgPCBNYXRoLm1pbihNQVhfSU9fUk9XU19JTl9BVFRSU19UQUJMRSwgaW5jb21pbmdFZGdlcy5sZW5ndGgpO1xuICAgIGkrK1xuICApIHtcbiAgICBjb25zdCBpbmNvbWluZ0VkZ2UgPSBpbmNvbWluZ0VkZ2VzW2ldO1xuICAgIGNvbnN0IHNvdXJjZU5vZGVJZCA9IGluY29taW5nRWRnZS5zb3VyY2VOb2RlSWQ7XG4gICAgY29uc3Qgc291cmNlTm9kZSA9IG1vZGVsR3JhcGgubm9kZXNCeUlkW3NvdXJjZU5vZGVJZF0gYXMgT3BOb2RlO1xuICAgIGNvbnN0IHNvdXJjZU5vZGVTaGFwZSA9IGdldFNoYXBlRm9yQXR0cnNUYWJsZShcbiAgICAgIChzb3VyY2VOb2RlLm91dHB1dHNNZXRhZGF0YSB8fCB7fSlbaW5jb21pbmdFZGdlLnNvdXJjZU5vZGVPdXRwdXRJZF0sXG4gICAgKTtcbiAgICBjb25zdCBpbnB1dE1ldGFkYXRhID1cbiAgICAgIChub2RlLmlucHV0c01ldGFkYXRhIHx8IHt9KVtpbmNvbWluZ0VkZ2UudGFyZ2V0Tm9kZUlucHV0SWRdIHx8IHt9O1xuICAgIGtleVZhbHVlUGFpcnMucHVzaCh7XG4gICAgICBrZXk6IGdldElucHV0TGFiZWxGb3JBdHRyc1RhYmxlKGksIHNvdXJjZU5vZGUsIGlucHV0TWV0YWRhdGEpLFxuICAgICAgdmFsdWU6IHNvdXJjZU5vZGVTaGFwZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpbmNvbWluZ0VkZ2VzLmxlbmd0aCA+IE1BWF9JT19ST1dTX0lOX0FUVFJTX1RBQkxFKSB7XG4gICAgY29uc3Qgb3Zlck1heENvdW50ID0gaW5jb21pbmdFZGdlcy5sZW5ndGggLSBNQVhfSU9fUk9XU19JTl9BVFRSU19UQUJMRTtcbiAgICBrZXlWYWx1ZVBhaXJzLnB1c2goe1xuICAgICAga2V5OiBgKCR7b3Zlck1heENvdW50fSBtb3JlIGlucHV0JHtcbiAgICAgICAgb3Zlck1heENvdW50ID09PSAxID8gJycgOiAncydcbiAgICAgIH0gb21pdHRlZClgLFxuICAgICAgdmFsdWU6ICcuLi4nLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGtleVZhbHVlUGFpcnM7XG59XG5cbi8qKiBHZXRzIHRoZSBrZXkgdmFsdWUgcGFpcnMgZm9yIHRoZSBnaXZlbiBub2RlJ3Mgb3V0cHV0cyBmb3IgYXR0cnMgdGFibGUuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BOb2RlT3V0cHV0c0tleVZhbHVlUGFpcnNGb3JBdHRyc1RhYmxlKFxuICBub2RlOiBPcE5vZGUsXG4pOiBLZXlWYWx1ZUxpc3Qge1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzOiBLZXlWYWx1ZUxpc3QgPSBbXTtcbiAgY29uc3Qgb3V0cHV0c01ldGFkYXRhID0gbm9kZS5vdXRwdXRzTWV0YWRhdGEgfHwge307XG4gIGNvbnN0IG91dHB1dERhdGFMaXN0ID0gT2JqZWN0LnZhbHVlcyhvdXRwdXRzTWV0YWRhdGEpO1xuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgTWF0aC5taW4oTUFYX0lPX1JPV1NfSU5fQVRUUlNfVEFCTEUsIG91dHB1dERhdGFMaXN0Lmxlbmd0aCk7XG4gICAgaSsrXG4gICkge1xuICAgIGNvbnN0IG91dHB1dERhdGEgPSBvdXRwdXREYXRhTGlzdFtpXTtcbiAgICBjb25zdCBzaGFwZSA9IGdldFNoYXBlRm9yQXR0cnNUYWJsZShvdXRwdXREYXRhKTtcbiAgICBrZXlWYWx1ZVBhaXJzLnB1c2goe1xuICAgICAga2V5OiBnZXRPdXRwdXRMYWJlbEZvckF0dHJzVGFibGUoaSwgb3V0cHV0RGF0YSwgbm9kZSksXG4gICAgICB2YWx1ZTogc2hhcGUsXG4gICAgfSk7XG4gIH1cblxuICBpZiAob3V0cHV0RGF0YUxpc3QubGVuZ3RoID4gTUFYX0lPX1JPV1NfSU5fQVRUUlNfVEFCTEUpIHtcbiAgICBjb25zdCBvdmVyTWF4Q291bnQgPSBvdXRwdXREYXRhTGlzdC5sZW5ndGggLSBNQVhfSU9fUk9XU19JTl9BVFRSU19UQUJMRTtcbiAgICBrZXlWYWx1ZVBhaXJzLnB1c2goe1xuICAgICAga2V5OiBgKCR7b3Zlck1heENvdW50fSBtb3JlIG91dHB1dCR7XG4gICAgICAgIG92ZXJNYXhDb3VudCA9PT0gMSA/ICcnIDogJ3MnXG4gICAgICB9IG9taXR0ZWQpYCxcbiAgICAgIHZhbHVlOiAnLi4uJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBrZXlWYWx1ZVBhaXJzO1xufVxuXG4vKiogR2V0cyB0aGUga2V5IHZhbHVlIHBhaXJzIGZvciB0aGUgZ2l2ZW4gbm9kZSdzIGRhdGEgcHJvdmlkZXIgcnVucy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcE5vZGVEYXRhUHJvdmlkZXJLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZShcbiAgbm9kZTogT3BOb2RlLFxuICBtb2RlbEdyYXBoSWQ6IHN0cmluZyxcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbiAgY3VyTm9kZURhdGFQcm92aWRlclJ1bnM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhPixcbik6IEtleVZhbHVlTGlzdCB7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnM6IEtleVZhbHVlTGlzdCA9IFtdO1xuICBjb25zdCBydW5OYW1lcyA9IE9iamVjdC5rZXlzKHNob3dPbk5vZGVJdGVtVHlwZXMpXG4gICAgLmZpbHRlcigodHlwZSkgPT4gc2hvd09uTm9kZUl0ZW1UeXBlc1t0eXBlXS5zZWxlY3RlZClcbiAgICAuZmlsdGVyKChpdGVtVHlwZTogc3RyaW5nKSA9PlxuICAgICAgaXRlbVR5cGUuc3RhcnRzV2l0aChOT0RFX0RBVEFfUFJPVklERVJfU0hPV19PTl9OT0RFX1RZUEVfUFJFRklYKSxcbiAgICApXG4gICAgLm1hcCgodHlwZSkgPT5cbiAgICAgIHR5cGUucmVwbGFjZShOT0RFX0RBVEFfUFJPVklERVJfU0hPV19PTl9OT0RFX1RZUEVfUFJFRklYLCAnJyksXG4gICAgKTtcbiAgY29uc3QgcnVucyA9IE9iamVjdC52YWx1ZXMoY3VyTm9kZURhdGFQcm92aWRlclJ1bnMpLmZpbHRlcigocnVuKSA9PlxuICAgIHJ1bk5hbWVzLmluY2x1ZGVzKHJ1bi5ydW5OYW1lKSxcbiAgKTtcbiAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgIGNvbnN0IHZhbHVlID0gKHJ1bi5yZXN1bHRzIHx8IHt9KT8uW21vZGVsR3JhcGhJZF1bbm9kZS5pZF0/LnN0clZhbHVlIHx8ICctJztcbiAgICBrZXlWYWx1ZVBhaXJzLnB1c2goe2tleTogcnVuLnJ1bk5hbWUsIHZhbHVlfSk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbHVlUGFpcnM7XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIG5hbWVzcGFjZSBzdHJpbmdzLCBlLmcuIGEvYi9jL2QgYW5kIGEvYi94LCByZXR1cm5zIHRoZSBjb21tb25cbiAqIHByZWZpeCwgZS5nLiBhL2IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ29tbW9uTmFtZXNwYWNlKG5zMTogc3RyaW5nLCBuczI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IG5zMVBhcnRzID0gbnMxLnNwbGl0KCcvJyk7XG4gIGNvbnN0IG5zMlBhcnRzID0gbnMyLnNwbGl0KCcvJyk7XG4gIGxldCBjb21tb25QcmVmaXggPSAnJztcbiAgZm9yIChsZXQgaSA9IE1hdGgubWluKG5zMVBhcnRzLmxlbmd0aCwgbnMyUGFydHMubGVuZ3RoKTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IG5zMVByZWZpeCA9IG5zMVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy8nKTtcbiAgICBjb25zdCBuczJQcmVmaXggPSBuczJQYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJyk7XG4gICAgaWYgKG5zMVByZWZpeCA9PT0gbnMyUHJlZml4KSB7XG4gICAgICBjb21tb25QcmVmaXggPSBuczJQcmVmaXg7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1vblByZWZpeDtcbn1cblxuLyoqIEdldHMgdGhlIG5leHQgbGV2ZWwgbmFtZXNwYWNlIHBhcnQgcmlnaHQgYWZ0ZXIgYmFzZU5zIHVwIHRvIGZ1bGxOcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0TGV2ZWxOc1BhcnQoYmFzZU5zOiBzdHJpbmcsIGZ1bGxOczogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGJhc2VOcyA9PT0gZnVsbE5zKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGJhc2VOc1BhcnRzID0gYmFzZU5zLnNwbGl0KCcvJykuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0ICE9PSAnJyk7XG4gIGNvbnN0IGZ1bGxOc1BhcnRzID0gZnVsbE5zLnNwbGl0KCcvJykuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0ICE9PSAnJyk7XG4gIGlmIChmdWxsTnNQYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGZ1bGxOc1BhcnRzW2Jhc2VOc1BhcnRzLmxlbmd0aF07XG59XG5cbi8qKiBMb2FkcyB0aGUgZ2l2ZW4gdHJ1c3RlZCBzY3JpcHQuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRydXN0ZWRTY3JpcHQoXG4gIHRydXN0ZWRTY3JpcHQ6IFRydXN0ZWRSZXNvdXJjZVVybCxcbik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzYWZlU2NyaXB0RWwuc2V0U3JjKHNjcmlwdCwgdHJ1c3RlZFNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSk7XG59XG5cbi8qKiBQcm9jZXNzZXMgdGhlIGVycm9yIG1lc3NhZ2UgdG8gbWFrZSBpdCBtb3JlIGNsZWFyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NFcnJvck1lc3NhZ2UobXNnOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgbmV3IFJlZ0V4cChcbiAgICAgIC9Pbmx5IGBTYXZlZE1vZGVsYHMgd2l0aCBcXGQrIE1ldGFHcmFwaCBhcmUgc3VwcG9ydGVkLiBJbnN0ZWFkLCBpdCBoYXMgXFxkKy8sXG4gICAgKS50ZXN0KG1zZylcbiAgKSB7XG4gICAgcmV0dXJuIGAke21zZ30uIFRyeSB1c2luZyB0aGUgXCJURiBhZGFwdGVyIChkaXJlY3QpXCIgYWRhcHRlci5gO1xuICB9XG4gIHJldHVybiBtc2c7XG59XG5cbi8qKiBHZXRzIHRoZSBzZWFyY2ggbWF0Y2hlcyBmb3IgdGhlIGdpdmVuIG5vZGUgdXNpbmcgcmVnZXguICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVnZXhNYXRjaGVzRm9yTm9kZShcbiAgc2hvdWxkTWF0Y2hUeXBlczogU2V0PHN0cmluZz4sXG4gIHJlZ2V4OiBSZWdFeHAsXG4gIG5vZGU6IE1vZGVsTm9kZSxcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbik6IHtcbiAgbWF0Y2hlczogU2VhcmNoTWF0Y2hbXTtcbiAgbWF0Y2hUeXBlczogU2V0PHN0cmluZz47XG59IHtcbiAgY29uc3QgbWF0Y2hlczogU2VhcmNoTWF0Y2hbXSA9IFtdO1xuICBjb25zdCBtYXRjaFR5cGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gTm9kZSBsYWJlbC5cbiAgaWYgKFxuICAgIHNob3VsZE1hdGNoVHlwZXMuaGFzKFNlYXJjaE1hdGNoVHlwZS5OT0RFX0xBQkVMKSAmJlxuICAgIHJlZ2V4LnRlc3Qobm9kZS5sYWJlbClcbiAgKSB7XG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFNlYXJjaE1hdGNoVHlwZS5OT0RFX0xBQkVMLFxuICAgIH0pO1xuICAgIG1hdGNoVHlwZXMuYWRkKFNlYXJjaE1hdGNoVHlwZS5OT0RFX0xBQkVMKTtcbiAgfVxuICAvLyBBdHRyaWJ1dGUuXG4gIGlmIChzaG91bGRNYXRjaFR5cGVzLmhhcyhTZWFyY2hNYXRjaFR5cGUuQVRUUklCVVRFKSkge1xuICAgIGNvbnN0IGF0dHJzID0gZ2V0QXR0cmlidXRlc0Zyb21Ob2RlKG5vZGUpO1xuICAgIGZvciAoY29uc3QgYXR0cklkIG9mIE9iamVjdC5rZXlzKGF0dHJzKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1thdHRySWRdO1xuICAgICAgY29uc3QgdGV4dDEgPSBgJHthdHRySWR9OiR7dmFsdWV9YDtcbiAgICAgIGNvbnN0IHRleHQyID0gYCR7YXR0cklkfT0ke3ZhbHVlfWA7XG4gICAgICBpZiAocmVnZXgudGVzdCh0ZXh0MSkgfHwgcmVnZXgudGVzdCh0ZXh0MikpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuQVRUUklCVVRFLFxuICAgICAgICAgIG1hdGNoZWRBdHRySWQ6IGF0dHJJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdGNoVHlwZXMuYWRkKFNlYXJjaE1hdGNoVHlwZS5BVFRSSUJVVEUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBJbnB1dHNcbiAgaWYgKHNob3VsZE1hdGNoVHlwZXMuaGFzKFNlYXJjaE1hdGNoVHlwZS5JTlBVVF9NRVRBREFUQSkgJiYgaXNPcE5vZGUobm9kZSkpIHtcbiAgICBmb3IgKGNvbnN0IGluY29taW5nRWRnZSBvZiBub2RlLmluY29taW5nRWRnZXMgfHwgW10pIHtcbiAgICAgIC8vIE1hdGNoIHNvdXJjZSBub2RlJ3MgbGFiZWwuXG4gICAgICBjb25zdCBzb3VyY2VOb2RlID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbXG4gICAgICAgIGluY29taW5nRWRnZS5zb3VyY2VOb2RlSWRcbiAgICAgIF0gYXMgT3BOb2RlO1xuICAgICAgaWYgKHJlZ2V4LnRlc3Qoc291cmNlTm9kZS5sYWJlbCkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuSU5QVVRfTUVUQURBVEEsXG4gICAgICAgICAgbWF0Y2hlZFRleHQ6IHNvdXJjZU5vZGUubGFiZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBtYXRjaFR5cGVzLmFkZChTZWFyY2hNYXRjaFR5cGUuSU5QVVRfTUVUQURBVEEpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0ZW5zb3IgdGFnIGluIGN1cnJlbnQgbm9kZSdzIGlucHV0IG1ldGFkYXRhLlxuICAgICAgY29uc3QgaW5wdXRzTWV0YWRhdGEgPSBub2RlLmlucHV0c01ldGFkYXRhIHx8IHt9O1xuICAgICAgY29uc3QgdGVuc29yVGFnID0gKGlucHV0c01ldGFkYXRhW2luY29taW5nRWRnZS50YXJnZXROb2RlSW5wdXRJZF0gfHwge30pW1xuICAgICAgICBURU5TT1JfVEFHX01FVEFEQVRBX0tFWVxuICAgICAgXTtcbiAgICAgIGlmICh0ZW5zb3JUYWcgJiYgcmVnZXgudGVzdCh0ZW5zb3JUYWcpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLklOUFVUX01FVEFEQVRBLFxuICAgICAgICAgIG1hdGNoZWRUZXh0OiB0ZW5zb3JUYWcsXG4gICAgICAgIH0pO1xuICAgICAgICBtYXRjaFR5cGVzLmFkZChTZWFyY2hNYXRjaFR5cGUuSU5QVVRfTUVUQURBVEEpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCBzb3VyY2Ugbm9kZSdzIG91dHB1dCBtZXRhZGF0YS5cbiAgICAgIGNvbnN0IG1ldGFkYXRhID1cbiAgICAgICAgKHNvdXJjZU5vZGUub3V0cHV0c01ldGFkYXRhIHx8IHt9KVtpbmNvbWluZ0VkZ2Uuc291cmNlTm9kZU91dHB1dElkXSB8fFxuICAgICAgICB7fTtcbiAgICAgIGZvciAoY29uc3QgbWV0YWRhdGFLZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YUtleS5zdGFydHNXaXRoKCdfXycpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBtZXRhZGF0YVttZXRhZGF0YUtleV07XG4gICAgICAgIGNvbnN0IHRleHQxID0gYCR7bWV0YWRhdGFLZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgY29uc3QgdGV4dDIgPSBgJHttZXRhZGF0YUtleX09JHt2YWx1ZX1gO1xuICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkgfHwgcmVnZXgudGVzdCh0ZXh0MSkgfHwgcmVnZXgudGVzdCh0ZXh0MikpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLklOUFVUX01FVEFEQVRBLFxuICAgICAgICAgICAgbWF0Y2hlZFRleHQ6IHZhbHVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hdGNoVHlwZXMuYWRkKFNlYXJjaE1hdGNoVHlwZS5JTlBVVF9NRVRBREFUQSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGFyZ2V0IG5vZGUncyBpbnB1dCBtZXRhZGF0YS5cbiAgICAgIGNvbnN0IGN1cklucHV0TWV0YWRhdGEgPVxuICAgICAgICBpbnB1dHNNZXRhZGF0YVtpbmNvbWluZ0VkZ2UudGFyZ2V0Tm9kZUlucHV0SWRdIHx8IHt9O1xuICAgICAgZm9yIChjb25zdCBtZXRhZGF0YUtleSBvZiBPYmplY3Qua2V5cyhjdXJJbnB1dE1ldGFkYXRhKSkge1xuICAgICAgICBpZiAobWV0YWRhdGFLZXkuc3RhcnRzV2l0aCgnX18nKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3VySW5wdXRNZXRhZGF0YVttZXRhZGF0YUtleV07XG4gICAgICAgIGNvbnN0IHRleHQxID0gYCR7bWV0YWRhdGFLZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgY29uc3QgdGV4dDIgPSBgJHttZXRhZGF0YUtleX09JHt2YWx1ZX1gO1xuICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkgfHwgcmVnZXgudGVzdCh0ZXh0MSkgfHwgcmVnZXgudGVzdCh0ZXh0MikpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLklOUFVUX01FVEFEQVRBLFxuICAgICAgICAgICAgbWF0Y2hlZFRleHQ6IHZhbHVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hdGNoVHlwZXMuYWRkKFNlYXJjaE1hdGNoVHlwZS5JTlBVVF9NRVRBREFUQSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gT3V0cHV0c1xuICBpZiAoc2hvdWxkTWF0Y2hUeXBlcy5oYXMoU2VhcmNoTWF0Y2hUeXBlLk9VVFBVVF9NRVRBREFUQSkgJiYgaXNPcE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBvdXRwdXRzTWV0YWRhdGEgPSBub2RlLm91dHB1dHNNZXRhZGF0YSB8fCB7fTtcblxuICAgIGZvciAoY29uc3Qgb3V0Z29pbmdFZGdlIG9mIG5vZGUub3V0Z29pbmdFZGdlcyB8fCBbXSkge1xuICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IG1vZGVsR3JhcGgubm9kZXNCeUlkW1xuICAgICAgICBvdXRnb2luZ0VkZ2UudGFyZ2V0Tm9kZUlkXG4gICAgICBdIGFzIE9wTm9kZTtcbiAgICAgIGlmIChyZWdleC50ZXN0KHRhcmdldE5vZGUubGFiZWwpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLk9VVFBVVF9NRVRBREFUQSxcbiAgICAgICAgICBtYXRjaGVkVGV4dDogdGFyZ2V0Tm9kZS5sYWJlbCxcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdGNoVHlwZXMuYWRkKFNlYXJjaE1hdGNoVHlwZS5PVVRQVVRfTUVUQURBVEEpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0ZW5zb3IgdGFnIGluIGN1cnJlbnQgbm9kZSdzIG91dHB1dCBtZXRhZGF0YS5cbiAgICAgIGNvbnN0IHRlbnNvclRhZyA9IChvdXRwdXRzTWV0YWRhdGFbb3V0Z29pbmdFZGdlLnNvdXJjZU5vZGVPdXRwdXRJZF0gfHxcbiAgICAgICAge30pW1RFTlNPUl9UQUdfTUVUQURBVEFfS0VZXTtcbiAgICAgIGlmICh0ZW5zb3JUYWcgJiYgcmVnZXgudGVzdCh0ZW5zb3JUYWcpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLk9VVFBVVF9NRVRBREFUQSxcbiAgICAgICAgICBtYXRjaGVkVGV4dDogdGVuc29yVGFnLFxuICAgICAgICB9KTtcbiAgICAgICAgbWF0Y2hUeXBlcy5hZGQoU2VhcmNoTWF0Y2hUeXBlLk9VVFBVVF9NRVRBREFUQSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiBPYmplY3QudmFsdWVzKG91dHB1dHNNZXRhZGF0YSkpIHtcbiAgICAgIGZvciAoY29uc3QgbWV0YWRhdGFLZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YUtleS5zdGFydHNXaXRoKCdfXycpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBtZXRhZGF0YVttZXRhZGF0YUtleV07XG4gICAgICAgIGNvbnN0IHRleHQxID0gYCR7bWV0YWRhdGFLZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgY29uc3QgdGV4dDIgPSBgJHttZXRhZGF0YUtleX09JHt2YWx1ZX1gO1xuICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkgfHwgcmVnZXgudGVzdCh0ZXh0MSkgfHwgcmVnZXgudGVzdCh0ZXh0MikpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogU2VhcmNoTWF0Y2hUeXBlLk9VVFBVVF9NRVRBREFUQSxcbiAgICAgICAgICAgIG1hdGNoZWRUZXh0OiB2YWx1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXRjaFR5cGVzLmFkZChTZWFyY2hNYXRjaFR5cGUuT1VUUFVUX01FVEFEQVRBKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bWF0Y2hlcywgbWF0Y2hUeXBlc307XG59XG5cbi8qKiBHZXRzIHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIGdpdmVuIG5vZGUuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21Ob2RlKG5vZGU6IE1vZGVsTm9kZSk6IEtleVZhbHVlUGFpcnMge1xuICBsZXQgYXR0cnM6IEtleVZhbHVlUGFpcnMgPSB7fTtcbiAgaWYgKGlzT3BOb2RlKG5vZGUpKSB7XG4gICAgYXR0cnMgPSB7Li4uKG5vZGUuYXR0cnMgfHwge30pfTtcbiAgICAvLyBBZGQgaWQgdG8gYXR0cmlidXRlLlxuICAgIGF0dHJzWydpZCddID0gbm9kZS5pZDtcbiAgfSBlbHNlIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgIGF0dHJzID0ge1xuICAgICAgJyNkZXNjZW5kYW50cyc6IGAkeyhub2RlLmRlc2NlbmRhbnRzTm9kZUlkcyB8fCBbXSkubGVuZ3RofWAsXG4gICAgICAnI2NoaWxkcmVuJzogYCR7KG5vZGUubnNDaGlsZHJlbklkcyB8fCBbXSkubGVuZ3RofWAsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXR0cnM7XG59XG5cbi8qKiBHZXRzIHRoZSBzZWFyY2ggbWF0Y2hlcyBmb3IgdGhlIGdpdmVuIG5vZGUgdXNpbmcgYXR0ciB2YWx1ZSByYW5nZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyVmFsdWVSYW5nZU1hdGNoZXNGb3JOb2RlKFxuICBhdHRyTmFtZTogc3RyaW5nLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIG5vZGU6IE1vZGVsTm9kZSxcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbik6IFNlYXJjaE1hdGNoW10ge1xuICBjb25zdCBtYXRjaGVzOiBTZWFyY2hNYXRjaFtdID0gW107XG5cbiAgY29uc3QgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzRnJvbU5vZGUobm9kZSk7XG4gIGNvbnN0IHZhbHVlID0gYXR0cnNbYXR0ck5hbWVdO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzTmFOKG51bVZhbHVlKSAmJiBudW1WYWx1ZSA+PSBtaW4gJiYgbnVtVmFsdWUgPD0gbWF4KSB7XG4gICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBTZWFyY2hNYXRjaFR5cGUuQVRUUklCVVRFLFxuICAgICAgICBtYXRjaGVkQXR0cklkOiBhdHRyTmFtZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiBxdWVyaWVzIGhhdmUgbm9uLWVtcHR5IHF1ZXJpZXMuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzTm9uRW1wdHlRdWVyaWVzKHF1ZXJpZXM6IE5vZGVRdWVyeVtdKTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcy5maWx0ZXIoXG4gICAgKHF1ZXJ5KSA9PiBxdWVyeS50eXBlICE9PSBOb2RlUXVlcnlUeXBlLk5PREVfVFlQRSxcbiAgKSkge1xuICAgIHN3aXRjaCAocXVlcnkudHlwZSkge1xuICAgICAgY2FzZSBOb2RlUXVlcnlUeXBlLlJFR0VYOlxuICAgICAgICBpZiAocXVlcnkucXVlcnlSZWdleCAhPT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTm9kZVF1ZXJ5VHlwZS5BVFRSX1ZBTFVFX1JBTkdFOlxuICAgICAgICBpZiAocXVlcnkuYXR0ck5hbWUgIT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogUHJvY2Vzc2VzIHRoZSBnaXZlbiBub2RlIHN0eWxlciBydWxlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzTm9kZVN0eWxlclJ1bGVzKFxuICBydWxlczogTm9kZVN0eWxlclJ1bGVbXSxcbik6IFByb2Nlc3NlZE5vZGVTdHlsZXJSdWxlW10ge1xuICByZXR1cm4gcnVsZXMubWFwKChydWxlKSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkUXVlcmllcyA9IHJ1bGUucXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB7XG4gICAgICBzd2l0Y2ggKHF1ZXJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSBOb2RlUXVlcnlUeXBlLlJFR0VYOiB7XG4gICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnJywgJ2knKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHF1ZXJ5LnF1ZXJ5UmVnZXgsICdpJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY3JlYXRlIHJlZ2V4JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFF1ZXJ5OiBQcm9jZXNzZWROb2RlUmVnZXhRdWVyeSA9IHtcbiAgICAgICAgICAgIHR5cGU6IE5vZGVRdWVyeVR5cGUuUkVHRVgsXG4gICAgICAgICAgICBxdWVyeVJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIG1hdGNoVHlwZXM6IG5ldyBTZXQ8U2VhcmNoTWF0Y2hUeXBlPihxdWVyeS5tYXRjaFR5cGVzKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzZWRRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVRdWVyeVR5cGUuTk9ERV9UWVBFOlxuICAgICAgICBjYXNlIE5vZGVRdWVyeVR5cGUuQVRUUl9WQUxVRV9SQU5HRToge1xuICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJpZXM6IHByb2Nlc3NlZFF1ZXJpZXMgYXMgUHJvY2Vzc2VkTm9kZVF1ZXJ5W10sXG4gICAgICBub2RlVHlwZTogcnVsZS5ub2RlVHlwZSxcbiAgICAgIHN0eWxlczogcnVsZS5zdHlsZXMsXG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKiBDaGVja3MgaWYgdGhlIGdpdmVuIG5vZGUgbWF0Y2hlcyB0aGUgZ2l2ZW4gcXVlcmllcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaE5vZGVGb3JRdWVyaWVzKFxuICBub2RlOiBNb2RlbE5vZGUsXG4gIHF1ZXJpZXM6IFByb2Nlc3NlZE5vZGVRdWVyeVtdLFxuICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuKTogYm9vbGVhbiB7XG4gIGxldCBtYXRjaGVkQWxsID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgaWYgKHF1ZXJ5LnR5cGUgPT09IE5vZGVRdWVyeVR5cGUuTk9ERV9UWVBFKSB7XG4gICAgICBsZXQgbWF0Y2hlZCA9IHRydWU7XG4gICAgICBpZiAoXG4gICAgICAgIChpc09wTm9kZShub2RlKSAmJiBxdWVyeS5ub2RlVHlwZSA9PT0gU2VhcmNoTm9kZVR5cGUuTEFZRVJfTk9ERVMpIHx8XG4gICAgICAgIChpc0dyb3VwTm9kZShub2RlKSAmJiBxdWVyeS5ub2RlVHlwZSA9PT0gU2VhcmNoTm9kZVR5cGUuT1BfTk9ERVMpXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIG1hdGNoZWRBbGwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChxdWVyeS50eXBlID09PSBOb2RlUXVlcnlUeXBlLlJFR0VYKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZ2V0UmVnZXhNYXRjaGVzRm9yTm9kZShcbiAgICAgICAgcXVlcnkubWF0Y2hUeXBlcyxcbiAgICAgICAgcXVlcnkucXVlcnlSZWdleCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICkubWF0Y2hlcztcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBtYXRjaGVkQWxsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocXVlcnkudHlwZSA9PT0gTm9kZVF1ZXJ5VHlwZS5BVFRSX1ZBTFVFX1JBTkdFKSB7XG4gICAgICBpZiAocXVlcnkuYXR0ck5hbWUgIT09ICcnKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRBdHRyVmFsdWVSYW5nZU1hdGNoZXNGb3JOb2RlKFxuICAgICAgICAgIHF1ZXJ5LmF0dHJOYW1lLFxuICAgICAgICAgIHF1ZXJ5Lm1pbiA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgcXVlcnkubWF4ID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG1vZGVsR3JhcGgsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIG1hdGNoZWRBbGwgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaGVkQWxsID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVkQWxsO1xufVxuIl19
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/worker_events.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/worker_events.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/common/worker_events.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_input_graph_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.input_graph");
const tsickle_model_graph_2 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_visualizer_config_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.visualizer_config");
/**
 * Various worker event types.
 * @enum {number}
 */
const WorkerEventType = {
    PROCESS_GRAPH_REQ: 0,
    PROCESS_GRAPH_RESP: 1,
    EXPAND_OR_COLLAPSE_GROUP_NODE_REQ: 2,
    EXPAND_OR_COLLAPSE_GROUP_NODE_RESP: 3,
    RELAYOUT_GRAPH_REQ: 4,
    RELAYOUT_GRAPH_RESP: 5,
    LOCATE_NODE_REQ: 6,
    LOCATE_NODE_RESP: 7,
    UPDATE_PROCESSING_PROGRESS: 8,
    PREPARE_POPUP_REQ: 9,
    PREPARE_POPUP_RESP: 10,
};
exports.WorkerEventType = WorkerEventType;
WorkerEventType[WorkerEventType.PROCESS_GRAPH_REQ] = 'PROCESS_GRAPH_REQ';
WorkerEventType[WorkerEventType.PROCESS_GRAPH_RESP] = 'PROCESS_GRAPH_RESP';
WorkerEventType[WorkerEventType.EXPAND_OR_COLLAPSE_GROUP_NODE_REQ] = 'EXPAND_OR_COLLAPSE_GROUP_NODE_REQ';
WorkerEventType[WorkerEventType.EXPAND_OR_COLLAPSE_GROUP_NODE_RESP] = 'EXPAND_OR_COLLAPSE_GROUP_NODE_RESP';
WorkerEventType[WorkerEventType.RELAYOUT_GRAPH_REQ] = 'RELAYOUT_GRAPH_REQ';
WorkerEventType[WorkerEventType.RELAYOUT_GRAPH_RESP] = 'RELAYOUT_GRAPH_RESP';
WorkerEventType[WorkerEventType.LOCATE_NODE_REQ] = 'LOCATE_NODE_REQ';
WorkerEventType[WorkerEventType.LOCATE_NODE_RESP] = 'LOCATE_NODE_RESP';
WorkerEventType[WorkerEventType.UPDATE_PROCESSING_PROGRESS] = 'UPDATE_PROCESSING_PROGRESS';
WorkerEventType[WorkerEventType.PREPARE_POPUP_REQ] = 'PREPARE_POPUP_REQ';
WorkerEventType[WorkerEventType.PREPARE_POPUP_RESP] = 'PREPARE_POPUP_RESP';
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.WorkerEventBase} */
exports.WorkerEventBase;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ProcessGraphRequest} */
exports.ProcessGraphRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ProcessGraphResponse} */
exports.ProcessGraphResponse;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ExpandOrCollapseGroupNodeRequest} */
exports.ExpandOrCollapseGroupNodeRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ExpandOrCollapseGroupNodeResponse} */
exports.ExpandOrCollapseGroupNodeResponse;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.RelayoutGraphRequest} */
exports.RelayoutGraphRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.RelayoutGraphResponse} */
exports.RelayoutGraphResponse;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.LocateNodeRequest} */
exports.LocateNodeRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.LocateNodeResponse} */
exports.LocateNodeResponse;
/**
 * Labels for processing progress.
 * @enum {string}
 */
const ProcessingLabel = {
    PROCESSING_NODES_AND_EDGES: "Processing nodes and edges",
    PROCESSING_LAYER_NAMESPACES: "Processing layer namespaces",
    PROCESSING_LAYOUT_DATA: "Processing layout data",
    SPLITTING_LARGE_LAYERS: "Splitting large layers (if any)",
    LAYING_OUT_ROOT_LAYER: "Laying out root layer",
    FINDING_IDENTICAL_LAYERS: "Finding identical layers",
};
exports.ProcessingLabel = ProcessingLabel;
/**
 * All processing labels.
 * @type {!Array<!ProcessingLabel>}
 */
exports.ALL_PROCESSING_LABELS = [
    ProcessingLabel.PROCESSING_NODES_AND_EDGES,
    ProcessingLabel.PROCESSING_LAYER_NAMESPACES,
    ProcessingLabel.PROCESSING_LAYOUT_DATA,
    ProcessingLabel.SPLITTING_LARGE_LAYERS,
    ProcessingLabel.LAYING_OUT_ROOT_LAYER,
    ProcessingLabel.FINDING_IDENTICAL_LAYERS,
];
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.UpdateProcessingProgressRequest} */
exports.UpdateProcessingProgressRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.PreparePopupRequest} */
exports.PreparePopupRequest;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.PreparePopupResponse} */
exports.PreparePopupResponse;
/**
 * Union of all worker events.
 * @typedef {(!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ProcessGraphRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ProcessGraphResponse|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ExpandOrCollapseGroupNodeRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.ExpandOrCollapseGroupNodeResponse|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.RelayoutGraphRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.RelayoutGraphResponse|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.LocateNodeRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.LocateNodeResponse|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.UpdateProcessingProgressRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.PreparePopupRequest|!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$common$worker_events.PreparePopupResponse)}
 */
exports.WorkerEvent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyX2V2ZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xlYXJuaW5nL2JyYWluL21vYmlsZS9saXRlL3Rvb2xpbmcvbW9kZWxfZ3JhcGhfdmlzdWFsaXplci9tb2R1bGUvY29tbW9uL3dvcmtlcl9ldmVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsTUFBWSxlQUFlO0lBQ3pCLGlCQUFpQixHQUFBO0lBQ2pCLGtCQUFrQixHQUFBO0lBQ2xCLGlDQUFpQyxHQUFBO0lBQ2pDLGtDQUFrQyxHQUFBO0lBQ2xDLGtCQUFrQixHQUFBO0lBQ2xCLG1CQUFtQixHQUFBO0lBQ25CLGVBQWUsR0FBQTtJQUNmLGdCQUFnQixHQUFBO0lBQ2hCLDBCQUEwQixHQUFBO0lBQzFCLGlCQUFpQixHQUFBO0lBQ2pCLGtCQUFrQixJQUFBO0VBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtIRCxNQUFZLGVBQWU7SUFDekIsMEJBQTBCLDhCQUErQjtJQUN6RCwyQkFBMkIsK0JBQWdDO0lBQzNELHNCQUFzQiwwQkFBMkI7SUFDakQsc0JBQXNCLG1DQUFvQztJQUMxRCxxQkFBcUIseUJBQTBCO0lBQy9DLHdCQUF3Qiw0QkFBNkI7RUFDdEQ7Ozs7OztBQUdZLFFBQUEscUJBQXFCLEdBQUc7SUFDbkMsZUFBZSxDQUFDLDBCQUEwQjtJQUMxQyxlQUFlLENBQUMsMkJBQTJCO0lBQzNDLGVBQWUsQ0FBQyxzQkFBc0I7SUFDdEMsZUFBZSxDQUFDLHNCQUFzQjtJQUN0QyxlQUFlLENBQUMscUJBQXFCO0lBQ3JDLGVBQWUsQ0FBQyx3QkFBd0I7Q0FDekM7Ozs7Ozs7Ozs7O0FBa0NELG9CQVd5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7R3JhcGh9IGZyb20gJy4vaW5wdXRfZ3JhcGgnO1xuaW1wb3J0IHtNb2RlbEdyYXBofSBmcm9tICcuL21vZGVsX2dyYXBoJztcbmltcG9ydCB7XG4gIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhLFxuICBOb2RlU3R5bGVyUnVsZSxcbiAgUG9pbnQsXG4gIFJlY3QsXG4gIFNob3dPbk5vZGVJdGVtRGF0YSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1Zpc3VhbGl6ZXJDb25maWd9IGZyb20gJy4vdmlzdWFsaXplcl9jb25maWcnO1xuXG4vKiogVmFyaW91cyB3b3JrZXIgZXZlbnQgdHlwZXMuICovXG5leHBvcnQgZW51bSBXb3JrZXJFdmVudFR5cGUge1xuICBQUk9DRVNTX0dSQVBIX1JFUSxcbiAgUFJPQ0VTU19HUkFQSF9SRVNQLFxuICBFWFBBTkRfT1JfQ09MTEFQU0VfR1JPVVBfTk9ERV9SRVEsXG4gIEVYUEFORF9PUl9DT0xMQVBTRV9HUk9VUF9OT0RFX1JFU1AsXG4gIFJFTEFZT1VUX0dSQVBIX1JFUSxcbiAgUkVMQVlPVVRfR1JBUEhfUkVTUCxcbiAgTE9DQVRFX05PREVfUkVRLFxuICBMT0NBVEVfTk9ERV9SRVNQLFxuICBVUERBVEVfUFJPQ0VTU0lOR19QUk9HUkVTUyxcbiAgUFJFUEFSRV9QT1BVUF9SRVEsXG4gIFBSRVBBUkVfUE9QVVBfUkVTUCxcbn1cblxuLyoqIFRoZSBiYXNlIG9mIGFsbCB3b3JrZXIgZXZlbnRzLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFdvcmtlckV2ZW50QmFzZSB7XG4gIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlO1xufVxuXG4vKiogVGhlIHJlcXVlc3QgZm9yIHByb2Nlc3NpbmcgYW4gaW5wdXQgZ3JhcGguICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgUHJvY2Vzc0dyYXBoUmVxdWVzdCBleHRlbmRzIFdvcmtlckV2ZW50QmFzZSB7XG4gIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLlBST0NFU1NfR1JBUEhfUkVRO1xuICBncmFwaDogR3JhcGg7XG4gIHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT47XG4gIG5vZGVEYXRhUHJvdmlkZXJSdW5zOiBSZWNvcmQ8c3RyaW5nLCBOb2RlRGF0YVByb3ZpZGVyUnVuRGF0YT47XG4gIGNvbmZpZz86IFZpc3VhbGl6ZXJDb25maWc7XG4gIHBhbmVJZDogc3RyaW5nO1xuICBncm91cE5vZGVDaGlsZHJlbkNvdW50VGhyZXNob2xkPzogbnVtYmVyO1xuICBmbGF0dGVuTGF5ZXJzPzogYm9vbGVhbjtcbn1cblxuLyoqIFRoZSByZXNwb25zZSBmb3IgcHJvY2Vzc2luZyBhbiBpbnB1dCBncmFwaC4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBQcm9jZXNzR3JhcGhSZXNwb25zZSBleHRlbmRzIFdvcmtlckV2ZW50QmFzZSB7XG4gIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLlBST0NFU1NfR1JBUEhfUkVTUDtcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaDtcbiAgcGFuZUlkOiBzdHJpbmc7XG59XG5cbi8qKiBUaGUgcmVxdWVzdCBmb3IgZXhwYW5kaW5nL2NvbGxhcHNpbmcgYSBncm91cCBub2RlLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEV4cGFuZE9yQ29sbGFwc2VHcm91cE5vZGVSZXF1ZXN0XG4gIGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuRVhQQU5EX09SX0NPTExBUFNFX0dST1VQX05PREVfUkVRO1xuICBtb2RlbEdyYXBoSWQ6IHN0cmluZztcbiAgLy8gdW5kZWZpbmVkIHdoZW4gZXhwYW5kaW5nL2NvbGxhcHNpbmcgZnJvbSByb290LlxuICBncm91cE5vZGVJZD86IHN0cmluZztcbiAgZXhwYW5kOiBib29sZWFuO1xuICBzaG93T25Ob2RlSXRlbVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+O1xuICBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJ1bkRhdGE+O1xuICByZW5kZXJlcklkOiBzdHJpbmc7XG4gIHBhbmVJZDogc3RyaW5nO1xuICAvLyBFeHBhbmQgb3IgY29sbGFwc2UgYWxsIGdyb3VwcyB1bmRlciB0aGUgc2VsZWN0ZWQgZ3JvdXAuXG4gIGFsbD86IGJvb2xlYW47XG4gIC8vIFRpbWVzdGFtcCBvZiB3aGVuIHRoZSByZXF1ZXN0IGlzIHNlbnQuXG4gIHRzPzogbnVtYmVyO1xufVxuXG4vKiogVGhlIHJlc3BvbnNlIGZvciBleHBhbmRpbmcvY29sbGFwc2luZyBhIGdyb3VwIG5vZGUuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgRXhwYW5kT3JDb2xsYXBzZUdyb3VwTm9kZVJlc3BvbnNlXG4gIGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuRVhQQU5EX09SX0NPTExBUFNFX0dST1VQX05PREVfUkVTUDtcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaDtcbiAgZXhwYW5kZWQ6IGJvb2xlYW47XG4gIC8vIHVuZGVmaW5lZCB3aGVuIGV4cGFuZGluZy9jb2xsYXBzaW5nIGZyb20gcm9vdC5cbiAgZ3JvdXBOb2RlSWQ/OiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgLy8gVGhlc2UgYXJlIHRoZSBkZWVwZXN0IGdyb3VwIG5vZGVzIChpbiB0ZXJtcyBvZiBsZXZlbCkgdGhhdCBub25lIG9mIGl0c1xuICAvLyBjaGlsZCBncm91cCBub2RlcyBpcyBleHBhbmRlZC5cbiAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBUaGUgcmVxdWVzdCBmb3IgcmUtbGF5aW5nIG91dCB0aGUgd2hvbGUgZ3JhcGgsIGtlZXBpbmcgdGhlIGN1cnJlbnRcbiAqIGNvbGxhcHNlL2V4cGFuZCBzdGF0ZXMgZm9yIGFsbCBncm91cCBub2Rlcy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFJlbGF5b3V0R3JhcGhSZXF1ZXN0IGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuUkVMQVlPVVRfR1JBUEhfUkVRO1xuICBtb2RlbEdyYXBoSWQ6IHN0cmluZztcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPjtcbiAgbm9kZURhdGFQcm92aWRlclJ1bnM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhPjtcbiAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kPzogc3RyaW5nW107XG4gIHNlbGVjdGVkTm9kZUlkOiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgZm9yUmVzdG9yaW5nVWlTdGF0ZT86IGJvb2xlYW47XG4gIHJlY3RUb1pvb21GaXQ/OiBSZWN0O1xuICBjbGVhckFsbEV4cGFuZFN0YXRlcz86IGJvb2xlYW47XG4gIGZvclJlc3RvcmluZ1NuYXBzaG90QWZ0ZXJUb2dnbGluZ0ZsYXR0ZW5MYXllcnM/OiBib29sZWFuO1xuICBub2RlU3R5bGVyUXVlcmllcz86IE5vZGVTdHlsZXJSdWxlW107XG59XG5cbi8qKiBUaGUgcmVzcG9uc2UgZm9yIHJlLWxheWluZyBvdXQgdGhlIHdob2xlIGdyYXBoLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFJlbGF5b3V0R3JhcGhSZXNwb25zZSBleHRlbmRzIFdvcmtlckV2ZW50QmFzZSB7XG4gIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLlJFTEFZT1VUX0dSQVBIX1JFU1A7XG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGg7XG4gIHNlbGVjdGVkTm9kZUlkOiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgZm9yUmVzdG9yaW5nVWlTdGF0ZT86IGJvb2xlYW47XG4gIHJlY3RUb1pvb21GaXQ/OiBSZWN0O1xuICBmb3JSZXN0b3JpbmdTbmFwc2hvdEFmdGVyVG9nZ2xpbmdGbGF0dGVuTGF5ZXJzPzogYm9vbGVhbjtcbiAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kPzogc3RyaW5nW107XG59XG5cbi8qKiBUaGUgcmVxdWVzdCBmb3IgbG9jYXRpbmcgYSBub2RlLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIExvY2F0ZU5vZGVSZXF1ZXN0IGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuTE9DQVRFX05PREVfUkVRO1xuICBtb2RlbEdyYXBoSWQ6IHN0cmluZztcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPjtcbiAgbm9kZURhdGFQcm92aWRlclJ1bnM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhPjtcbiAgbm9kZUlkOiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgbm9Ob2RlU2hha2U/OiBib29sZWFuO1xuICBzZWxlY3Q/OiBib29sZWFuO1xufVxuXG4vKiogVGhlIHJlc3BvbnNlIGZvciBsb2NhdGluZyBhIG5vZGUuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTG9jYXRlTm9kZVJlc3BvbnNlIGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuTE9DQVRFX05PREVfUkVTUDtcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaDtcbiAgbm9kZUlkOiBzdHJpbmc7XG4gIHJlbmRlcmVySWQ6IHN0cmluZztcbiAgLy8gU2VlIGNvbW1lbnRzIGFib3ZlLlxuICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHM6IHN0cmluZ1tdO1xuICBub05vZGVTaGFrZT86IGJvb2xlYW47XG4gIHNlbGVjdD86IGJvb2xlYW47XG59XG5cbi8qKiBMYWJlbHMgZm9yIHByb2Nlc3NpbmcgcHJvZ3Jlc3MuICovXG5leHBvcnQgZW51bSBQcm9jZXNzaW5nTGFiZWwge1xuICBQUk9DRVNTSU5HX05PREVTX0FORF9FREdFUyA9ICdQcm9jZXNzaW5nIG5vZGVzIGFuZCBlZGdlcycsXG4gIFBST0NFU1NJTkdfTEFZRVJfTkFNRVNQQUNFUyA9ICdQcm9jZXNzaW5nIGxheWVyIG5hbWVzcGFjZXMnLFxuICBQUk9DRVNTSU5HX0xBWU9VVF9EQVRBID0gJ1Byb2Nlc3NpbmcgbGF5b3V0IGRhdGEnLFxuICBTUExJVFRJTkdfTEFSR0VfTEFZRVJTID0gJ1NwbGl0dGluZyBsYXJnZSBsYXllcnMgKGlmIGFueSknLFxuICBMQVlJTkdfT1VUX1JPT1RfTEFZRVIgPSAnTGF5aW5nIG91dCByb290IGxheWVyJyxcbiAgRklORElOR19JREVOVElDQUxfTEFZRVJTID0gJ0ZpbmRpbmcgaWRlbnRpY2FsIGxheWVycycsXG59XG5cbi8qKiBBbGwgcHJvY2Vzc2luZyBsYWJlbHMuICovXG5leHBvcnQgY29uc3QgQUxMX1BST0NFU1NJTkdfTEFCRUxTID0gW1xuICBQcm9jZXNzaW5nTGFiZWwuUFJPQ0VTU0lOR19OT0RFU19BTkRfRURHRVMsXG4gIFByb2Nlc3NpbmdMYWJlbC5QUk9DRVNTSU5HX0xBWUVSX05BTUVTUEFDRVMsXG4gIFByb2Nlc3NpbmdMYWJlbC5QUk9DRVNTSU5HX0xBWU9VVF9EQVRBLFxuICBQcm9jZXNzaW5nTGFiZWwuU1BMSVRUSU5HX0xBUkdFX0xBWUVSUyxcbiAgUHJvY2Vzc2luZ0xhYmVsLkxBWUlOR19PVVRfUk9PVF9MQVlFUixcbiAgUHJvY2Vzc2luZ0xhYmVsLkZJTkRJTkdfSURFTlRJQ0FMX0xBWUVSUyxcbl07XG5cbi8qKiBUaGUgcmVxdWVzdCBmb3IgdXBkYXRpbmcgdGhlIHByb2Nlc3NpbmcgcHJvZ3Jlc3MgKHNlbnQgZnJvbSB3b3JrZXIpLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFVwZGF0ZVByb2Nlc3NpbmdQcm9ncmVzc1JlcXVlc3RcbiAgZXh0ZW5kcyBXb3JrZXJFdmVudEJhc2Uge1xuICBldmVudFR5cGU6IFdvcmtlckV2ZW50VHlwZS5VUERBVEVfUFJPQ0VTU0lOR19QUk9HUkVTUztcbiAgcGFuZUlkOiBzdHJpbmc7XG4gIGxhYmVsOiBQcm9jZXNzaW5nTGFiZWw7XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG4vKiogVGhlIHJlcXVlc3QgZm9yIHByZXBhcmluZyBhIHBvcHVwLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFByZXBhcmVQb3B1cFJlcXVlc3QgZXh0ZW5kcyBXb3JrZXJFdmVudEJhc2Uge1xuICBldmVudFR5cGU6IFdvcmtlckV2ZW50VHlwZS5QUkVQQVJFX1BPUFVQX1JFUTtcbiAgbW9kZWxHcmFwaElkOiBzdHJpbmc7XG4gIC8vIFRoZSBtb2RlbCBncmFwaCBvZiB0aGlzIHBhbmUgaWQgd2lsbCBiZSBkdXBsaWNhdGVkLlxuICBwYW5lSWQ6IHN0cmluZztcbiAgLy8gVGhlIGR1cGxpY2F0ZWQgbW9kZWwgZ3JhcGggd2lsbCBiZSBjYWNoZWQgaW4gdGhpcyByZW5kZXJlcklkLlxuICByZW5kZXJlcklkOiBzdHJpbmc7XG4gIGdyb3VwTm9kZUlkOiBzdHJpbmc7XG4gIGluaXRpYWxQb3NpdGlvbjogUG9pbnQ7XG59XG5cbi8qKiBUaGUgcmVzcG9uc2UgZm9yIHByZXBhcmluZyBhIHBvcHVwLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFByZXBhcmVQb3B1cFJlc3BvbnNlIGV4dGVuZHMgV29ya2VyRXZlbnRCYXNlIHtcbiAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuUFJFUEFSRV9QT1BVUF9SRVNQO1xuICBwYW5lSWQ6IHN0cmluZztcbiAgcmVuZGVyZXJJZDogc3RyaW5nO1xuICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoO1xuICBncm91cE5vZGVJZDogc3RyaW5nO1xuICBpbml0aWFsUG9zaXRpb246IFBvaW50O1xufVxuXG4vKiogVW5pb24gb2YgYWxsIHdvcmtlciBldmVudHMuICovXG5leHBvcnQgdHlwZSBXb3JrZXJFdmVudCA9XG4gIHwgUHJvY2Vzc0dyYXBoUmVxdWVzdFxuICB8IFByb2Nlc3NHcmFwaFJlc3BvbnNlXG4gIHwgRXhwYW5kT3JDb2xsYXBzZUdyb3VwTm9kZVJlcXVlc3RcbiAgfCBFeHBhbmRPckNvbGxhcHNlR3JvdXBOb2RlUmVzcG9uc2VcbiAgfCBSZWxheW91dEdyYXBoUmVxdWVzdFxuICB8IFJlbGF5b3V0R3JhcGhSZXNwb25zZVxuICB8IExvY2F0ZU5vZGVSZXF1ZXN0XG4gIHwgTG9jYXRlTm9kZVJlc3BvbnNlXG4gIHwgVXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzUmVxdWVzdFxuICB8IFByZXBhcmVQb3B1cFJlcXVlc3RcbiAgfCBQcmVwYXJlUG9wdXBSZXNwb25zZTtcbiJdfQ==
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_layout.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_layout.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_layout.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_consts_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts");
const tsickle_model_graph_2 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_utils_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils");
const tsickle_dagre_types_5 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.dagre_types");
const consts_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts');
const types_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types');
const utils_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
/**
 * The margin for the left and right side of the layout.
 * @type {number}
 */
exports.LAYOUT_MARGIN_X = 20;
/**
 * The margin for the top and bottom side of the layout.
 * @type {number}
 */
exports.LAYOUT_MARGIN_TOP = 36;
/**
 * The margin for the bottom side of the layout
 * @type {number}
 */
exports.LAYOUT_MARGIN_BOTTOM = 16;
/**
 * The default height of a node.
 * @type {number}
 */
exports.DEFAULT_NODE_HEIGHT = 26;
/**
 * Node width for test cases.
 * @type {number}
 */
exports.NODE_WIDTH_FOR_TEST = 50;
/** @type {number} */
const LABEL_PADDING = 24;
/** @type {number} */
const MIN_NODE_WIDTH = 80;
/** @type {number} */
const ATTRS_TABLE_MARGIN_X = 8;
/** @typedef {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$worker$graph_layout.DagreNode} */
exports.DagreNode;
/**
 * @record
 */
function LayoutGraph() { }
/* istanbul ignore if */
if (false) {
    /**
     * @type {!Object<string,!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$worker$graph_layout.DagreNode>}
     * @public
     */
    LayoutGraph.prototype.nodes;
    /**
     * @type {!Object<string,!Array<string>>}
     * @public
     */
    LayoutGraph.prototype.incomingEdges;
    /**
     * @type {!Object<string,!Array<string>>}
     * @public
     */
    LayoutGraph.prototype.outgoingEdges;
}
/**
 * To manage graph layout related tasks.
 *
 * TODO(jingjin): distribute this task to multiple workers to improvement
 * performance.
 */
class GraphLayout {
    /**
     * @public
     * @param {!tsickle_model_graph_2.ModelGraph} modelGraph
     * @param {!tsickle_dagre_types_5.Dagre} dagre
     * @param {?} showOnNodeItemTypes
     * @param {?} nodeDataProviderRuns
     * @param {boolean=} testMode
     */
    constructor(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns, testMode = false) {
        this.modelGraph = modelGraph;
        this.dagre = dagre;
        this.showOnNodeItemTypes = showOnNodeItemTypes;
        this.nodeDataProviderRuns = nodeDataProviderRuns;
        this.testMode = testMode;
        this.dagreGraph = new this.dagre.graphlib.Graph();
    }
    /**
     * Lays out the model graph rooted from the given root node.
     * @public
     * @param {(undefined|string)=} rootNodeId
     * @return {!tsickle_types_3.Rect}
     */
    layout(rootNodeId) {
        // Get the children nodes of the given root node.
        //
        // TODO(jingjin): need special handling for graphs > 500 nodes.
        /** @type {(undefined|!tsickle_model_graph_2.GroupNode)} */
        let rootNode = undefined;
        /** @type {!Array<(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)>} */
        let nodes = [];
        if (rootNodeId == null) {
            nodes = this.modelGraph.rootNodes;
        }
        else {
            rootNode = (/** @type {!tsickle_model_graph_2.GroupNode} */ (this.modelGraph.nodesById[rootNodeId]));
            nodes = (rootNode.nsChildrenIds || []).map((/**
             * @param {string} nodeId
             * @return {(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)}
             */
            (nodeId) => this.modelGraph.nodesById[nodeId]));
        }
        // Init.
        this.configLayout(this.dagreGraph);
        // Get layout graph.
        /** @type {!LayoutGraph} */
        const layoutGraph = getLayoutGraph(rootNode?.id || '', nodes, this.modelGraph, this.showOnNodeItemTypes, this.nodeDataProviderRuns, this.testMode);
        // Set nodes/edges to dagre.
        for (const id of Object.keys(layoutGraph.nodes)) {
            this.dagreGraph.setNode(id, layoutGraph.nodes[id]);
        }
        for (const fromNodeId of Object.keys(layoutGraph.outgoingEdges)) {
            for (const toNodeId of layoutGraph.outgoingEdges[fromNodeId]) {
                this.dagreGraph.setEdge(fromNodeId, toNodeId);
            }
        }
        // Run the layout algorithm.
        this.dagre.layout(this.dagreGraph);
        // Set the results back to the original model nodes.
        /** @type {number} */
        let minX = Number.MAX_VALUE;
        /** @type {number} */
        let minY = Number.MAX_VALUE;
        /** @type {number} */
        let maxX = Number.NEGATIVE_INFINITY;
        /** @type {number} */
        let maxY = Number.NEGATIVE_INFINITY;
        for (const node of nodes) {
            /** @type {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$worker$graph_layout.DagreNode} */
            const dagreNode = layoutGraph.nodes[node.id];
            if (!dagreNode) {
                console.warn(`Node "${node.id}" is not in the dagre layout result`);
                continue;
            }
            node.x = (dagreNode.x || 0) - dagreNode.width / 2;
            node.y = (dagreNode.y || 0) - dagreNode.height / 2;
            node.width = dagreNode.width;
            node.height = dagreNode.height;
            node.localOffsetX = 0;
            node.localOffsetY = 0;
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x + node.width);
            maxY = Math.max(maxY, node.y + node.height);
        }
        // Edges.
        /** @type {number} */
        let minEdgeX = Number.MAX_VALUE;
        /** @type {number} */
        let minEdgeY = Number.MAX_VALUE;
        /** @type {number} */
        let maxEdgeX = Number.NEGATIVE_INFINITY;
        /** @type {number} */
        let maxEdgeY = Number.NEGATIVE_INFINITY;
        /** @type {!Array<!tsickle_dagre_types_5.DagreEdge>} */
        const dagreEdgeRefs = this.dagreGraph.edges();
        /** @type {!Array<!tsickle_model_graph_2.ModelEdge>} */
        const edges = [];
        for (const dagreEdge of dagreEdgeRefs) {
            /** @type {!Array<!tsickle_types_3.Point>} */
            const points = (/** @type {!Array<!tsickle_types_3.Point>} */ (this.dagreGraph.edge(dagreEdge).points));
            // tslint:disable-next-line:no-any Allow arbitrary types.
            /** @type {?} */
            const d3 = ((/** @type {?} */ (globalThis)))['d3'];
            // tslint:disable-next-line:no-any Allow arbitrary types.
            /** @type {?} */
            const three = ((/** @type {?} */ (globalThis)))['THREE'];
            /** @type {!Array<!tsickle_types_3.Point>} */
            const curvePoints = typeof three === 'undefined'
                ? []
                : (0, utils_1.generateCurvePoints)(points, d3['line'], d3['curveMonotoneY'], three);
            /** @type {(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)} */
            const fromNode = this.modelGraph.nodesById[dagreEdge.v];
            /** @type {(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)} */
            const toNode = this.modelGraph.nodesById[dagreEdge.w];
            if (fromNode == null) {
                console.warn(`Edge from node not found: "${dagreEdge.v}"`);
                continue;
            }
            if (toNode == null) {
                console.warn(`Edge to node not found: "${dagreEdge.w}"`);
                continue;
            }
            /** @type {string} */
            const edgeId = `${fromNode.id}|${toNode.id}`;
            edges.push({
                id: edgeId,
                fromNodeId: fromNode.id,
                toNodeId: toNode.id,
                points,
                curvePoints,
            });
            for (const point of points) {
                minEdgeX = Math.min(minEdgeX, point.x);
                minEdgeY = Math.min(minEdgeY, point.y);
                maxEdgeX = Math.max(maxEdgeX, point.x);
                maxEdgeY = Math.max(maxEdgeY, point.y);
            }
        }
        this.modelGraph.edgesByGroupNodeIds[rootNodeId || ''] = edges;
        // Offset nodes to take into account of edges going out of the bound of all
        // the nodes.
        if (minEdgeX < minX) {
            for (const node of nodes) {
                node.localOffsetX = Math.max(0, minX - minEdgeX);
            }
        }
        minX = Math.min(minEdgeX, minX);
        maxX = Math.max(maxEdgeX, maxX);
        // Make sure the subgraph width is at least the width of the root node.
        /** @type {number} */
        let subgraphFullWidth = maxX - minX + exports.LAYOUT_MARGIN_X * 2;
        if (rootNode) {
            /** @type {number} */
            const parentNodeWidth = getNodeWidth(rootNode, this.modelGraph, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
            if (subgraphFullWidth < parentNodeWidth) {
                /** @type {number} */
                const extraOffsetX = (parentNodeWidth - subgraphFullWidth) / 2;
                for (const node of nodes) {
                    if (!node.localOffsetX) {
                        node.localOffsetX = 0;
                    }
                    node.localOffsetX += extraOffsetX;
                }
                subgraphFullWidth = parentNodeWidth;
            }
        }
        // Offset downwards if the root node has attrs table shown.
        if (rootNode && (0, utils_1.isGroupNode)(rootNode)) {
            /** @type {number} */
            const attrsRowCount = getGroupNodeAttrsTableRowCount(this.showOnNodeItemTypes);
            if (attrsRowCount > 0) {
                /** @type {number} */
                const localOffsetY = attrsRowCount * consts_1.NODE_ATTRS_TABLE_ROW_HEIGHT + 16;
                for (const node of nodes) {
                    node.localOffsetY = localOffsetY;
                }
                maxY += localOffsetY;
            }
        }
        return {
            x: minX,
            y: minY,
            width: subgraphFullWidth - exports.LAYOUT_MARGIN_X * 2,
            height: maxY - minY,
        };
    }
    /**
     * @private
     * @param {!tsickle_dagre_types_5.DagreGraphInstance} dagreGraph
     * @return {void}
     */
    configLayout(dagreGraph) {
        // See available configs here:
        // https://github.com/dagrejs/dagre/wiki#configuring-the-layout.
        dagreGraph.setGraph({
            nodesep: 20,
            ranksep: 50,
            edgesep: 20,
            marginx: exports.LAYOUT_MARGIN_X,
            marginy: exports.LAYOUT_MARGIN_TOP,
        });
        // No edge labels.
        dagreGraph.setDefaultEdgeLabel((/**
         * @return {*}
         */
        () => ({})));
    }
}
exports.GraphLayout = GraphLayout;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!tsickle_dagre_types_5.DagreGraphInstance}
     * @public
     */
    GraphLayout.prototype.dagreGraph;
    /**
     * @const {!tsickle_model_graph_2.ModelGraph}
     * @private
     */
    GraphLayout.prototype.modelGraph;
    /**
     * @const {!tsickle_dagre_types_5.Dagre}
     * @private
     */
    GraphLayout.prototype.dagre;
    /**
     * @const {?}
     * @private
     */
    GraphLayout.prototype.showOnNodeItemTypes;
    /**
     * @const {?}
     * @private
     */
    GraphLayout.prototype.nodeDataProviderRuns;
    /**
     * @const {boolean}
     * @private
     */
    GraphLayout.prototype.testMode;
}
/**
 * An utility function to get the node width using an offscreen canvas.
 * @param {(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)} node
 * @param {!tsickle_model_graph_2.ModelGraph} modelGraph
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {boolean=} testMode
 * @return {number}
 */
function getNodeWidth(node, modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, testMode = false) {
    // Always return 32 in test mode.
    if (testMode) {
        return exports.NODE_WIDTH_FOR_TEST;
    }
    /** @type {string} */
    const label = node.label;
    /** @type {number} */
    let labelWidth = (0, utils_1.getLabelWidth)(label, 11, (0, utils_1.isGroupNode)(node)) + LABEL_PADDING;
    // Add space to label width for the "expand/collapse icon" at the left and the
    // "more" icon at the right.
    if ((0, utils_1.isGroupNode)(node)) {
        labelWidth += 28;
    }
    // Calculate the width of attrs table.
    //
    // Figure out the max width of all the labels and values respectively.
    /** @type {number} */
    let maxAttrLabelWidth = 0;
    /** @type {number} */
    let maxAttrValueWidth = 0;
    if ((0, utils_1.isOpNode)(node)) {
        // Basic info.
        //
        // Gather field ids for the selected show-on-node items.
        /** @type {!Array<string>} */
        const fieldIds = (0, utils_1.getOpNodeFieldLabelsFromShowOnNodeItemTypes)(showOnNodeItemTypes);
        // Calculate width.
        for (const fieldId of fieldIds) {
            /** @type {number} */
            const attrLabelWidth = (0, utils_1.getLabelWidth)(`${fieldId}:`, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, true);
            /** @type {string} */
            const value = (0, utils_1.getNodeInfoFieldValue)(node, fieldId);
            /** @type {number} */
            const attrValueWidth = (0, utils_1.getLabelWidth)(value, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, false);
            maxAttrLabelWidth = Math.max(maxAttrLabelWidth, attrLabelWidth);
            maxAttrValueWidth = Math.max(maxAttrValueWidth, attrValueWidth);
        }
        // Attrs.
        if (showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_ATTRS]?.selected) {
            /** @type {!Array<!tsickle_types_3.KeyValue>} */
            const keyValuePairs = (0, utils_1.getOpNodeAttrsKeyValuePairsForAttrsTable)(node, showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_ATTRS]?.filterRegex || '');
            /** @type {{maxAttrLabelWidth: number, maxAttrValueWidth: number}} */
            const widths = getMaxAttrLabelAndValueWidth(keyValuePairs);
            maxAttrLabelWidth = Math.max(maxAttrLabelWidth, widths.maxAttrLabelWidth);
            maxAttrValueWidth = Math.max(maxAttrValueWidth, widths.maxAttrValueWidth);
        }
        // Inputs.
        if (showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_INPUTS]?.selected) {
            /** @type {!Array<!tsickle_types_3.KeyValue>} */
            const keyValuePairs = (0, utils_1.getOpNodeInputsKeyValuePairsForAttrsTable)(node, modelGraph);
            /** @type {{maxAttrLabelWidth: number, maxAttrValueWidth: number}} */
            const widths = getMaxAttrLabelAndValueWidth(keyValuePairs);
            maxAttrLabelWidth = Math.max(maxAttrLabelWidth, widths.maxAttrLabelWidth);
            maxAttrValueWidth = Math.max(maxAttrValueWidth, widths.maxAttrValueWidth);
        }
        // Outputs
        if (showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_OUTPUTS]?.selected) {
            /** @type {!Array<!tsickle_types_3.KeyValue>} */
            const keyValuePairs = (0, utils_1.getOpNodeOutputsKeyValuePairsForAttrsTable)(node);
            /** @type {{maxAttrLabelWidth: number, maxAttrValueWidth: number}} */
            const widths = getMaxAttrLabelAndValueWidth(keyValuePairs);
            maxAttrLabelWidth = Math.max(maxAttrLabelWidth, widths.maxAttrLabelWidth);
            maxAttrValueWidth = Math.max(maxAttrValueWidth, widths.maxAttrValueWidth);
        }
        // Node data providers.
        /** @type {!Array<!tsickle_types_3.KeyValue>} */
        const nodeDataProviderKeyValuePairs = (0, utils_1.getOpNodeDataProviderKeyValuePairsForAttrsTable)(node, modelGraph.id, showOnNodeItemTypes, nodeDataProviderRuns);
        /** @type {{maxAttrLabelWidth: number, maxAttrValueWidth: number}} */
        const nodeDataProviderWidths = getMaxAttrLabelAndValueWidth(nodeDataProviderKeyValuePairs);
        maxAttrLabelWidth = Math.max(maxAttrLabelWidth, nodeDataProviderWidths.maxAttrLabelWidth);
        maxAttrValueWidth = Math.max(maxAttrValueWidth, nodeDataProviderWidths.maxAttrValueWidth);
    }
    else if ((0, utils_1.isGroupNode)(node)) {
        // Basic info
        //
        // Gather basic info field ids for the selected show-on-node items.
        /** @type {!Array<string>} */
        const basicInfoFieldIds = (0, utils_1.getGroupNodeFieldLabelsFromShowOnNodeItemTypes)(showOnNodeItemTypes);
        // Calculate width.
        for (const fieldId of basicInfoFieldIds) {
            /** @type {number} */
            const attrLabelWidth = (0, utils_1.getLabelWidth)(`${fieldId}:`, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, true);
            /** @type {string} */
            const value = (0, utils_1.getNodeInfoFieldValue)(node, fieldId);
            /** @type {number} */
            const attrValueWidth = (0, utils_1.getLabelWidth)(value, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, false);
            maxAttrLabelWidth = Math.max(maxAttrLabelWidth, attrLabelWidth);
            maxAttrValueWidth = Math.max(maxAttrValueWidth, attrValueWidth);
        }
    }
    maxAttrValueWidth = Math.min(maxAttrValueWidth, consts_1.NODE_ATTRS_TABLE_VALUE_MAX_WIDTH);
    /** @type {number} */
    let attrsTableWidth = maxAttrLabelWidth +
        maxAttrValueWidth +
        consts_1.NODE_ATTRS_TABLE_LEFT_RIGHT_PADDING * 2 +
        consts_1.NODE_ATTRS_TABLE_LABEL_VALUE_PADDING;
    if (attrsTableWidth !== consts_1.NODE_ATTRS_TABLE_LABEL_VALUE_PADDING) {
        attrsTableWidth += ATTRS_TABLE_MARGIN_X * 2;
    }
    return Math.max(MIN_NODE_WIDTH, Math.max(labelWidth, attrsTableWidth));
}
exports.getNodeWidth = getNodeWidth;
/**
 * An utility function to get the node height.
 * @param {(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)} node
 * @param {!tsickle_model_graph_2.ModelGraph} modelGraph
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {boolean=} testMode
 * @param {boolean=} forceRecalculate
 * @return {number}
 */
function getNodeHeight(node, modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, testMode = false, forceRecalculate = false) {
    if (testMode) {
        return exports.DEFAULT_NODE_HEIGHT;
    }
    if (node.height != null && !forceRecalculate) {
        return node.height;
    }
    // Count how many rows will be in the attrs table.
    /** @type {number} */
    let attrsTableRowCount = 0;
    if ((0, utils_1.isOpNode)(node)) {
        attrsTableRowCount = getOpNodeAttrsTableRowCount(showOnNodeItemTypes, node, nodeDataProviderRuns);
    }
    else if ((0, utils_1.isGroupNode)(node)) {
        attrsTableRowCount = getGroupNodeAttrsTableRowCount(showOnNodeItemTypes);
    }
    return (exports.DEFAULT_NODE_HEIGHT +
        attrsTableRowCount * consts_1.NODE_ATTRS_TABLE_ROW_HEIGHT +
        (attrsTableRowCount > 0 ? consts_1.NODE_ATTRS_TABLE_MARGIN_TOP - 4 : 0));
}
exports.getNodeHeight = getNodeHeight;
/**
 * Gets a layout graph for the given nodes.
 * @param {string} rootGroupNodeId
 * @param {!Array<(!tsickle_model_graph_2.GroupNode|!tsickle_model_graph_2.OpNode)>} nodes
 * @param {!tsickle_model_graph_2.ModelGraph} modelGraph
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {boolean=} testMode
 * @param {boolean=} useFakeNodeSize
 * @return {!LayoutGraph}
 */
function getLayoutGraph(rootGroupNodeId, nodes, modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, testMode = false, useFakeNodeSize = false) {
    /** @type {!LayoutGraph} */
    const layoutGraph = {
        nodes: {},
        incomingEdges: {},
        outgoingEdges: {},
    };
    // Create layout graph nodes.
    for (const node of nodes) {
        if ((0, utils_1.isOpNode)(node) && (/** @type {!tsickle_model_graph_2.OpNode} */ (node)).hideInLayout) {
            continue;
        }
        /** @type {!google3$learning$brain$mobile$lite$tooling$model_graph_visualizer$module$worker$graph_layout.DagreNode} */
        const dagreNode = {
            id: node.id,
            width: node.width ||
                (useFakeNodeSize
                    ? 10
                    : getNodeWidth(node, modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, testMode)),
            height: useFakeNodeSize
                ? 10
                : getNodeHeight(node, modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, testMode),
        };
        layoutGraph.nodes[node.id] = dagreNode;
    }
    // Set layout graph edges.
    /** @type {?} */
    const curLayoutGraphEdges = modelGraph.layoutGraphEdges[rootGroupNodeId] || {};
    for (const [fromNodeId__tsickle_destructured_1, toNodeIds__tsickle_destructured_2] of Object.entries(curLayoutGraphEdges)) {
        const fromNodeId = /** @type {string} */ (fromNodeId__tsickle_destructured_1);
        const toNodeIds = /** @type {?} */ (toNodeIds__tsickle_destructured_2);
        for (const toNodeId of Object.keys(toNodeIds)) {
            addLayoutGraphEdge(layoutGraph, fromNodeId, toNodeId);
        }
    }
    return layoutGraph;
}
exports.getLayoutGraph = getLayoutGraph;
/**
 * @param {?} showOnNodeItemTypes
 * @param {!tsickle_model_graph_2.OpNode} node
 * @param {?} nodeDataProviderRuns
 * @return {number}
 */
function getOpNodeAttrsTableRowCount(showOnNodeItemTypes, node, nodeDataProviderRuns) {
    // Basic info fields.
    /** @type {!Array<!tsickle_types_3.FieldLabel>} */
    const baiscFieldIds = (0, utils_1.getOpNodeFieldLabelsFromShowOnNodeItemTypes)(showOnNodeItemTypes);
    // Node attributes.
    /** @type {number} */
    const attrsCount = showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_ATTRS]?.selected
        ? (0, utils_1.getOpNodeAttrsKeyValuePairsForAttrsTable)(node, showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_ATTRS]?.filterRegex || '').length
        : 0;
    // Inputs.
    /** @type {number} */
    let inputsCount = showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_INPUTS]?.selected
        ? Object.keys(node.incomingEdges || []).length
        : 0;
    if (inputsCount > consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE) {
        inputsCount = consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE + 1;
    }
    // Outputs.
    /** @type {number} */
    let outputsCount = showOnNodeItemTypes[types_1.ShowOnNodeItemType.OP_OUTPUTS]
        ?.selected
        ? Object.keys(node.outputsMetadata || {}).length
        : 0;
    if (outputsCount > consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE) {
        outputsCount = consts_1.MAX_IO_ROWS_IN_ATTRS_TABLE + 1;
    }
    // Node data providers.
    /** @type {number} */
    const nodeDataProviderCount = Object.keys(showOnNodeItemTypes)
        .filter((/**
     * @param {string} type
     * @return {boolean}
     */
    (type) => showOnNodeItemTypes[type].selected))
        .filter((/**
     * @param {string} showOnNodeItemType
     * @return {boolean}
     */
    (showOnNodeItemType) => showOnNodeItemType.startsWith(consts_1.NODE_DATA_PROVIDER_SHOW_ON_NODE_TYPE_PREFIX) &&
        Object.values(nodeDataProviderRuns).some((/**
         * @param {!tsickle_types_3.NodeDataProviderRunData} run
         * @return {boolean}
         */
        (run) => run.runName ===
            showOnNodeItemType.replace(consts_1.NODE_DATA_PROVIDER_SHOW_ON_NODE_TYPE_PREFIX, ''))))).length;
    return (baiscFieldIds.length +
        attrsCount +
        inputsCount +
        outputsCount +
        nodeDataProviderCount);
}
/**
 * @param {?} showOnNodeItemTypes
 * @return {number}
 */
function getGroupNodeAttrsTableRowCount(showOnNodeItemTypes) {
    /** @type {!Array<!tsickle_types_3.FieldLabel>} */
    const baiscFieldIds = (0, utils_1.getGroupNodeFieldLabelsFromShowOnNodeItemTypes)(showOnNodeItemTypes);
    return baiscFieldIds.length;
}
/**
 * @param {!LayoutGraph} layoutGraph
 * @param {string} fromNodeId
 * @param {string} toNodeId
 * @return {void}
 */
function addLayoutGraphEdge(layoutGraph, fromNodeId, toNodeId) {
    if (layoutGraph.outgoingEdges[fromNodeId] == null) {
        layoutGraph.outgoingEdges[fromNodeId] = [];
    }
    layoutGraph.outgoingEdges[fromNodeId].push(toNodeId);
    if (layoutGraph.incomingEdges[toNodeId] == null) {
        layoutGraph.incomingEdges[toNodeId] = [];
    }
    layoutGraph.incomingEdges[toNodeId].push(fromNodeId);
}
/**
 * @param {!Array<!tsickle_types_3.KeyValue>} keyValuePairs
 * @return {{maxAttrLabelWidth: number, maxAttrValueWidth: number}}
 */
function getMaxAttrLabelAndValueWidth(keyValuePairs) {
    /** @type {number} */
    let maxAttrLabelWidth = 0;
    /** @type {number} */
    let maxAttrValueWidth = 0;
    for (const { key, value } of keyValuePairs) {
        /** @type {number} */
        const attrLabelWidth = (0, utils_1.getLabelWidth)(key, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, true);
        maxAttrLabelWidth = Math.max(maxAttrLabelWidth, attrLabelWidth);
        /** @type {number} */
        const attrValueWidth = (0, utils_1.getLabelWidth)(value, consts_1.NODE_ATTRS_TABLE_FONT_SIZE, false);
        maxAttrValueWidth = Math.max(maxAttrValueWidth, attrValueWidth);
    }
    return { maxAttrLabelWidth, maxAttrValueWidth };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhfbGF5b3V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL21vZHVsZS93b3JrZXIvZ3JhcGhfbGF5b3V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdIQVMwQjtBQVExQixzSEFPeUI7QUFDekIsc0hBWXlCOzs7OztBQUtaLFFBQUEsZUFBZSxHQUFHLEVBQUU7Ozs7O0FBR3BCLFFBQUEsaUJBQWlCLEdBQUcsRUFBRTs7Ozs7QUFHdEIsUUFBQSxvQkFBb0IsR0FBRyxFQUFFOzs7OztBQUd6QixRQUFBLG1CQUFtQixHQUFHLEVBQUU7Ozs7O0FBR3hCLFFBQUEsbUJBQW1CLEdBQUcsRUFBRTs7TUFFL0IsYUFBYSxHQUFHLEVBQUU7O01BRWxCLGNBQWMsR0FBRyxFQUFFOztNQUVuQixvQkFBb0IsR0FBRyxDQUFDOzs7Ozs7QUFXOUIsMEJBSUM7Ozs7Ozs7SUFIQyw0QkFBaUM7Ozs7O0lBQ2pDLG9DQUE0Qzs7Ozs7SUFDNUMsb0NBQTRDOzs7Ozs7OztBQVM5QyxNQUFhLFdBQVc7Ozs7Ozs7OztJQUd0QixZQUNtQixVQUFzQixFQUN0QixLQUFZLEVBQ1osbUJBQXVELEVBQ3ZELG9CQUdoQixFQUNnQixXQUFXLEtBQUs7UUFQaEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixVQUFLLEdBQUwsS0FBSyxDQUFPO1FBQ1osd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFvQztRQUN2RCx5QkFBb0IsR0FBcEIsb0JBQW9CLENBR3BDO1FBQ2dCLGFBQVEsR0FBUixRQUFRLENBQVE7UUFFakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3BELENBQUM7Ozs7Ozs7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LEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBQ0QsT0FBTyxFQUFDLGlCQUFpQixFQUFFLGlCQUFpQixFQUFDLENBQUM7QUFDaEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIE1BWF9JT19ST1dTX0lOX0FUVFJTX1RBQkxFLFxuICBOT0RFX0FUVFJTX1RBQkxFX0ZPTlRfU0laRSxcbiAgTk9ERV9BVFRSU19UQUJMRV9MQUJFTF9WQUxVRV9QQURESU5HLFxuICBOT0RFX0FUVFJTX1RBQkxFX0xFRlRfUklHSFRfUEFERElORyxcbiAgTk9ERV9BVFRSU19UQUJMRV9NQVJHSU5fVE9QLFxuICBOT0RFX0FUVFJTX1RBQkxFX1JPV19IRUlHSFQsXG4gIE5PREVfQVRUUlNfVEFCTEVfVkFMVUVfTUFYX1dJRFRILFxuICBOT0RFX0RBVEFfUFJPVklERVJfU0hPV19PTl9OT0RFX1RZUEVfUFJFRklYLFxufSBmcm9tICcuLi9jb21tb24vY29uc3RzJztcbmltcG9ydCB7XG4gIEdyb3VwTm9kZSxcbiAgTW9kZWxFZGdlLFxuICBNb2RlbEdyYXBoLFxuICBNb2RlbE5vZGUsXG4gIE9wTm9kZSxcbn0gZnJvbSAnLi4vY29tbW9uL21vZGVsX2dyYXBoJztcbmltcG9ydCB7XG4gIEtleVZhbHVlTGlzdCxcbiAgTm9kZURhdGFQcm92aWRlclJ1bkRhdGEsXG4gIFBvaW50LFxuICBSZWN0LFxuICBTaG93T25Ob2RlSXRlbURhdGEsXG4gIFNob3dPbk5vZGVJdGVtVHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7XG4gIGdlbmVyYXRlQ3VydmVQb2ludHMsXG4gIGdldEdyb3VwTm9kZUZpZWxkTGFiZWxzRnJvbVNob3dPbk5vZGVJdGVtVHlwZXMsXG4gIGdldExhYmVsV2lkdGgsXG4gIGdldE5vZGVJbmZvRmllbGRWYWx1ZSxcbiAgZ2V0T3BOb2RlQXR0cnNLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZSxcbiAgZ2V0T3BOb2RlRGF0YVByb3ZpZGVyS2V5VmFsdWVQYWlyc0ZvckF0dHJzVGFibGUsXG4gIGdldE9wTm9kZUZpZWxkTGFiZWxzRnJvbVNob3dPbk5vZGVJdGVtVHlwZXMsXG4gIGdldE9wTm9kZUlucHV0c0tleVZhbHVlUGFpcnNGb3JBdHRyc1RhYmxlLFxuICBnZXRPcE5vZGVPdXRwdXRzS2V5VmFsdWVQYWlyc0ZvckF0dHJzVGFibGUsXG4gIGlzR3JvdXBOb2RlLFxuICBpc09wTm9kZSxcbn0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuaW1wb3J0IHtEYWdyZSwgRGFncmVHcmFwaEluc3RhbmNlfSBmcm9tICcuL2RhZ3JlX3R5cGVzJztcblxuLyoqIFRoZSBtYXJnaW4gZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBsYXlvdXQuICovXG5leHBvcnQgY29uc3QgTEFZT1VUX01BUkdJTl9YID0gMjA7XG5cbi8qKiBUaGUgbWFyZ2luIGZvciB0aGUgdG9wIGFuZCBib3R0b20gc2lkZSBvZiB0aGUgbGF5b3V0LiAqL1xuZXhwb3J0IGNvbnN0IExBWU9VVF9NQVJHSU5fVE9QID0gMzY7XG5cbi8qKiBUaGUgbWFyZ2luIGZvciB0aGUgYm90dG9tIHNpZGUgb2YgdGhlIGxheW91dCAqL1xuZXhwb3J0IGNvbnN0IExBWU9VVF9NQVJHSU5fQk9UVE9NID0gMTY7XG5cbi8qKiBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBub2RlLiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTk9ERV9IRUlHSFQgPSAyNjtcblxuLyoqIE5vZGUgd2lkdGggZm9yIHRlc3QgY2FzZXMuICovXG5leHBvcnQgY29uc3QgTk9ERV9XSURUSF9GT1JfVEVTVCA9IDUwO1xuXG5jb25zdCBMQUJFTF9QQURESU5HID0gMjQ7XG5cbmNvbnN0IE1JTl9OT0RFX1dJRFRIID0gODA7XG5cbmNvbnN0IEFUVFJTX1RBQkxFX01BUkdJTl9YID0gODtcblxuLyoqIEEgbm9kZSBpbiBkYWdyZS4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBEYWdyZU5vZGUge1xuICBpZDogc3RyaW5nO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgeD86IG51bWJlcjtcbiAgeT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIExheW91dEdyYXBoIHtcbiAgbm9kZXM6IHtbaWQ6IHN0cmluZ106IERhZ3JlTm9kZX07XG4gIGluY29taW5nRWRnZXM6IHtbZnJvbUlkOiBzdHJpbmddOiBzdHJpbmdbXX07XG4gIG91dGdvaW5nRWRnZXM6IHtbZnJvbUlkOiBzdHJpbmddOiBzdHJpbmdbXX07XG59XG5cbi8qKlxuICogVG8gbWFuYWdlIGdyYXBoIGxheW91dCByZWxhdGVkIHRhc2tzLlxuICpcbiAqIFRPRE8oamluZ2ppbik6IGRpc3RyaWJ1dGUgdGhpcyB0YXNrIHRvIG11bHRpcGxlIHdvcmtlcnMgdG8gaW1wcm92ZW1lbnRcbiAqIHBlcmZvcm1hbmNlLlxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhMYXlvdXQge1xuICBkYWdyZUdyYXBoITogRGFncmVHcmFwaEluc3RhbmNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhZ3JlOiBEYWdyZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPFxuICAgICAgc3RyaW5nLFxuICAgICAgTm9kZURhdGFQcm92aWRlclJ1bkRhdGFcbiAgICA+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGVzdE1vZGUgPSBmYWxzZSxcbiAgKSB7XG4gICAgdGhpcy5kYWdyZUdyYXBoID0gbmV3IHRoaXMuZGFncmUuZ3JhcGhsaWIuR3JhcGgoKTtcbiAgfVxuXG4gIC8qKiBMYXlzIG91dCB0aGUgbW9kZWwgZ3JhcGggcm9vdGVkIGZyb20gdGhlIGdpdmVuIHJvb3Qgbm9kZS4gICovXG4gIGxheW91dChyb290Tm9kZUlkPzogc3RyaW5nKTogUmVjdCB7XG4gICAgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2RlcyBvZiB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgIC8vXG4gICAgLy8gVE9ETyhqaW5namluKTogbmVlZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBncmFwaHMgPiA1MDAgbm9kZXMuXG4gICAgbGV0IHJvb3ROb2RlOiBHcm91cE5vZGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG5vZGVzOiBNb2RlbE5vZGVbXSA9IFtdO1xuICAgIGlmIChyb290Tm9kZUlkID09IG51bGwpIHtcbiAgICAgIG5vZGVzID0gdGhpcy5tb2RlbEdyYXBoLnJvb3ROb2RlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdE5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW3Jvb3ROb2RlSWRdIGFzIEdyb3VwTm9kZTtcbiAgICAgIG5vZGVzID0gKHJvb3ROb2RlLm5zQ2hpbGRyZW5JZHMgfHwgW10pLm1hcChcbiAgICAgICAgKG5vZGVJZCkgPT4gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtub2RlSWRdLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJbml0LlxuICAgIHRoaXMuY29uZmlnTGF5b3V0KHRoaXMuZGFncmVHcmFwaCk7XG5cbiAgICAvLyBHZXQgbGF5b3V0IGdyYXBoLlxuICAgIGNvbnN0IGxheW91dEdyYXBoID0gZ2V0TGF5b3V0R3JhcGgoXG4gICAgICByb290Tm9kZT8uaWQgfHwgJycsXG4gICAgICBub2RlcyxcbiAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgIHRoaXMuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgIHRoaXMubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICB0aGlzLnRlc3RNb2RlLFxuICAgICk7XG5cbiAgICAvLyBTZXQgbm9kZXMvZWRnZXMgdG8gZGFncmUuXG4gICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhsYXlvdXRHcmFwaC5ub2RlcykpIHtcbiAgICAgIHRoaXMuZGFncmVHcmFwaC5zZXROb2RlKGlkLCBsYXlvdXRHcmFwaC5ub2Rlc1tpZF0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZyb21Ob2RlSWQgb2YgT2JqZWN0LmtleXMobGF5b3V0R3JhcGgub3V0Z29pbmdFZGdlcykpIHtcbiAgICAgIGZvciAoY29uc3QgdG9Ob2RlSWQgb2YgbGF5b3V0R3JhcGgub3V0Z29pbmdFZGdlc1tmcm9tTm9kZUlkXSkge1xuICAgICAgICB0aGlzLmRhZ3JlR3JhcGguc2V0RWRnZShmcm9tTm9kZUlkLCB0b05vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxuICAgIHRoaXMuZGFncmUubGF5b3V0KHRoaXMuZGFncmVHcmFwaCk7XG5cbiAgICAvLyBTZXQgdGhlIHJlc3VsdHMgYmFjayB0byB0aGUgb3JpZ2luYWwgbW9kZWwgbm9kZXMuXG4gICAgbGV0IG1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGxldCBtaW5ZID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IGRhZ3JlTm9kZSA9IGxheW91dEdyYXBoLm5vZGVzW25vZGUuaWRdO1xuICAgICAgaWYgKCFkYWdyZU5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBOb2RlIFwiJHtub2RlLmlkfVwiIGlzIG5vdCBpbiB0aGUgZGFncmUgbGF5b3V0IHJlc3VsdGApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUueCA9IChkYWdyZU5vZGUueCB8fCAwKSAtIGRhZ3JlTm9kZS53aWR0aCAvIDI7XG4gICAgICBub2RlLnkgPSAoZGFncmVOb2RlLnkgfHwgMCkgLSBkYWdyZU5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIG5vZGUud2lkdGggPSBkYWdyZU5vZGUud2lkdGg7XG4gICAgICBub2RlLmhlaWdodCA9IGRhZ3JlTm9kZS5oZWlnaHQ7XG4gICAgICBub2RlLmxvY2FsT2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLmxvY2FsT2Zmc2V0WSA9IDA7XG5cbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBub2RlLngpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIG5vZGUueSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgbm9kZS54ICsgbm9kZS53aWR0aCk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgbm9kZS55ICsgbm9kZS5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIEVkZ2VzLlxuICAgIGxldCBtaW5FZGdlWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbGV0IG1pbkVkZ2VZID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgbWF4RWRnZVggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heEVkZ2VZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRhZ3JlRWRnZVJlZnMgPSB0aGlzLmRhZ3JlR3JhcGguZWRnZXMoKTtcbiAgICBjb25zdCBlZGdlczogTW9kZWxFZGdlW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRhZ3JlRWRnZSBvZiBkYWdyZUVkZ2VSZWZzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmRhZ3JlR3JhcGguZWRnZShkYWdyZUVkZ2UpLnBvaW50cyBhcyBQb2ludFtdO1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBBbGxvdyBhcmJpdHJhcnkgdHlwZXMuXG4gICAgICBjb25zdCBkMyA9IChnbG9iYWxUaGlzIGFzIGFueSlbJ2QzJ107XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IEFsbG93IGFyYml0cmFyeSB0eXBlcy5cbiAgICAgIGNvbnN0IHRocmVlID0gKGdsb2JhbFRoaXMgYXMgYW55KVsnVEhSRUUnXTtcbiAgICAgIGNvbnN0IGN1cnZlUG9pbnRzID1cbiAgICAgICAgdHlwZW9mIHRocmVlID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IGdlbmVyYXRlQ3VydmVQb2ludHMoXG4gICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgZDNbJ2xpbmUnXSxcbiAgICAgICAgICAgICAgZDNbJ2N1cnZlTW9ub3RvbmVZJ10sXG4gICAgICAgICAgICAgIHRocmVlLFxuICAgICAgICAgICAgKTtcbiAgICAgIGNvbnN0IGZyb21Ob2RlID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtkYWdyZUVkZ2Uudl07XG4gICAgICBjb25zdCB0b05vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW2RhZ3JlRWRnZS53XTtcbiAgICAgIGlmIChmcm9tTm9kZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRWRnZSBmcm9tIG5vZGUgbm90IGZvdW5kOiBcIiR7ZGFncmVFZGdlLnZ9XCJgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9Ob2RlID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFZGdlIHRvIG5vZGUgbm90IGZvdW5kOiBcIiR7ZGFncmVFZGdlLnd9XCJgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGdlSWQgPSBgJHtmcm9tTm9kZS5pZH18JHt0b05vZGUuaWR9YDtcbiAgICAgIGVkZ2VzLnB1c2goe1xuICAgICAgICBpZDogZWRnZUlkLFxuICAgICAgICBmcm9tTm9kZUlkOiBmcm9tTm9kZS5pZCxcbiAgICAgICAgdG9Ob2RlSWQ6IHRvTm9kZS5pZCxcbiAgICAgICAgcG9pbnRzLFxuICAgICAgICBjdXJ2ZVBvaW50cyxcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgbWluRWRnZVggPSBNYXRoLm1pbihtaW5FZGdlWCwgcG9pbnQueCk7XG4gICAgICAgIG1pbkVkZ2VZID0gTWF0aC5taW4obWluRWRnZVksIHBvaW50LnkpO1xuICAgICAgICBtYXhFZGdlWCA9IE1hdGgubWF4KG1heEVkZ2VYLCBwb2ludC54KTtcbiAgICAgICAgbWF4RWRnZVkgPSBNYXRoLm1heChtYXhFZGdlWSwgcG9pbnQueSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubW9kZWxHcmFwaC5lZGdlc0J5R3JvdXBOb2RlSWRzW3Jvb3ROb2RlSWQgfHwgJyddID0gZWRnZXM7XG5cbiAgICAvLyBPZmZzZXQgbm9kZXMgdG8gdGFrZSBpbnRvIGFjY291bnQgb2YgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBib3VuZCBvZiBhbGxcbiAgICAvLyB0aGUgbm9kZXMuXG4gICAgaWYgKG1pbkVkZ2VYIDwgbWluWCkge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUubG9jYWxPZmZzZXRYID0gTWF0aC5tYXgoMCwgbWluWCAtIG1pbkVkZ2VYKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW5YID0gTWF0aC5taW4obWluRWRnZVgsIG1pblgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhFZGdlWCwgbWF4WCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHN1YmdyYXBoIHdpZHRoIGlzIGF0IGxlYXN0IHRoZSB3aWR0aCBvZiB0aGUgcm9vdCBub2RlLlxuICAgIGxldCBzdWJncmFwaEZ1bGxXaWR0aCA9IG1heFggLSBtaW5YICsgTEFZT1VUX01BUkdJTl9YICogMjtcbiAgICBpZiAocm9vdE5vZGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGVXaWR0aCA9IGdldE5vZGVXaWR0aChcbiAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgICAgdGhpcy5zaG93T25Ob2RlSXRlbVR5cGVzLFxuICAgICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICAgKTtcbiAgICAgIGlmIChzdWJncmFwaEZ1bGxXaWR0aCA8IHBhcmVudE5vZGVXaWR0aCkge1xuICAgICAgICBjb25zdCBleHRyYU9mZnNldFggPSAocGFyZW50Tm9kZVdpZHRoIC0gc3ViZ3JhcGhGdWxsV2lkdGgpIC8gMjtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKCFub2RlLmxvY2FsT2Zmc2V0WCkge1xuICAgICAgICAgICAgbm9kZS5sb2NhbE9mZnNldFggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmxvY2FsT2Zmc2V0WCArPSBleHRyYU9mZnNldFg7XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JhcGhGdWxsV2lkdGggPSBwYXJlbnROb2RlV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0IGRvd253YXJkcyBpZiB0aGUgcm9vdCBub2RlIGhhcyBhdHRycyB0YWJsZSBzaG93bi5cbiAgICBpZiAocm9vdE5vZGUgJiYgaXNHcm91cE5vZGUocm9vdE5vZGUpKSB7XG4gICAgICBjb25zdCBhdHRyc1Jvd0NvdW50ID0gZ2V0R3JvdXBOb2RlQXR0cnNUYWJsZVJvd0NvdW50KFxuICAgICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICApO1xuICAgICAgaWYgKGF0dHJzUm93Q291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsT2Zmc2V0WSA9IGF0dHJzUm93Q291bnQgKiBOT0RFX0FUVFJTX1RBQkxFX1JPV19IRUlHSFQgKyAxNjtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZS5sb2NhbE9mZnNldFkgPSBsb2NhbE9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4WSArPSBsb2NhbE9mZnNldFk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG1pblgsXG4gICAgICB5OiBtaW5ZLFxuICAgICAgd2lkdGg6IHN1YmdyYXBoRnVsbFdpZHRoIC0gTEFZT1VUX01BUkdJTl9YICogMixcbiAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY29uZmlnTGF5b3V0KGRhZ3JlR3JhcGg6IERhZ3JlR3JhcGhJbnN0YW5jZSkge1xuICAgIC8vIFNlZSBhdmFpbGFibGUgY29uZmlncyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWdyZWpzL2RhZ3JlL3dpa2kjY29uZmlndXJpbmctdGhlLWxheW91dC5cbiAgICBkYWdyZUdyYXBoLnNldEdyYXBoKHtcbiAgICAgIG5vZGVzZXA6IDIwLFxuICAgICAgcmFua3NlcDogNTAsXG4gICAgICBlZGdlc2VwOiAyMCxcbiAgICAgIG1hcmdpbng6IExBWU9VVF9NQVJHSU5fWCxcbiAgICAgIG1hcmdpbnk6IExBWU9VVF9NQVJHSU5fVE9QLFxuICAgIH0pO1xuICAgIC8vIE5vIGVkZ2UgbGFiZWxzLlxuICAgIGRhZ3JlR3JhcGguc2V0RGVmYXVsdEVkZ2VMYWJlbCgoKSA9PiAoe30pKTtcbiAgfVxufVxuXG4vKiogQW4gdXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgdGhlIG5vZGUgd2lkdGggdXNpbmcgYW4gb2Zmc2NyZWVuIGNhbnZhcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlV2lkdGgoXG4gIG5vZGU6IE1vZGVsTm9kZSxcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbiAgbm9kZURhdGFQcm92aWRlclJ1bnM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhPixcbiAgdGVzdE1vZGUgPSBmYWxzZSxcbikge1xuICAvLyBBbHdheXMgcmV0dXJuIDMyIGluIHRlc3QgbW9kZS5cbiAgaWYgKHRlc3RNb2RlKSB7XG4gICAgcmV0dXJuIE5PREVfV0lEVEhfRk9SX1RFU1Q7XG4gIH1cblxuICBjb25zdCBsYWJlbCA9IG5vZGUubGFiZWw7XG4gIGxldCBsYWJlbFdpZHRoID0gZ2V0TGFiZWxXaWR0aChsYWJlbCwgMTEsIGlzR3JvdXBOb2RlKG5vZGUpKSArIExBQkVMX1BBRERJTkc7XG4gIC8vIEFkZCBzcGFjZSB0byBsYWJlbCB3aWR0aCBmb3IgdGhlIFwiZXhwYW5kL2NvbGxhcHNlIGljb25cIiBhdCB0aGUgbGVmdCBhbmQgdGhlXG4gIC8vIFwibW9yZVwiIGljb24gYXQgdGhlIHJpZ2h0LlxuICBpZiAoaXNHcm91cE5vZGUobm9kZSkpIHtcbiAgICBsYWJlbFdpZHRoICs9IDI4O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiBhdHRycyB0YWJsZS5cbiAgLy9cbiAgLy8gRmlndXJlIG91dCB0aGUgbWF4IHdpZHRoIG9mIGFsbCB0aGUgbGFiZWxzIGFuZCB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICBsZXQgbWF4QXR0ckxhYmVsV2lkdGggPSAwO1xuICBsZXQgbWF4QXR0clZhbHVlV2lkdGggPSAwO1xuICBpZiAoaXNPcE5vZGUobm9kZSkpIHtcbiAgICAvLyBCYXNpYyBpbmZvLlxuICAgIC8vXG4gICAgLy8gR2F0aGVyIGZpZWxkIGlkcyBmb3IgdGhlIHNlbGVjdGVkIHNob3ctb24tbm9kZSBpdGVtcy5cbiAgICBjb25zdCBmaWVsZElkczogc3RyaW5nW10gPVxuICAgICAgZ2V0T3BOb2RlRmllbGRMYWJlbHNGcm9tU2hvd09uTm9kZUl0ZW1UeXBlcyhzaG93T25Ob2RlSXRlbVR5cGVzKTtcbiAgICAvLyBDYWxjdWxhdGUgd2lkdGguXG4gICAgZm9yIChjb25zdCBmaWVsZElkIG9mIGZpZWxkSWRzKSB7XG4gICAgICBjb25zdCBhdHRyTGFiZWxXaWR0aCA9IGdldExhYmVsV2lkdGgoXG4gICAgICAgIGAke2ZpZWxkSWR9OmAsXG4gICAgICAgIE5PREVfQVRUUlNfVEFCTEVfRk9OVF9TSVpFLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0Tm9kZUluZm9GaWVsZFZhbHVlKG5vZGUsIGZpZWxkSWQpO1xuICAgICAgY29uc3QgYXR0clZhbHVlV2lkdGggPSBnZXRMYWJlbFdpZHRoKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgTk9ERV9BVFRSU19UQUJMRV9GT05UX1NJWkUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgKTtcbiAgICAgIG1heEF0dHJMYWJlbFdpZHRoID0gTWF0aC5tYXgobWF4QXR0ckxhYmVsV2lkdGgsIGF0dHJMYWJlbFdpZHRoKTtcbiAgICAgIG1heEF0dHJWYWx1ZVdpZHRoID0gTWF0aC5tYXgobWF4QXR0clZhbHVlV2lkdGgsIGF0dHJWYWx1ZVdpZHRoKTtcbiAgICB9XG5cbiAgICAvLyBBdHRycy5cbiAgICBpZiAoc2hvd09uTm9kZUl0ZW1UeXBlc1tTaG93T25Ob2RlSXRlbVR5cGUuT1BfQVRUUlNdPy5zZWxlY3RlZCkge1xuICAgICAgY29uc3Qga2V5VmFsdWVQYWlycyA9IGdldE9wTm9kZUF0dHJzS2V5VmFsdWVQYWlyc0ZvckF0dHJzVGFibGUoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHNob3dPbk5vZGVJdGVtVHlwZXNbU2hvd09uTm9kZUl0ZW1UeXBlLk9QX0FUVFJTXT8uZmlsdGVyUmVnZXggfHwgJycsXG4gICAgICApO1xuICAgICAgY29uc3Qgd2lkdGhzID0gZ2V0TWF4QXR0ckxhYmVsQW5kVmFsdWVXaWR0aChrZXlWYWx1ZVBhaXJzKTtcbiAgICAgIG1heEF0dHJMYWJlbFdpZHRoID0gTWF0aC5tYXgobWF4QXR0ckxhYmVsV2lkdGgsIHdpZHRocy5tYXhBdHRyTGFiZWxXaWR0aCk7XG4gICAgICBtYXhBdHRyVmFsdWVXaWR0aCA9IE1hdGgubWF4KG1heEF0dHJWYWx1ZVdpZHRoLCB3aWR0aHMubWF4QXR0clZhbHVlV2lkdGgpO1xuICAgIH1cblxuICAgIC8vIElucHV0cy5cbiAgICBpZiAoc2hvd09uTm9kZUl0ZW1UeXBlc1tTaG93T25Ob2RlSXRlbVR5cGUuT1BfSU5QVVRTXT8uc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBnZXRPcE5vZGVJbnB1dHNLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICk7XG4gICAgICBjb25zdCB3aWR0aHMgPSBnZXRNYXhBdHRyTGFiZWxBbmRWYWx1ZVdpZHRoKGtleVZhbHVlUGFpcnMpO1xuICAgICAgbWF4QXR0ckxhYmVsV2lkdGggPSBNYXRoLm1heChtYXhBdHRyTGFiZWxXaWR0aCwgd2lkdGhzLm1heEF0dHJMYWJlbFdpZHRoKTtcbiAgICAgIG1heEF0dHJWYWx1ZVdpZHRoID0gTWF0aC5tYXgobWF4QXR0clZhbHVlV2lkdGgsIHdpZHRocy5tYXhBdHRyVmFsdWVXaWR0aCk7XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0c1xuICAgIGlmIChzaG93T25Ob2RlSXRlbVR5cGVzW1Nob3dPbk5vZGVJdGVtVHlwZS5PUF9PVVRQVVRTXT8uc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBnZXRPcE5vZGVPdXRwdXRzS2V5VmFsdWVQYWlyc0ZvckF0dHJzVGFibGUobm9kZSk7XG4gICAgICBjb25zdCB3aWR0aHMgPSBnZXRNYXhBdHRyTGFiZWxBbmRWYWx1ZVdpZHRoKGtleVZhbHVlUGFpcnMpO1xuICAgICAgbWF4QXR0ckxhYmVsV2lkdGggPSBNYXRoLm1heChtYXhBdHRyTGFiZWxXaWR0aCwgd2lkdGhzLm1heEF0dHJMYWJlbFdpZHRoKTtcbiAgICAgIG1heEF0dHJWYWx1ZVdpZHRoID0gTWF0aC5tYXgobWF4QXR0clZhbHVlV2lkdGgsIHdpZHRocy5tYXhBdHRyVmFsdWVXaWR0aCk7XG4gICAgfVxuXG4gICAgLy8gTm9kZSBkYXRhIHByb3ZpZGVycy5cbiAgICBjb25zdCBub2RlRGF0YVByb3ZpZGVyS2V5VmFsdWVQYWlycyA9XG4gICAgICBnZXRPcE5vZGVEYXRhUHJvdmlkZXJLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbW9kZWxHcmFwaC5pZCxcbiAgICAgICAgc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgbm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICApO1xuICAgIGNvbnN0IG5vZGVEYXRhUHJvdmlkZXJXaWR0aHMgPSBnZXRNYXhBdHRyTGFiZWxBbmRWYWx1ZVdpZHRoKFxuICAgICAgbm9kZURhdGFQcm92aWRlcktleVZhbHVlUGFpcnMsXG4gICAgKTtcbiAgICBtYXhBdHRyTGFiZWxXaWR0aCA9IE1hdGgubWF4KFxuICAgICAgbWF4QXR0ckxhYmVsV2lkdGgsXG4gICAgICBub2RlRGF0YVByb3ZpZGVyV2lkdGhzLm1heEF0dHJMYWJlbFdpZHRoLFxuICAgICk7XG4gICAgbWF4QXR0clZhbHVlV2lkdGggPSBNYXRoLm1heChcbiAgICAgIG1heEF0dHJWYWx1ZVdpZHRoLFxuICAgICAgbm9kZURhdGFQcm92aWRlcldpZHRocy5tYXhBdHRyVmFsdWVXaWR0aCxcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzR3JvdXBOb2RlKG5vZGUpKSB7XG4gICAgLy8gQmFzaWMgaW5mb1xuICAgIC8vXG4gICAgLy8gR2F0aGVyIGJhc2ljIGluZm8gZmllbGQgaWRzIGZvciB0aGUgc2VsZWN0ZWQgc2hvdy1vbi1ub2RlIGl0ZW1zLlxuICAgIGNvbnN0IGJhc2ljSW5mb0ZpZWxkSWRzOiBzdHJpbmdbXSA9XG4gICAgICBnZXRHcm91cE5vZGVGaWVsZExhYmVsc0Zyb21TaG93T25Ob2RlSXRlbVR5cGVzKHNob3dPbk5vZGVJdGVtVHlwZXMpO1xuICAgIC8vIENhbGN1bGF0ZSB3aWR0aC5cbiAgICBmb3IgKGNvbnN0IGZpZWxkSWQgb2YgYmFzaWNJbmZvRmllbGRJZHMpIHtcbiAgICAgIGNvbnN0IGF0dHJMYWJlbFdpZHRoID0gZ2V0TGFiZWxXaWR0aChcbiAgICAgICAgYCR7ZmllbGRJZH06YCxcbiAgICAgICAgTk9ERV9BVFRSU19UQUJMRV9GT05UX1NJWkUsXG4gICAgICAgIHRydWUsXG4gICAgICApO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXROb2RlSW5mb0ZpZWxkVmFsdWUobm9kZSwgZmllbGRJZCk7XG4gICAgICBjb25zdCBhdHRyVmFsdWVXaWR0aCA9IGdldExhYmVsV2lkdGgoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBOT0RFX0FUVFJTX1RBQkxFX0ZPTlRfU0laRSxcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuICAgICAgbWF4QXR0ckxhYmVsV2lkdGggPSBNYXRoLm1heChtYXhBdHRyTGFiZWxXaWR0aCwgYXR0ckxhYmVsV2lkdGgpO1xuICAgICAgbWF4QXR0clZhbHVlV2lkdGggPSBNYXRoLm1heChtYXhBdHRyVmFsdWVXaWR0aCwgYXR0clZhbHVlV2lkdGgpO1xuICAgIH1cbiAgfVxuICBtYXhBdHRyVmFsdWVXaWR0aCA9IE1hdGgubWluKFxuICAgIG1heEF0dHJWYWx1ZVdpZHRoLFxuICAgIE5PREVfQVRUUlNfVEFCTEVfVkFMVUVfTUFYX1dJRFRILFxuICApO1xuICBsZXQgYXR0cnNUYWJsZVdpZHRoID1cbiAgICBtYXhBdHRyTGFiZWxXaWR0aCArXG4gICAgbWF4QXR0clZhbHVlV2lkdGggK1xuICAgIE5PREVfQVRUUlNfVEFCTEVfTEVGVF9SSUdIVF9QQURESU5HICogMiArXG4gICAgTk9ERV9BVFRSU19UQUJMRV9MQUJFTF9WQUxVRV9QQURESU5HO1xuICBpZiAoYXR0cnNUYWJsZVdpZHRoICE9PSBOT0RFX0FUVFJTX1RBQkxFX0xBQkVMX1ZBTFVFX1BBRERJTkcpIHtcbiAgICBhdHRyc1RhYmxlV2lkdGggKz0gQVRUUlNfVEFCTEVfTUFSR0lOX1ggKiAyO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChNSU5fTk9ERV9XSURUSCwgTWF0aC5tYXgobGFiZWxXaWR0aCwgYXR0cnNUYWJsZVdpZHRoKSk7XG59XG5cbi8qKiBBbiB1dGlsaXR5IGZ1bmN0aW9uIHRvIGdldCB0aGUgbm9kZSBoZWlnaHQuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUhlaWdodChcbiAgbm9kZTogTW9kZWxOb2RlLFxuICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuICBzaG93T25Ob2RlSXRlbVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+LFxuICBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJ1bkRhdGE+LFxuICB0ZXN0TW9kZSA9IGZhbHNlLFxuICBmb3JjZVJlY2FsY3VsYXRlID0gZmFsc2UsXG4pIHtcbiAgaWYgKHRlc3RNb2RlKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfTk9ERV9IRUlHSFQ7XG4gIH1cblxuICBpZiAobm9kZS5oZWlnaHQgIT0gbnVsbCAmJiAhZm9yY2VSZWNhbGN1bGF0ZSkge1xuICAgIHJldHVybiBub2RlLmhlaWdodDtcbiAgfVxuXG4gIC8vIENvdW50IGhvdyBtYW55IHJvd3Mgd2lsbCBiZSBpbiB0aGUgYXR0cnMgdGFibGUuXG4gIGxldCBhdHRyc1RhYmxlUm93Q291bnQgPSAwO1xuICBpZiAoaXNPcE5vZGUobm9kZSkpIHtcbiAgICBhdHRyc1RhYmxlUm93Q291bnQgPSBnZXRPcE5vZGVBdHRyc1RhYmxlUm93Q291bnQoXG4gICAgICBzaG93T25Ob2RlSXRlbVR5cGVzLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNHcm91cE5vZGUobm9kZSkpIHtcbiAgICBhdHRyc1RhYmxlUm93Q291bnQgPSBnZXRHcm91cE5vZGVBdHRyc1RhYmxlUm93Q291bnQoc2hvd09uTm9kZUl0ZW1UeXBlcyk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIERFRkFVTFRfTk9ERV9IRUlHSFQgK1xuICAgIGF0dHJzVGFibGVSb3dDb3VudCAqIE5PREVfQVRUUlNfVEFCTEVfUk9XX0hFSUdIVCArXG4gICAgKGF0dHJzVGFibGVSb3dDb3VudCA+IDAgPyBOT0RFX0FUVFJTX1RBQkxFX01BUkdJTl9UT1AgLSA0IDogMClcbiAgKTtcbn1cblxuLyoqIEdldHMgYSBsYXlvdXQgZ3JhcGggZm9yIHRoZSBnaXZlbiBub2Rlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXlvdXRHcmFwaChcbiAgcm9vdEdyb3VwTm9kZUlkOiBzdHJpbmcsXG4gIG5vZGVzOiBNb2RlbE5vZGVbXSxcbiAgbW9kZWxHcmFwaDogTW9kZWxHcmFwaCxcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbiAgbm9kZURhdGFQcm92aWRlclJ1bnM6IFJlY29yZDxzdHJpbmcsIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhPixcbiAgdGVzdE1vZGUgPSBmYWxzZSxcbiAgdXNlRmFrZU5vZGVTaXplID0gZmFsc2UsXG4pOiBMYXlvdXRHcmFwaCB7XG4gIGNvbnN0IGxheW91dEdyYXBoOiBMYXlvdXRHcmFwaCA9IHtcbiAgICBub2Rlczoge30sXG4gICAgaW5jb21pbmdFZGdlczoge30sXG4gICAgb3V0Z29pbmdFZGdlczoge30sXG4gIH07XG5cbiAgLy8gQ3JlYXRlIGxheW91dCBncmFwaCBub2Rlcy5cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKGlzT3BOb2RlKG5vZGUpICYmIG5vZGUuaGlkZUluTGF5b3V0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZGFncmVOb2RlOiBEYWdyZU5vZGUgPSB7XG4gICAgICBpZDogbm9kZS5pZCxcbiAgICAgIHdpZHRoOlxuICAgICAgICBub2RlLndpZHRoIHx8XG4gICAgICAgICh1c2VGYWtlTm9kZVNpemVcbiAgICAgICAgICA/IDEwXG4gICAgICAgICAgOiBnZXROb2RlV2lkdGgoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIG1vZGVsR3JhcGgsXG4gICAgICAgICAgICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICAgICAgICAgIG5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICAgICAgICAgICB0ZXN0TW9kZSxcbiAgICAgICAgICAgICkpLFxuICAgICAgaGVpZ2h0OiB1c2VGYWtlTm9kZVNpemVcbiAgICAgICAgPyAxMFxuICAgICAgICA6IGdldE5vZGVIZWlnaHQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICAgICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICAgICAgICBub2RlRGF0YVByb3ZpZGVyUnVucyxcbiAgICAgICAgICAgIHRlc3RNb2RlLFxuICAgICAgICAgICksXG4gICAgfTtcbiAgICBsYXlvdXRHcmFwaC5ub2Rlc1tub2RlLmlkXSA9IGRhZ3JlTm9kZTtcbiAgfVxuXG4gIC8vIFNldCBsYXlvdXQgZ3JhcGggZWRnZXMuXG4gIGNvbnN0IGN1ckxheW91dEdyYXBoRWRnZXMgPVxuICAgIG1vZGVsR3JhcGgubGF5b3V0R3JhcGhFZGdlc1tyb290R3JvdXBOb2RlSWRdIHx8IHt9O1xuICBmb3IgKGNvbnN0IFtmcm9tTm9kZUlkLCB0b05vZGVJZHNdIG9mIE9iamVjdC5lbnRyaWVzKGN1ckxheW91dEdyYXBoRWRnZXMpKSB7XG4gICAgZm9yIChjb25zdCB0b05vZGVJZCBvZiBPYmplY3Qua2V5cyh0b05vZGVJZHMpKSB7XG4gICAgICBhZGRMYXlvdXRHcmFwaEVkZ2UobGF5b3V0R3JhcGgsIGZyb21Ob2RlSWQsIHRvTm9kZUlkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGF5b3V0R3JhcGg7XG59XG5cbmZ1bmN0aW9uIGdldE9wTm9kZUF0dHJzVGFibGVSb3dDb3VudChcbiAgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbiAgbm9kZTogT3BOb2RlLFxuICBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJ1bkRhdGE+LFxuKTogbnVtYmVyIHtcbiAgLy8gQmFzaWMgaW5mbyBmaWVsZHMuXG4gIGNvbnN0IGJhaXNjRmllbGRJZHMgPVxuICAgIGdldE9wTm9kZUZpZWxkTGFiZWxzRnJvbVNob3dPbk5vZGVJdGVtVHlwZXMoc2hvd09uTm9kZUl0ZW1UeXBlcyk7XG5cbiAgLy8gTm9kZSBhdHRyaWJ1dGVzLlxuICBjb25zdCBhdHRyc0NvdW50ID0gc2hvd09uTm9kZUl0ZW1UeXBlc1tTaG93T25Ob2RlSXRlbVR5cGUuT1BfQVRUUlNdPy5zZWxlY3RlZFxuICAgID8gZ2V0T3BOb2RlQXR0cnNLZXlWYWx1ZVBhaXJzRm9yQXR0cnNUYWJsZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2hvd09uTm9kZUl0ZW1UeXBlc1tTaG93T25Ob2RlSXRlbVR5cGUuT1BfQVRUUlNdPy5maWx0ZXJSZWdleCB8fCAnJyxcbiAgICAgICkubGVuZ3RoXG4gICAgOiAwO1xuXG4gIC8vIElucHV0cy5cbiAgbGV0IGlucHV0c0NvdW50ID0gc2hvd09uTm9kZUl0ZW1UeXBlc1tTaG93T25Ob2RlSXRlbVR5cGUuT1BfSU5QVVRTXT8uc2VsZWN0ZWRcbiAgICA/IE9iamVjdC5rZXlzKG5vZGUuaW5jb21pbmdFZGdlcyB8fCBbXSkubGVuZ3RoXG4gICAgOiAwO1xuICBpZiAoaW5wdXRzQ291bnQgPiBNQVhfSU9fUk9XU19JTl9BVFRSU19UQUJMRSkge1xuICAgIGlucHV0c0NvdW50ID0gTUFYX0lPX1JPV1NfSU5fQVRUUlNfVEFCTEUgKyAxO1xuICB9XG5cbiAgLy8gT3V0cHV0cy5cbiAgbGV0IG91dHB1dHNDb3VudCA9IHNob3dPbk5vZGVJdGVtVHlwZXNbU2hvd09uTm9kZUl0ZW1UeXBlLk9QX09VVFBVVFNdXG4gICAgPy5zZWxlY3RlZFxuICAgID8gT2JqZWN0LmtleXMobm9kZS5vdXRwdXRzTWV0YWRhdGEgfHwge30pLmxlbmd0aFxuICAgIDogMDtcbiAgaWYgKG91dHB1dHNDb3VudCA+IE1BWF9JT19ST1dTX0lOX0FUVFJTX1RBQkxFKSB7XG4gICAgb3V0cHV0c0NvdW50ID0gTUFYX0lPX1JPV1NfSU5fQVRUUlNfVEFCTEUgKyAxO1xuICB9XG5cbiAgLy8gTm9kZSBkYXRhIHByb3ZpZGVycy5cbiAgY29uc3Qgbm9kZURhdGFQcm92aWRlckNvdW50ID0gT2JqZWN0LmtleXMoc2hvd09uTm9kZUl0ZW1UeXBlcylcbiAgICAuZmlsdGVyKCh0eXBlKSA9PiBzaG93T25Ob2RlSXRlbVR5cGVzW3R5cGVdLnNlbGVjdGVkKVxuICAgIC5maWx0ZXIoXG4gICAgICAoc2hvd09uTm9kZUl0ZW1UeXBlOiBzdHJpbmcpID0+XG4gICAgICAgIHNob3dPbk5vZGVJdGVtVHlwZS5zdGFydHNXaXRoKFxuICAgICAgICAgIE5PREVfREFUQV9QUk9WSURFUl9TSE9XX09OX05PREVfVFlQRV9QUkVGSVgsXG4gICAgICAgICkgJiZcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhub2RlRGF0YVByb3ZpZGVyUnVucykuc29tZShcbiAgICAgICAgICAocnVuKSA9PlxuICAgICAgICAgICAgcnVuLnJ1bk5hbWUgPT09XG4gICAgICAgICAgICBzaG93T25Ob2RlSXRlbVR5cGUucmVwbGFjZShcbiAgICAgICAgICAgICAgTk9ERV9EQVRBX1BST1ZJREVSX1NIT1dfT05fTk9ERV9UWVBFX1BSRUZJWCxcbiAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICkubGVuZ3RoO1xuXG4gIHJldHVybiAoXG4gICAgYmFpc2NGaWVsZElkcy5sZW5ndGggK1xuICAgIGF0dHJzQ291bnQgK1xuICAgIGlucHV0c0NvdW50ICtcbiAgICBvdXRwdXRzQ291bnQgK1xuICAgIG5vZGVEYXRhUHJvdmlkZXJDb3VudFxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cE5vZGVBdHRyc1RhYmxlUm93Q291bnQoXG4gIHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT4sXG4pOiBudW1iZXIge1xuICBjb25zdCBiYWlzY0ZpZWxkSWRzID1cbiAgICBnZXRHcm91cE5vZGVGaWVsZExhYmVsc0Zyb21TaG93T25Ob2RlSXRlbVR5cGVzKHNob3dPbk5vZGVJdGVtVHlwZXMpO1xuICByZXR1cm4gYmFpc2NGaWVsZElkcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGFkZExheW91dEdyYXBoRWRnZShcbiAgbGF5b3V0R3JhcGg6IExheW91dEdyYXBoLFxuICBmcm9tTm9kZUlkOiBzdHJpbmcsXG4gIHRvTm9kZUlkOiBzdHJpbmcsXG4pIHtcbiAgaWYgKGxheW91dEdyYXBoLm91dGdvaW5nRWRnZXNbZnJvbU5vZGVJZF0gPT0gbnVsbCkge1xuICAgIGxheW91dEdyYXBoLm91dGdvaW5nRWRnZXNbZnJvbU5vZGVJZF0gPSBbXTtcbiAgfVxuICBsYXlvdXRHcmFwaC5vdXRnb2luZ0VkZ2VzW2Zyb21Ob2RlSWRdLnB1c2godG9Ob2RlSWQpO1xuXG4gIGlmIChsYXlvdXRHcmFwaC5pbmNvbWluZ0VkZ2VzW3RvTm9kZUlkXSA9PSBudWxsKSB7XG4gICAgbGF5b3V0R3JhcGguaW5jb21pbmdFZGdlc1t0b05vZGVJZF0gPSBbXTtcbiAgfVxuICBsYXlvdXRHcmFwaC5pbmNvbWluZ0VkZ2VzW3RvTm9kZUlkXS5wdXNoKGZyb21Ob2RlSWQpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhBdHRyTGFiZWxBbmRWYWx1ZVdpZHRoKGtleVZhbHVlUGFpcnM6IEtleVZhbHVlTGlzdCk6IHtcbiAgbWF4QXR0ckxhYmVsV2lkdGg6IG51bWJlcjtcbiAgbWF4QXR0clZhbHVlV2lkdGg6IG51bWJlcjtcbn0ge1xuICBsZXQgbWF4QXR0ckxhYmVsV2lkdGggPSAwO1xuICBsZXQgbWF4QXR0clZhbHVlV2lkdGggPSAwO1xuICBmb3IgKGNvbnN0IHtrZXksIHZhbHVlfSBvZiBrZXlWYWx1ZVBhaXJzKSB7XG4gICAgY29uc3QgYXR0ckxhYmVsV2lkdGggPSBnZXRMYWJlbFdpZHRoKGtleSwgTk9ERV9BVFRSU19UQUJMRV9GT05UX1NJWkUsIHRydWUpO1xuICAgIG1heEF0dHJMYWJlbFdpZHRoID0gTWF0aC5tYXgobWF4QXR0ckxhYmVsV2lkdGgsIGF0dHJMYWJlbFdpZHRoKTtcbiAgICBjb25zdCBhdHRyVmFsdWVXaWR0aCA9IGdldExhYmVsV2lkdGgoXG4gICAgICB2YWx1ZSxcbiAgICAgIE5PREVfQVRUUlNfVEFCTEVfRk9OVF9TSVpFLFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICBtYXhBdHRyVmFsdWVXaWR0aCA9IE1hdGgubWF4KG1heEF0dHJWYWx1ZVdpZHRoLCBhdHRyVmFsdWVXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIHttYXhBdHRyTGFiZWxXaWR0aCwgbWF4QXR0clZhbHVlV2lkdGh9O1xufVxuIl19
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_expander.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_expander.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_expander');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_expander.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_model_graph_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_2 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_utils_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils");
const tsickle_dagre_types_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.dagre_types");
const tsickle_graph_layout_5 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout");
const utils_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
const graph_layout_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout');
/**
 * A class that handles expanding and collapsing group nodes in a model graph.
 */
class GraphExpander {
    /**
     * @public
     * @param {!tsickle_model_graph_1.ModelGraph} modelGraph
     * @param {!tsickle_dagre_types_4.Dagre} dagre
     * @param {?} showOnNodeItemTypes
     * @param {?} nodeDataProviderRuns
     * @param {boolean=} testMode
     */
    constructor(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns, testMode = false) {
        this.modelGraph = modelGraph;
        this.dagre = dagre;
        this.showOnNodeItemTypes = showOnNodeItemTypes;
        this.nodeDataProviderRuns = nodeDataProviderRuns;
        this.testMode = testMode;
        /**
         * This is for testing purpose.
         */
        this.dagreGraphs = [];
    }
    /**
     * Expands the given group node to show its child nodes.
     * @public
     * @param {string} groupNodeId
     * @return {void}
     */
    expandGroupNode(groupNodeId) {
        /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
        const groupNode = this.modelGraph.nodesById[groupNodeId];
        if (groupNode && (0, utils_1.isGroupNode)(groupNode)) {
            if ((/** @type {!tsickle_model_graph_1.GroupNode} */ (groupNode)).expanded) {
                return;
            }
            (/** @type {!tsickle_model_graph_1.GroupNode} */ (groupNode)).expanded = true;
        }
        // From the given group node, layout its children, grow its size, and
        // continue to do the same for all its ancestors until reaching the root.
        /** @type {(undefined|string)} */
        let curGroupNodeId = groupNodeId;
        while (curGroupNodeId != null) {
            /** @type {!tsickle_model_graph_1.GroupNode} */
            const curGroupNode = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[curGroupNodeId]));
            if (!curGroupNode) {
                break;
            }
            curGroupNode.expanded = true;
            // Layout children.
            /** @type {!tsickle_graph_layout_5.GraphLayout} */
            const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
            /** @type {!tsickle_types_2.Rect} */
            const rect = layout.layout(curGroupNodeId);
            if (this.testMode) {
                this.dagreGraphs.push(layout.dagreGraph);
            }
            // Grow size.
            /** @type {number} */
            const curTargetWidth = rect.width + graph_layout_1.LAYOUT_MARGIN_X * 2;
            /** @type {number} */
            const curTargetHeight = rect.height + graph_layout_1.LAYOUT_MARGIN_TOP + graph_layout_1.LAYOUT_MARGIN_BOTTOM;
            curGroupNode.width = curTargetWidth;
            curGroupNode.height = curTargetHeight;
            // Continue with parent.
            curGroupNodeId = curGroupNode.nsParentId;
        }
        // Layout the root level nodes.
        /** @type {!tsickle_graph_layout_5.GraphLayout} */
        const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
        layout.layout();
        if (this.testMode) {
            this.dagreGraphs.push(layout.dagreGraph);
        }
        // From root, update offsets of all nodes that have x, y set (meaning they
        // have the layout data).
        for (const node of this.modelGraph.rootNodes) {
            if ((0, utils_1.isGroupNode)(node)) {
                this.updateNodeOffset(node);
            }
        }
    }
    /**
     * Expands from the given deepest group nodes back to root.
     * @public
     * @param {!Array<string>} groupNodeIds
     * @return {void}
     */
    expandFromDeepestGroupNodes(groupNodeIds) {
        // Get all ancestors from the given group node ids.
        /** @type {!Set<string>} */
        const seenGroupNodeIds = new Set();
        /** @type {!Array<string>} */
        const queue = [...groupNodeIds];
        while (queue.length > 0) {
            /** @type {string} */
            const curGroupNodeId = (/** @type {string} */ (queue.shift()));
            if (seenGroupNodeIds.has(curGroupNodeId)) {
                continue;
            }
            seenGroupNodeIds.add(curGroupNodeId);
            /** @type {!tsickle_model_graph_1.GroupNode} */
            const groupNode = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[curGroupNodeId]));
            /** @type {(undefined|string)} */
            const parentGroupNodeId = groupNode?.nsParentId;
            if (parentGroupNodeId) {
                queue.push(parentGroupNodeId);
            }
        }
        // Sort them by level in descending order.
        /** @type {!Array<string>} */
        const sortedGroupNodeIds = Array.from(seenGroupNodeIds).sort((/**
         * @param {string} a
         * @param {string} b
         * @return {number}
         */
        (a, b) => {
            /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
            const nodeA = this.modelGraph.nodesById[a];
            /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
            const nodeB = this.modelGraph.nodesById[b];
            return nodeB.level - nodeA.level;
        }));
        // Layout group nodes in this sorted list.
        for (const groupNodeId of sortedGroupNodeIds) {
            /** @type {!tsickle_model_graph_1.GroupNode} */
            const groupNode = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[groupNodeId]));
            groupNode.expanded = true;
            // Layout children.
            /** @type {!tsickle_graph_layout_5.GraphLayout} */
            const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
            /** @type {!tsickle_types_2.Rect} */
            const rect = layout.layout(groupNodeId);
            if (this.testMode) {
                this.dagreGraphs.push(layout.dagreGraph);
            }
            // Grow size.
            /** @type {number} */
            const curTargetWidth = rect.width + graph_layout_1.LAYOUT_MARGIN_X * 2;
            /** @type {number} */
            const curTargetHeight = rect.height + graph_layout_1.LAYOUT_MARGIN_TOP + graph_layout_1.LAYOUT_MARGIN_BOTTOM;
            groupNode.width = curTargetWidth;
            groupNode.height = curTargetHeight;
        }
        // Layout the root level nodes.
        /** @type {!tsickle_graph_layout_5.GraphLayout} */
        const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
        layout.layout();
        if (this.testMode) {
            this.dagreGraphs.push(layout.dagreGraph);
        }
        // From root, update offsets of all nodes that have x, y set (meaning they
        // have the layout data).
        for (const node of this.modelGraph.rootNodes) {
            if ((0, utils_1.isGroupNode)(node)) {
                this.updateNodeOffset(node);
            }
        }
    }
    /**
     * Expands the graph to reveal the given node.
     * @public
     * @param {string} nodeId
     * @return {!Array<string>}
     */
    expandToRevealNode(nodeId) {
        /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
        const node = this.modelGraph.nodesById[nodeId];
        /** @type {!Array<!tsickle_model_graph_1.GroupNode>} */
        const groupNodes = [];
        /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
        let curNode = node;
        while (true) {
            /** @type {!tsickle_model_graph_1.GroupNode} */
            const nsParent = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[curNode.nsParentId || '']));
            if (!nsParent) {
                break;
            }
            groupNodes.unshift(nsParent);
            curNode = nsParent;
        }
        for (const groupNode of groupNodes) {
            this.expandGroupNode(groupNode.id);
        }
        /** @type {!Array<string>} */
        const deepestExpandedGroupNodeIds = [];
        (0, utils_1.getDeepestExpandedGroupNodeIds)(undefined, this.modelGraph, deepestExpandedGroupNodeIds);
        return deepestExpandedGroupNodeIds;
    }
    /**
     * Collapses the given group node to hide all its child nodes.
     * @public
     * @param {string} groupNodeId
     * @return {!Array<string>}
     */
    collapseGroupNode(groupNodeId) {
        /** @type {!tsickle_model_graph_1.GroupNode} */
        const groupNode = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[groupNodeId]));
        if (!groupNode) {
            return [];
        }
        groupNode.expanded = false;
        delete this.modelGraph.edgesByGroupNodeIds[groupNodeId];
        // Shrink size for the current group node.
        groupNode.width = (0, graph_layout_1.getNodeWidth)(groupNode, this.modelGraph, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
        groupNode.height = (0, graph_layout_1.getNodeHeight)(groupNode, this.modelGraph, this.showOnNodeItemTypes, this.nodeDataProviderRuns, this.testMode, true);
        // From the given group node's parent, layout, update size, and continue to
        // do the same for all its ancestors until reaching the root.
        /** @type {(undefined|string)} */
        let curGroupNodeId = groupNode.nsParentId;
        while (curGroupNodeId != null) {
            /** @type {!tsickle_model_graph_1.GroupNode} */
            const curGroupNode = (/** @type {!tsickle_model_graph_1.GroupNode} */ (this.modelGraph.nodesById[curGroupNodeId]));
            if (!curGroupNode) {
                break;
            }
            // Layout.
            /** @type {!tsickle_graph_layout_5.GraphLayout} */
            const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
            /** @type {!tsickle_types_2.Rect} */
            const rect = layout.layout(curGroupNodeId);
            if (this.testMode) {
                this.dagreGraphs.push(layout.dagreGraph);
            }
            // Shrink size.
            /** @type {number} */
            const curTargetWidth = rect.width + graph_layout_1.LAYOUT_MARGIN_X * 2;
            /** @type {number} */
            const curTargetHeight = rect.height + graph_layout_1.LAYOUT_MARGIN_TOP + graph_layout_1.LAYOUT_MARGIN_BOTTOM;
            curGroupNode.width = curTargetWidth;
            curGroupNode.height = curTargetHeight;
            // Continue with parent.
            curGroupNodeId = curGroupNode.nsParentId;
        }
        // Layout the root level nodes.
        /** @type {!tsickle_graph_layout_5.GraphLayout} */
        const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
        layout.layout();
        if (this.testMode) {
            this.dagreGraphs.push(layout.dagreGraph);
        }
        // From root, update offsets of all nodes that have x, y set (meaning they
        // have the layout data).
        for (const node of this.modelGraph.rootNodes) {
            if ((0, utils_1.isGroupNode)(node)) {
                this.updateNodeOffset(node);
            }
        }
        /** @type {!Array<string>} */
        const deepestExpandedGroupNodeIds = [];
        (0, utils_1.getDeepestExpandedGroupNodeIds)(undefined, this.modelGraph, deepestExpandedGroupNodeIds);
        return deepestExpandedGroupNodeIds;
    }
    /**
     * Uses the current collapse/expand states of the group nodes and re-lays out
     * the entire graph.
     * @public
     * @param {(undefined|!Array<string>)=} targetDeepestGroupNodeIdsToExpand
     * @param {(undefined|boolean)=} clearAllExpandStates
     * @return {!Array<string>}
     */
    reLayoutGraph(targetDeepestGroupNodeIdsToExpand, clearAllExpandStates) {
        /** @type {(undefined|!Array<string>)} */
        let curTargetDeepestGroupNodeIdsToExpand = targetDeepestGroupNodeIdsToExpand;
        if (!curTargetDeepestGroupNodeIdsToExpand) {
            // Find the deepest group nodes that non of its child group nodes is
            // expanded.
            /** @type {!Array<string>} */
            const deepestExpandedGroupNodeIds = [];
            this.clearLayoutData(undefined);
            (0, utils_1.getDeepestExpandedGroupNodeIds)(undefined, this.modelGraph, deepestExpandedGroupNodeIds);
            curTargetDeepestGroupNodeIdsToExpand = deepestExpandedGroupNodeIds;
        }
        else {
            if (clearAllExpandStates) {
                this.clearLayoutData(undefined, true);
            }
        }
        // Expand those nodes one by one.
        if (curTargetDeepestGroupNodeIdsToExpand.length > 0) {
            this.expandFromDeepestGroupNodes(curTargetDeepestGroupNodeIdsToExpand);
        }
        else {
            /** @type {!tsickle_graph_layout_5.GraphLayout} */
            const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
            layout.layout();
        }
        return curTargetDeepestGroupNodeIdsToExpand;
    }
    /**
     * @public
     * @return {!Array<string>}
     */
    expandAllGroups() {
        this.clearLayoutData(undefined, true);
        // Find all deepest group nodes.
        /** @type {!Array<string>} */
        const deepestGroupNodeIds = this.modelGraph.nodes
            .filter((/**
         * @param {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} node
         * @return {boolean}
         */
        (node) => (0, utils_1.isGroupNode)(node) &&
            ((/** @type {!tsickle_model_graph_1.GroupNode} */ (node)).nsChildrenIds || []).filter((/**
             * @param {string} id
             * @return {boolean}
             */
            (id) => (0, utils_1.isGroupNode)(this.modelGraph.nodesById[id]))).length === 0))
            .map((/**
         * @param {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} node
         * @return {string}
         */
        (node) => node.id));
        // Expand from them.
        if (deepestGroupNodeIds.length > 0) {
            this.expandFromDeepestGroupNodes(deepestGroupNodeIds);
        }
        return deepestGroupNodeIds;
    }
    /**
     * @public
     * @return {!Array<string>}
     */
    collapseAllGroup() {
        this.clearLayoutData(undefined, true);
        // Layout the root level nodes.
        /** @type {!tsickle_graph_layout_5.GraphLayout} */
        const layout = new graph_layout_1.GraphLayout(this.modelGraph, this.dagre, this.showOnNodeItemTypes, this.nodeDataProviderRuns);
        layout.layout();
        // From root, update offsets of all nodes that have x, y set (meaning they
        // have the layout data).
        for (const node of this.modelGraph.rootNodes) {
            if ((0, utils_1.isGroupNode)(node)) {
                this.updateNodeOffset(node);
            }
        }
        return [];
    }
    /**
     * @private
     * @param {!tsickle_model_graph_1.GroupNode} groupNode
     * @return {void}
     */
    updateNodeOffset(groupNode) {
        for (const nodeId of groupNode.nsChildrenIds || []) {
            /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
            const node = this.modelGraph.nodesById[nodeId];
            if (node.x != null && node.y != null) {
                node.globalX =
                    (groupNode.x || 0) +
                        (groupNode.globalX || 0) +
                        (node.localOffsetX || 0);
                node.globalY =
                    (groupNode.y || 0) +
                        (groupNode.globalY || 0) +
                        (node.localOffsetY || 0);
            }
            if ((0, utils_1.isGroupNode)(node)) {
                this.updateNodeOffset(node);
            }
        }
    }
    /**
     * @private
     * @param {(undefined|!tsickle_model_graph_1.GroupNode)} root
     * @param {(undefined|boolean)=} clearAllExpandStates
     * @return {void}
     */
    clearLayoutData(root, clearAllExpandStates) {
        /** @type {!Array<string>} */
        let nsChildrenIds = [];
        if (root == null) {
            nsChildrenIds = this.modelGraph.rootNodes.map((/**
             * @param {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} node
             * @return {string}
             */
            (node) => node.id));
        }
        else {
            nsChildrenIds = root.nsChildrenIds || [];
        }
        if (clearAllExpandStates && root != null) {
            root.expanded = false;
            delete this.modelGraph.edgesByGroupNodeIds[root.id];
        }
        for (const nsChildNodeId of nsChildrenIds) {
            /** @type {(!tsickle_model_graph_1.OpNode|!tsickle_model_graph_1.GroupNode)} */
            const childNode = this.modelGraph.nodesById[nsChildNodeId];
            if (!childNode) {
                continue;
            }
            childNode.width = undefined;
            childNode.height = undefined;
            if ((0, utils_1.isGroupNode)(childNode) && (/** @type {!tsickle_model_graph_1.GroupNode} */ (childNode)).expanded) {
                this.clearLayoutData(childNode, clearAllExpandStates);
            }
        }
    }
}
exports.GraphExpander = GraphExpander;
/* istanbul ignore if */
if (false) {
    /**
     * This is for testing purpose.
     * @const {!Array<!tsickle_dagre_types_4.DagreGraphInstance>}
     * @public
     */
    GraphExpander.prototype.dagreGraphs;
    /**
     * @const {!tsickle_model_graph_1.ModelGraph}
     * @private
     */
    GraphExpander.prototype.modelGraph;
    /**
     * @const {!tsickle_dagre_types_4.Dagre}
     * @private
     */
    GraphExpander.prototype.dagre;
    /**
     * @const {?}
     * @private
     */
    GraphExpander.prototype.showOnNodeItemTypes;
    /**
     * @const {?}
     * @private
     */
    GraphExpander.prototype.nodeDataProviderRuns;
    /**
     * @const {boolean}
     * @private
     */
    GraphExpander.prototype.testMode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhfZXhwYW5kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL3dvcmtlci9ncmFwaF9leHBhbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxzSEFBNEU7QUFHNUUsb0lBT3dCOzs7O0FBS3hCLE1BQWEsYUFBYTs7Ozs7Ozs7O0lBSXhCLFlBQ21CLFVBQXNCLEVBQ3RCLEtBQVksRUFDWixtQkFBdUQsRUFDdkQsb0JBR2hCLEVBQ2dCLFdBQVcsS0FBSztRQVBoQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFVBQUssR0FBTCxLQUFLLENBQU87UUFDWix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQW9DO1FBQ3ZELHlCQUFvQixHQUFwQixvQkFBb0IsQ0FHcEM7UUFDZ0IsYUFBUSxHQUFSLFFBQVEsQ0FBUTs7OztRQVYxQixnQkFBVyxHQUF5QixFQUFFLENBQUM7SUFXN0MsQ0FBQzs7Ozs7OztJQUdKLGVBQWUsQ0FBQyxXQUFtQjs7Y0FDM0IsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztRQUN4RCxJQUFJLFNBQVMsSUFBSSxJQUFBLG1CQUFXLEVBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUN4QyxJQUFJLGtEQUFBLFNBQVMsRUFBQSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN2QixPQUFPO1lBQ1QsQ0FBQztZQUNELGtEQUFBLFNBQVMsRUFBQSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDNUIsQ0FBQzs7OztZQUlHLGNBQWMsR0FBdUIsV0FBVztRQUNwRCxPQUFPLGNBQWMsSUFBSSxJQUFJLEVBQUUsQ0FBQzs7a0JBQ3hCLFlBQVksR0FBRyxrREFBQSxJQUFJLENB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LElBQUksb0JBQW9CLElBQUksSUFBSSxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEQsQ0FBQztRQUNELEtBQUssTUFBTSxhQUFhLElBQUksYUFBYSxFQUFFLENBQUM7O2tCQUNwQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDO1lBQzFELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDZixTQUFTO1lBQ1gsQ0FBQztZQUNELFNBQVMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO1lBQzVCLFNBQVMsQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO1lBQzdCLElBQUksSUFBQSxtQkFBVyxFQUFDLFNBQVMsQ0FBQyxJQUFJLGtEQUFBLFNBQVMsRUFBQSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNqRCxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ3hELENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBalpELHNDQWlaQzs7Ozs7Ozs7SUEvWUMsb0NBQWdEOzs7OztJQUc5QyxtQ0FBdUM7Ozs7O0lBQ3ZDLDhCQUE2Qjs7Ozs7SUFDN0IsNENBQXdFOzs7OztJQUN4RSw2Q0FHQzs7Ozs7SUFDRCxpQ0FBaUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0dyb3VwTm9kZSwgTW9kZWxHcmFwaH0gZnJvbSAnLi4vY29tbW9uL21vZGVsX2dyYXBoJztcbmltcG9ydCB7Tm9kZURhdGFQcm92aWRlclJ1bkRhdGEsIFNob3dPbk5vZGVJdGVtRGF0YX0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7Z2V0RGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzLCBpc0dyb3VwTm9kZX0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuaW1wb3J0IHtEYWdyZSwgRGFncmVHcmFwaEluc3RhbmNlfSBmcm9tICcuL2RhZ3JlX3R5cGVzJztcbmltcG9ydCB7XG4gIEdyYXBoTGF5b3V0LFxuICBMQVlPVVRfTUFSR0lOX0JPVFRPTSxcbiAgTEFZT1VUX01BUkdJTl9UT1AsXG4gIExBWU9VVF9NQVJHSU5fWCxcbiAgZ2V0Tm9kZUhlaWdodCxcbiAgZ2V0Tm9kZVdpZHRoLFxufSBmcm9tICcuL2dyYXBoX2xheW91dCc7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgZXhwYW5kaW5nIGFuZCBjb2xsYXBzaW5nIGdyb3VwIG5vZGVzIGluIGEgbW9kZWwgZ3JhcGguXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaEV4cGFuZGVyIHtcbiAgLyoqIFRoaXMgaXMgZm9yIHRlc3RpbmcgcHVycG9zZS4gKi9cbiAgcmVhZG9ubHkgZGFncmVHcmFwaHM6IERhZ3JlR3JhcGhJbnN0YW5jZVtdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGFncmU6IERhZ3JlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hvd09uTm9kZUl0ZW1UeXBlczogUmVjb3JkPHN0cmluZywgU2hvd09uTm9kZUl0ZW1EYXRhPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5vZGVEYXRhUHJvdmlkZXJSdW5zOiBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICBOb2RlRGF0YVByb3ZpZGVyUnVuRGF0YVxuICAgID4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZXN0TW9kZSA9IGZhbHNlLFxuICApIHt9XG5cbiAgLyoqIEV4cGFuZHMgdGhlIGdpdmVuIGdyb3VwIG5vZGUgdG8gc2hvdyBpdHMgY2hpbGQgbm9kZXMuICovXG4gIGV4cGFuZEdyb3VwTm9kZShncm91cE5vZGVJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZ3JvdXBOb2RlID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtncm91cE5vZGVJZF07XG4gICAgaWYgKGdyb3VwTm9kZSAmJiBpc0dyb3VwTm9kZShncm91cE5vZGUpKSB7XG4gICAgICBpZiAoZ3JvdXBOb2RlLmV4cGFuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdyb3VwTm9kZS5leHBhbmRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRnJvbSB0aGUgZ2l2ZW4gZ3JvdXAgbm9kZSwgbGF5b3V0IGl0cyBjaGlsZHJlbiwgZ3JvdyBpdHMgc2l6ZSwgYW5kXG4gICAgLy8gY29udGludWUgdG8gZG8gdGhlIHNhbWUgZm9yIGFsbCBpdHMgYW5jZXN0b3JzIHVudGlsIHJlYWNoaW5nIHRoZSByb290LlxuICAgIGxldCBjdXJHcm91cE5vZGVJZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gZ3JvdXBOb2RlSWQ7XG4gICAgd2hpbGUgKGN1ckdyb3VwTm9kZUlkICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1ckdyb3VwTm9kZSA9IHRoaXMubW9kZWxHcmFwaC5ub2Rlc0J5SWRbXG4gICAgICAgIGN1ckdyb3VwTm9kZUlkXG4gICAgICBdIGFzIEdyb3VwTm9kZTtcbiAgICAgIGlmICghY3VyR3JvdXBOb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VyR3JvdXBOb2RlLmV4cGFuZGVkID0gdHJ1ZTtcblxuICAgICAgLy8gTGF5b3V0IGNoaWxkcmVuLlxuICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IEdyYXBoTGF5b3V0KFxuICAgICAgICB0aGlzLm1vZGVsR3JhcGgsXG4gICAgICAgIHRoaXMuZGFncmUsXG4gICAgICAgIHRoaXMuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgdGhpcy5ub2RlRGF0YVByb3ZpZGVyUnVucyxcbiAgICAgICk7XG4gICAgICBjb25zdCByZWN0ID0gbGF5b3V0LmxheW91dChjdXJHcm91cE5vZGVJZCk7XG4gICAgICBpZiAodGhpcy50ZXN0TW9kZSkge1xuICAgICAgICB0aGlzLmRhZ3JlR3JhcGhzLnB1c2gobGF5b3V0LmRhZ3JlR3JhcGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcm93IHNpemUuXG4gICAgICBjb25zdCBjdXJUYXJnZXRXaWR0aCA9IHJlY3Qud2lkdGggKyBMQVlPVVRfTUFSR0lOX1ggKiAyO1xuICAgICAgY29uc3QgY3VyVGFyZ2V0SGVpZ2h0ID1cbiAgICAgICAgcmVjdC5oZWlnaHQgKyBMQVlPVVRfTUFSR0lOX1RPUCArIExBWU9VVF9NQVJHSU5fQk9UVE9NO1xuICAgICAgY3VyR3JvdXBOb2RlLndpZHRoID0gY3VyVGFyZ2V0V2lkdGg7XG4gICAgICBjdXJHcm91cE5vZGUuaGVpZ2h0ID0gY3VyVGFyZ2V0SGVpZ2h0O1xuXG4gICAgICAvLyBDb250aW51ZSB3aXRoIHBhcmVudC5cbiAgICAgIGN1ckdyb3VwTm9kZUlkID0gY3VyR3JvdXBOb2RlLm5zUGFyZW50SWQ7XG4gICAgfVxuXG4gICAgLy8gTGF5b3V0IHRoZSByb290IGxldmVsIG5vZGVzLlxuICAgIGNvbnN0IGxheW91dCA9IG5ldyBHcmFwaExheW91dChcbiAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgIHRoaXMuZGFncmUsXG4gICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICk7XG4gICAgbGF5b3V0LmxheW91dCgpO1xuICAgIGlmICh0aGlzLnRlc3RNb2RlKSB7XG4gICAgICB0aGlzLmRhZ3JlR3JhcGhzLnB1c2gobGF5b3V0LmRhZ3JlR3JhcGgpO1xuICAgIH1cblxuICAgIC8vIEZyb20gcm9vdCwgdXBkYXRlIG9mZnNldHMgb2YgYWxsIG5vZGVzIHRoYXQgaGF2ZSB4LCB5IHNldCAobWVhbmluZyB0aGV5XG4gICAgLy8gaGF2ZSB0aGUgbGF5b3V0IGRhdGEpLlxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm1vZGVsR3JhcGgucm9vdE5vZGVzKSB7XG4gICAgICBpZiAoaXNHcm91cE5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhpcy51cGRhdGVOb2RlT2Zmc2V0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBFeHBhbmRzIGZyb20gdGhlIGdpdmVuIGRlZXBlc3QgZ3JvdXAgbm9kZXMgYmFjayB0byByb290LiAqL1xuICBleHBhbmRGcm9tRGVlcGVzdEdyb3VwTm9kZXMoZ3JvdXBOb2RlSWRzOiBzdHJpbmdbXSkge1xuICAgIC8vIEdldCBhbGwgYW5jZXN0b3JzIGZyb20gdGhlIGdpdmVuIGdyb3VwIG5vZGUgaWRzLlxuICAgIGNvbnN0IHNlZW5Hcm91cE5vZGVJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBxdWV1ZTogc3RyaW5nW10gPSBbLi4uZ3JvdXBOb2RlSWRzXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VyR3JvdXBOb2RlSWQgPSBxdWV1ZS5zaGlmdCgpITtcbiAgICAgIGlmIChzZWVuR3JvdXBOb2RlSWRzLmhhcyhjdXJHcm91cE5vZGVJZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzZWVuR3JvdXBOb2RlSWRzLmFkZChjdXJHcm91cE5vZGVJZCk7XG4gICAgICBjb25zdCBncm91cE5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW2N1ckdyb3VwTm9kZUlkXSBhcyBHcm91cE5vZGU7XG4gICAgICBjb25zdCBwYXJlbnRHcm91cE5vZGVJZCA9IGdyb3VwTm9kZT8ubnNQYXJlbnRJZDtcbiAgICAgIGlmIChwYXJlbnRHcm91cE5vZGVJZCkge1xuICAgICAgICBxdWV1ZS5wdXNoKHBhcmVudEdyb3VwTm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZW0gYnkgbGV2ZWwgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICBjb25zdCBzb3J0ZWRHcm91cE5vZGVJZHMgPSBBcnJheS5mcm9tKHNlZW5Hcm91cE5vZGVJZHMpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVBID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFthXTtcbiAgICAgIGNvbnN0IG5vZGVCID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtiXTtcbiAgICAgIHJldHVybiBub2RlQi5sZXZlbCAtIG5vZGVBLmxldmVsO1xuICAgIH0pO1xuXG4gICAgLy8gTGF5b3V0IGdyb3VwIG5vZGVzIGluIHRoaXMgc29ydGVkIGxpc3QuXG4gICAgZm9yIChjb25zdCBncm91cE5vZGVJZCBvZiBzb3J0ZWRHcm91cE5vZGVJZHMpIHtcbiAgICAgIGNvbnN0IGdyb3VwTm9kZSA9IHRoaXMubW9kZWxHcmFwaC5ub2Rlc0J5SWRbZ3JvdXBOb2RlSWRdIGFzIEdyb3VwTm9kZTtcbiAgICAgIGdyb3VwTm9kZS5leHBhbmRlZCA9IHRydWU7XG5cbiAgICAgIC8vIExheW91dCBjaGlsZHJlbi5cbiAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBHcmFwaExheW91dChcbiAgICAgICAgdGhpcy5tb2RlbEdyYXBoLFxuICAgICAgICB0aGlzLmRhZ3JlLFxuICAgICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICAgIHRoaXMubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICApO1xuICAgICAgY29uc3QgcmVjdCA9IGxheW91dC5sYXlvdXQoZ3JvdXBOb2RlSWQpO1xuICAgICAgaWYgKHRoaXMudGVzdE1vZGUpIHtcbiAgICAgICAgdGhpcy5kYWdyZUdyYXBocy5wdXNoKGxheW91dC5kYWdyZUdyYXBoKTtcbiAgICAgIH1cblxuICAgICAgLy8gR3JvdyBzaXplLlxuICAgICAgY29uc3QgY3VyVGFyZ2V0V2lkdGggPSByZWN0LndpZHRoICsgTEFZT1VUX01BUkdJTl9YICogMjtcbiAgICAgIGNvbnN0IGN1clRhcmdldEhlaWdodCA9XG4gICAgICAgIHJlY3QuaGVpZ2h0ICsgTEFZT1VUX01BUkdJTl9UT1AgKyBMQVlPVVRfTUFSR0lOX0JPVFRPTTtcbiAgICAgIGdyb3VwTm9kZS53aWR0aCA9IGN1clRhcmdldFdpZHRoO1xuICAgICAgZ3JvdXBOb2RlLmhlaWdodCA9IGN1clRhcmdldEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBMYXlvdXQgdGhlIHJvb3QgbGV2ZWwgbm9kZXMuXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IEdyYXBoTGF5b3V0KFxuICAgICAgdGhpcy5tb2RlbEdyYXBoLFxuICAgICAgdGhpcy5kYWdyZSxcbiAgICAgIHRoaXMuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgIHRoaXMubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgKTtcbiAgICBsYXlvdXQubGF5b3V0KCk7XG4gICAgaWYgKHRoaXMudGVzdE1vZGUpIHtcbiAgICAgIHRoaXMuZGFncmVHcmFwaHMucHVzaChsYXlvdXQuZGFncmVHcmFwaCk7XG4gICAgfVxuXG4gICAgLy8gRnJvbSByb290LCB1cGRhdGUgb2Zmc2V0cyBvZiBhbGwgbm9kZXMgdGhhdCBoYXZlIHgsIHkgc2V0IChtZWFuaW5nIHRoZXlcbiAgICAvLyBoYXZlIHRoZSBsYXlvdXQgZGF0YSkuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubW9kZWxHcmFwaC5yb290Tm9kZXMpIHtcbiAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVPZmZzZXQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEV4cGFuZHMgdGhlIGdyYXBoIHRvIHJldmVhbCB0aGUgZ2l2ZW4gbm9kZS4gKi9cbiAgZXhwYW5kVG9SZXZlYWxOb2RlKG5vZGVJZDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW25vZGVJZF07XG4gICAgY29uc3QgZ3JvdXBOb2RlczogR3JvdXBOb2RlW10gPSBbXTtcbiAgICBsZXQgY3VyTm9kZSA9IG5vZGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IG5zUGFyZW50ID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtcbiAgICAgICAgY3VyTm9kZS5uc1BhcmVudElkIHx8ICcnXG4gICAgICBdIGFzIEdyb3VwTm9kZTtcbiAgICAgIGlmICghbnNQYXJlbnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBncm91cE5vZGVzLnVuc2hpZnQobnNQYXJlbnQpO1xuICAgICAgY3VyTm9kZSA9IG5zUGFyZW50O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGdyb3VwTm9kZSBvZiBncm91cE5vZGVzKSB7XG4gICAgICB0aGlzLmV4cGFuZEdyb3VwTm9kZShncm91cE5vZGUuaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkczogc3RyaW5nW10gPSBbXTtcbiAgICBnZXREZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm1vZGVsR3JhcGgsXG4gICAgICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMsXG4gICAgKTtcbiAgICByZXR1cm4gZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzO1xuICB9XG5cbiAgLyoqIENvbGxhcHNlcyB0aGUgZ2l2ZW4gZ3JvdXAgbm9kZSB0byBoaWRlIGFsbCBpdHMgY2hpbGQgbm9kZXMuICovXG4gIGNvbGxhcHNlR3JvdXBOb2RlKGdyb3VwTm9kZUlkOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZ3JvdXBOb2RlID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtncm91cE5vZGVJZF0gYXMgR3JvdXBOb2RlO1xuICAgIGlmICghZ3JvdXBOb2RlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdyb3VwTm9kZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgIGRlbGV0ZSB0aGlzLm1vZGVsR3JhcGguZWRnZXNCeUdyb3VwTm9kZUlkc1tncm91cE5vZGVJZF07XG5cbiAgICAvLyBTaHJpbmsgc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAgbm9kZS5cbiAgICBncm91cE5vZGUud2lkdGggPSBnZXROb2RlV2lkdGgoXG4gICAgICBncm91cE5vZGUsXG4gICAgICB0aGlzLm1vZGVsR3JhcGgsXG4gICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICk7XG4gICAgZ3JvdXBOb2RlLmhlaWdodCA9IGdldE5vZGVIZWlnaHQoXG4gICAgICBncm91cE5vZGUsXG4gICAgICB0aGlzLm1vZGVsR3JhcGgsXG4gICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICAgdGhpcy50ZXN0TW9kZSxcbiAgICAgIHRydWUsXG4gICAgKTtcblxuICAgIC8vIEZyb20gdGhlIGdpdmVuIGdyb3VwIG5vZGUncyBwYXJlbnQsIGxheW91dCwgdXBkYXRlIHNpemUsIGFuZCBjb250aW51ZSB0b1xuICAgIC8vIGRvIHRoZSBzYW1lIGZvciBhbGwgaXRzIGFuY2VzdG9ycyB1bnRpbCByZWFjaGluZyB0aGUgcm9vdC5cbiAgICBsZXQgY3VyR3JvdXBOb2RlSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGdyb3VwTm9kZS5uc1BhcmVudElkO1xuICAgIHdoaWxlIChjdXJHcm91cE5vZGVJZCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjdXJHcm91cE5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW1xuICAgICAgICBjdXJHcm91cE5vZGVJZFxuICAgICAgXSBhcyBHcm91cE5vZGU7XG4gICAgICBpZiAoIWN1ckdyb3VwTm9kZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gTGF5b3V0LlxuICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IEdyYXBoTGF5b3V0KFxuICAgICAgICB0aGlzLm1vZGVsR3JhcGgsXG4gICAgICAgIHRoaXMuZGFncmUsXG4gICAgICAgIHRoaXMuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgdGhpcy5ub2RlRGF0YVByb3ZpZGVyUnVucyxcbiAgICAgICk7XG4gICAgICBjb25zdCByZWN0ID0gbGF5b3V0LmxheW91dChjdXJHcm91cE5vZGVJZCk7XG4gICAgICBpZiAodGhpcy50ZXN0TW9kZSkge1xuICAgICAgICB0aGlzLmRhZ3JlR3JhcGhzLnB1c2gobGF5b3V0LmRhZ3JlR3JhcGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaHJpbmsgc2l6ZS5cbiAgICAgIGNvbnN0IGN1clRhcmdldFdpZHRoID0gcmVjdC53aWR0aCArIExBWU9VVF9NQVJHSU5fWCAqIDI7XG4gICAgICBjb25zdCBjdXJUYXJnZXRIZWlnaHQgPVxuICAgICAgICByZWN0LmhlaWdodCArIExBWU9VVF9NQVJHSU5fVE9QICsgTEFZT1VUX01BUkdJTl9CT1RUT007XG4gICAgICBjdXJHcm91cE5vZGUud2lkdGggPSBjdXJUYXJnZXRXaWR0aDtcbiAgICAgIGN1ckdyb3VwTm9kZS5oZWlnaHQgPSBjdXJUYXJnZXRIZWlnaHQ7XG5cbiAgICAgIC8vIENvbnRpbnVlIHdpdGggcGFyZW50LlxuICAgICAgY3VyR3JvdXBOb2RlSWQgPSBjdXJHcm91cE5vZGUubnNQYXJlbnRJZDtcbiAgICB9XG5cbiAgICAvLyBMYXlvdXQgdGhlIHJvb3QgbGV2ZWwgbm9kZXMuXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IEdyYXBoTGF5b3V0KFxuICAgICAgdGhpcy5tb2RlbEdyYXBoLFxuICAgICAgdGhpcy5kYWdyZSxcbiAgICAgIHRoaXMuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgIHRoaXMubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgKTtcbiAgICBsYXlvdXQubGF5b3V0KCk7XG4gICAgaWYgKHRoaXMudGVzdE1vZGUpIHtcbiAgICAgIHRoaXMuZGFncmVHcmFwaHMucHVzaChsYXlvdXQuZGFncmVHcmFwaCk7XG4gICAgfVxuXG4gICAgLy8gRnJvbSByb290LCB1cGRhdGUgb2Zmc2V0cyBvZiBhbGwgbm9kZXMgdGhhdCBoYXZlIHgsIHkgc2V0IChtZWFuaW5nIHRoZXlcbiAgICAvLyBoYXZlIHRoZSBsYXlvdXQgZGF0YSkuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubW9kZWxHcmFwaC5yb290Tm9kZXMpIHtcbiAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVPZmZzZXQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGdldERlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcyhcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgIGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcyxcbiAgICApO1xuICAgIHJldHVybiBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHM7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgY3VycmVudCBjb2xsYXBzZS9leHBhbmQgc3RhdGVzIG9mIHRoZSBncm91cCBub2RlcyBhbmQgcmUtbGF5cyBvdXRcbiAgICogdGhlIGVudGlyZSBncmFwaC5cbiAgICovXG4gIHJlTGF5b3V0R3JhcGgoXG4gICAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kPzogc3RyaW5nW10sXG4gICAgY2xlYXJBbGxFeHBhbmRTdGF0ZXM/OiBib29sZWFuLFxuICApOiBzdHJpbmdbXSB7XG4gICAgbGV0IGN1clRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZDogc3RyaW5nW10gfCB1bmRlZmluZWQgPVxuICAgICAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kO1xuICAgIGlmICghY3VyVGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kKSB7XG4gICAgICAvLyBGaW5kIHRoZSBkZWVwZXN0IGdyb3VwIG5vZGVzIHRoYXQgbm9uIG9mIGl0cyBjaGlsZCBncm91cCBub2RlcyBpc1xuICAgICAgLy8gZXhwYW5kZWQuXG4gICAgICBjb25zdCBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHM6IHN0cmluZ1tdID0gW107XG4gICAgICB0aGlzLmNsZWFyTGF5b3V0RGF0YSh1bmRlZmluZWQpO1xuICAgICAgZ2V0RGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgICAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzLFxuICAgICAgKTtcbiAgICAgIGN1clRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZCA9IGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNsZWFyQWxsRXhwYW5kU3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJMYXlvdXREYXRhKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwYW5kIHRob3NlIG5vZGVzIG9uZSBieSBvbmUuXG4gICAgaWYgKGN1clRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4cGFuZEZyb21EZWVwZXN0R3JvdXBOb2RlcyhjdXJUYXJnZXREZWVwZXN0R3JvdXBOb2RlSWRzVG9FeHBhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBuZXcgR3JhcGhMYXlvdXQoXG4gICAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgICAgdGhpcy5kYWdyZSxcbiAgICAgICAgdGhpcy5zaG93T25Ob2RlSXRlbVR5cGVzLFxuICAgICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICAgKTtcbiAgICAgIGxheW91dC5sYXlvdXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VyVGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kO1xuICB9XG5cbiAgZXhwYW5kQWxsR3JvdXBzKCk6IHN0cmluZ1tdIHtcbiAgICB0aGlzLmNsZWFyTGF5b3V0RGF0YSh1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgLy8gRmluZCBhbGwgZGVlcGVzdCBncm91cCBub2Rlcy5cbiAgICBjb25zdCBkZWVwZXN0R3JvdXBOb2RlSWRzID0gdGhpcy5tb2RlbEdyYXBoLm5vZGVzXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAobm9kZSkgPT5cbiAgICAgICAgICBpc0dyb3VwTm9kZShub2RlKSAmJlxuICAgICAgICAgIChub2RlLm5zQ2hpbGRyZW5JZHMgfHwgW10pLmZpbHRlcigoaWQpID0+XG4gICAgICAgICAgICBpc0dyb3VwTm9kZSh0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW2lkXSksXG4gICAgICAgICAgKS5sZW5ndGggPT09IDAsXG4gICAgICApXG4gICAgICAubWFwKChub2RlKSA9PiBub2RlLmlkKTtcblxuICAgIC8vIEV4cGFuZCBmcm9tIHRoZW0uXG4gICAgaWYgKGRlZXBlc3RHcm91cE5vZGVJZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHBhbmRGcm9tRGVlcGVzdEdyb3VwTm9kZXMoZGVlcGVzdEdyb3VwTm9kZUlkcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZXBlc3RHcm91cE5vZGVJZHM7XG4gIH1cblxuICBjb2xsYXBzZUFsbEdyb3VwKCk6IHN0cmluZ1tdIHtcbiAgICB0aGlzLmNsZWFyTGF5b3V0RGF0YSh1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgLy8gTGF5b3V0IHRoZSByb290IGxldmVsIG5vZGVzLlxuICAgIGNvbnN0IGxheW91dCA9IG5ldyBHcmFwaExheW91dChcbiAgICAgIHRoaXMubW9kZWxHcmFwaCxcbiAgICAgIHRoaXMuZGFncmUsXG4gICAgICB0aGlzLnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICB0aGlzLm5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICk7XG4gICAgbGF5b3V0LmxheW91dCgpO1xuXG4gICAgLy8gRnJvbSByb290LCB1cGRhdGUgb2Zmc2V0cyBvZiBhbGwgbm9kZXMgdGhhdCBoYXZlIHgsIHkgc2V0IChtZWFuaW5nIHRoZXlcbiAgICAvLyBoYXZlIHRoZSBsYXlvdXQgZGF0YSkuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubW9kZWxHcmFwaC5yb290Tm9kZXMpIHtcbiAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVPZmZzZXQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVOb2RlT2Zmc2V0KGdyb3VwTm9kZTogR3JvdXBOb2RlKSB7XG4gICAgZm9yIChjb25zdCBub2RlSWQgb2YgZ3JvdXBOb2RlLm5zQ2hpbGRyZW5JZHMgfHwgW10pIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW25vZGVJZF07XG4gICAgICBpZiAobm9kZS54ICE9IG51bGwgJiYgbm9kZS55ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5nbG9iYWxYID1cbiAgICAgICAgICAoZ3JvdXBOb2RlLnggfHwgMCkgK1xuICAgICAgICAgIChncm91cE5vZGUuZ2xvYmFsWCB8fCAwKSArXG4gICAgICAgICAgKG5vZGUubG9jYWxPZmZzZXRYIHx8IDApO1xuICAgICAgICBub2RlLmdsb2JhbFkgPVxuICAgICAgICAgIChncm91cE5vZGUueSB8fCAwKSArXG4gICAgICAgICAgKGdyb3VwTm9kZS5nbG9iYWxZIHx8IDApICtcbiAgICAgICAgICAobm9kZS5sb2NhbE9mZnNldFkgfHwgMCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNHcm91cE5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhpcy51cGRhdGVOb2RlT2Zmc2V0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJMYXlvdXREYXRhKFxuICAgIHJvb3Q6IEdyb3VwTm9kZSB8IHVuZGVmaW5lZCxcbiAgICBjbGVhckFsbEV4cGFuZFN0YXRlcz86IGJvb2xlYW4sXG4gICkge1xuICAgIGxldCBuc0NoaWxkcmVuSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChyb290ID09IG51bGwpIHtcbiAgICAgIG5zQ2hpbGRyZW5JZHMgPSB0aGlzLm1vZGVsR3JhcGgucm9vdE5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5zQ2hpbGRyZW5JZHMgPSByb290Lm5zQ2hpbGRyZW5JZHMgfHwgW107XG4gICAgfVxuICAgIGlmIChjbGVhckFsbEV4cGFuZFN0YXRlcyAmJiByb290ICE9IG51bGwpIHtcbiAgICAgIHJvb3QuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgIGRlbGV0ZSB0aGlzLm1vZGVsR3JhcGguZWRnZXNCeUdyb3VwTm9kZUlkc1tyb290LmlkXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuc0NoaWxkTm9kZUlkIG9mIG5zQ2hpbGRyZW5JZHMpIHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMubW9kZWxHcmFwaC5ub2Rlc0J5SWRbbnNDaGlsZE5vZGVJZF07XG4gICAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkTm9kZS53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIGNoaWxkTm9kZS5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNHcm91cE5vZGUoY2hpbGROb2RlKSAmJiBjaGlsZE5vZGUuZXhwYW5kZWQpIHtcbiAgICAgICAgdGhpcy5jbGVhckxheW91dERhdGEoY2hpbGROb2RlLCBjbGVhckFsbEV4cGFuZFN0YXRlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/utils.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/utils.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.utils');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/utils.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_worker_events_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events");
const worker_events_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events');
/**
 * Updates processing progress.
 * @param {string} paneId
 * @param {!tsickle_worker_events_1.ProcessingLabel} label
 * @param {(undefined|string)=} error
 * @return {void}
 */
function updateProcessingProgress(paneId, label, error) {
    /** @type {!tsickle_worker_events_1.UpdateProcessingProgressRequest} */
    const req = {
        eventType: worker_events_1.WorkerEventType.UPDATE_PROCESSING_PROGRESS,
        paneId,
        label,
        error,
    };
    postMessage(req);
}
exports.updateProcessingProgress = updateProcessingProgress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL3dvcmtlci91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNJQUlpQzs7Ozs7Ozs7QUFHakMsU0FBZ0Isd0JBQXdCLENBQ3RDLE1BQWMsRUFDZCxLQUFzQixFQUN0QixLQUFjOztVQUVSLEdBQUcsR0FBb0M7UUFDM0MsU0FBUyxFQUFFLCtCQUFlLENBQUMsMEJBQTBCO1FBQ3JELE1BQU07UUFDTixLQUFLO1FBQ0wsS0FBSztLQUNOO0lBQ0QsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFaRCw0REFZQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFByb2Nlc3NpbmdMYWJlbCxcbiAgVXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzUmVxdWVzdCxcbiAgV29ya2VyRXZlbnRUeXBlLFxufSBmcm9tICcuLi9jb21tb24vd29ya2VyX2V2ZW50cyc7XG5cbi8qKiBVcGRhdGVzIHByb2Nlc3NpbmcgcHJvZ3Jlc3MuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzKFxuICBwYW5lSWQ6IHN0cmluZyxcbiAgbGFiZWw6IFByb2Nlc3NpbmdMYWJlbCxcbiAgZXJyb3I/OiBzdHJpbmcsXG4pIHtcbiAgY29uc3QgcmVxOiBVcGRhdGVQcm9jZXNzaW5nUHJvZ3Jlc3NSZXF1ZXN0ID0ge1xuICAgIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLlVQREFURV9QUk9DRVNTSU5HX1BST0dSRVNTLFxuICAgIHBhbmVJZCxcbiAgICBsYWJlbCxcbiAgICBlcnJvcixcbiAgfTtcbiAgcG9zdE1lc3NhZ2UocmVxKTtcbn1cbiJdfQ==
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_processor.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_processor.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_processor');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/graph_processor.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_consts_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts");
const tsickle_input_graph_2 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.input_graph");
const tsickle_model_graph_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_utils_5 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils");
const tsickle_visualizer_config_6 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.visualizer_config");
const tsickle_worker_events_7 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events");
const tsickle_graph_layout_8 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout");
const tsickle_utils_9 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.utils");
const consts_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.consts');
const model_graph_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph');
const utils_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
const worker_events_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events');
const graph_layout_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout');
const utils_2 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.utils');
/** @type {!RegExp} */
const CONST_VALUE_REGEX = /dense<([^>]*)>/;
/**
 * A class that processes a given `Graph` into a `ModelGraph`.
 */
class GraphProcessor {
    /**
     * @public
     * @param {string} paneId
     * @param {!tsickle_input_graph_2.Graph} graph
     * @param {(undefined|!tsickle_visualizer_config_6.VisualizerConfig)=} config
     * @param {?=} showOnNodeItemTypes
     * @param {?=} nodeDataProviderRuns
     * @param {number=} groupNodeChildrenCountThreshold
     * @param {boolean=} testMode
     * @param {boolean=} flattenLayers
     */
    constructor(paneId, graph, config, showOnNodeItemTypes = {}, nodeDataProviderRuns = {}, groupNodeChildrenCountThreshold = consts_1.DEFAULT_GROUP_NODE_CHILDREN_COUNT_THRESHOLD, testMode = false, flattenLayers = false) {
        this.paneId = paneId;
        this.graph = graph;
        this.config = config;
        this.showOnNodeItemTypes = showOnNodeItemTypes;
        this.nodeDataProviderRuns = nodeDataProviderRuns;
        this.groupNodeChildrenCountThreshold = groupNodeChildrenCountThreshold;
        this.testMode = testMode;
        this.flattenLayers = flattenLayers;
        this.nodeLabelsToHide = new Set((this.config?.nodeLabelsToHide || []).map((/**
         * @param {string} label
         * @return {string}
         */
        (label) => label.toLowerCase())));
    }
    /**
     * @public
     * @return {!tsickle_model_graph_3.ModelGraph}
     */
    process() {
        /** @type {!tsickle_model_graph_3.ModelGraph} */
        const modelGraph = this.createEmptyModelGraph();
        this.processNodes(modelGraph);
        this.processEdgeRelationships(modelGraph);
        (0, utils_2.updateProcessingProgress)(this.paneId, worker_events_1.ProcessingLabel.PROCESSING_NODES_AND_EDGES);
        this.processNamespaceRelationships(modelGraph);
        (0, utils_2.updateProcessingProgress)(this.paneId, worker_events_1.ProcessingLabel.PROCESSING_LAYER_NAMESPACES);
        this.generateLayoutGraphConnections(modelGraph);
        (0, utils_2.updateProcessingProgress)(this.paneId, worker_events_1.ProcessingLabel.PROCESSING_LAYOUT_DATA);
        this.splitLargeGroupNodes(modelGraph);
        (0, utils_2.updateProcessingProgress)(this.paneId, worker_events_1.ProcessingLabel.SPLITTING_LARGE_LAYERS);
        this.populateDescendantsAndCounts(modelGraph);
        return modelGraph;
    }
    /**
     * Scans nodes in `Graph` and creates the corresponding `OpNode` and
     * `GroupNode` in the `ModelGraph` (see model_graph.ts for more details).
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    processNodes(modelGraph) {
        /** @type {!Set<string>} */
        const seenNamespaces = new Set();
        for (const graphNode of this.graph.nodes) {
            // Add an `OpNode` to the model graph for each node in the input graph.
            //
            // If namespace is a ";" separated string, use the last component as the
            // actual namespace.
            /** @type {string} */
            const namespace = graphNode.namespace;
            /** @type {!Array<string>} */
            const parts = namespace.split(';').filter((/**
             * @param {string} part
             * @return {boolean}
             */
            (part) => part !== ''));
            if (parts.length > 1) {
                graphNode.namespace = parts[parts.length - 1];
            }
            /** @type {!tsickle_model_graph_3.OpNode} */
            const opNode = {
                nodeType: model_graph_1.NodeType.OP_NODE,
                id: graphNode.id,
                namespace: this.flattenLayers ? '' : graphNode.namespace,
                savedNamespace: graphNode.namespace,
                label: graphNode.label,
                level: this.getNonEmptyNamespaceComponents(graphNode.namespace).length,
            };
            if (graphNode.subgraphIds && graphNode.subgraphIds.length > 0) {
                opNode.subgraphIds = graphNode.subgraphIds;
            }
            if (this.nodeLabelsToHide.has(graphNode.label.toLowerCase())) {
                opNode.hideInLayout = true;
            }
            if (graphNode.attrs) {
                /** @type {?} */
                const attrs = {};
                for (const attr of graphNode.attrs) {
                    attrs[attr.key] = this.processAttrValue(attr.key, attr.value);
                }
                opNode.attrs = attrs;
            }
            if (graphNode.inputsMetadata) {
                opNode.inputsMetadata = this.processMetadataList(graphNode.inputsMetadata);
            }
            if (graphNode.outputsMetadata) {
                opNode.outputsMetadata = this.processMetadataList(graphNode.outputsMetadata);
            }
            if (graphNode.style) {
                opNode.style = graphNode.style;
            }
            modelGraph.nodes.push(opNode);
            modelGraph.nodesById[opNode.id] = opNode;
            // Add group nodes for all ancestor namespaces from this op node.
            //
            // For example, if an op node's namespace is a/b/c, then add the following
            // group nodes.
            //
            // - namespace: a/b, label: c.
            // - namespace: a, label: b.
            // - namespace: <empty>, label a.
            if (!opNode.hideInLayout && !this.flattenLayers) {
                /** @type {!Array<string>} */
                const ancestorNamespaces = this.getAncestorNamespaces(opNode.namespace);
                for (const ns of ancestorNamespaces) {
                    if (seenNamespaces.has(ns)) {
                        continue;
                    }
                    seenNamespaces.add(ns);
                    /** @type {!Array<string>} */
                    const components = ns.split('/');
                    // Use the last component of the namespace as its display label.
                    /** @type {string} */
                    const label = components.splice(-1)[0];
                    // Group node's namespace doesn't contain the last component.
                    /** @type {string} */
                    const namespace = components.join('/');
                    /** @type {!tsickle_model_graph_3.GroupNode} */
                    const groupNode = {
                        nodeType: model_graph_1.NodeType.GROUP_NODE,
                        id: this.getGroupNodeIdFromNamespace(ns),
                        namespace,
                        label,
                        level: components.length,
                        expanded: false,
                    };
                    modelGraph.nodes.push(groupNode);
                    modelGraph.nodesById[groupNode.id] = groupNode;
                }
            }
        }
    }
    /**
     * Sets edges in the given model graph based on the edges in the input graph.
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    processEdgeRelationships(modelGraph) {
        for (const graphNode of this.graph.nodes) {
            /** @type {!tsickle_model_graph_3.OpNode} */
            const node = (/** @type {!tsickle_model_graph_3.OpNode} */ (modelGraph.nodesById[graphNode.id]));
            if (!node) {
                continue;
            }
            // From the graph node's incoming edges, populate the incoming and
            // outgoing edges for the corresponding node in the model graph.
            for (const incomingEdge of graphNode.incomingEdges || []) {
                /** @type {string} */
                const sourceNodeId = incomingEdge.sourceNodeId;
                /** @type {!tsickle_model_graph_3.OpNode} */
                const sourceNode = (/** @type {!tsickle_model_graph_3.OpNode} */ (modelGraph.nodesById[sourceNodeId]));
                if (!sourceNode) {
                    continue;
                }
                // Incoming edges.
                if (node.incomingEdges == null) {
                    node.incomingEdges = [];
                }
                if (node.incomingEdges.find((/**
                 * @param {!tsickle_types_4.IncomingEdge} edge
                 * @return {boolean}
                 */
                (edge) => edge.sourceNodeId === sourceNodeId &&
                    edge.sourceNodeOutputId === incomingEdge.sourceNodeOutputId &&
                    edge.targetNodeInputId === incomingEdge.targetNodeInputId)) == null) {
                    node.incomingEdges.push({ ...incomingEdge });
                }
                // Outgoing edges.
                if (sourceNode.outgoingEdges == null) {
                    sourceNode.outgoingEdges = [];
                }
                if (sourceNode.outgoingEdges.find((/**
                 * @param {!tsickle_types_4.OutgoingEdge} edge
                 * @return {boolean}
                 */
                (edge) => edge.targetNodeId === node.id &&
                    edge.sourceNodeOutputId === incomingEdge.sourceNodeOutputId &&
                    edge.targetNodeInputId === incomingEdge.targetNodeInputId)) == null) {
                    sourceNode.outgoingEdges.push({
                        targetNodeId: node.id,
                        sourceNodeOutputId: incomingEdge.sourceNodeOutputId,
                        targetNodeInputId: incomingEdge.targetNodeInputId,
                    });
                }
            }
        }
    }
    /**
     * Sets namespace relationships in model graph based on the hierarchy data
     * stored in input node's `namespace`.
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    processNamespaceRelationships(modelGraph) {
        for (const node of modelGraph.nodes) {
            if ((0, utils_1.isOpNode)(node) && (/** @type {!tsickle_model_graph_3.OpNode} */ (node)).hideInLayout) {
                continue;
            }
            /** @type {string} */
            const ns = node.namespace;
            // Root node.
            if (ns === '') {
                modelGraph.rootNodes.push(node);
                continue;
            }
            // Set namespace parent.
            /** @type {string} */
            const parentNodeId = this.getGroupNodeIdFromNamespace(ns);
            /** @type {!tsickle_model_graph_3.GroupNode} */
            const parentGroupNode = (/** @type {!tsickle_model_graph_3.GroupNode} */ (modelGraph.nodesById[parentNodeId]));
            if (parentGroupNode) {
                node.nsParentId = parentGroupNode.id;
            }
            else {
                console.warn(`Failed to find the NS parent of node "${node.id}": "${parentNodeId}"`);
            }
            // Set namespace children.
            if (parentGroupNode) {
                if (parentGroupNode.nsChildrenIds == null) {
                    parentGroupNode.nsChildrenIds = [];
                }
                if (!parentGroupNode.nsChildrenIds.includes(node.id)) {
                    parentGroupNode.nsChildrenIds.push(node.id);
                }
            }
        }
        // Find group nodes that only have one single op node as its child. For
        // these nodes, remove the group node and move the child op node up a level
        // from its namespace.
        //
        // Repeatedly do this until no such nodes are found.
        while (true) {
            /** @type {number} */
            let numNodeProcessed = 0;
            for (const node of modelGraph.nodes) {
                if (!(0, utils_1.isGroupNode)(node)) {
                    continue;
                }
                if ((/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsChildrenIds != null && (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsChildrenIds.length === 1) {
                    /** @type {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} */
                    const opNode = modelGraph.nodesById[(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsChildrenIds[0]];
                    if ((0, utils_1.isOpNode)(opNode)) {
                        numNodeProcessed++;
                        // Delete group node.
                        /** @type {number} */
                        const index = modelGraph.nodes.indexOf(node);
                        if (index >= 0) {
                            modelGraph.nodes.splice(index, 1);
                        }
                        delete modelGraph.nodesById[node.id];
                        // Move op node up one level in namespace.
                        /** @type {string} */
                        const ns = (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).namespace;
                        /** @type {!Array<string>} */
                        const parts = this.getNonEmptyNamespaceComponents(ns);
                        parts.pop();
                        (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).namespace = parts.join('/');
                        (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).savedNamespace = (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).namespace;
                        (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).level = parts.length;
                        (/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).nsParentId = (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsParentId;
                        // Update root node if necessary.
                        /** @type {number} */
                        const indexInRootNodes = modelGraph.rootNodes.indexOf(node);
                        if (indexInRootNodes >= 0) {
                            modelGraph.rootNodes.splice(indexInRootNodes, 1);
                            modelGraph.rootNodes.push(opNode);
                        }
                        // Remove this node from its NS parent node's nsChildrenIds, and add
                        // the op node to it.
                        if ((/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsParentId) {
                            /** @type {!tsickle_model_graph_3.GroupNode} */
                            const nsParent = (/** @type {!tsickle_model_graph_3.GroupNode} */ (modelGraph.nodesById[(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsParentId]));
                            /** @type {number} */
                            const index = (/** @type {!Array<string>} */ (nsParent.nsChildrenIds)).indexOf((/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id);
                            (/** @type {!Array<string>} */ (nsParent.nsChildrenIds)).splice(index, 1);
                            (/** @type {!Array<string>} */ (nsParent.nsChildrenIds)).push((/** @type {!tsickle_model_graph_3.OpNode} */ (opNode)).id);
                        }
                    }
                }
            }
            if (numNodeProcessed === 0) {
                break;
            }
        }
    }
    /**
     * Generates layout graph connections for the given model graph.
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    generateLayoutGraphConnections(modelGraph) {
        modelGraph.layoutGraphEdges = {};
        // Find all op nodes that don't have incoming edges.
        /** @type {!Array<!tsickle_model_graph_3.OpNode>} */
        const opNodesWithoutIncomingEdges = [];
        for (const node of modelGraph.nodes) {
            if (!(0, utils_1.isOpNode)(node) || (/** @type {!tsickle_model_graph_3.OpNode} */ (node)).hideInLayout) {
                continue;
            }
            /** @type {!Array<!tsickle_types_4.IncomingEdge>} */
            const filteredIncomingEdges = ((/** @type {!tsickle_model_graph_3.OpNode} */ (node)).incomingEdges || []).filter((/**
             * @param {!tsickle_types_4.IncomingEdge} edge
             * @return {boolean}
             */
            (edge) => !((/** @type {!tsickle_model_graph_3.OpNode} */ (modelGraph.nodesById[edge.sourceNodeId]))).hideInLayout));
            if (filteredIncomingEdges.length === 0) {
                opNodesWithoutIncomingEdges.push(node);
            }
        }
        // Do a BFS from opNodesWithoutIncomingEdges.
        /** @type {!Array<!tsickle_model_graph_3.OpNode>} */
        const queue = [...opNodesWithoutIncomingEdges];
        /** @type {!Set<string>} */
        const seenNodeIds = new Set();
        while (queue.length > 0) {
            /** @type {(undefined|!tsickle_model_graph_3.OpNode)} */
            const curNode = queue.shift();
            if (curNode == null || curNode.hideInLayout) {
                continue;
            }
            if (seenNodeIds.has(curNode.id)) {
                continue;
            }
            seenNodeIds.add(curNode.id);
            // For each edge going from curNode (A), find the common namespace of
            // curNode and edge's target node (B), and mark the connection between the
            // top-level node that contains A and B within the common namespace.
            //
            // For example, op node X's namespae is a/b/c, op node Y's namespace
            // is a/b/d, and X has an edge to Y. X and Y's common namespace is a/b.
            // So we mark a/b/c and a/b/d to be connected.
            /** @type {!Array<!tsickle_types_4.OutgoingEdge>} */
            const outgoingEdges = curNode.outgoingEdges || [];
            for (const edge of outgoingEdges) {
                /** @type {!tsickle_model_graph_3.OpNode} */
                const targetNode = (/** @type {!tsickle_model_graph_3.OpNode} */ (modelGraph.nodesById[edge.targetNodeId]));
                if (targetNode.hideInLayout) {
                    continue;
                }
                /** @type {string} */
                const commonNs = (0, utils_1.findCommonNamespace)(curNode.namespace, targetNode.namespace);
                /** @type {string} */
                const sourceNodeNextLevelNsPart = (0, utils_1.getNextLevelNsPart)(commonNs, curNode.namespace);
                /** @type {string} */
                const connectionFromNodeId = sourceNodeNextLevelNsPart === ''
                    ? curNode.id
                    : `${commonNs}${commonNs === '' ? '' : '/'}${sourceNodeNextLevelNsPart}___group___`;
                /** @type {string} */
                const targetNodeNextLevelNsPart = (0, utils_1.getNextLevelNsPart)(commonNs, targetNode.namespace);
                /** @type {string} */
                const connectionToNodeId = targetNodeNextLevelNsPart === ''
                    ? targetNode.id
                    : `${commonNs}${commonNs === '' ? '' : '/'}${targetNodeNextLevelNsPart}___group___`;
                /** @type {string} */
                const commonNsGroupId = commonNs === '' ? '' : `${commonNs}___group___`;
                if (modelGraph.layoutGraphEdges[commonNsGroupId] == null) {
                    modelGraph.layoutGraphEdges[commonNsGroupId] = {};
                }
                if (modelGraph.layoutGraphEdges[commonNsGroupId][connectionFromNodeId] ==
                    null) {
                    modelGraph.layoutGraphEdges[commonNsGroupId][connectionFromNodeId] =
                        {};
                }
                modelGraph.layoutGraphEdges[commonNsGroupId][connectionFromNodeId][connectionToNodeId] = true;
            }
            for (const edge of outgoingEdges) {
                /** @type {!tsickle_model_graph_3.OpNode} */
                const targetNode = (/** @type {!tsickle_model_graph_3.OpNode} */ (modelGraph.nodesById[edge.targetNodeId]));
                queue.push(targetNode);
            }
        }
    }
    /**
     * Finds group nodes with a large number of children, and splits them into
     * different groups
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    splitLargeGroupNodes(modelGraph) {
        // From root, do a BFS search on all group nodes.
        /** @type {!Array<(undefined|!tsickle_model_graph_3.GroupNode)>} */
        const queue = [undefined];
        /** @type {boolean} */
        let hasLargeGroupNodes = false;
        while (queue.length > 0) {
            /** @type {(undefined|!tsickle_model_graph_3.GroupNode)} */
            const curGroupNode = queue.shift();
            /** @type {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} */
            let children = curGroupNode == null
                ? modelGraph.rootNodes
                : (curGroupNode.nsChildrenIds || []).map((/**
                 * @param {string} id
                 * @return {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)}
                 */
                (id) => modelGraph.nodesById[id]));
            // Split the group node if its child count is over the threshold.
            if (children.length > this.groupNodeChildrenCountThreshold) {
                hasLargeGroupNodes = true;
                /** @type {!LayoutGraph} */
                const layoutGraph = (0, graph_layout_1.getLayoutGraph)(curGroupNode?.id || '', children, modelGraph, this.showOnNodeItemTypes, this.nodeDataProviderRuns, this.testMode, 
                // Use fake node size.
                true);
                // Find root nodes of the layout graph.
                /** @type {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} */
                const rootNodes = [];
                for (const nodeId of Object.keys(layoutGraph.nodes)) {
                    if (layoutGraph.incomingEdges[nodeId] == null) {
                        rootNodes.push(modelGraph.nodesById[nodeId]);
                    }
                }
                // Do a DFS from the layout graph root nodes. Create a new group
                // whenever the node counts reaches the threshold.
                /** @type {!Array<!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>>} */
                const groups = [];
                /** @type {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} */
                let curGroup = [];
                /** @type {!Set<string>} */
                const visitedNodeIds = new Set();
                /** @type {function(string): void} */
                const visit = (/**
                 * @param {string} curNodeId
                 * @return {void}
                 */
                (curNodeId) => {
                    if (visitedNodeIds.has(curNodeId)) {
                        return;
                    }
                    visitedNodeIds.add(curNodeId);
                    /** @type {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} */
                    const node = modelGraph.nodesById[curNodeId];
                    curGroup.push(node);
                    if (curGroup.length === this.groupNodeChildrenCountThreshold) {
                        groups.push(curGroup);
                        curGroup = [];
                    }
                    for (const childId of layoutGraph.outgoingEdges[node.id] || []) {
                        visit(childId);
                    }
                });
                for (const rootNode of rootNodes) {
                    visit(rootNode.id);
                }
                if (curGroup.length < this.groupNodeChildrenCountThreshold &&
                    curGroup.length > 0) {
                    groups.push(curGroup);
                }
                // Create a new group node for each group.
                /** @type {!Array<!tsickle_model_graph_3.GroupNode>} */
                const newGroupNodes = [];
                for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                    /** @type {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} */
                    const nodes = groups[groupIndex];
                    /** @type {string} */
                    const newGroupNodeNamespace = curGroupNode == null
                        ? ''
                        : `${curGroupNode.namespace}/${curGroupNode.label}`;
                    /** @type {string} */
                    const newGroupNodeLabel = `section_${groupIndex + 1}_of_${groups.length}`;
                    /** @type {string} */
                    const newGroupNodeId = curGroupNode == null
                        ? `${newGroupNodeLabel}___group___`
                        : `${newGroupNodeNamespace}/${newGroupNodeLabel}___group___`;
                    /** @type {!tsickle_model_graph_3.GroupNode} */
                    const newGroupNode = {
                        nodeType: model_graph_1.NodeType.GROUP_NODE,
                        id: newGroupNodeId,
                        label: newGroupNodeLabel,
                        namespace: newGroupNodeNamespace,
                        level: newGroupNodeNamespace.split('/').filter((/**
                         * @param {string} c
                         * @return {boolean}
                         */
                        (c) => c !== ''))
                            .length,
                        nsParentId: curGroupNode?.id,
                        nsChildrenIds: nodes.map((/**
                         * @param {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} node
                         * @return {string}
                         */
                        (node) => node.id)),
                        expanded: false,
                        sectionContainer: true,
                    };
                    newGroupNodes.push(newGroupNode);
                    // Add the new group node to the model graph.
                    modelGraph.nodes.push(newGroupNode);
                    modelGraph.nodesById[newGroupNode.id] = newGroupNode;
                    if (modelGraph.artificialGroupNodeIds == null) {
                        modelGraph.artificialGroupNodeIds = [];
                    }
                    modelGraph.artificialGroupNodeIds.push(newGroupNode.id);
                    // Update the ns parent for all nodes in the new group.
                    for (const node of nodes) {
                        node.nsParentId = newGroupNode.id;
                    }
                    // Update the namespace of all nodes and their desendents in the new
                    // group.
                    /** @type {string} */
                    const newNamespacePart = newGroupNodeId.replace('___group___', '');
                    /** @type {function((!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)): void} */
                    const updateNamespace = (/**
                     * @param {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} node
                     * @return {void}
                     */
                    (node) => {
                        /** @type {string} */
                        const oldNamespace = node.namespace;
                        if (oldNamespace === '') {
                            node.namespace = newNamespacePart;
                        }
                        else {
                            if (curGroupNode == null) {
                                node.namespace = `${newNamespacePart}/${node.namespace}`;
                            }
                            else {
                                node.namespace = (node.nsParentId || '').replace('___group___', '');
                            }
                        }
                        node.level = node.namespace
                            .split('/')
                            .filter((/**
                         * @param {string} c
                         * @return {boolean}
                         */
                        (c) => c !== '')).length;
                        if ((0, utils_1.isGroupNode)(node)) {
                            // Update group node id since its namespace has been changed.
                            /** @type {string} */
                            const oldNodeId = (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id;
                            delete modelGraph.nodesById[node.id];
                            (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id = `${(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).namespace}/${(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).label}___group___`;
                            modelGraph.nodesById[(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id] = node;
                            // Update its parent's nsChildren to use the new id.
                            if ((/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsParentId) {
                                /** @type {!tsickle_model_graph_3.GroupNode} */
                                const nsParent = (/** @type {!tsickle_model_graph_3.GroupNode} */ (modelGraph.nodesById[(/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsParentId]));
                                /** @type {number} */
                                const index = (nsParent.nsChildrenIds || []).indexOf(oldNodeId);
                                if (index >= 0) {
                                    (nsParent.nsChildrenIds || [])[index] = (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id;
                                }
                            }
                            for (const nsChildId of (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).nsChildrenIds || []) {
                                /** @type {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} */
                                const childNode = modelGraph.nodesById[nsChildId];
                                if (childNode != null) {
                                    // Update its children's nsParent id.
                                    childNode.nsParentId = (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).id;
                                    // BFS.
                                    updateNamespace(childNode);
                                }
                            }
                        }
                    });
                    for (const node of nodes) {
                        updateNamespace(node);
                    }
                    if (curGroupNode == null) {
                        // Remove the nodes in the current new group if they are in the root
                        // node list.
                        for (const node of nodes) {
                            /** @type {number} */
                            const index = modelGraph.rootNodes.indexOf(node);
                            if (index >= 0) {
                                modelGraph.rootNodes.splice(index, 1);
                            }
                        }
                        // Add the new group node to root node list if its namespace is
                        // empty.
                        if (newGroupNode.namespace === '') {
                            modelGraph.rootNodes.push(newGroupNode);
                        }
                    }
                    children = newGroupNodes;
                }
                // Update curGropNode's nsChildrenIds.
                if (curGroupNode != null) {
                    curGroupNode.nsChildrenIds = newGroupNodes.map((/**
                     * @param {!tsickle_model_graph_3.GroupNode} node
                     * @return {string}
                     */
                    (node) => node.id));
                }
            }
            for (const child of children) {
                if ((0, utils_1.isGroupNode)(child)) {
                    queue.push(child);
                }
            }
        }
        if (hasLargeGroupNodes) {
            this.generateLayoutGraphConnections(modelGraph);
        }
    }
    /**
     * @public
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @return {void}
     */
    populateDescendantsAndCounts(modelGraph) {
        // For each group node, gather all its descendant nodes.
        /** @type {number} */
        let minOpNodeCount = Number.MAX_VALUE;
        /** @type {number} */
        let maxOpNodeCount = Number.NEGATIVE_INFINITY;
        for (const node of modelGraph.nodes) {
            if ((0, utils_1.isGroupNode)(node)) {
                /** @type {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} */
                const descendants = [];
                this.gatherDescendants(modelGraph, node, descendants);
                (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).descendantsNodeIds = descendants.map((/**
                 * @param {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} node
                 * @return {string}
                 */
                (node) => node.id));
                (/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).descendantsOpNodeIds = descendants
                    .filter((/**
                 * @param {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} node
                 * @return {boolean}
                 */
                (node) => node.nodeType === model_graph_1.NodeType.OP_NODE))
                    .map((/**
                 * @param {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} node
                 * @return {string}
                 */
                (node) => node.id));
                /** @type {number} */
                const opNodeCount = ((/** @type {!tsickle_model_graph_3.GroupNode} */ (node)).descendantsOpNodeIds || []).length;
                minOpNodeCount = Math.min(opNodeCount, minOpNodeCount);
                maxOpNodeCount = Math.max(opNodeCount, maxOpNodeCount);
            }
        }
        modelGraph.minDescendantOpNodeCount = minOpNodeCount;
        modelGraph.maxDescendantOpNodeCount = maxOpNodeCount;
    }
    /**
     * @public
     * @return {!tsickle_model_graph_3.ModelGraph}
     */
    createEmptyModelGraph() {
        return {
            id: this.graph.id,
            collectionLabel: this.graph.collectionLabel || '',
            nodes: [],
            nodesById: {},
            rootNodes: [],
            edgesByGroupNodeIds: {},
            layoutGraphEdges: {},
            minDescendantOpNodeCount: -1,
            maxDescendantOpNodeCount: -1,
        };
    }
    /**
     * @private
     * @param {string} ns
     * @return {!Array<string>}
     */
    getAncestorNamespaces(ns) {
        // The returned namespaces include `ns` as well.
        /** @type {!Array<string>} */
        const components = this.getNonEmptyNamespaceComponents(ns);
        /** @type {!Array<string>} */
        const namespaces = [];
        while (components.length > 0) {
            namespaces.push(components.join('/'));
            components.pop();
        }
        return namespaces;
    }
    /**
     * @private
     * @param {string} ns
     * @return {!Array<string>}
     */
    getNonEmptyNamespaceComponents(ns) {
        return ns.split('/').filter((/**
         * @param {string} component
         * @return {boolean}
         */
        (component) => component !== ''));
    }
    /**
     * @private
     * @param {string} ns
     * @return {string}
     */
    getGroupNodeIdFromNamespace(ns) {
        return `${ns}___group___`;
    }
    /**
     * @private
     * @param {!tsickle_model_graph_3.ModelGraph} modelGraph
     * @param {!tsickle_model_graph_3.GroupNode} curRoot
     * @param {!Array<(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)>} descendants
     * @return {void}
     */
    gatherDescendants(modelGraph, curRoot, descendants) {
        for (const childId of curRoot.nsChildrenIds || []) {
            /** @type {(!tsickle_model_graph_3.OpNode|!tsickle_model_graph_3.GroupNode)} */
            const child = modelGraph.nodesById[childId];
            if ((0, utils_1.isGroupNode)(child) || ((0, utils_1.isOpNode)(child) && !(/** @type {!tsickle_model_graph_3.OpNode} */ (child)).hideInLayout)) {
                descendants.push(child);
            }
            if ((0, utils_1.isGroupNode)(child)) {
                this.gatherDescendants(modelGraph, child, descendants);
            }
        }
    }
    /**
     * @private
     * @param {string} key
     * @param {string} value
     * @return {string}
     */
    processAttrValue(key, value) {
        // Process const value that in `dense<...>` format. This is for backward
        // compatibility.
        if (value.startsWith('dense<')) {
            /** @type {(null|!RegExpMatchArray)} */
            const matches = value.match(CONST_VALUE_REGEX);
            if (matches != null && matches.length > 1) {
                /** @type {string} */
                const strTensorValue = matches[1];
                return formatTensorValues(strTensorValue);
            }
        }
        // Process tensor values.
        else if (key === consts_1.TENSOR_VALUES_KEY) {
            return formatTensorValues(value);
        }
        return value.replaceAll('"', '') || '<empty>';
    }
    /**
     * @private
     * @param {!Array<!tsickle_types_4.MetadataItem>} metadataItems
     * @return {?}
     */
    processMetadataList(metadataItems) {
        /** @type {?} */
        const metadata = {};
        for (const metadataItem of metadataItems) {
            /** @type {?} */
            const attrs = {};
            for (const attr of metadataItem.attrs) {
                /** @type {string} */
                let key = attr.key;
                /** @type {string} */
                let value = attr.value;
                // Special handlings.
                if (key === 'tensor_shape') {
                    key = 'shape';
                    value = value
                        .replace('tensor<', '')
                        .replace('>', '')
                        .replace('*', 'â')
                        .split('x')
                        .join(' x ');
                }
                attrs[key] = value;
            }
            metadata[metadataItem.id] = attrs;
        }
        return metadata;
    }
}
exports.GraphProcessor = GraphProcessor;
/* istanbul ignore if */
if (false) {
    /**
     * @const {!Set<string>}
     * @private
     */
    GraphProcessor.prototype.nodeLabelsToHide;
    /**
     * @const {string}
     * @private
     */
    GraphProcessor.prototype.paneId;
    /**
     * @const {!tsickle_input_graph_2.Graph}
     * @private
     */
    GraphProcessor.prototype.graph;
    /**
     * @const {(undefined|!tsickle_visualizer_config_6.VisualizerConfig)}
     * @private
     */
    GraphProcessor.prototype.config;
    /**
     * @const {?}
     * @private
     */
    GraphProcessor.prototype.showOnNodeItemTypes;
    /**
     * @const {?}
     * @private
     */
    GraphProcessor.prototype.nodeDataProviderRuns;
    /**
     * @const {number}
     * @private
     */
    GraphProcessor.prototype.groupNodeChildrenCountThreshold;
    /**
     * @const {boolean}
     * @private
     */
    GraphProcessor.prototype.testMode;
    /**
     * @const {boolean}
     * @private
     */
    GraphProcessor.prototype.flattenLayers;
}
/**
 * Formats the given tensor values string.
 *
 * The given string is in the form of:
 * [[[1, 2], [3, 4]]]
 *
 * And we want to format it to:
 * [
 *   [
 *     [
 *       1,
 *       2
 *     ],
 *     [
 *       3,
 *       4
 *     ]
 *   ]
 * ]
 * @param {string} strValues
 * @return {string}
 */
function formatTensorValues(strValues) {
    try {
        return JSON.stringify(JSON.parse(strValues), null, 2)
            .replaceAll('\\n', '\n')
            .trim();
    }
    catch (e) {
        return strValues;
    }
}
exports.formatTensorValues = formatTensorValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhfcHJvY2Vzc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL21vZHVsZS93b3JrZXIvZ3JhcGhfcHJvY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3SEFHMEI7QUFFMUIsa0lBTStCO0FBTy9CLHNIQUt5QjtBQUV6QixzSUFBd0Q7QUFFeEQsb0lBQThDO0FBQzlDLHNIQUFpRDs7TUFFM0MsaUJBQWlCLEdBQUcsZ0JBQWdCOzs7O0FBSzFDLE1BQWEsY0FBYzs7Ozs7Ozs7Ozs7O0lBR3pCLFlBQ21CLE1BQWMsRUFDZCxLQUFZLEVBQ1osTUFBeUIsRUFDekIsc0JBR2IsRUFBRSxFQUNXLHVCQUdiLEVBQUUsRUFDVyxrQ0FBa0Msb0RBQTJDLEVBQzdFLFdBQVcsS0FBSyxFQUNoQixnQkFBZ0IsS0FBSztRQWJyQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsVUFBSyxHQUFMLEtBQUssQ0FBTztRQUNaLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBQ3pCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FHOUI7UUFDVyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBRy9CO1FBQ1csb0NBQStCLEdBQS9CLCtCQUErQixDQUE4QztRQUM3RSxhQUFRLEdBQVIsUUFBUSxDQUFRO1FBQ2hCLGtCQUFhLEdBQWIsYUFBYSxDQUFRO1FBRXRDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLEdBQUcsQ0FDN0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGdCQUFnQixJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUc7Ozs7UUFBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxFQUFDLENBQzFFLENBQUM7SUFDSixD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OUYsa0NBQWlDOzs7OztJQUNqQyx1Q0FBc0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVzQjFDLFNBQWdCLGtCQUFrQixDQUFDLFNBQWlCO0lBQ2xELElBQUksQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7YUFDbEQsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7YUFDdkIsSUFBSSxFQUFFLENBQUM7SUFDWixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7QUFDSCxDQUFDO0FBUkQsZ0RBUUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBERUZBVUxUX0dST1VQX05PREVfQ0hJTERSRU5fQ09VTlRfVEhSRVNIT0xELFxuICBURU5TT1JfVkFMVUVTX0tFWSxcbn0gZnJvbSAnLi4vY29tbW9uL2NvbnN0cyc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi9jb21tb24vaW5wdXRfZ3JhcGgnO1xuaW1wb3J0IHtcbiAgR3JvdXBOb2RlLFxuICBNb2RlbEdyYXBoLFxuICBNb2RlbE5vZGUsXG4gIE5vZGVUeXBlLFxuICBPcE5vZGUsXG59IGZyb20gJy4uL2NvbW1vbi9tb2RlbF9ncmFwaCc7XG5pbXBvcnQge1xuICBLZXlWYWx1ZVBhaXJzLFxuICBNZXRhZGF0YUl0ZW0sXG4gIE5vZGVEYXRhUHJvdmlkZXJSdW5EYXRhLFxuICBTaG93T25Ob2RlSXRlbURhdGEsXG59IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQge1xuICBmaW5kQ29tbW9uTmFtZXNwYWNlLFxuICBnZXROZXh0TGV2ZWxOc1BhcnQsXG4gIGlzR3JvdXBOb2RlLFxuICBpc09wTm9kZSxcbn0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7VmlzdWFsaXplckNvbmZpZ30gZnJvbSAnLi4vY29tbW9uL3Zpc3VhbGl6ZXJfY29uZmlnJztcbmltcG9ydCB7UHJvY2Vzc2luZ0xhYmVsfSBmcm9tICcuLi9jb21tb24vd29ya2VyX2V2ZW50cyc7XG5cbmltcG9ydCB7Z2V0TGF5b3V0R3JhcGh9IGZyb20gJy4vZ3JhcGhfbGF5b3V0JztcbmltcG9ydCB7dXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQ09OU1RfVkFMVUVfUkVHRVggPSAvZGVuc2U8KFtePl0qKT4vO1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBwcm9jZXNzZXMgYSBnaXZlbiBgR3JhcGhgIGludG8gYSBgTW9kZWxHcmFwaGAuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaFByb2Nlc3NvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbm9kZUxhYmVsc1RvSGlkZTogU2V0PHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYW5lSWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyYXBoOiBHcmFwaCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZz86IFZpc3VhbGl6ZXJDb25maWcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaG93T25Ob2RlSXRlbVR5cGVzOiBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICBTaG93T25Ob2RlSXRlbURhdGFcbiAgICA+ID0ge30sXG4gICAgcHJpdmF0ZSByZWFkb25seSBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPFxuICAgICAgc3RyaW5nLFxuICAgICAgTm9kZURhdGFQcm92aWRlclJ1bkRhdGFcbiAgICA+ID0ge30sXG4gICAgcHJpdmF0ZSByZWFkb25seSBncm91cE5vZGVDaGlsZHJlbkNvdW50VGhyZXNob2xkID0gREVGQVVMVF9HUk9VUF9OT0RFX0NISUxEUkVOX0NPVU5UX1RIUkVTSE9MRCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRlc3RNb2RlID0gZmFsc2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmbGF0dGVuTGF5ZXJzID0gZmFsc2UsXG4gICkge1xuICAgIHRoaXMubm9kZUxhYmVsc1RvSGlkZSA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgICh0aGlzLmNvbmZpZz8ubm9kZUxhYmVsc1RvSGlkZSB8fCBbXSkubWFwKChsYWJlbCkgPT4gbGFiZWwudG9Mb3dlckNhc2UoKSksXG4gICAgKTtcbiAgfVxuXG4gIHByb2Nlc3MoKTogTW9kZWxHcmFwaCB7XG4gICAgY29uc3QgbW9kZWxHcmFwaCA9IHRoaXMuY3JlYXRlRW1wdHlNb2RlbEdyYXBoKCk7XG5cbiAgICB0aGlzLnByb2Nlc3NOb2Rlcyhtb2RlbEdyYXBoKTtcbiAgICB0aGlzLnByb2Nlc3NFZGdlUmVsYXRpb25zaGlwcyhtb2RlbEdyYXBoKTtcbiAgICB1cGRhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MoXG4gICAgICB0aGlzLnBhbmVJZCxcbiAgICAgIFByb2Nlc3NpbmdMYWJlbC5QUk9DRVNTSU5HX05PREVTX0FORF9FREdFUyxcbiAgICApO1xuXG4gICAgdGhpcy5wcm9jZXNzTmFtZXNwYWNlUmVsYXRpb25zaGlwcyhtb2RlbEdyYXBoKTtcbiAgICB1cGRhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MoXG4gICAgICB0aGlzLnBhbmVJZCxcbiAgICAgIFByb2Nlc3NpbmdMYWJlbC5QUk9DRVNTSU5HX0xBWUVSX05BTUVTUEFDRVMsXG4gICAgKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVMYXlvdXRHcmFwaENvbm5lY3Rpb25zKG1vZGVsR3JhcGgpO1xuICAgIHVwZGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyhcbiAgICAgIHRoaXMucGFuZUlkLFxuICAgICAgUHJvY2Vzc2luZ0xhYmVsLlBST0NFU1NJTkdfTEFZT1VUX0RBVEEsXG4gICAgKTtcblxuICAgIHRoaXMuc3BsaXRMYXJnZUdyb3VwTm9kZXMobW9kZWxHcmFwaCk7XG4gICAgdXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzKFxuICAgICAgdGhpcy5wYW5lSWQsXG4gICAgICBQcm9jZXNzaW5nTGFiZWwuU1BMSVRUSU5HX0xBUkdFX0xBWUVSUyxcbiAgICApO1xuXG4gICAgdGhpcy5wb3B1bGF0ZURlc2NlbmRhbnRzQW5kQ291bnRzKG1vZGVsR3JhcGgpO1xuXG4gICAgcmV0dXJuIG1vZGVsR3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogU2NhbnMgbm9kZXMgaW4gYEdyYXBoYCBhbmQgY3JlYXRlcyB0aGUgY29ycmVzcG9uZGluZyBgT3BOb2RlYCBhbmRcbiAgICogYEdyb3VwTm9kZWAgaW4gdGhlIGBNb2RlbEdyYXBoYCAoc2VlIG1vZGVsX2dyYXBoLnRzIGZvciBtb3JlIGRldGFpbHMpLlxuICAgKi9cbiAgcHJvY2Vzc05vZGVzKG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgpIHtcbiAgICBjb25zdCBzZWVuTmFtZXNwYWNlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgZ3JhcGhOb2RlIG9mIHRoaXMuZ3JhcGgubm9kZXMpIHtcbiAgICAgIC8vIEFkZCBhbiBgT3BOb2RlYCB0byB0aGUgbW9kZWwgZ3JhcGggZm9yIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGguXG4gICAgICAvL1xuICAgICAgLy8gSWYgbmFtZXNwYWNlIGlzIGEgXCI7XCIgc2VwYXJhdGVkIHN0cmluZywgdXNlIHRoZSBsYXN0IGNvbXBvbmVudCBhcyB0aGVcbiAgICAgIC8vIGFjdHVhbCBuYW1lc3BhY2UuXG4gICAgICBjb25zdCBuYW1lc3BhY2UgPSBncmFwaE5vZGUubmFtZXNwYWNlO1xuICAgICAgY29uc3QgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJzsnKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQgIT09ICcnKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdyYXBoTm9kZS5uYW1lc3BhY2UgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wTm9kZTogT3BOb2RlID0ge1xuICAgICAgICBub2RlVHlwZTogTm9kZVR5cGUuT1BfTk9ERSxcbiAgICAgICAgaWQ6IGdyYXBoTm9kZS5pZCxcbiAgICAgICAgbmFtZXNwYWNlOiB0aGlzLmZsYXR0ZW5MYXllcnMgPyAnJyA6IGdyYXBoTm9kZS5uYW1lc3BhY2UsXG4gICAgICAgIHNhdmVkTmFtZXNwYWNlOiBncmFwaE5vZGUubmFtZXNwYWNlLFxuICAgICAgICBsYWJlbDogZ3JhcGhOb2RlLmxhYmVsLFxuICAgICAgICBsZXZlbDogdGhpcy5nZXROb25FbXB0eU5hbWVzcGFjZUNvbXBvbmVudHMoZ3JhcGhOb2RlLm5hbWVzcGFjZSkubGVuZ3RoLFxuICAgICAgfTtcbiAgICAgIGlmIChncmFwaE5vZGUuc3ViZ3JhcGhJZHMgJiYgZ3JhcGhOb2RlLnN1YmdyYXBoSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BOb2RlLnN1YmdyYXBoSWRzID0gZ3JhcGhOb2RlLnN1YmdyYXBoSWRzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm9kZUxhYmVsc1RvSGlkZS5oYXMoZ3JhcGhOb2RlLmxhYmVsLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIG9wTm9kZS5oaWRlSW5MYXlvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGdyYXBoTm9kZS5hdHRycykge1xuICAgICAgICBjb25zdCBhdHRyczogS2V5VmFsdWVQYWlycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgZ3JhcGhOb2RlLmF0dHJzKSB7XG4gICAgICAgICAgYXR0cnNbYXR0ci5rZXldID0gdGhpcy5wcm9jZXNzQXR0clZhbHVlKGF0dHIua2V5LCBhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvcE5vZGUuYXR0cnMgPSBhdHRycztcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaE5vZGUuaW5wdXRzTWV0YWRhdGEpIHtcbiAgICAgICAgb3BOb2RlLmlucHV0c01ldGFkYXRhID0gdGhpcy5wcm9jZXNzTWV0YWRhdGFMaXN0KFxuICAgICAgICAgIGdyYXBoTm9kZS5pbnB1dHNNZXRhZGF0YSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaE5vZGUub3V0cHV0c01ldGFkYXRhKSB7XG4gICAgICAgIG9wTm9kZS5vdXRwdXRzTWV0YWRhdGEgPSB0aGlzLnByb2Nlc3NNZXRhZGF0YUxpc3QoXG4gICAgICAgICAgZ3JhcGhOb2RlLm91dHB1dHNNZXRhZGF0YSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaE5vZGUuc3R5bGUpIHtcbiAgICAgICAgb3BOb2RlLnN0eWxlID0gZ3JhcGhOb2RlLnN0eWxlO1xuICAgICAgfVxuICAgICAgbW9kZWxHcmFwaC5ub2Rlcy5wdXNoKG9wTm9kZSk7XG4gICAgICBtb2RlbEdyYXBoLm5vZGVzQnlJZFtvcE5vZGUuaWRdID0gb3BOb2RlO1xuXG4gICAgICAvLyBBZGQgZ3JvdXAgbm9kZXMgZm9yIGFsbCBhbmNlc3RvciBuYW1lc3BhY2VzIGZyb20gdGhpcyBvcCBub2RlLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBleGFtcGxlLCBpZiBhbiBvcCBub2RlJ3MgbmFtZXNwYWNlIGlzIGEvYi9jLCB0aGVuIGFkZCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBncm91cCBub2Rlcy5cbiAgICAgIC8vXG4gICAgICAvLyAtIG5hbWVzcGFjZTogYS9iLCBsYWJlbDogYy5cbiAgICAgIC8vIC0gbmFtZXNwYWNlOiBhLCBsYWJlbDogYi5cbiAgICAgIC8vIC0gbmFtZXNwYWNlOiA8ZW1wdHk+LCBsYWJlbCBhLlxuICAgICAgaWYgKCFvcE5vZGUuaGlkZUluTGF5b3V0ICYmICF0aGlzLmZsYXR0ZW5MYXllcnMpIHtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JOYW1lc3BhY2VzID0gdGhpcy5nZXRBbmNlc3Rvck5hbWVzcGFjZXMob3BOb2RlLm5hbWVzcGFjZSk7XG4gICAgICAgIGZvciAoY29uc3QgbnMgb2YgYW5jZXN0b3JOYW1lc3BhY2VzKSB7XG4gICAgICAgICAgaWYgKHNlZW5OYW1lc3BhY2VzLmhhcyhucykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWVuTmFtZXNwYWNlcy5hZGQobnMpO1xuXG4gICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG5zLnNwbGl0KCcvJyk7XG4gICAgICAgICAgLy8gVXNlIHRoZSBsYXN0IGNvbXBvbmVudCBvZiB0aGUgbmFtZXNwYWNlIGFzIGl0cyBkaXNwbGF5IGxhYmVsLlxuICAgICAgICAgIGNvbnN0IGxhYmVsID0gY29tcG9uZW50cy5zcGxpY2UoLTEpWzBdO1xuICAgICAgICAgIC8vIEdyb3VwIG5vZGUncyBuYW1lc3BhY2UgZG9lc24ndCBjb250YWluIHRoZSBsYXN0IGNvbXBvbmVudC5cbiAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBjb21wb25lbnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICBjb25zdCBncm91cE5vZGU6IEdyb3VwTm9kZSA9IHtcbiAgICAgICAgICAgIG5vZGVUeXBlOiBOb2RlVHlwZS5HUk9VUF9OT0RFLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0R3JvdXBOb2RlSWRGcm9tTmFtZXNwYWNlKG5zKSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgbGV2ZWw6IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgbW9kZWxHcmFwaC5ub2Rlcy5wdXNoKGdyb3VwTm9kZSk7XG4gICAgICAgICAgbW9kZWxHcmFwaC5ub2Rlc0J5SWRbZ3JvdXBOb2RlLmlkXSA9IGdyb3VwTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGVkZ2VzIGluIHRoZSBnaXZlbiBtb2RlbCBncmFwaCBiYXNlZCBvbiB0aGUgZWRnZXMgaW4gdGhlIGlucHV0IGdyYXBoLlxuICAgKi9cbiAgcHJvY2Vzc0VkZ2VSZWxhdGlvbnNoaXBzKG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgpIHtcbiAgICBmb3IgKGNvbnN0IGdyYXBoTm9kZSBvZiB0aGlzLmdyYXBoLm5vZGVzKSB7XG4gICAgICBjb25zdCBub2RlID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbZ3JhcGhOb2RlLmlkXSBhcyBPcE5vZGU7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZyb20gdGhlIGdyYXBoIG5vZGUncyBpbmNvbWluZyBlZGdlcywgcG9wdWxhdGUgdGhlIGluY29taW5nIGFuZFxuICAgICAgLy8gb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgaW4gdGhlIG1vZGVsIGdyYXBoLlxuICAgICAgZm9yIChjb25zdCBpbmNvbWluZ0VkZ2Ugb2YgZ3JhcGhOb2RlLmluY29taW5nRWRnZXMgfHwgW10pIHtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZUlkID0gaW5jb21pbmdFZGdlLnNvdXJjZU5vZGVJZDtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IG1vZGVsR3JhcGgubm9kZXNCeUlkW3NvdXJjZU5vZGVJZF0gYXMgT3BOb2RlO1xuICAgICAgICBpZiAoIXNvdXJjZU5vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY29taW5nIGVkZ2VzLlxuICAgICAgICBpZiAobm9kZS5pbmNvbWluZ0VkZ2VzID09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmluY29taW5nRWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbm9kZS5pbmNvbWluZ0VkZ2VzLmZpbmQoXG4gICAgICAgICAgICAoZWRnZSkgPT5cbiAgICAgICAgICAgICAgZWRnZS5zb3VyY2VOb2RlSWQgPT09IHNvdXJjZU5vZGVJZCAmJlxuICAgICAgICAgICAgICBlZGdlLnNvdXJjZU5vZGVPdXRwdXRJZCA9PT0gaW5jb21pbmdFZGdlLnNvdXJjZU5vZGVPdXRwdXRJZCAmJlxuICAgICAgICAgICAgICBlZGdlLnRhcmdldE5vZGVJbnB1dElkID09PSBpbmNvbWluZ0VkZ2UudGFyZ2V0Tm9kZUlucHV0SWQsXG4gICAgICAgICAgKSA9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIG5vZGUuaW5jb21pbmdFZGdlcy5wdXNoKHsuLi5pbmNvbWluZ0VkZ2V9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE91dGdvaW5nIGVkZ2VzLlxuICAgICAgICBpZiAoc291cmNlTm9kZS5vdXRnb2luZ0VkZ2VzID09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VOb2RlLm91dGdvaW5nRWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgc291cmNlTm9kZS5vdXRnb2luZ0VkZ2VzLmZpbmQoXG4gICAgICAgICAgICAoZWRnZSkgPT5cbiAgICAgICAgICAgICAgZWRnZS50YXJnZXROb2RlSWQgPT09IG5vZGUuaWQgJiZcbiAgICAgICAgICAgICAgZWRnZS5zb3VyY2VOb2RlT3V0cHV0SWQgPT09IGluY29taW5nRWRnZS5zb3VyY2VOb2RlT3V0cHV0SWQgJiZcbiAgICAgICAgICAgICAgZWRnZS50YXJnZXROb2RlSW5wdXRJZCA9PT0gaW5jb21pbmdFZGdlLnRhcmdldE5vZGVJbnB1dElkLFxuICAgICAgICAgICkgPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBzb3VyY2VOb2RlLm91dGdvaW5nRWRnZXMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXROb2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICBzb3VyY2VOb2RlT3V0cHV0SWQ6IGluY29taW5nRWRnZS5zb3VyY2VOb2RlT3V0cHV0SWQsXG4gICAgICAgICAgICB0YXJnZXROb2RlSW5wdXRJZDogaW5jb21pbmdFZGdlLnRhcmdldE5vZGVJbnB1dElkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbmFtZXNwYWNlIHJlbGF0aW9uc2hpcHMgaW4gbW9kZWwgZ3JhcGggYmFzZWQgb24gdGhlIGhpZXJhcmNoeSBkYXRhXG4gICAqIHN0b3JlZCBpbiBpbnB1dCBub2RlJ3MgYG5hbWVzcGFjZWAuXG4gICAqL1xuICBwcm9jZXNzTmFtZXNwYWNlUmVsYXRpb25zaGlwcyhtb2RlbEdyYXBoOiBNb2RlbEdyYXBoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG1vZGVsR3JhcGgubm9kZXMpIHtcbiAgICAgIGlmIChpc09wTm9kZShub2RlKSAmJiBub2RlLmhpZGVJbkxheW91dCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnMgPSBub2RlLm5hbWVzcGFjZTtcblxuICAgICAgLy8gUm9vdCBub2RlLlxuICAgICAgaWYgKG5zID09PSAnJykge1xuICAgICAgICBtb2RlbEdyYXBoLnJvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IG5hbWVzcGFjZSBwYXJlbnQuXG4gICAgICBjb25zdCBwYXJlbnROb2RlSWQgPSB0aGlzLmdldEdyb3VwTm9kZUlkRnJvbU5hbWVzcGFjZShucyk7XG4gICAgICBjb25zdCBwYXJlbnRHcm91cE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtwYXJlbnROb2RlSWRdIGFzIEdyb3VwTm9kZTtcbiAgICAgIGlmIChwYXJlbnRHcm91cE5vZGUpIHtcbiAgICAgICAgbm9kZS5uc1BhcmVudElkID0gcGFyZW50R3JvdXBOb2RlLmlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZmluZCB0aGUgTlMgcGFyZW50IG9mIG5vZGUgXCIke25vZGUuaWR9XCI6IFwiJHtwYXJlbnROb2RlSWR9XCJgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgbmFtZXNwYWNlIGNoaWxkcmVuLlxuICAgICAgaWYgKHBhcmVudEdyb3VwTm9kZSkge1xuICAgICAgICBpZiAocGFyZW50R3JvdXBOb2RlLm5zQ2hpbGRyZW5JZHMgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudEdyb3VwTm9kZS5uc0NoaWxkcmVuSWRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRHcm91cE5vZGUubnNDaGlsZHJlbklkcy5pbmNsdWRlcyhub2RlLmlkKSkge1xuICAgICAgICAgIHBhcmVudEdyb3VwTm9kZS5uc0NoaWxkcmVuSWRzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5kIGdyb3VwIG5vZGVzIHRoYXQgb25seSBoYXZlIG9uZSBzaW5nbGUgb3Agbm9kZSBhcyBpdHMgY2hpbGQuIEZvclxuICAgIC8vIHRoZXNlIG5vZGVzLCByZW1vdmUgdGhlIGdyb3VwIG5vZGUgYW5kIG1vdmUgdGhlIGNoaWxkIG9wIG5vZGUgdXAgYSBsZXZlbFxuICAgIC8vIGZyb20gaXRzIG5hbWVzcGFjZS5cbiAgICAvL1xuICAgIC8vIFJlcGVhdGVkbHkgZG8gdGhpcyB1bnRpbCBubyBzdWNoIG5vZGVzIGFyZSBmb3VuZC5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IG51bU5vZGVQcm9jZXNzZWQgPSAwO1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG1vZGVsR3JhcGgubm9kZXMpIHtcbiAgICAgICAgaWYgKCFpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5zQ2hpbGRyZW5JZHMgIT0gbnVsbCAmJiBub2RlLm5zQ2hpbGRyZW5JZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgb3BOb2RlID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbbm9kZS5uc0NoaWxkcmVuSWRzWzBdXTtcbiAgICAgICAgICBpZiAoaXNPcE5vZGUob3BOb2RlKSkge1xuICAgICAgICAgICAgbnVtTm9kZVByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgLy8gRGVsZXRlIGdyb3VwIG5vZGUuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vZGVsR3JhcGgubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIG1vZGVsR3JhcGgubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtub2RlLmlkXTtcblxuICAgICAgICAgICAgLy8gTW92ZSBvcCBub2RlIHVwIG9uZSBsZXZlbCBpbiBuYW1lc3BhY2UuXG4gICAgICAgICAgICBjb25zdCBucyA9IG9wTm9kZS5uYW1lc3BhY2U7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuZ2V0Tm9uRW1wdHlOYW1lc3BhY2VDb21wb25lbnRzKG5zKTtcbiAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgb3BOb2RlLm5hbWVzcGFjZSA9IHBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIG9wTm9kZS5zYXZlZE5hbWVzcGFjZSA9IG9wTm9kZS5uYW1lc3BhY2U7XG4gICAgICAgICAgICBvcE5vZGUubGV2ZWwgPSBwYXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICBvcE5vZGUubnNQYXJlbnRJZCA9IG5vZGUubnNQYXJlbnRJZDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJvb3Qgbm9kZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBjb25zdCBpbmRleEluUm9vdE5vZGVzID0gbW9kZWxHcmFwaC5yb290Tm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpbmRleEluUm9vdE5vZGVzID49IDApIHtcbiAgICAgICAgICAgICAgbW9kZWxHcmFwaC5yb290Tm9kZXMuc3BsaWNlKGluZGV4SW5Sb290Tm9kZXMsIDEpO1xuICAgICAgICAgICAgICBtb2RlbEdyYXBoLnJvb3ROb2Rlcy5wdXNoKG9wTm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBpdHMgTlMgcGFyZW50IG5vZGUncyBuc0NoaWxkcmVuSWRzLCBhbmQgYWRkXG4gICAgICAgICAgICAvLyB0aGUgb3Agbm9kZSB0byBpdC5cbiAgICAgICAgICAgIGlmIChub2RlLm5zUGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbnNQYXJlbnQgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtcbiAgICAgICAgICAgICAgICBub2RlLm5zUGFyZW50SWRcbiAgICAgICAgICAgICAgXSBhcyBHcm91cE5vZGU7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbnNQYXJlbnQubnNDaGlsZHJlbklkcyEuaW5kZXhPZihub2RlLmlkKTtcbiAgICAgICAgICAgICAgbnNQYXJlbnQubnNDaGlsZHJlbklkcyEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgbnNQYXJlbnQubnNDaGlsZHJlbklkcyEucHVzaChvcE5vZGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bU5vZGVQcm9jZXNzZWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBsYXlvdXQgZ3JhcGggY29ubmVjdGlvbnMgZm9yIHRoZSBnaXZlbiBtb2RlbCBncmFwaC5cbiAgICovXG4gIGdlbmVyYXRlTGF5b3V0R3JhcGhDb25uZWN0aW9ucyhtb2RlbEdyYXBoOiBNb2RlbEdyYXBoKSB7XG4gICAgbW9kZWxHcmFwaC5sYXlvdXRHcmFwaEVkZ2VzID0ge307XG5cbiAgICAvLyBGaW5kIGFsbCBvcCBub2RlcyB0aGF0IGRvbid0IGhhdmUgaW5jb21pbmcgZWRnZXMuXG4gICAgY29uc3Qgb3BOb2Rlc1dpdGhvdXRJbmNvbWluZ0VkZ2VzOiBPcE5vZGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtb2RlbEdyYXBoLm5vZGVzKSB7XG4gICAgICBpZiAoIWlzT3BOb2RlKG5vZGUpIHx8IG5vZGUuaGlkZUluTGF5b3V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyZWRJbmNvbWluZ0VkZ2VzID0gKG5vZGUuaW5jb21pbmdFZGdlcyB8fCBbXSkuZmlsdGVyKFxuICAgICAgICAoZWRnZSkgPT5cbiAgICAgICAgICAhKG1vZGVsR3JhcGgubm9kZXNCeUlkW2VkZ2Uuc291cmNlTm9kZUlkXSBhcyBPcE5vZGUpLmhpZGVJbkxheW91dCxcbiAgICAgICk7XG4gICAgICBpZiAoZmlsdGVyZWRJbmNvbWluZ0VkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcE5vZGVzV2l0aG91dEluY29taW5nRWRnZXMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEbyBhIEJGUyBmcm9tIG9wTm9kZXNXaXRob3V0SW5jb21pbmdFZGdlcy5cbiAgICBjb25zdCBxdWV1ZTogT3BOb2RlW10gPSBbLi4ub3BOb2Rlc1dpdGhvdXRJbmNvbWluZ0VkZ2VzXTtcbiAgICBjb25zdCBzZWVuTm9kZUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJOb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGlmIChjdXJOb2RlID09IG51bGwgfHwgY3VyTm9kZS5oaWRlSW5MYXlvdXQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc2Vlbk5vZGVJZHMuaGFzKGN1ck5vZGUuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2Vlbk5vZGVJZHMuYWRkKGN1ck5vZGUuaWQpO1xuXG4gICAgICAvLyBGb3IgZWFjaCBlZGdlIGdvaW5nIGZyb20gY3VyTm9kZSAoQSksIGZpbmQgdGhlIGNvbW1vbiBuYW1lc3BhY2Ugb2ZcbiAgICAgIC8vIGN1ck5vZGUgYW5kIGVkZ2UncyB0YXJnZXQgbm9kZSAoQiksIGFuZCBtYXJrIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gdGhlXG4gICAgICAvLyB0b3AtbGV2ZWwgbm9kZSB0aGF0IGNvbnRhaW5zIEEgYW5kIEIgd2l0aGluIHRoZSBjb21tb24gbmFtZXNwYWNlLlxuICAgICAgLy9cbiAgICAgIC8vIEZvciBleGFtcGxlLCBvcCBub2RlIFgncyBuYW1lc3BhZSBpcyBhL2IvYywgb3Agbm9kZSBZJ3MgbmFtZXNwYWNlXG4gICAgICAvLyBpcyBhL2IvZCwgYW5kIFggaGFzIGFuIGVkZ2UgdG8gWS4gWCBhbmQgWSdzIGNvbW1vbiBuYW1lc3BhY2UgaXMgYS9iLlxuICAgICAgLy8gU28gd2UgbWFyayBhL2IvYyBhbmQgYS9iL2QgdG8gYmUgY29ubmVjdGVkLlxuICAgICAgY29uc3Qgb3V0Z29pbmdFZGdlcyA9IGN1ck5vZGUub3V0Z29pbmdFZGdlcyB8fCBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRnb2luZ0VkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtlZGdlLnRhcmdldE5vZGVJZF0gYXMgT3BOb2RlO1xuICAgICAgICBpZiAodGFyZ2V0Tm9kZS5oaWRlSW5MYXlvdXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21tb25OcyA9IGZpbmRDb21tb25OYW1lc3BhY2UoXG4gICAgICAgICAgY3VyTm9kZS5uYW1lc3BhY2UsXG4gICAgICAgICAgdGFyZ2V0Tm9kZS5uYW1lc3BhY2UsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGVOZXh0TGV2ZWxOc1BhcnQgPSBnZXROZXh0TGV2ZWxOc1BhcnQoXG4gICAgICAgICAgY29tbW9uTnMsXG4gICAgICAgICAgY3VyTm9kZS5uYW1lc3BhY2UsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25Gcm9tTm9kZUlkID1cbiAgICAgICAgICBzb3VyY2VOb2RlTmV4dExldmVsTnNQYXJ0ID09PSAnJ1xuICAgICAgICAgICAgPyBjdXJOb2RlLmlkXG4gICAgICAgICAgICA6IGAke2NvbW1vbk5zfSR7XG4gICAgICAgICAgICAgICAgY29tbW9uTnMgPT09ICcnID8gJycgOiAnLydcbiAgICAgICAgICAgICAgfSR7c291cmNlTm9kZU5leHRMZXZlbE5zUGFydH1fX19ncm91cF9fX2A7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGVOZXh0TGV2ZWxOc1BhcnQgPSBnZXROZXh0TGV2ZWxOc1BhcnQoXG4gICAgICAgICAgY29tbW9uTnMsXG4gICAgICAgICAgdGFyZ2V0Tm9kZS5uYW1lc3BhY2UsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25Ub05vZGVJZCA9XG4gICAgICAgICAgdGFyZ2V0Tm9kZU5leHRMZXZlbE5zUGFydCA9PT0gJydcbiAgICAgICAgICAgID8gdGFyZ2V0Tm9kZS5pZFxuICAgICAgICAgICAgOiBgJHtjb21tb25Oc30ke1xuICAgICAgICAgICAgICAgIGNvbW1vbk5zID09PSAnJyA/ICcnIDogJy8nXG4gICAgICAgICAgICAgIH0ke3RhcmdldE5vZGVOZXh0TGV2ZWxOc1BhcnR9X19fZ3JvdXBfX19gO1xuXG4gICAgICAgIGNvbnN0IGNvbW1vbk5zR3JvdXBJZCA9IGNvbW1vbk5zID09PSAnJyA/ICcnIDogYCR7Y29tbW9uTnN9X19fZ3JvdXBfX19gO1xuICAgICAgICBpZiAobW9kZWxHcmFwaC5sYXlvdXRHcmFwaEVkZ2VzW2NvbW1vbk5zR3JvdXBJZF0gPT0gbnVsbCkge1xuICAgICAgICAgIG1vZGVsR3JhcGgubGF5b3V0R3JhcGhFZGdlc1tjb21tb25Oc0dyb3VwSWRdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vZGVsR3JhcGgubGF5b3V0R3JhcGhFZGdlc1tjb21tb25Oc0dyb3VwSWRdW2Nvbm5lY3Rpb25Gcm9tTm9kZUlkXSA9PVxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgbW9kZWxHcmFwaC5sYXlvdXRHcmFwaEVkZ2VzW2NvbW1vbk5zR3JvdXBJZF1bY29ubmVjdGlvbkZyb21Ob2RlSWRdID1cbiAgICAgICAgICAgIHt9O1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsR3JhcGgubGF5b3V0R3JhcGhFZGdlc1tjb21tb25Oc0dyb3VwSWRdW2Nvbm5lY3Rpb25Gcm9tTm9kZUlkXVtcbiAgICAgICAgICBjb25uZWN0aW9uVG9Ob2RlSWRcbiAgICAgICAgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRnb2luZ0VkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtlZGdlLnRhcmdldE5vZGVJZF0gYXMgT3BOb2RlO1xuICAgICAgICBxdWV1ZS5wdXNoKHRhcmdldE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBncm91cCBub2RlcyB3aXRoIGEgbGFyZ2UgbnVtYmVyIG9mIGNoaWxkcmVuLCBhbmQgc3BsaXRzIHRoZW0gaW50b1xuICAgKiBkaWZmZXJlbnQgZ3JvdXBzXG4gICAqL1xuICBzcGxpdExhcmdlR3JvdXBOb2Rlcyhtb2RlbEdyYXBoOiBNb2RlbEdyYXBoKSB7XG4gICAgLy8gRnJvbSByb290LCBkbyBhIEJGUyBzZWFyY2ggb24gYWxsIGdyb3VwIG5vZGVzLlxuICAgIGNvbnN0IHF1ZXVlOiBBcnJheTxHcm91cE5vZGUgfCB1bmRlZmluZWQ+ID0gW3VuZGVmaW5lZF07XG4gICAgbGV0IGhhc0xhcmdlR3JvdXBOb2RlcyA9IGZhbHNlO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJHcm91cE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgbGV0IGNoaWxkcmVuOiBNb2RlbE5vZGVbXSA9XG4gICAgICAgIGN1ckdyb3VwTm9kZSA9PSBudWxsXG4gICAgICAgICAgPyBtb2RlbEdyYXBoLnJvb3ROb2Rlc1xuICAgICAgICAgIDogKGN1ckdyb3VwTm9kZS5uc0NoaWxkcmVuSWRzIHx8IFtdKS5tYXAoXG4gICAgICAgICAgICAgIChpZCkgPT4gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbaWRdLFxuICAgICAgICAgICAgKTtcblxuICAgICAgLy8gU3BsaXQgdGhlIGdyb3VwIG5vZGUgaWYgaXRzIGNoaWxkIGNvdW50IGlzIG92ZXIgdGhlIHRocmVzaG9sZC5cbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiB0aGlzLmdyb3VwTm9kZUNoaWxkcmVuQ291bnRUaHJlc2hvbGQpIHtcbiAgICAgICAgaGFzTGFyZ2VHcm91cE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbGF5b3V0R3JhcGggPSBnZXRMYXlvdXRHcmFwaChcbiAgICAgICAgICBjdXJHcm91cE5vZGU/LmlkIHx8ICcnLFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIG1vZGVsR3JhcGgsXG4gICAgICAgICAgdGhpcy5zaG93T25Ob2RlSXRlbVR5cGVzLFxuICAgICAgICAgIHRoaXMubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICAgICAgdGhpcy50ZXN0TW9kZSxcbiAgICAgICAgICAvLyBVc2UgZmFrZSBub2RlIHNpemUuXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBGaW5kIHJvb3Qgbm9kZXMgb2YgdGhlIGxheW91dCBncmFwaC5cbiAgICAgICAgY29uc3Qgcm9vdE5vZGVzOiBNb2RlbE5vZGVbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBPYmplY3Qua2V5cyhsYXlvdXRHcmFwaC5ub2RlcykpIHtcbiAgICAgICAgICBpZiAobGF5b3V0R3JhcGguaW5jb21pbmdFZGdlc1tub2RlSWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3ROb2Rlcy5wdXNoKG1vZGVsR3JhcGgubm9kZXNCeUlkW25vZGVJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIGEgREZTIGZyb20gdGhlIGxheW91dCBncmFwaCByb290IG5vZGVzLiBDcmVhdGUgYSBuZXcgZ3JvdXBcbiAgICAgICAgLy8gd2hlbmV2ZXIgdGhlIG5vZGUgY291bnRzIHJlYWNoZXMgdGhlIHRocmVzaG9sZC5cbiAgICAgICAgY29uc3QgZ3JvdXBzOiBNb2RlbE5vZGVbXVtdID0gW107XG4gICAgICAgIGxldCBjdXJHcm91cDogTW9kZWxOb2RlW10gPSBbXTtcbiAgICAgICAgY29uc3QgdmlzaXRlZE5vZGVJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgY29uc3QgdmlzaXQgPSAoY3VyTm9kZUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAodmlzaXRlZE5vZGVJZHMuaGFzKGN1ck5vZGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmlzaXRlZE5vZGVJZHMuYWRkKGN1ck5vZGVJZCk7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG1vZGVsR3JhcGgubm9kZXNCeUlkW2N1ck5vZGVJZF07XG4gICAgICAgICAgY3VyR3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAoY3VyR3JvdXAubGVuZ3RoID09PSB0aGlzLmdyb3VwTm9kZUNoaWxkcmVuQ291bnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGN1ckdyb3VwKTtcbiAgICAgICAgICAgIGN1ckdyb3VwID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBsYXlvdXRHcmFwaC5vdXRnb2luZ0VkZ2VzW25vZGUuaWRdIHx8IFtdKSB7XG4gICAgICAgICAgICB2aXNpdChjaGlsZElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgcm9vdE5vZGUgb2Ygcm9vdE5vZGVzKSB7XG4gICAgICAgICAgdmlzaXQocm9vdE5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJHcm91cC5sZW5ndGggPCB0aGlzLmdyb3VwTm9kZUNoaWxkcmVuQ291bnRUaHJlc2hvbGQgJiZcbiAgICAgICAgICBjdXJHcm91cC5sZW5ndGggPiAwXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3Vwcy5wdXNoKGN1ckdyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBncm91cCBub2RlIGZvciBlYWNoIGdyb3VwLlxuICAgICAgICBjb25zdCBuZXdHcm91cE5vZGVzOiBHcm91cE5vZGVbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBncm91cEluZGV4ID0gMDsgZ3JvdXBJbmRleCA8IGdyb3Vwcy5sZW5ndGg7IGdyb3VwSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGVzID0gZ3JvdXBzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5ld0dyb3VwTm9kZU5hbWVzcGFjZSA9XG4gICAgICAgICAgICBjdXJHcm91cE5vZGUgPT0gbnVsbFxuICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgIDogYCR7Y3VyR3JvdXBOb2RlLm5hbWVzcGFjZX0vJHtjdXJHcm91cE5vZGUubGFiZWx9YDtcbiAgICAgICAgICBjb25zdCBuZXdHcm91cE5vZGVMYWJlbCA9IGBzZWN0aW9uXyR7Z3JvdXBJbmRleCArIDF9X29mXyR7XG4gICAgICAgICAgICBncm91cHMubGVuZ3RoXG4gICAgICAgICAgfWA7XG4gICAgICAgICAgY29uc3QgbmV3R3JvdXBOb2RlSWQgPVxuICAgICAgICAgICAgY3VyR3JvdXBOb2RlID09IG51bGxcbiAgICAgICAgICAgICAgPyBgJHtuZXdHcm91cE5vZGVMYWJlbH1fX19ncm91cF9fX2BcbiAgICAgICAgICAgICAgOiBgJHtuZXdHcm91cE5vZGVOYW1lc3BhY2V9LyR7bmV3R3JvdXBOb2RlTGFiZWx9X19fZ3JvdXBfX19gO1xuICAgICAgICAgIGNvbnN0IG5ld0dyb3VwTm9kZTogR3JvdXBOb2RlID0ge1xuICAgICAgICAgICAgbm9kZVR5cGU6IE5vZGVUeXBlLkdST1VQX05PREUsXG4gICAgICAgICAgICBpZDogbmV3R3JvdXBOb2RlSWQsXG4gICAgICAgICAgICBsYWJlbDogbmV3R3JvdXBOb2RlTGFiZWwsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5ld0dyb3VwTm9kZU5hbWVzcGFjZSxcbiAgICAgICAgICAgIGxldmVsOiBuZXdHcm91cE5vZGVOYW1lc3BhY2Uuc3BsaXQoJy8nKS5maWx0ZXIoKGMpID0+IGMgIT09ICcnKVxuICAgICAgICAgICAgICAubGVuZ3RoLFxuICAgICAgICAgICAgbnNQYXJlbnRJZDogY3VyR3JvdXBOb2RlPy5pZCxcbiAgICAgICAgICAgIG5zQ2hpbGRyZW5JZHM6IG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCksXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBzZWN0aW9uQ29udGFpbmVyOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3R3JvdXBOb2Rlcy5wdXNoKG5ld0dyb3VwTm9kZSk7XG5cbiAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBncm91cCBub2RlIHRvIHRoZSBtb2RlbCBncmFwaC5cbiAgICAgICAgICBtb2RlbEdyYXBoLm5vZGVzLnB1c2gobmV3R3JvdXBOb2RlKTtcbiAgICAgICAgICBtb2RlbEdyYXBoLm5vZGVzQnlJZFtuZXdHcm91cE5vZGUuaWRdID0gbmV3R3JvdXBOb2RlO1xuICAgICAgICAgIGlmIChtb2RlbEdyYXBoLmFydGlmaWNpYWxHcm91cE5vZGVJZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgbW9kZWxHcmFwaC5hcnRpZmljaWFsR3JvdXBOb2RlSWRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsR3JhcGguYXJ0aWZpY2lhbEdyb3VwTm9kZUlkcy5wdXNoKG5ld0dyb3VwTm9kZS5pZCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5zIHBhcmVudCBmb3IgYWxsIG5vZGVzIGluIHRoZSBuZXcgZ3JvdXAuXG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBub2RlLm5zUGFyZW50SWQgPSBuZXdHcm91cE5vZGUuaWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBuYW1lc3BhY2Ugb2YgYWxsIG5vZGVzIGFuZCB0aGVpciBkZXNlbmRlbnRzIGluIHRoZSBuZXdcbiAgICAgICAgICAvLyBncm91cC5cbiAgICAgICAgICBjb25zdCBuZXdOYW1lc3BhY2VQYXJ0ID0gbmV3R3JvdXBOb2RlSWQucmVwbGFjZSgnX19fZ3JvdXBfX18nLCAnJyk7XG4gICAgICAgICAgY29uc3QgdXBkYXRlTmFtZXNwYWNlID0gKG5vZGU6IE1vZGVsTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkTmFtZXNwYWNlID0gbm9kZS5uYW1lc3BhY2U7XG4gICAgICAgICAgICBpZiAob2xkTmFtZXNwYWNlID09PSAnJykge1xuICAgICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IG5ld05hbWVzcGFjZVBhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY3VyR3JvdXBOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IGAke25ld05hbWVzcGFjZVBhcnR9LyR7bm9kZS5uYW1lc3BhY2V9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IChub2RlLm5zUGFyZW50SWQgfHwgJycpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAnX19fZ3JvdXBfX18nLFxuICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5sZXZlbCA9IG5vZGUubmFtZXNwYWNlXG4gICAgICAgICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT09ICcnKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNHcm91cE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyb3VwIG5vZGUgaWQgc2luY2UgaXRzIG5hbWVzcGFjZSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgICAgICBjb25zdCBvbGROb2RlSWQgPSBub2RlLmlkO1xuICAgICAgICAgICAgICBkZWxldGUgbW9kZWxHcmFwaC5ub2Rlc0J5SWRbbm9kZS5pZF07XG4gICAgICAgICAgICAgIG5vZGUuaWQgPSBgJHtub2RlLm5hbWVzcGFjZX0vJHtub2RlLmxhYmVsfV9fX2dyb3VwX19fYDtcbiAgICAgICAgICAgICAgbW9kZWxHcmFwaC5ub2Rlc0J5SWRbbm9kZS5pZF0gPSBub2RlO1xuXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBpdHMgcGFyZW50J3MgbnNDaGlsZHJlbiB0byB1c2UgdGhlIG5ldyBpZC5cbiAgICAgICAgICAgICAgaWYgKG5vZGUubnNQYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5zUGFyZW50ID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbXG4gICAgICAgICAgICAgICAgICBub2RlLm5zUGFyZW50SWRcbiAgICAgICAgICAgICAgICBdIGFzIEdyb3VwTm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IChuc1BhcmVudC5uc0NoaWxkcmVuSWRzIHx8IFtdKS5pbmRleE9mKG9sZE5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgIChuc1BhcmVudC5uc0NoaWxkcmVuSWRzIHx8IFtdKVtpbmRleF0gPSBub2RlLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgbnNDaGlsZElkIG9mIG5vZGUubnNDaGlsZHJlbklkcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG1vZGVsR3JhcGgubm9kZXNCeUlkW25zQ2hpbGRJZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaXRzIGNoaWxkcmVuJ3MgbnNQYXJlbnQgaWQuXG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGUubnNQYXJlbnRJZCA9IG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAvLyBCRlMuXG4gICAgICAgICAgICAgICAgICB1cGRhdGVOYW1lc3BhY2UoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgdXBkYXRlTmFtZXNwYWNlKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJHcm91cE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlcyBpbiB0aGUgY3VycmVudCBuZXcgZ3JvdXAgaWYgdGhleSBhcmUgaW4gdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIG5vZGUgbGlzdC5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vZGVsR3JhcGgucm9vdE5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxHcmFwaC5yb290Tm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBncm91cCBub2RlIHRvIHJvb3Qgbm9kZSBsaXN0IGlmIGl0cyBuYW1lc3BhY2UgaXNcbiAgICAgICAgICAgIC8vIGVtcHR5LlxuICAgICAgICAgICAgaWYgKG5ld0dyb3VwTm9kZS5uYW1lc3BhY2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgIG1vZGVsR3JhcGgucm9vdE5vZGVzLnB1c2gobmV3R3JvdXBOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZHJlbiA9IG5ld0dyb3VwTm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgY3VyR3JvcE5vZGUncyBuc0NoaWxkcmVuSWRzLlxuICAgICAgICBpZiAoY3VyR3JvdXBOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICBjdXJHcm91cE5vZGUubnNDaGlsZHJlbklkcyA9IG5ld0dyb3VwTm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChpc0dyb3VwTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNMYXJnZUdyb3VwTm9kZXMpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVMYXlvdXRHcmFwaENvbm5lY3Rpb25zKG1vZGVsR3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHBvcHVsYXRlRGVzY2VuZGFudHNBbmRDb3VudHMobW9kZWxHcmFwaDogTW9kZWxHcmFwaCkge1xuICAgIC8vIEZvciBlYWNoIGdyb3VwIG5vZGUsIGdhdGhlciBhbGwgaXRzIGRlc2NlbmRhbnQgbm9kZXMuXG4gICAgbGV0IG1pbk9wTm9kZUNvdW50ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgbWF4T3BOb2RlQ291bnQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG1vZGVsR3JhcGgubm9kZXMpIHtcbiAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBkZXNjZW5kYW50czogTW9kZWxOb2RlW10gPSBbXTtcbiAgICAgICAgdGhpcy5nYXRoZXJEZXNjZW5kYW50cyhtb2RlbEdyYXBoLCBub2RlLCBkZXNjZW5kYW50cyk7XG4gICAgICAgIG5vZGUuZGVzY2VuZGFudHNOb2RlSWRzID0gZGVzY2VuZGFudHMubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgbm9kZS5kZXNjZW5kYW50c09wTm9kZUlkcyA9IGRlc2NlbmRhbnRzXG4gICAgICAgICAgLmZpbHRlcigobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuT1BfTk9ERSlcbiAgICAgICAgICAubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgY29uc3Qgb3BOb2RlQ291bnQgPSAobm9kZS5kZXNjZW5kYW50c09wTm9kZUlkcyB8fCBbXSkubGVuZ3RoO1xuICAgICAgICBtaW5PcE5vZGVDb3VudCA9IE1hdGgubWluKG9wTm9kZUNvdW50LCBtaW5PcE5vZGVDb3VudCk7XG4gICAgICAgIG1heE9wTm9kZUNvdW50ID0gTWF0aC5tYXgob3BOb2RlQ291bnQsIG1heE9wTm9kZUNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZWxHcmFwaC5taW5EZXNjZW5kYW50T3BOb2RlQ291bnQgPSBtaW5PcE5vZGVDb3VudDtcbiAgICBtb2RlbEdyYXBoLm1heERlc2NlbmRhbnRPcE5vZGVDb3VudCA9IG1heE9wTm9kZUNvdW50O1xuICB9XG5cbiAgY3JlYXRlRW1wdHlNb2RlbEdyYXBoKCk6IE1vZGVsR3JhcGgge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5ncmFwaC5pZCxcbiAgICAgIGNvbGxlY3Rpb25MYWJlbDogdGhpcy5ncmFwaC5jb2xsZWN0aW9uTGFiZWwgfHwgJycsXG4gICAgICBub2RlczogW10sXG4gICAgICBub2Rlc0J5SWQ6IHt9LFxuICAgICAgcm9vdE5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzQnlHcm91cE5vZGVJZHM6IHt9LFxuICAgICAgbGF5b3V0R3JhcGhFZGdlczoge30sXG4gICAgICBtaW5EZXNjZW5kYW50T3BOb2RlQ291bnQ6IC0xLFxuICAgICAgbWF4RGVzY2VuZGFudE9wTm9kZUNvdW50OiAtMSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbmNlc3Rvck5hbWVzcGFjZXMobnM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBUaGUgcmV0dXJuZWQgbmFtZXNwYWNlcyBpbmNsdWRlIGBuc2AgYXMgd2VsbC5cbiAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5nZXROb25FbXB0eU5hbWVzcGFjZUNvbXBvbmVudHMobnMpO1xuICAgIGNvbnN0IG5hbWVzcGFjZXM6IHN0cmluZ1tdID0gW107XG4gICAgd2hpbGUgKGNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgbmFtZXNwYWNlcy5wdXNoKGNvbXBvbmVudHMuam9pbignLycpKTtcbiAgICAgIGNvbXBvbmVudHMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2VzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXROb25FbXB0eU5hbWVzcGFjZUNvbXBvbmVudHMobnM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gbnMuc3BsaXQoJy8nKS5maWx0ZXIoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50ICE9PSAnJyk7XG4gIH1cblxuICBwcml2YXRlIGdldEdyb3VwTm9kZUlkRnJvbU5hbWVzcGFjZShuczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7bnN9X19fZ3JvdXBfX19gO1xuICB9XG5cbiAgcHJpdmF0ZSBnYXRoZXJEZXNjZW5kYW50cyhcbiAgICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuICAgIGN1clJvb3Q6IEdyb3VwTm9kZSxcbiAgICBkZXNjZW5kYW50czogTW9kZWxOb2RlW10sXG4gICkge1xuICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBjdXJSb290Lm5zQ2hpbGRyZW5JZHMgfHwgW10pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbY2hpbGRJZF07XG4gICAgICBpZiAoaXNHcm91cE5vZGUoY2hpbGQpIHx8IChpc09wTm9kZShjaGlsZCkgJiYgIWNoaWxkLmhpZGVJbkxheW91dCkpIHtcbiAgICAgICAgZGVzY2VuZGFudHMucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNHcm91cE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHRoaXMuZ2F0aGVyRGVzY2VuZGFudHMobW9kZWxHcmFwaCwgY2hpbGQsIGRlc2NlbmRhbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NBdHRyVmFsdWUoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFByb2Nlc3MgY29uc3QgdmFsdWUgdGhhdCBpbiBgZGVuc2U8Li4uPmAgZm9ybWF0LiBUaGlzIGlzIGZvciBiYWNrd2FyZFxuICAgIC8vIGNvbXBhdGliaWxpdHkuXG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ2RlbnNlPCcpKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goQ09OU1RfVkFMVUVfUkVHRVgpO1xuICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RyVGVuc29yVmFsdWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICByZXR1cm4gZm9ybWF0VGVuc29yVmFsdWVzKHN0clRlbnNvclZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJvY2VzcyB0ZW5zb3IgdmFsdWVzLlxuICAgIGVsc2UgaWYgKGtleSA9PT0gVEVOU09SX1ZBTFVFU19LRVkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRUZW5zb3JWYWx1ZXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgnXCInLCAnJykgfHwgJzxlbXB0eT4nO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzTWV0YWRhdGFMaXN0KG1ldGFkYXRhSXRlbXM6IE1ldGFkYXRhSXRlbVtdKSB7XG4gICAgY29uc3QgbWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIEtleVZhbHVlUGFpcnM+ID0ge307XG4gICAgZm9yIChjb25zdCBtZXRhZGF0YUl0ZW0gb2YgbWV0YWRhdGFJdGVtcykge1xuICAgICAgY29uc3QgYXR0cnM6IEtleVZhbHVlUGFpcnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBtZXRhZGF0YUl0ZW0uYXR0cnMpIHtcbiAgICAgICAgbGV0IGtleSA9IGF0dHIua2V5O1xuICAgICAgICBsZXQgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5ncy5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3RlbnNvcl9zaGFwZScpIHtcbiAgICAgICAgICBrZXkgPSAnc2hhcGUnO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKCd0ZW5zb3I8JywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgnPicsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyonLCAn4oiXJylcbiAgICAgICAgICAgIC5zcGxpdCgneCcpXG4gICAgICAgICAgICAuam9pbignIHggJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbWV0YWRhdGFbbWV0YWRhdGFJdGVtLmlkXSA9IGF0dHJzO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBnaXZlbiB0ZW5zb3IgdmFsdWVzIHN0cmluZy5cbiAqXG4gKiBUaGUgZ2l2ZW4gc3RyaW5nIGlzIGluIHRoZSBmb3JtIG9mOlxuICogW1tbMSwgMl0sIFszLCA0XV1dXG4gKlxuICogQW5kIHdlIHdhbnQgdG8gZm9ybWF0IGl0IHRvOlxuICogW1xuICogICBbXG4gKiAgICAgW1xuICogICAgICAgMSxcbiAqICAgICAgIDJcbiAqICAgICBdLFxuICogICAgIFtcbiAqICAgICAgIDMsXG4gKiAgICAgICA0XG4gKiAgICAgXVxuICogICBdXG4gKiBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUZW5zb3JWYWx1ZXMoc3RyVmFsdWVzOiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKHN0clZhbHVlcyksIG51bGwsIDIpXG4gICAgICAucmVwbGFjZUFsbCgnXFxcXG4nLCAnXFxuJylcbiAgICAgIC50cmltKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gc3RyVmFsdWVzO1xuICB9XG59XG4iXX0=
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/identical_groups_finder.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/identical_groups_finder.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.identical_groups_finder');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/identical_groups_finder.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_model_graph_1 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_utils_2 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils");
const utils_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
/** @type {number} */
const BIG_PRIME = 10000019;
/**
 * Finds identical subgraphs using hash.
 *
 * TODO(jingjin): add tests.
 */
class IdenticalGroupsFinder {
    /**
     * @public
     * @param {!tsickle_model_graph_1.ModelGraph} modelGraph
     */
    constructor(modelGraph) {
        this.modelGraph = modelGraph;
    }
    /**
     * @public
     * @return {void}
     */
    markIdenticalGroups() {
        // From group hash to a list of group nodes with that hash.
        /** @type {!Object<number,!Array<!tsickle_model_graph_1.GroupNode>>} */
        const identicalGroups = {};
        for (const node of this.modelGraph.nodes) {
            if (!(0, utils_1.isGroupNode)(node)) {
                continue;
            }
            /** @type {number} */
            let hash = 0;
            // Add hashes for nodes.
            //
            // Only consider nodes that are not hidden in layout.
            /** @type {!Array<!tsickle_model_graph_1.OpNode>} */
            const opNodes = (/** @type {!Array<!tsickle_model_graph_1.OpNode>} */ (((/** @type {!tsickle_model_graph_1.GroupNode} */ (node)).descendantsOpNodeIds || [])
                .map((/**
             * @param {string} id
             * @return {(!tsickle_model_graph_1.GroupNode|!tsickle_model_graph_1.OpNode)}
             */
            (id) => this.modelGraph.nodesById[id]))
                .filter((/**
             * @param {(!tsickle_model_graph_1.GroupNode|!tsickle_model_graph_1.OpNode)} node
             * @return {boolean}
             */
            (node) => !((/** @type {!tsickle_model_graph_1.OpNode} */ (node))).hideInLayout))));
            /** @type {!Set<string>} */
            const opNodeIdsSet = new Set(opNodes.map((/**
             * @param {!tsickle_model_graph_1.OpNode} node
             * @return {string}
             */
            (node) => node.id)));
            for (const opNode of opNodes) {
                hash = (hash + this.getNodeHash(opNode, opNodeIdsSet)) % BIG_PRIME;
            }
            // Add hashes for edges.
            //
            // Only consider edges within the subgraph.
            for (const opNode of opNodes) {
                for (const edge of opNode.outgoingEdges || []) {
                    /** @type {string} */
                    const targetNodeId = edge.targetNodeId;
                    if (!opNodeIdsSet.has(targetNodeId)) {
                        continue;
                    }
                    /** @type {!tsickle_model_graph_1.OpNode} */
                    const targetNode = (/** @type {!tsickle_model_graph_1.OpNode} */ (this.modelGraph.nodesById[targetNodeId]));
                    hash = (hash + this.getEdgeHash(opNode, targetNode)) % BIG_PRIME;
                }
            }
            if (!identicalGroups[hash]) {
                identicalGroups[hash] = [];
            }
            identicalGroups[hash].push(node);
        }
        /** @type {number} */
        let identicalGroupIndex = 0;
        for (const groups of Object.values(identicalGroups)) {
            // Ignore groups with a single group node.
            if (groups.length <= 1) {
                continue;
            }
            // Ignore groups where group nodes only have one single op node.
            //
            // Re-enable this if needed.
            // if ((groups[0].descendantsOpNodeIds || []).length <= 1) {
            //   continue;
            // }
            // Ignore groups where there are only group nodes and one group node is
            // the NS parent of the other.
            if (groups.length === 2) {
                if (groups[0].nsParentId === groups[1].id ||
                    groups[1].nsParentId === groups[0].id) {
                    continue;
                }
            }
            for (const groupNode of groups) {
                groupNode.identicalGroupIndex = identicalGroupIndex;
            }
            identicalGroupIndex++;
        }
    }
    /**
     * @private
     * @param {!tsickle_model_graph_1.OpNode} opNode
     * @param {!Set<string>} allowedOpNodeIds
     * @return {number}
     */
    getNodeHash(opNode, allowedOpNodeIds) {
        /** @type {number} */
        let hash = 0;
        // Op.
        hash = this.addToHash(hash, opNode.label);
        // Incoming nodes.
        //
        // Limit the sources of its incoming edges among the nodes within the group.
        /** @type {number} */
        let incomingEdgeCount = 0;
        for (const edge of opNode.incomingEdges || []) {
            /** @type {string} */
            const sourceNodeId = edge.sourceNodeId;
            if (allowedOpNodeIds.has(sourceNodeId)) {
                /** @type {!tsickle_model_graph_1.OpNode} */
                const sourceNode = (/** @type {!tsickle_model_graph_1.OpNode} */ (this.modelGraph.nodesById[sourceNodeId]));
                hash = this.addToHash(hash, `in ${sourceNode.label}`);
                incomingEdgeCount++;
            }
        }
        // Outputing nodes.
        //
        // Limit the targets of its outgoing edges among the nodes within the group.
        /** @type {number} */
        let outgoingEdgeCount = 0;
        for (const edge of opNode.outgoingEdges || []) {
            /** @type {string} */
            const targetNodeId = edge.targetNodeInputId;
            if (allowedOpNodeIds.has(targetNodeId)) {
                /** @type {!tsickle_model_graph_1.OpNode} */
                const targetNode = (/** @type {!tsickle_model_graph_1.OpNode} */ (this.modelGraph.nodesById[targetNodeId]));
                hash = this.addToHash(hash, `out ${targetNode.label}`);
                outgoingEdgeCount++;
            }
        }
        // Incoming and outgoing edge count.
        hash = this.addToHash(hash, `${incomingEdgeCount}`);
        hash = this.addToHash(hash, `${outgoingEdgeCount}`);
        return hash;
    }
    /**
     * @private
     * @param {!tsickle_model_graph_1.OpNode} fromNode
     * @param {!tsickle_model_graph_1.OpNode} toNode
     * @return {number}
     */
    getEdgeHash(fromNode, toNode) {
        return this.genHash(fromNode.label + toNode.label) % BIG_PRIME;
    }
    /**
     * @private
     * @param {(undefined|string)} str
     * @return {number}
     */
    genHash(str) {
        /** @type {number} */
        let hash = 5381;
        str = str || '';
        for (let i = 0, len = str.length; i < len; i++) {
            hash += (hash << 5) + str.charCodeAt(i);
        }
        return hash & 0x7fffffff;
    }
    /**
     * @private
     * @param {number} hash
     * @param {(undefined|string)} str
     * @return {number}
     */
    addToHash(hash, str) {
        return (hash + this.genHash(str)) % BIG_PRIME;
    }
}
exports.IdenticalGroupsFinder = IdenticalGroupsFinder;
/* istanbul ignore if */
if (false) {
    /**
     * @const {!tsickle_model_graph_1.ModelGraph}
     * @private
     */
    IdenticalGroupsFinder.prototype.modelGraph;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlbnRpY2FsX2dyb3Vwc19maW5kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9sZWFybmluZy9icmFpbi9tb2JpbGUvbGl0ZS90b29saW5nL21vZGVsX2dyYXBoX3Zpc3VhbGl6ZXIvbW9kdWxlL3dvcmtlci9pZGVudGljYWxfZ3JvdXBzX2ZpbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxzSEFBNEM7O01BRXRDLFNBQVMsR0FBRyxRQUFROzs7Ozs7QUFPMUIsTUFBYSxxQkFBcUI7Ozs7O0lBQ2hDLFlBQTZCLFVBQXNCO1FBQXRCLGVBQVUsR0FBVixVQUFVLENBQVk7SUFBRyxDQUFDOzs7OztJQUV2RCxtQkFBbUI7OztjQUVYLGVBQWUsR0FBa0MsRUFBRTtRQUN6RCxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDekMsSUFBSSxDQUFDLElBQUEsbUJBQVcsRUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN2QixTQUFTO1lBQ1gsQ0FBQzs7Z0JBRUcsSUFBSSxHQUFHLENBQUM7Ozs7O2tCQUtOLE9BQU8sR0FBRyx1REFBQSxDQUFDLGtEQUFBLElBQUksRUFBQSxDQUFDLG9CQUFvQixJQUFJLEVBQUUsQ0FBQztpQkFDOUMsR0FBRzs7OztZQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBQztpQkFDMUMsTUFBTTs7OztZQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsK0NBQUEsSUFBSSxFQUFVLENBQUMsQ0FBQyxZQUFZLEVBQUMsRUFBWTs7a0JBQ3pELFlBQVksR0FBRyxJQUFJLEdBQUcsQ0FBUyxPQUFPLENBQUMsR0FBRzs7OztZQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUs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Q0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvQyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDO1FBQ0QsT0FBTyxJQUFJLEdBQUcsVUFBVSxDQUFDO0lBQzNCLENBQUM7Ozs7Ozs7SUFFTyxTQUFTLENBQUMsSUFBWSxFQUFFLEdBQXVCO1FBQ3JELE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUNoRCxDQUFDO0NBQ0Y7QUFuSUQsc0RBbUlDOzs7Ozs7O0lBbElhLDJDQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7R3JvdXBOb2RlLCBNb2RlbEdyYXBoLCBPcE5vZGV9IGZyb20gJy4uL2NvbW1vbi9tb2RlbF9ncmFwaCc7XG5pbXBvcnQge2lzR3JvdXBOb2RlfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuXG5jb25zdCBCSUdfUFJJTUUgPSAxMDAwMDAxOTtcblxuLyoqXG4gKiBGaW5kcyBpZGVudGljYWwgc3ViZ3JhcGhzIHVzaW5nIGhhc2guXG4gKlxuICogVE9ETyhqaW5namluKTogYWRkIHRlc3RzLlxuICovXG5leHBvcnQgY2xhc3MgSWRlbnRpY2FsR3JvdXBzRmluZGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoKSB7fVxuXG4gIG1hcmtJZGVudGljYWxHcm91cHMoKSB7XG4gICAgLy8gRnJvbSBncm91cCBoYXNoIHRvIGEgbGlzdCBvZiBncm91cCBub2RlcyB3aXRoIHRoYXQgaGFzaC5cbiAgICBjb25zdCBpZGVudGljYWxHcm91cHM6IHtbaGFzaDogbnVtYmVyXTogR3JvdXBOb2RlW119ID0ge307XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubW9kZWxHcmFwaC5ub2Rlcykge1xuICAgICAgaWYgKCFpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGhhc2ggPSAwO1xuXG4gICAgICAvLyBBZGQgaGFzaGVzIGZvciBub2Rlcy5cbiAgICAgIC8vXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIG5vZGVzIHRoYXQgYXJlIG5vdCBoaWRkZW4gaW4gbGF5b3V0LlxuICAgICAgY29uc3Qgb3BOb2RlcyA9IChub2RlLmRlc2NlbmRhbnRzT3BOb2RlSWRzIHx8IFtdKVxuICAgICAgICAubWFwKChpZCkgPT4gdGhpcy5tb2RlbEdyYXBoLm5vZGVzQnlJZFtpZF0pXG4gICAgICAgIC5maWx0ZXIoKG5vZGUpID0+ICEobm9kZSBhcyBPcE5vZGUpLmhpZGVJbkxheW91dCkgYXMgT3BOb2RlW107XG4gICAgICBjb25zdCBvcE5vZGVJZHNTZXQgPSBuZXcgU2V0PHN0cmluZz4ob3BOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICAgIGZvciAoY29uc3Qgb3BOb2RlIG9mIG9wTm9kZXMpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoICsgdGhpcy5nZXROb2RlSGFzaChvcE5vZGUsIG9wTm9kZUlkc1NldCkpICUgQklHX1BSSU1FO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgaGFzaGVzIGZvciBlZGdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIGVkZ2VzIHdpdGhpbiB0aGUgc3ViZ3JhcGguXG4gICAgICBmb3IgKGNvbnN0IG9wTm9kZSBvZiBvcE5vZGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBvcE5vZGUub3V0Z29pbmdFZGdlcyB8fCBbXSkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGVJZCA9IGVkZ2UudGFyZ2V0Tm9kZUlkO1xuICAgICAgICAgIGlmICghb3BOb2RlSWRzU2V0Lmhhcyh0YXJnZXROb2RlSWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMubW9kZWxHcmFwaC5ub2Rlc0J5SWRbdGFyZ2V0Tm9kZUlkXSBhcyBPcE5vZGU7XG4gICAgICAgICAgaGFzaCA9IChoYXNoICsgdGhpcy5nZXRFZGdlSGFzaChvcE5vZGUsIHRhcmdldE5vZGUpKSAlIEJJR19QUklNRTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlkZW50aWNhbEdyb3Vwc1toYXNoXSkge1xuICAgICAgICBpZGVudGljYWxHcm91cHNbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGlkZW50aWNhbEdyb3Vwc1toYXNoXS5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIGxldCBpZGVudGljYWxHcm91cEluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGdyb3VwcyBvZiBPYmplY3QudmFsdWVzKGlkZW50aWNhbEdyb3VwcykpIHtcbiAgICAgIC8vIElnbm9yZSBncm91cHMgd2l0aCBhIHNpbmdsZSBncm91cCBub2RlLlxuICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPD0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIGdyb3VwcyB3aGVyZSBncm91cCBub2RlcyBvbmx5IGhhdmUgb25lIHNpbmdsZSBvcCBub2RlLlxuICAgICAgLy9cbiAgICAgIC8vIFJlLWVuYWJsZSB0aGlzIGlmIG5lZWRlZC5cbiAgICAgIC8vIGlmICgoZ3JvdXBzWzBdLmRlc2NlbmRhbnRzT3BOb2RlSWRzIHx8IFtdKS5sZW5ndGggPD0gMSkge1xuICAgICAgLy8gICBjb250aW51ZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gSWdub3JlIGdyb3VwcyB3aGVyZSB0aGVyZSBhcmUgb25seSBncm91cCBub2RlcyBhbmQgb25lIGdyb3VwIG5vZGUgaXNcbiAgICAgIC8vIHRoZSBOUyBwYXJlbnQgb2YgdGhlIG90aGVyLlxuICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGdyb3Vwc1swXS5uc1BhcmVudElkID09PSBncm91cHNbMV0uaWQgfHxcbiAgICAgICAgICBncm91cHNbMV0ubnNQYXJlbnRJZCA9PT0gZ3JvdXBzWzBdLmlkXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZ3JvdXBOb2RlIG9mIGdyb3Vwcykge1xuICAgICAgICBncm91cE5vZGUuaWRlbnRpY2FsR3JvdXBJbmRleCA9IGlkZW50aWNhbEdyb3VwSW5kZXg7XG4gICAgICB9XG4gICAgICBpZGVudGljYWxHcm91cEluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXROb2RlSGFzaChvcE5vZGU6IE9wTm9kZSwgYWxsb3dlZE9wTm9kZUlkczogU2V0PHN0cmluZz4pOiBudW1iZXIge1xuICAgIGxldCBoYXNoID0gMDtcblxuICAgIC8vIE9wLlxuICAgIGhhc2ggPSB0aGlzLmFkZFRvSGFzaChoYXNoLCBvcE5vZGUubGFiZWwpO1xuXG4gICAgLy8gSW5jb21pbmcgbm9kZXMuXG4gICAgLy9cbiAgICAvLyBMaW1pdCB0aGUgc291cmNlcyBvZiBpdHMgaW5jb21pbmcgZWRnZXMgYW1vbmcgdGhlIG5vZGVzIHdpdGhpbiB0aGUgZ3JvdXAuXG4gICAgbGV0IGluY29taW5nRWRnZUNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3BOb2RlLmluY29taW5nRWRnZXMgfHwgW10pIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5vZGVJZCA9IGVkZ2Uuc291cmNlTm9kZUlkO1xuICAgICAgaWYgKGFsbG93ZWRPcE5vZGVJZHMuaGFzKHNvdXJjZU5vZGVJZCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHRoaXMubW9kZWxHcmFwaC5ub2Rlc0J5SWRbc291cmNlTm9kZUlkXSBhcyBPcE5vZGU7XG4gICAgICAgIGhhc2ggPSB0aGlzLmFkZFRvSGFzaChoYXNoLCBgaW4gJHtzb3VyY2VOb2RlLmxhYmVsfWApO1xuICAgICAgICBpbmNvbWluZ0VkZ2VDb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE91dHB1dGluZyBub2Rlcy5cbiAgICAvL1xuICAgIC8vIExpbWl0IHRoZSB0YXJnZXRzIG9mIGl0cyBvdXRnb2luZyBlZGdlcyBhbW9uZyB0aGUgbm9kZXMgd2l0aGluIHRoZSBncm91cC5cbiAgICBsZXQgb3V0Z29pbmdFZGdlQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvcE5vZGUub3V0Z29pbmdFZGdlcyB8fCBbXSkge1xuICAgICAgY29uc3QgdGFyZ2V0Tm9kZUlkID0gZWRnZS50YXJnZXROb2RlSW5wdXRJZDtcbiAgICAgIGlmIChhbGxvd2VkT3BOb2RlSWRzLmhhcyh0YXJnZXROb2RlSWQpKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLm1vZGVsR3JhcGgubm9kZXNCeUlkW3RhcmdldE5vZGVJZF0gYXMgT3BOb2RlO1xuICAgICAgICBoYXNoID0gdGhpcy5hZGRUb0hhc2goaGFzaCwgYG91dCAke3RhcmdldE5vZGUubGFiZWx9YCk7XG4gICAgICAgIG91dGdvaW5nRWRnZUNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5jb21pbmcgYW5kIG91dGdvaW5nIGVkZ2UgY291bnQuXG4gICAgaGFzaCA9IHRoaXMuYWRkVG9IYXNoKGhhc2gsIGAke2luY29taW5nRWRnZUNvdW50fWApO1xuICAgIGhhc2ggPSB0aGlzLmFkZFRvSGFzaChoYXNoLCBgJHtvdXRnb2luZ0VkZ2VDb3VudH1gKTtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RWRnZUhhc2goZnJvbU5vZGU6IE9wTm9kZSwgdG9Ob2RlOiBPcE5vZGUpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdlbkhhc2goZnJvbU5vZGUubGFiZWwgKyB0b05vZGUubGFiZWwpICUgQklHX1BSSU1FO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5IYXNoKHN0cjogc3RyaW5nIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgc3RyID0gc3RyIHx8ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaGFzaCArPSAoaGFzaCA8PCA1KSArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCAmIDB4N2ZmZmZmZmY7XG4gIH1cblxuICBwcml2YXRlIGFkZFRvSGFzaChoYXNoOiBudW1iZXIsIHN0cjogc3RyaW5nIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKGhhc2ggKyB0aGlzLmdlbkhhc2goc3RyKSkgJSBCSUdfUFJJTUU7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/sensitive_attributes.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
// AUTOGENERATED. DO NOT EDIT.
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/sensitive_attributes.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.sensitive_attributes');
var module = module || { id: 'third_party/javascript/safevalues/builders/sensitive_attributes.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Security sensitive attribute names that should not be set through
 * `setAttribute` or similar functions.
 * @type {!Array<?>}
 */
exports.SECURITY_SENSITIVE_ATTRIBUTES = (/** @type {!Array<?>} */ ([
    'src',
    'srcdoc',
    'codebase',
    'data',
    'href',
    'rel',
    'action',
    'formaction',
    'sandbox',
    'cite',
    'poster',
    'icon',
]));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Vuc2l0aXZlX2F0dHJpYnV0ZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvc2Vuc2l0aXZlX2F0dHJpYnV0ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXYSxRQUFBLDZCQUE2QixHQUFHLDJCQUFBO0lBQzNDLEtBQUs7SUFDTCxRQUFRO0lBQ1IsVUFBVTtJQUNWLE1BQU07SUFDTixNQUFNO0lBQ04sS0FBSztJQUNMLFFBQVE7SUFDUixZQUFZO0lBQ1osU0FBUztJQUNULE1BQU07SUFDTixRQUFRO0lBQ1IsTUFBTTtDQUNQLEVBQVMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8vIEFVVE9HRU5FUkFURUQuIERPIE5PVCBFRElULlxuXG4vKipcbiAqIFNlY3VyaXR5IHNlbnNpdGl2ZSBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzaG91bGQgbm90IGJlIHNldCB0aHJvdWdoXG4gKiBgc2V0QXR0cmlidXRlYCBvciBzaW1pbGFyIGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNvbnN0IFNFQ1VSSVRZX1NFTlNJVElWRV9BVFRSSUJVVEVTID0gW1xuICAnc3JjJyxcbiAgJ3NyY2RvYycsXG4gICdjb2RlYmFzZScsXG4gICdkYXRhJyxcbiAgJ2hyZWYnLFxuICAncmVsJyxcbiAgJ2FjdGlvbicsXG4gICdmb3JtYWN0aW9uJyxcbiAgJ3NhbmRib3gnLFxuICAnY2l0ZScsXG4gICdwb3N0ZXInLFxuICAnaWNvbicsXG5dIGFzIGNvbnN0O1xuIl19
;return exports;});

//third_party/javascript/safevalues/builders/attribute_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/attribute_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.attribute_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/attribute_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_attribute_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.attribute_impl");
const tsickle_string_literal_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_sensitive_attributes_4 = goog.requireType("google3.third_party.javascript.safevalues.builders.sensitive_attributes");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const attribute_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.attribute_impl');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
const sensitive_attributes_1 = goog.require('google3.third_party.javascript.safevalues.builders.sensitive_attributes');
/**
 * Creates a SafeAttributePrefix object from a template literal with no
 * interpolations for attributes that share a common prefix guaranteed to be not
 * security sensitive.
 *
 * The template literal is a prefix that makes it obvious this attribute is not
 * security sensitive. If it doesn't, this function will throw.
 * @param {!TemplateStringsArray} templ
 * @return {!tsickle_attribute_impl_2.SafeAttributePrefix}
 */
function safeAttrPrefix(templ) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templ, 0);
    }
    /** @type {string} */
    const attrPrefix = templ[0].toLowerCase();
    if (dev_1.DEV_MODE) {
        if (attrPrefix.indexOf('on') === 0 || 'on'.indexOf(attrPrefix) === 0) {
            throw new Error(`Prefix '${templ[0]}' does not guarantee the attribute ` +
                `to be safe as it is also a prefix for event handler attributes` +
                `Please use 'addEventListener' to set event handlers.`);
        }
        sensitive_attributes_1.SECURITY_SENSITIVE_ATTRIBUTES.forEach((/**
         * @param {string} sensitiveAttr
         * @return {void}
         */
        (sensitiveAttr) => {
            if (sensitiveAttr.indexOf(attrPrefix) === 0) {
                throw new Error(`Prefix '${templ[0]}' does not guarantee the attribute ` +
                    `to be safe as it is also a prefix for ` +
                    `the security sensitive attribute '${sensitiveAttr}'. ` +
                    `Please use native or safe DOM APIs to set the attribute.`);
            }
        }));
    }
    return (0, attribute_impl_1.createAttributePrefixInternal)(attrPrefix);
}
exports.safeAttrPrefix = safeAttrPrefix;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXR0cmlidXRlX2J1aWxkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2J1aWxkZXJzL2F0dHJpYnV0ZV9idWlsZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx3RkFBNEM7QUFDNUMsNEdBR3FDO0FBQ3JDLDRHQUFtRTtBQUVuRSx1SEFBcUU7Ozs7Ozs7Ozs7O0FBVXJFLFNBQWdCLGNBQWMsQ0FDNUIsS0FBMkI7SUFFM0IsSUFBSSxjQUFRLEVBQUUsQ0FBQztRQUNiLElBQUEsdUNBQXNCLEVBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7O1VBRUssVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUU7SUFFekMsSUFBSSxjQUFRLEVBQUUsQ0FBQztRQUNiLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNyRSxNQUFNLElBQUksS0FBSyxDQUNiLFdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7Z0JBQ3RELGdFQUFnRTtnQkFDaEUsc0RBQXNELENBQ3pELENBQUM7UUFDSixDQUFDO1FBRUQsb0RBQTZCLENBQUMsT0FBTzs7OztRQUFDLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDdEQsSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUM1QyxNQUFNLElBQUksS0FBSyxDQUNiLFdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7b0JBQ3RELHdDQUF3QztvQkFDeEMscUNBQXFDLGFBQWEsS0FBSztvQkFDdkQsMERBQTBELENBQzdELENBQUM7WUFDSixDQUFDO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsT0FBTyxJQUFBLDhDQUE2QixFQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUEvQkQsd0NBK0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi9lbnZpcm9ubWVudC9kZXYnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQXR0cmlidXRlUHJlZml4SW50ZXJuYWwsXG4gIFNhZmVBdHRyaWJ1dGVQcmVmaXgsXG59IGZyb20gJy4uL2ludGVybmFscy9hdHRyaWJ1dGVfaW1wbCc7XG5pbXBvcnQge2Fzc2VydElzVGVtcGxhdGVPYmplY3R9IGZyb20gJy4uL2ludGVybmFscy9zdHJpbmdfbGl0ZXJhbCc7XG5cbmltcG9ydCB7U0VDVVJJVFlfU0VOU0lUSVZFX0FUVFJJQlVURVN9IGZyb20gJy4vc2Vuc2l0aXZlX2F0dHJpYnV0ZXMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlQXR0cmlidXRlUHJlZml4IG9iamVjdCBmcm9tIGEgdGVtcGxhdGUgbGl0ZXJhbCB3aXRoIG5vXG4gKiBpbnRlcnBvbGF0aW9ucyBmb3IgYXR0cmlidXRlcyB0aGF0IHNoYXJlIGEgY29tbW9uIHByZWZpeCBndWFyYW50ZWVkIHRvIGJlIG5vdFxuICogc2VjdXJpdHkgc2Vuc2l0aXZlLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBsaXRlcmFsIGlzIGEgcHJlZml4IHRoYXQgbWFrZXMgaXQgb2J2aW91cyB0aGlzIGF0dHJpYnV0ZSBpcyBub3RcbiAqIHNlY3VyaXR5IHNlbnNpdGl2ZS4gSWYgaXQgZG9lc24ndCwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZUF0dHJQcmVmaXgoXG4gIHRlbXBsOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSxcbik6IFNhZmVBdHRyaWJ1dGVQcmVmaXgge1xuICBpZiAoREVWX01PREUpIHtcbiAgICBhc3NlcnRJc1RlbXBsYXRlT2JqZWN0KHRlbXBsLCAwKTtcbiAgfVxuXG4gIGNvbnN0IGF0dHJQcmVmaXggPSB0ZW1wbFswXS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChERVZfTU9ERSkge1xuICAgIGlmIChhdHRyUHJlZml4LmluZGV4T2YoJ29uJykgPT09IDAgfHwgJ29uJy5pbmRleE9mKGF0dHJQcmVmaXgpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcmVmaXggJyR7dGVtcGxbMF19JyBkb2VzIG5vdCBndWFyYW50ZWUgdGhlIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICBgdG8gYmUgc2FmZSBhcyBpdCBpcyBhbHNvIGEgcHJlZml4IGZvciBldmVudCBoYW5kbGVyIGF0dHJpYnV0ZXNgICtcbiAgICAgICAgICBgUGxlYXNlIHVzZSAnYWRkRXZlbnRMaXN0ZW5lcicgdG8gc2V0IGV2ZW50IGhhbmRsZXJzLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIFNFQ1VSSVRZX1NFTlNJVElWRV9BVFRSSUJVVEVTLmZvckVhY2goKHNlbnNpdGl2ZUF0dHIpID0+IHtcbiAgICAgIGlmIChzZW5zaXRpdmVBdHRyLmluZGV4T2YoYXR0clByZWZpeCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQcmVmaXggJyR7dGVtcGxbMF19JyBkb2VzIG5vdCBndWFyYW50ZWUgdGhlIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgIGB0byBiZSBzYWZlIGFzIGl0IGlzIGFsc28gYSBwcmVmaXggZm9yIGAgK1xuICAgICAgICAgICAgYHRoZSBzZWN1cml0eSBzZW5zaXRpdmUgYXR0cmlidXRlICcke3NlbnNpdGl2ZUF0dHJ9Jy4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIHVzZSBuYXRpdmUgb3Igc2FmZSBET00gQVBJcyB0byBzZXQgdGhlIGF0dHJpYnV0ZS5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVByZWZpeEludGVybmFsKGF0dHJQcmVmaXgpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/builders/document_fragment_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/document_fragment_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.document_fragment_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/document_fragment_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_string_literal_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_SafeHtml_4 = goog.requireType("goog.html.SafeHtml");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
/**
 * Creates a DocumentFragment object from a template literal (without any
 * embedded expressions) using the document context (HTML).
 *
 * Note: use svgFragment instead to create a DocumentFragment belonging to the
 * SVG namespace.
 *
 * This function is a template literal tag function. It should be called with
 * a template literal that does not contain any expressions. For example,
 *                           htmlFragment`foo`;
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @return {!DocumentFragment}
 */
function htmlFragment(templateObj) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, 0);
    }
    /** @type {!Range} */
    const range = document.createRange();
    return range.createContextualFragment((/** @type {string} */ ((0, html_impl_1.unwrapHtml)((0, html_impl_1.createHtmlInternal)(templateObj[0])))));
}
exports.htmlFragment = htmlFragment;
/**
 * Creates a DocumentFragment object from a template literal (without any
 * embedded expressions), with an SVG context.
 *
 * This function is a template literal tag function. It should be called with
 * a template literal that does not contain any expressions. For example,
 *                           svgFragment`foo`;
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @return {!DocumentFragment}
 */
function svgFragment(templateObj) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, 0);
    }
    /** @type {!SVGSVGElement} */
    const svgElem = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    /** @type {!Range} */
    const range = document.createRange();
    range.selectNodeContents(svgElem);
    return range.createContextualFragment((/** @type {string} */ ((0, html_impl_1.unwrapHtml)((0, html_impl_1.createHtmlInternal)(templateObj[0])))));
}
exports.svgFragment = svgFragment;
/**
 * Converts HTML markup into a node.
 * @param {!tsickle_SafeHtml_4} html
 * @return {!Node}
 */
function htmlToNode(html) {
    /** @type {!Range} */
    const range = document.createRange();
    /** @type {!DocumentFragment} */
    const fragment = range.createContextualFragment((/** @type {string} */ ((0, html_impl_1.unwrapHtml)(html))));
    if (fragment.childNodes.length === 1) {
        return fragment.childNodes[0];
    }
    else {
        return fragment;
    }
}
exports.htmlToNode = htmlToNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnRfZnJhZ21lbnRfYnVpbGRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvZG9jdW1lbnRfZnJhZ21lbnRfYnVpbGRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0ZBQTRDO0FBQzVDLGtHQUFnRjtBQUNoRiw0R0FBbUU7Ozs7Ozs7Ozs7Ozs7OztBQWVuRSxTQUFnQixZQUFZLENBQzFCLFdBQWlDO0lBRWpDLElBQUksY0FBUSxFQUFFLENBQUM7UUFDYixJQUFBLHVDQUFzQixFQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDOztVQUNLLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFO0lBQ3BDLE9BQU8sS0FBSyxDQUFDLHdCQUF3QixDQUNuQyx3QkFBQSxJQUFBLHNCQUFVLEVBQUMsSUFBQSw4QkFBa0IsRUFBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFVLENBQ3pELENBQUM7QUFDSixDQUFDO0FBVkQsb0NBVUM7Ozs7Ozs7Ozs7OztBQVlELFNBQWdCLFdBQVcsQ0FDekIsV0FBaUM7SUFFakMsSUFBSSxjQUFRLEVBQUUsQ0FBQztRQUNiLElBQUEsdUNBQXNCLEVBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7O1VBQ0ssT0FBTyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsNEJBQTRCLEVBQUUsS0FBSyxDQUFDOztVQUN2RSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRTtJQUNwQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsT0FBTyxLQUFLLENBQUMsd0JBQXdCLENBQ25DLHdCQUFBLElBQUEsc0JBQVUsRUFBQyxJQUFBLDhCQUFrQixFQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQVUsQ0FDekQsQ0FBQztBQUNKLENBQUM7QUFaRCxrQ0FZQzs7Ozs7O0FBR0QsU0FBZ0IsVUFBVSxDQUFDLElBQWM7O1VBQ2pDLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFOztVQUM5QixRQUFRLEdBQUcsS0FBSyxDQUFDLHdCQUF3QixDQUFDLHdCQUFBLElBQUEsc0JBQVUsRUFBQyxJQUFJLENBQUMsRUFBVSxDQUFDO0lBQzNFLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDckMsT0FBTyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztBQUNILENBQUM7QUFSRCxnQ0FRQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtERVZfTU9ERX0gZnJvbSAnLi4vZW52aXJvbm1lbnQvZGV2JztcbmltcG9ydCB7Y3JlYXRlSHRtbEludGVybmFsLCBTYWZlSHRtbCwgdW53cmFwSHRtbH0gZnJvbSAnLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5pbXBvcnQge2Fzc2VydElzVGVtcGxhdGVPYmplY3R9IGZyb20gJy4uL2ludGVybmFscy9zdHJpbmdfbGl0ZXJhbCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0IGZyb20gYSB0ZW1wbGF0ZSBsaXRlcmFsICh3aXRob3V0IGFueVxuICogZW1iZWRkZWQgZXhwcmVzc2lvbnMpIHVzaW5nIHRoZSBkb2N1bWVudCBjb250ZXh0IChIVE1MKS5cbiAqXG4gKiBOb3RlOiB1c2Ugc3ZnRnJhZ21lbnQgaW5zdGVhZCB0byBjcmVhdGUgYSBEb2N1bWVudEZyYWdtZW50IGJlbG9uZ2luZyB0byB0aGVcbiAqIFNWRyBuYW1lc3BhY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHRlbXBsYXRlIGxpdGVyYWwgdGFnIGZ1bmN0aW9uLiBJdCBzaG91bGQgYmUgY2FsbGVkIHdpdGhcbiAqIGEgdGVtcGxhdGUgbGl0ZXJhbCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IGV4cHJlc3Npb25zLiBGb3IgZXhhbXBsZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEZyYWdtZW50YGZvb2A7XG4gKlxuICogQHBhcmFtIHRlbXBsYXRlT2JqIFRoaXMgY29udGFpbnMgdGhlIGxpdGVyYWwgcGFydCBvZiB0aGUgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxGcmFnbWVudChcbiAgdGVtcGxhdGVPYmo6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuKTogRG9jdW1lbnRGcmFnbWVudCB7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIGFzc2VydElzVGVtcGxhdGVPYmplY3QodGVtcGxhdGVPYmosIDApO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChcbiAgICB1bndyYXBIdG1sKGNyZWF0ZUh0bWxJbnRlcm5hbCh0ZW1wbGF0ZU9ialswXSkpIGFzIHN0cmluZyxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgRG9jdW1lbnRGcmFnbWVudCBvYmplY3QgZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWwgKHdpdGhvdXQgYW55XG4gKiBlbWJlZGRlZCBleHByZXNzaW9ucyksIHdpdGggYW4gU1ZHIGNvbnRleHQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHRlbXBsYXRlIGxpdGVyYWwgdGFnIGZ1bmN0aW9uLiBJdCBzaG91bGQgYmUgY2FsbGVkIHdpdGhcbiAqIGEgdGVtcGxhdGUgbGl0ZXJhbCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IGV4cHJlc3Npb25zLiBGb3IgZXhhbXBsZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnRnJhZ21lbnRgZm9vYDtcbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGVPYmogVGhpcyBjb250YWlucyB0aGUgbGl0ZXJhbCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnRnJhZ21lbnQoXG4gIHRlbXBsYXRlT2JqOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSxcbik6IERvY3VtZW50RnJhZ21lbnQge1xuICBpZiAoREVWX01PREUpIHtcbiAgICBhc3NlcnRJc1RlbXBsYXRlT2JqZWN0KHRlbXBsYXRlT2JqLCAwKTtcbiAgfVxuICBjb25zdCBzdmdFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoc3ZnRWxlbSk7XG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoXG4gICAgdW53cmFwSHRtbChjcmVhdGVIdG1sSW50ZXJuYWwodGVtcGxhdGVPYmpbMF0pKSBhcyBzdHJpbmcsXG4gICk7XG59XG5cbi8qKiBDb252ZXJ0cyBIVE1MIG1hcmt1cCBpbnRvIGEgbm9kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sVG9Ob2RlKGh0bWw6IFNhZmVIdG1sKTogTm9kZSB7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgY29uc3QgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodW53cmFwSHRtbChodG1sKSBhcyBzdHJpbmcpO1xuICBpZiAoZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/style_sheet_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/style_sheet_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.style_sheet_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/style_sheet_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_string_literal_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_style_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_impl");
const tsickle_style_sheet_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_sheet_impl");
const tsickle_SafeStyle_5 = goog.requireType("goog.html.SafeStyle");
const tsickle_SafeStyleSheet_6 = goog.requireType("goog.html.SafeStyleSheet");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
// LINE-INTERNAL
const style_sheet_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_sheet_impl');
/** @typedef {(string|number|boolean)} */
var Primitive;
/**
 * Creates a SafeStyleSheet object from a template literal, representing a
 * single CSSStyleRule.
 * This builder parses the CSSStyleRule using browser APIs and serializes it
 * back to a string. This may change the string representation of the
 * stylesheet.
 *
 * This function is a template literal tag function. It should be called with
 * a template literal. For example,
 *                         safeStyleRule`.foo {}`.
 * @param {!TemplateStringsArray} templateObj
 * @param {...(string|number|boolean|!tsickle_SafeStyle_5)} rest
 * @return {(undefined|!tsickle_SafeStyleSheet_6)} A SafeStyleSheet object for the CSSStyleRule if successfuly parsed,
 *     undefined otherwise.
 */
function safeStyleRule(templateObj, ...rest) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, rest.length);
    }
    /** @type {string} */
    let stringifiedRule = templateObj[0];
    for (let i = 0; i < templateObj.length - 1; i++) {
        stringifiedRule += String(rest[i]);
        stringifiedRule += templateObj[i + 1];
    }
    // TODO(gweg): use the CSSStyleSheet API when it has broader browser support.
    /** @type {!Document} */
    const doc = document.implementation.createHTMLDocument('');
    /** @type {!HTMLStyleElement} */
    const styleEl = doc.createElement('style');
    doc.head.appendChild(styleEl);
    /** @type {!CSSStyleSheet} */
    const styleSheet = (/** @type {!CSSStyleSheet} */ (styleEl.sheet));
    styleSheet.insertRule(stringifiedRule, 0);
    if (styleSheet.cssRules.length !== 1) {
        if (dev_1.DEV_MODE) {
            throw new Error('safeStyleRule can be used to construct only 1 CSSStyleRule at a time. Use the concatStyle function to create sheet with several rules. Tried to parse: ' +
                stringifiedRule +
                `which has ${styleSheet.cssRules.length} rules: ${styleSheet.cssRules[0].cssText} #$% ${styleSheet.cssRules[1].cssText}.`);
        }
        return undefined;
    }
    /** @type {!CSSRule} */
    const styleSheetRule = styleSheet.cssRules[0];
    if (!(styleSheetRule instanceof CSSStyleRule)) {
        if (dev_1.DEV_MODE) {
            throw new Error('safeStyleRule can be used to construct a CSSStyleRule. @-rules should be constructed with the safeStyleSheet builder. Tried to parse: ' +
                stringifiedRule);
        }
        return undefined;
    }
    /** @type {string} */
    const styleSheetValue = (/** @type {!CSSStyleRule} */ (styleSheetRule)).cssText;
    return (0, style_sheet_impl_1.createStyleSheetInternal)(styleSheetValue.replace(/</g, '\\3C '));
}
exports.safeStyleRule = safeStyleRule;
// END-INTERNAL
/**
 * Creates a SafeStyleSheet object from a template literal (without any
 * embedded expressions).
 *
 * This function is a template literal tag function. It should be called with
 * a template literal that does not contain any expressions. For example,
 *                         safeStyleSheet`foo`;
 * The argument must not have any < or > characters in it. This is so that
 * SafeStyleSheet's contract is preserved, allowing the SafeStyleSheet to
 * correctly be interpreted as a sequence of CSS declarations and without
 * affecting the syntactic structure of any surrounding CSS and HTML.
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @return {!tsickle_SafeStyleSheet_6}
 */
function safeStyleSheet(templateObj) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, 0);
    }
    /** @type {string} */
    const styleSheet = templateObj[0];
    if (dev_1.DEV_MODE) {
        if (/</.test(styleSheet)) {
            throw new Error(`'<' character is forbidden in styleSheet string: ${styleSheet}`);
        }
    }
    return (0, style_sheet_impl_1.createStyleSheetInternal)(styleSheet);
}
exports.safeStyleSheet = safeStyleSheet;
/**
 * Creates a `SafeStyleSheet` value by concatenating multiple
 * `SafeStyleSheet`s.
 * @param {!ReadonlyArray<!tsickle_SafeStyleSheet_6>} sheets
 * @return {!tsickle_SafeStyleSheet_6}
 */
function concatStyleSheets(sheets) {
    return (0, style_sheet_impl_1.createStyleSheetInternal)(sheets.map(style_sheet_impl_1.unwrapStyleSheet).join(''));
}
exports.concatStyleSheets = concatStyleSheets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGVfc2hlZXRfYnVpbGRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvc3R5bGVfc2hlZXRfYnVpbGRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx3RkFBNEM7QUFDNUMsNEdBQW1FOztBQUVuRSxnSEFJdUM7O0FBR3ZDLGNBQTJDOzs7Ozs7Ozs7Ozs7Ozs7O0FBZTNDLFNBQWdCLGFBQWEsQ0FDM0IsV0FBaUMsRUFDakMsR0FBRyxJQUFrQztJQUVyQyxJQUFJLGNBQVEsRUFBRSxDQUFDO1FBQ2IsSUFBQSx1Q0FBc0IsRUFBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7O1FBQ0csZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEQsZUFBZSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxlQUFlLElBQUksV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN4QyxDQUFDOzs7VUFHSyxHQUFHLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7O1VBQ3BELE9BQU8sR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztJQUMxQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7VUFDeEIsVUFBVSxHQUFHLGdDQUFBLE9BQU8sQ0FBQyxLQUFLLEVBQWlCO0lBRWpELFVBQVUsQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFDLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDckMsSUFBSSxjQUFRLEVBQUUsQ0FBQztZQUNiLE1BQU0sSUFBSSxLQUFLLENBQ2IseUpBQXlKO2dCQUN2SixlQUFlO2dCQUNmLGFBQWEsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLFdBQVcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FDNUgsQ0FBQztRQUNKLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOztVQUNLLGNBQWMsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUM3QyxJQUFJLENBQUMsQ0FBQyxjQUFjLFlBQVksWUFBWSxDQUFDLEVBQUUsQ0FBQztRQUM5QyxJQUFJLGNBQVEsRUFBRSxDQUFDO1lBQ2IsTUFBTSxJQUFJLEtBQUssQ0FDYix3SUFBd0k7Z0JBQ3RJLGVBQWUsQ0FDbEIsQ0FBQztRQUNKLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOztVQUNLLGVBQWUsR0FBRywrQkFBQSxjQUFjLEVBQUEsQ0FBQyxPQUFPO0lBQzlDLE9BQU8sSUFBQSwyQ0FBd0IsRUFBQyxlQUFlLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzFFLENBQUM7QUExQ0Qsc0NBMENDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRCxTQUFnQixjQUFjLENBQzVCLFdBQWlDO0lBRWpDLElBQUksY0FBUSxFQUFFLENBQUM7UUFDYixJQUFBLHVDQUFzQixFQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDOztVQUVLLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLElBQUksY0FBUSxFQUFFLENBQUM7UUFDYixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztZQUN6QixNQUFNLElBQUksS0FBSyxDQUNiLG9EQUFvRCxVQUFVLEVBQUUsQ0FDakUsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxJQUFBLDJDQUF3QixFQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFqQkQsd0NBaUJDOzs7Ozs7O0FBTUQsU0FBZ0IsaUJBQWlCLENBQy9CLE1BQWlDO0lBRWpDLE9BQU8sSUFBQSwyQ0FBd0IsRUFBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG1DQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUpELDhDQUlDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi9lbnZpcm9ubWVudC9kZXYnO1xuaW1wb3J0IHthc3NlcnRJc1RlbXBsYXRlT2JqZWN0fSBmcm9tICcuLi9pbnRlcm5hbHMvc3RyaW5nX2xpdGVyYWwnO1xuaW1wb3J0IHtTYWZlU3R5bGV9IGZyb20gJy4uL2ludGVybmFscy9zdHlsZV9pbXBsJzsgLy8gTElORS1JTlRFUk5BTFxuaW1wb3J0IHtcbiAgY3JlYXRlU3R5bGVTaGVldEludGVybmFsLFxuICBTYWZlU3R5bGVTaGVldCxcbiAgdW53cmFwU3R5bGVTaGVldCxcbn0gZnJvbSAnLi4vaW50ZXJuYWxzL3N0eWxlX3NoZWV0X2ltcGwnO1xuXG4vLyBCRUdJTi1JTlRFUk5BTFxudHlwZSBQcmltaXRpdmUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlU3R5bGVTaGVldCBvYmplY3QgZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWwsIHJlcHJlc2VudGluZyBhXG4gKiBzaW5nbGUgQ1NTU3R5bGVSdWxlLlxuICogVGhpcyBidWlsZGVyIHBhcnNlcyB0aGUgQ1NTU3R5bGVSdWxlIHVzaW5nIGJyb3dzZXIgQVBJcyBhbmQgc2VyaWFsaXplcyBpdFxuICogYmFjayB0byBhIHN0cmluZy4gVGhpcyBtYXkgY2hhbmdlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiBzdHlsZXNoZWV0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZyBmdW5jdGlvbi4gSXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG4gKiBhIHRlbXBsYXRlIGxpdGVyYWwuIEZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVN0eWxlUnVsZWAuZm9vIHt9YC5cbiAqIEByZXR1cm4gQSBTYWZlU3R5bGVTaGVldCBvYmplY3QgZm9yIHRoZSBDU1NTdHlsZVJ1bGUgaWYgc3VjY2Vzc2Z1bHkgcGFyc2VkLFxuICogICAgIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlU3R5bGVSdWxlKFxuICB0ZW1wbGF0ZU9iajogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gIC4uLnJlc3Q6IEFycmF5PFByaW1pdGl2ZSB8IFNhZmVTdHlsZT5cbik6IFNhZmVTdHlsZVNoZWV0IHwgdW5kZWZpbmVkIHtcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgYXNzZXJ0SXNUZW1wbGF0ZU9iamVjdCh0ZW1wbGF0ZU9iaiwgcmVzdC5sZW5ndGgpO1xuICB9XG4gIGxldCBzdHJpbmdpZmllZFJ1bGUgPSB0ZW1wbGF0ZU9ialswXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZU9iai5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBzdHJpbmdpZmllZFJ1bGUgKz0gU3RyaW5nKHJlc3RbaV0pO1xuICAgIHN0cmluZ2lmaWVkUnVsZSArPSB0ZW1wbGF0ZU9ialtpICsgMV07XG4gIH1cblxuICAvLyBUT0RPKGd3ZWcpOiB1c2UgdGhlIENTU1N0eWxlU2hlZXQgQVBJIHdoZW4gaXQgaGFzIGJyb2FkZXIgYnJvd3NlciBzdXBwb3J0LlxuICBjb25zdCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICBjb25zdCBzdHlsZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGRvYy5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICBjb25zdCBzdHlsZVNoZWV0ID0gc3R5bGVFbC5zaGVldCBhcyBDU1NTdHlsZVNoZWV0O1xuXG4gIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShzdHJpbmdpZmllZFJ1bGUsIDApO1xuICBpZiAoc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NhZmVTdHlsZVJ1bGUgY2FuIGJlIHVzZWQgdG8gY29uc3RydWN0IG9ubHkgMSBDU1NTdHlsZVJ1bGUgYXQgYSB0aW1lLiBVc2UgdGhlIGNvbmNhdFN0eWxlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzaGVldCB3aXRoIHNldmVyYWwgcnVsZXMuIFRyaWVkIHRvIHBhcnNlOiAnICtcbiAgICAgICAgICBzdHJpbmdpZmllZFJ1bGUgK1xuICAgICAgICAgIGB3aGljaCBoYXMgJHtzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aH0gcnVsZXM6ICR7c3R5bGVTaGVldC5jc3NSdWxlc1swXS5jc3NUZXh0fSAjJCUgJHtzdHlsZVNoZWV0LmNzc1J1bGVzWzFdLmNzc1RleHR9LmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHN0eWxlU2hlZXRSdWxlID0gc3R5bGVTaGVldC5jc3NSdWxlc1swXTtcbiAgaWYgKCEoc3R5bGVTaGVldFJ1bGUgaW5zdGFuY2VvZiBDU1NTdHlsZVJ1bGUpKSB7XG4gICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzYWZlU3R5bGVSdWxlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENTU1N0eWxlUnVsZS4gQC1ydWxlcyBzaG91bGQgYmUgY29uc3RydWN0ZWQgd2l0aCB0aGUgc2FmZVN0eWxlU2hlZXQgYnVpbGRlci4gVHJpZWQgdG8gcGFyc2U6ICcgK1xuICAgICAgICAgIHN0cmluZ2lmaWVkUnVsZSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc3R5bGVTaGVldFZhbHVlID0gc3R5bGVTaGVldFJ1bGUuY3NzVGV4dDtcbiAgcmV0dXJuIGNyZWF0ZVN0eWxlU2hlZXRJbnRlcm5hbChzdHlsZVNoZWV0VmFsdWUucmVwbGFjZSgvPC9nLCAnXFxcXDNDICcpKTtcbn1cbi8vIEVORC1JTlRFUk5BTFxuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlU3R5bGVTaGVldCBvYmplY3QgZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWwgKHdpdGhvdXQgYW55XG4gKiBlbWJlZGRlZCBleHByZXNzaW9ucykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHRlbXBsYXRlIGxpdGVyYWwgdGFnIGZ1bmN0aW9uLiBJdCBzaG91bGQgYmUgY2FsbGVkIHdpdGhcbiAqIGEgdGVtcGxhdGUgbGl0ZXJhbCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IGV4cHJlc3Npb25zLiBGb3IgZXhhbXBsZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVTdHlsZVNoZWV0YGZvb2A7XG4gKiBUaGUgYXJndW1lbnQgbXVzdCBub3QgaGF2ZSBhbnkgPCBvciA+IGNoYXJhY3RlcnMgaW4gaXQuIFRoaXMgaXMgc28gdGhhdFxuICogU2FmZVN0eWxlU2hlZXQncyBjb250cmFjdCBpcyBwcmVzZXJ2ZWQsIGFsbG93aW5nIHRoZSBTYWZlU3R5bGVTaGVldCB0b1xuICogY29ycmVjdGx5IGJlIGludGVycHJldGVkIGFzIGEgc2VxdWVuY2Ugb2YgQ1NTIGRlY2xhcmF0aW9ucyBhbmQgd2l0aG91dFxuICogYWZmZWN0aW5nIHRoZSBzeW50YWN0aWMgc3RydWN0dXJlIG9mIGFueSBzdXJyb3VuZGluZyBDU1MgYW5kIEhUTUwuXG4gKlxuICogQHBhcmFtIHRlbXBsYXRlT2JqIFRoaXMgY29udGFpbnMgdGhlIGxpdGVyYWwgcGFydCBvZiB0aGUgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHlsZVNoZWV0KFxuICB0ZW1wbGF0ZU9iajogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4pOiBTYWZlU3R5bGVTaGVldCB7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIGFzc2VydElzVGVtcGxhdGVPYmplY3QodGVtcGxhdGVPYmosIDApO1xuICB9XG5cbiAgY29uc3Qgc3R5bGVTaGVldCA9IHRlbXBsYXRlT2JqWzBdO1xuICBpZiAoREVWX01PREUpIHtcbiAgICBpZiAoLzwvLnRlc3Qoc3R5bGVTaGVldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCc8JyBjaGFyYWN0ZXIgaXMgZm9yYmlkZGVuIGluIHN0eWxlU2hlZXQgc3RyaW5nOiAke3N0eWxlU2hlZXR9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVN0eWxlU2hlZXRJbnRlcm5hbChzdHlsZVNoZWV0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFNhZmVTdHlsZVNoZWV0YCB2YWx1ZSBieSBjb25jYXRlbmF0aW5nIG11bHRpcGxlXG4gKiBgU2FmZVN0eWxlU2hlZXRgcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdFN0eWxlU2hlZXRzKFxuICBzaGVldHM6IHJlYWRvbmx5IFNhZmVTdHlsZVNoZWV0W10sXG4pOiBTYWZlU3R5bGVTaGVldCB7XG4gIHJldHVybiBjcmVhdGVTdHlsZVNoZWV0SW50ZXJuYWwoc2hlZXRzLm1hcCh1bndyYXBTdHlsZVNoZWV0KS5qb2luKCcnKSk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/builders/html_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_resource_url_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_script_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_style_impl_5 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_impl");
const tsickle_style_sheet_impl_6 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_sheet_impl");
const tsickle_url_impl_7 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_style_sheet_builders_8 = goog.requireType("google3.third_party.javascript.safevalues.builders.style_sheet_builders");
const tsickle_url_builders_9 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_SafeHtml_10 = goog.requireType("goog.html.SafeHtml");
const tsickle_TrustedResourceUrl_11 = goog.requireType("goog.html.TrustedResourceUrl");
const tsickle_SafeStyle_12 = goog.requireType("goog.html.SafeStyle");
const tsickle_SafeStyleSheet_13 = goog.requireType("goog.html.SafeStyleSheet");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev'); // LINE-INTERNAL
// LINE-INTERNAL
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const style_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_impl'); // LINE-INTERNAL
// LINE-INTERNAL
const style_sheet_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_sheet_impl'); // LINE-INTERNAL
// LINE-INTERNAL
const url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.url_impl'); // LINE-INTERNAL
// LINE-INTERNAL
const style_sheet_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.style_sheet_builders'); // LINE-INTERNAL
// LINE-INTERNAL
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders'); // LINE-INTERNAL
// LINE-INTERNAL
/**
 * Returns HTML-escaped text as a `SafeHtml` object. No-op if value is already a
 * SafeHtml instance.
 *
 * Available options:
 * - `preserveSpaces` turns every second consecutive space character into its
 * HTML entity representation (`&#160;`).
 * - `preserveNewlines` turns newline characters into breaks (`<br>`).
 * - `preserveTabs` wraps tab characters in a span with style=white-space:pre.
 * @param {(string|!tsickle_SafeHtml_10)} value
 * @param {{preserveNewlines: (undefined|boolean), preserveSpaces: (undefined|boolean), preserveTabs: (undefined|boolean)}=} options
 * @return {!tsickle_SafeHtml_10}
 */
function htmlEscape(value, options = {}) {
    if ((0, html_impl_1.isHtml)(value)) {
        return value;
    }
    /** @type {string} */
    let htmlEscapedString = htmlEscapeToString(String(value));
    if (options.preserveSpaces) {
        // Do this first to ensure we preserve spaces after newlines and tabs.
        htmlEscapedString = htmlEscapedString.replace(/(^|[\r\n\t ]) /g, '$1&#160;');
    }
    if (options.preserveNewlines) {
        htmlEscapedString = htmlEscapedString.replace(/(\r\n|\n|\r)/g, '<br>');
    }
    if (options.preserveTabs) {
        htmlEscapedString = htmlEscapedString.replace(/(\t+)/g, '<span style="white-space:pre">$1</span>');
    }
    return (0, html_impl_1.createHtmlInternal)(htmlEscapedString);
}
exports.htmlEscape = htmlEscape;
/**
 * Creates a `SafeHtml` representing a script tag with inline script content.
 * @param {!tsickle_script_impl_4.SafeScript} script
 * @param {{defer: (undefined|boolean), id: (undefined|string), nonce: (undefined|string), type: (undefined|string)}=} options
 * @return {!tsickle_SafeHtml_10}
 */
function scriptToHtml(script, options = {}) {
    /** @type {string} */
    const unwrappedScript = (0, script_impl_1.unwrapScript)(script).toString();
    /** @type {string} */
    let stringTag = `<script`;
    if (options.id) {
        stringTag += ` id="${htmlEscapeToString(options.id)}"`;
    }
    if (options.nonce) {
        stringTag += ` nonce="${htmlEscapeToString(options.nonce)}"`;
    }
    if (options.type) {
        stringTag += ` type="${htmlEscapeToString(options.type)}"`;
    }
    if (options.defer) {
        stringTag += ` defer`;
    }
    stringTag += `>${unwrappedScript}\u003C/script>`;
    return (0, html_impl_1.createHtmlInternal)(stringTag);
}
exports.scriptToHtml = scriptToHtml;
/**
 * Creates a `SafeHtml` representing a script tag with the src attribute.
 * This also supports CSP nonces and async loading.
 * @param {!tsickle_TrustedResourceUrl_11} src
 * @param {{async: (undefined|boolean), customElement: (undefined|string), defer: (undefined|boolean), id: (undefined|string), nonce: (undefined|string), type: (undefined|string), crossorigin: (undefined|string)}=} options
 * @return {!tsickle_SafeHtml_10}
 */
function scriptUrlToHtml(src, options = {}) {
    /** @type {string} */
    const unwrappedSrc = (0, resource_url_impl_1.unwrapResourceUrl)(src).toString();
    /** @type {string} */
    let stringTag = `<script src="${htmlEscapeToString(unwrappedSrc)}"`;
    if (options.async) {
        stringTag += ' async';
    }
    if (options.customElement) {
        stringTag += ` custom-element="${htmlEscapeToString(options.customElement)}"`;
    }
    if (options.defer) {
        stringTag += ` defer`;
    }
    if (options.id) {
        stringTag += ` id="${htmlEscapeToString(options.id)}"`;
    }
    if (options.nonce) {
        stringTag += ` nonce="${htmlEscapeToString(options.nonce)}"`;
    }
    if (options.type) {
        stringTag += ` type="${htmlEscapeToString(options.type)}"`;
    }
    if (options.crossorigin) {
        stringTag += ` crossorigin="${htmlEscapeToString(options.crossorigin)}"`;
    }
    stringTag += '>\u003C/script>';
    return (0, html_impl_1.createHtmlInternal)(stringTag);
}
exports.scriptUrlToHtml = scriptUrlToHtml;
/**
 * HTML-escapes the given text (`&`, `<`, `>`, `"` and `'`).
 * @param {string} text
 * @return {string}
 */
function htmlEscapeToString(text) {
    /** @type {string} */
    const escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    return escaped;
}
/**
 * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s.
 * @param {!ReadonlyArray<(string|!tsickle_SafeHtml_10)>} htmls
 * @return {!tsickle_SafeHtml_10}
 */
function concatHtmls(htmls) {
    return joinHtmls('', htmls);
}
exports.concatHtmls = concatHtmls;
/**
 * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s interleaved
 * with a separator.
 * @param {(string|!tsickle_SafeHtml_10)} separator
 * @param {!ReadonlyArray<(string|!tsickle_SafeHtml_10)>} htmls
 * @return {!tsickle_SafeHtml_10}
 */
function joinHtmls(separator, htmls) {
    /** @type {!tsickle_SafeHtml_10} */
    const separatorHtml = htmlEscape(separator);
    return (0, html_impl_1.createHtmlInternal)(htmls
        .map((/**
     * @param {(string|!tsickle_SafeHtml_10)} value
     * @return {(string|!TrustedHTML)}
     */
    (value) => (0, html_impl_1.unwrapHtml)(htmlEscape(value))))
        .join((0, html_impl_1.unwrapHtml)(separatorHtml).toString()));
}
exports.joinHtmls = joinHtmls;
/**
 * Returns a `SafeHtml` that contains `<!DOCTYPE html>`.
 * This is defined as a function to prevent the definition of a Trusted Type
 * policy when simply importing safevalues.
 * @return {!tsickle_SafeHtml_10}
 */
function doctypeHtml() {
    return (0, html_impl_1.createHtmlInternal)('<!DOCTYPE html>');
}
exports.doctypeHtml = doctypeHtml;
/**
 * Non-exported version of `nodeToHtml`, with an explicit temporary root to
 * accomodate for the sanitizer's user case.
 * @param {!Node} node
 * @param {!Element} temporaryRoot
 * @return {!tsickle_SafeHtml_10}
 */
function nodeToHtmlInternal(node, temporaryRoot) {
    temporaryRoot.appendChild(node);
    // XML serialization is preferred over HTML serialization as it is
    // stricter and makes sure all attributes are properly escaped, avoiding
    // cases where the tree might mutate when parsed again later due to the
    // complexities of the HTML parsing algorithm
    /** @type {string} */
    let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);
    // We remove the outer most element as this is the span node created as
    // the root for the sanitized tree and contains a spurious xmlns attribute
    // from the XML serialization step.
    serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));
    return (0, html_impl_1.createHtmlInternal)(serializedNewTree);
}
exports.nodeToHtmlInternal = nodeToHtmlInternal;
/**
 * Serializes a Node into it's HTML representation.
 *
 * Note: this method uses strict XML serialization to mitigate mutation issues
 * when the html is then re-parsed by the browser.
 * @param {!Node} node
 * @return {!tsickle_SafeHtml_10}
 */
function nodeToHtml(node) {
    /** @type {!HTMLSpanElement} */
    const tempRoot = document.createElement('span');
    return nodeToHtmlInternal(node, tempRoot);
}
exports.nodeToHtml = nodeToHtml;
/**
 * Type for the attribute value in SafeHtml builders. SafeStyle and SafeUrl are
 * in for legacy reasons.
 * @typedef {(string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)}
 */
exports.AttributeValue;
/**
 * Shorthand for union of types that can sensibly be converted to strings
 * or might already be SafeHtml.
 * @typedef {(string|number|boolean|!tsickle_SafeHtml_10)}
 */
var TextOrHtml;
/** @type {!RegExp} */
const VALID_TAG_OR_ATTRIBUTE_NAMES = /^[a-z][a-z\d-]*$/i;
/**
 * Tags which are unsupported via createHtml(). They might be
 * supported via a tag-specific create method. These are tags which might
 * require a TrustedResourceUrl in one of their attributes or a restricted
 * type for their content.
 * @type {!Array<string>}
 */
const DISALLOWED_TAG_NAMES = [
    'APPLET',
    'BASE',
    'EMBED',
    'IFRAME',
    'LINK',
    'MATH',
    'META',
    'OBJECT',
    'SCRIPT',
    'STYLE',
    'SVG',
    'TEMPLATE',
];
/**
 * List of void tags.
 * @type {!Array<string>}
 */
exports.VOID_TAG_NAMES = [
    'AREA',
    'BR',
    'COL',
    'COMMAND',
    'HR',
    'IMG',
    'INPUT',
    'KEYGEN',
    'PARAM',
    'SOURCE',
    'TRACK',
    'WBR',
];
/**
 * Attributes that can cause the execution of javascript: URLs.
 * @type {!Array<string>}
 */
const URL_ATTRIBUTES = ['action', 'formaction', 'href'];
/**
 * Verifies if the tag name is valid and if it doesn't change the context.
 * E.g. STRONG is fine but SCRIPT throws because it changes context. See
 * createHtml for an explanation of allowed tags.
 * @throws {!Error} If invalid tag name is provided.
 * @param {string} tagName
 * @return {void}
 */
function verifyTagName(tagName) {
    if (!VALID_TAG_OR_ATTRIBUTE_NAMES.test(tagName)) {
        throw new Error(dev_1.DEV_MODE ? `Invalid tag name <${tagName}>.` : '');
    }
    if (DISALLOWED_TAG_NAMES.indexOf(tagName.toUpperCase()) !== -1) {
        throw new Error(dev_1.DEV_MODE ? `Tag name <${tagName}> is not allowed for createHtml.` : '');
    }
}
exports.verifyTagName = verifyTagName;
/**
 * Returns true if the tag name is a void tag.
 * @param {string} tagName
 * @return {boolean}
 */
function isVoidTag(tagName) {
    return exports.VOID_TAG_NAMES.indexOf(tagName.toUpperCase()) !== -1;
}
exports.isVoidTag = isVoidTag;
/**
 * Creates a SafeHtml content consisting of a tag with optional attributes and
 * optional content.
 * This is roughly equivalent to Closure's goog.html.SafeHtml.create function,
 * with a few dropped features, like Const strings. It is discouraged for new
 * usages. Prefer using a recommended templating system like Lit instead.
 *
 * Example usage:
 *
 * createHtml('br');
 * createHtml('div', {'class': 'a'});
 * createHtml('p', {}, 'a');
 * createHtml('p', {}, createHtml('br'));
 *
 * createHtml('span', {
 *   'style': {'margin': '0'}
 * });
 *
 * To guarantee SafeHtml's type contract is upheld there are restrictions on
 * attribute values and tag names.
 *
 * - Attributes which contain script code (e.g. on*) are disallowed.
 * - For attributes which are interpreted as URLs (e.g. src, href), the URL
 * will be sanitized with javascript: URLs blocked.
 * - Tags which are not supported by this function are applet, base, embed,
 *   iframe, link, math, meta, object, script, style, svg, and template.
 * @param {string} tagName
 * @param {(undefined|!Object<string,(undefined|string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)>)=} attributes
 * @param {(undefined|string|number|boolean|!tsickle_SafeHtml_10|!Array<(string|number|boolean|!tsickle_SafeHtml_10)>)=} content
 * @return {!tsickle_SafeHtml_10}
 */
function createHtml(tagName, attributes, content) {
    verifyTagName(tagName);
    /** @type {string} */
    let result = `<${tagName}`;
    if (attributes) {
        result += stringifyAttributes(tagName, attributes);
    }
    if (!Array.isArray(content)) {
        content = content === undefined ? [] : [content];
    }
    if (isVoidTag(tagName)) {
        if (dev_1.DEV_MODE) {
            if ((/** @type {!Array<(string|number|boolean|!tsickle_SafeHtml_10)>} */ (content)).length > 0) {
                throw new Error(`Void tag <${tagName}> does not allow content.`);
            }
        }
        result += '>';
    }
    else {
        /** @type {!tsickle_SafeHtml_10} */
        const html = concatHtmls((/** @type {!Array<(string|number|boolean|!tsickle_SafeHtml_10)>} */ (content)).map((/**
         * @param {(string|number|boolean|!tsickle_SafeHtml_10)} value
         * @return {!tsickle_SafeHtml_10}
         */
        (value) => (0, html_impl_1.isHtml)(value) ? value : htmlEscape(String(value)))));
        result += '>' + html.toString() + '</' + tagName + '>';
    }
    return (0, html_impl_1.createHtmlInternal)(result);
}
exports.createHtml = createHtml;
/**
 * Creates a SafeHtml representing a style tag. The type attribute is set
 * to "text/css".
 * @throws {!Error} If invalid attribute name or attribute value is provided or
 *     if attributes contains the type attribute.
 * @param {(!tsickle_SafeStyleSheet_13|!Array<!tsickle_SafeStyleSheet_13>)} styleSheet Content to put inside the tag. Array elements are
 *     concatenated.
 * @param {(undefined|!Object<string,(undefined|string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)>)=} attributes Mapping from attribute names to their values. Only
 *     attribute names consisting of [a-zA-Z0-9-] are allowed. Value of
 *     undefined causes the attribute to be omitted.
 * @return {!tsickle_SafeHtml_10} The SafeHtml content with the tag.
 */
function styleSheetToHtml(styleSheet, attributes) {
    /** @type {!Object<string,(undefined|string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)>} */
    const combinedAttributes = {};
    if (attributes) {
        /** @type {!Array<string>} */
        const customAttrNames = Object.keys(attributes);
        for (let i = 0; i < customAttrNames.length; i++) {
            /** @type {string} */
            const name = customAttrNames[i];
            if (name.toLowerCase() === 'type') {
                throw new Error(dev_1.DEV_MODE
                    ? `Cannot override the 'type' attribute with value ${attributes[name]}.`
                    : '');
            }
            combinedAttributes[name] = attributes[name];
        }
    }
    combinedAttributes['type'] = 'text/css';
    /** @type {string} */
    const stringifiedAttributes = stringifyAttributes('style', combinedAttributes);
    if (Array.isArray(styleSheet)) {
        styleSheet = (0, style_sheet_builders_1.concatStyleSheets)(styleSheet);
    }
    /** @type {string} */
    const styleContent = (0, style_sheet_impl_1.unwrapStyleSheet)(styleSheet);
    return (0, html_impl_1.createHtmlInternal)(`<style ${stringifiedAttributes}>${styleContent}</style>`);
}
exports.styleSheetToHtml = styleSheetToHtml;
/**
 * Creates a string with attributes to insert after tagName.
 * @throws {!Error} If attribute value is unsafe for the given tag and
 *     attribute.
 * @param {string} tagName
 * @param {!Object<string,(undefined|string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)>} attributes
 * @return {string}
 */
function stringifyAttributes(tagName, attributes) {
    /** @type {string} */
    let result = '';
    /** @type {!Array<string>} */
    const attrNames = Object.keys(attributes);
    for (let i = 0; i < attrNames.length; i++) {
        /** @type {string} */
        const name = attrNames[i];
        /** @type {(undefined|string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)} */
        const value = attributes[name];
        if (!VALID_TAG_OR_ATTRIBUTE_NAMES.test(name)) {
            throw new Error(dev_1.DEV_MODE ? `Invalid attribute name "${name}".` : '');
        }
        if (value === undefined || value === null) {
            continue;
        }
        result += ' ' + getAttrNameAndValue(tagName, name, value);
    }
    return result;
}
exports.stringifyAttributes = stringifyAttributes;
/**
 * @param {string} tagName
 * @param {string} name
 * @param {(string|number|!tsickle_url_impl_7.SafeUrl|!tsickle_SafeStyle_12)} value
 * @return {string}
 */
function getAttrNameAndValue(tagName, name, value) {
    if (/^on/i.test(name)) {
        throw new Error(dev_1.DEV_MODE
            ? `Attribute "${name} is forbidden. Inline event handlers can lead to XSS. Please use the 'addEventListener' API instead.`
            : '');
    }
    else if (URL_ATTRIBUTES.indexOf(name.toLowerCase()) !== -1) {
        if ((0, url_impl_1.isUrl)(value)) {
            value = (/** @type {!tsickle_url_impl_7.SafeUrl} */ (value)).toString();
        }
        else {
            value = (0, url_builders_1.sanitizeJavaScriptUrl)(String(value)) || 'about:invalid#zClosurez';
        }
    }
    if (dev_1.DEV_MODE) {
        if (!(0, url_impl_1.isUrl)(value) &&
            !(0, html_impl_1.isHtml)(value) &&
            !(0, style_impl_1.isStyle)(value) &&
            typeof value !== 'string' &&
            typeof value !== 'number') {
            throw new Error(`String or number value expected, got ${typeof value} with value '${value}' given.`);
        }
    }
    return `${name}="${htmlEscape(String(value))}"`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF9idWlsZGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9idWlsZGVycy9odG1sX2J1aWxkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHdGQUE0QyxDQUFDLGdCQUFnQjs7QUFDN0Qsa0dBS2dDO0FBQ2hDLGtIQUd3QztBQUN4QyxzR0FBa0U7QUFDbEUsb0dBQTJELENBQUMsZ0JBQWdCOztBQUM1RSxnSEFBK0UsQ0FBQyxnQkFBZ0I7O0FBQ2hHLGdHQUFxRCxDQUFDLGdCQUFnQjs7QUFFdEUsdUhBQXlELENBQUMsZ0JBQWdCOztBQUMxRSx1R0FBcUQsQ0FBQyxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7OztBQVl0RSxTQUFnQixVQUFVLENBQ3hCLEtBQXdCLEVBQ3hCLFVBSUksRUFBRTtJQUVOLElBQUksSUFBQSxrQkFBTSxFQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDbEIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOztRQUNHLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6RCxJQUFJLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQzs7UUFFM0IsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUMzQyxpQkFBaUIsRUFDakIsVUFBVSxDQUNYLENBQUM7SUFDSixDQUFDO0lBQ0QsSUFBSSxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUM3QixpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFDRCxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN6QixpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQzNDLFFBQVEs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QVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uL2Vudmlyb25tZW50L2Rldic7IC8vIExJTkUtSU5URVJOQUxcbmltcG9ydCB7XG4gIGNyZWF0ZUh0bWxJbnRlcm5hbCxcbiAgaXNIdG1sLFxuICBTYWZlSHRtbCxcbiAgdW53cmFwSHRtbCxcbn0gZnJvbSAnLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5pbXBvcnQge1xuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuaW1wb3J0IHtTYWZlU2NyaXB0LCB1bndyYXBTY3JpcHR9IGZyb20gJy4uL2ludGVybmFscy9zY3JpcHRfaW1wbCc7XG5pbXBvcnQge2lzU3R5bGUsIFNhZmVTdHlsZX0gZnJvbSAnLi4vaW50ZXJuYWxzL3N0eWxlX2ltcGwnOyAvLyBMSU5FLUlOVEVSTkFMXG5pbXBvcnQge1NhZmVTdHlsZVNoZWV0LCB1bndyYXBTdHlsZVNoZWV0fSBmcm9tICcuLi9pbnRlcm5hbHMvc3R5bGVfc2hlZXRfaW1wbCc7IC8vIExJTkUtSU5URVJOQUxcbmltcG9ydCB7aXNVcmwsIFNhZmVVcmx9IGZyb20gJy4uL2ludGVybmFscy91cmxfaW1wbCc7IC8vIExJTkUtSU5URVJOQUxcblxuaW1wb3J0IHtjb25jYXRTdHlsZVNoZWV0c30gZnJvbSAnLi9zdHlsZV9zaGVldF9idWlsZGVycyc7IC8vIExJTkUtSU5URVJOQUxcbmltcG9ydCB7c2FuaXRpemVKYXZhU2NyaXB0VXJsfSBmcm9tICcuL3VybF9idWlsZGVycyc7IC8vIExJTkUtSU5URVJOQUxcblxuLyoqXG4gKiBSZXR1cm5zIEhUTUwtZXNjYXBlZCB0ZXh0IGFzIGEgYFNhZmVIdG1sYCBvYmplY3QuIE5vLW9wIGlmIHZhbHVlIGlzIGFscmVhZHkgYVxuICogU2FmZUh0bWwgaW5zdGFuY2UuXG4gKlxuICogQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAtIGBwcmVzZXJ2ZVNwYWNlc2AgdHVybnMgZXZlcnkgc2Vjb25kIGNvbnNlY3V0aXZlIHNwYWNlIGNoYXJhY3RlciBpbnRvIGl0c1xuICogSFRNTCBlbnRpdHkgcmVwcmVzZW50YXRpb24gKGAmIzE2MDtgKS5cbiAqIC0gYHByZXNlcnZlTmV3bGluZXNgIHR1cm5zIG5ld2xpbmUgY2hhcmFjdGVycyBpbnRvIGJyZWFrcyAoYDxicj5gKS5cbiAqIC0gYHByZXNlcnZlVGFic2Agd3JhcHMgdGFiIGNoYXJhY3RlcnMgaW4gYSBzcGFuIHdpdGggc3R5bGU9d2hpdGUtc3BhY2U6cHJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVzY2FwZShcbiAgdmFsdWU6IFNhZmVIdG1sIHwgc3RyaW5nLFxuICBvcHRpb25zOiB7XG4gICAgcHJlc2VydmVOZXdsaW5lcz86IGJvb2xlYW47XG4gICAgcHJlc2VydmVTcGFjZXM/OiBib29sZWFuO1xuICAgIHByZXNlcnZlVGFicz86IGJvb2xlYW47XG4gIH0gPSB7fSxcbik6IFNhZmVIdG1sIHtcbiAgaWYgKGlzSHRtbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IGh0bWxFc2NhcGVkU3RyaW5nID0gaHRtbEVzY2FwZVRvU3RyaW5nKFN0cmluZyh2YWx1ZSkpO1xuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVNwYWNlcykge1xuICAgIC8vIERvIHRoaXMgZmlyc3QgdG8gZW5zdXJlIHdlIHByZXNlcnZlIHNwYWNlcyBhZnRlciBuZXdsaW5lcyBhbmQgdGFicy5cbiAgICBodG1sRXNjYXBlZFN0cmluZyA9IGh0bWxFc2NhcGVkU3RyaW5nLnJlcGxhY2UoXG4gICAgICAvKF58W1xcclxcblxcdCBdKSAvZyxcbiAgICAgICckMSYjMTYwOycsXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZU5ld2xpbmVzKSB7XG4gICAgaHRtbEVzY2FwZWRTdHJpbmcgPSBodG1sRXNjYXBlZFN0cmluZy5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2csICc8YnI+Jyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVUYWJzKSB7XG4gICAgaHRtbEVzY2FwZWRTdHJpbmcgPSBodG1sRXNjYXBlZFN0cmluZy5yZXBsYWNlKFxuICAgICAgLyhcXHQrKS9nLFxuICAgICAgJzxzcGFuIHN0eWxlPVwid2hpdGUtc3BhY2U6cHJlXCI+JDE8L3NwYW4+JyxcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVIdG1sSW50ZXJuYWwoaHRtbEVzY2FwZWRTdHJpbmcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2FmZUh0bWxgIHJlcHJlc2VudGluZyBhIHNjcmlwdCB0YWcgd2l0aCBpbmxpbmUgc2NyaXB0IGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3JpcHRUb0h0bWwoXG4gIHNjcmlwdDogU2FmZVNjcmlwdCxcbiAgb3B0aW9uczoge1xuICAgIGRlZmVyPzogYm9vbGVhbjtcbiAgICBpZD86IHN0cmluZztcbiAgICBub25jZT86IHN0cmluZztcbiAgICB0eXBlPzogc3RyaW5nO1xuICB9ID0ge30sXG4pOiBTYWZlSHRtbCB7XG4gIGNvbnN0IHVud3JhcHBlZFNjcmlwdCA9IHVud3JhcFNjcmlwdChzY3JpcHQpLnRvU3RyaW5nKCk7XG4gIGxldCBzdHJpbmdUYWcgPSBgPHNjcmlwdGA7XG4gIGlmIChvcHRpb25zLmlkKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgaWQ9XCIke2h0bWxFc2NhcGVUb1N0cmluZyhvcHRpb25zLmlkKX1cImA7XG4gIH1cbiAgaWYgKG9wdGlvbnMubm9uY2UpIHtcbiAgICBzdHJpbmdUYWcgKz0gYCBub25jZT1cIiR7aHRtbEVzY2FwZVRvU3RyaW5nKG9wdGlvbnMubm9uY2UpfVwiYDtcbiAgfVxuICBpZiAob3B0aW9ucy50eXBlKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgdHlwZT1cIiR7aHRtbEVzY2FwZVRvU3RyaW5nKG9wdGlvbnMudHlwZSl9XCJgO1xuICB9XG4gIGlmIChvcHRpb25zLmRlZmVyKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgZGVmZXJgO1xuICB9XG4gIHN0cmluZ1RhZyArPSBgPiR7dW53cmFwcGVkU2NyaXB0fVxcdTAwM0Mvc2NyaXB0PmA7XG4gIHJldHVybiBjcmVhdGVIdG1sSW50ZXJuYWwoc3RyaW5nVGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFNhZmVIdG1sYCByZXByZXNlbnRpbmcgYSBzY3JpcHQgdGFnIHdpdGggdGhlIHNyYyBhdHRyaWJ1dGUuXG4gKiBUaGlzIGFsc28gc3VwcG9ydHMgQ1NQIG5vbmNlcyBhbmQgYXN5bmMgbG9hZGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcmlwdFVybFRvSHRtbChcbiAgc3JjOiBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIG9wdGlvbnM6IHtcbiAgICBhc3luYz86IGJvb2xlYW47XG4gICAgY3VzdG9tRWxlbWVudD86IHN0cmluZztcbiAgICBkZWZlcj86IGJvb2xlYW47XG4gICAgaWQ/OiBzdHJpbmc7XG4gICAgbm9uY2U/OiBzdHJpbmc7XG4gICAgdHlwZT86IHN0cmluZztcbiAgICBjcm9zc29yaWdpbj86ICdhbm9ueW1vdXMnIHwgJ3VzZS1jcmVkZW50aWFscyc7XG4gIH0gPSB7fSxcbik6IFNhZmVIdG1sIHtcbiAgY29uc3QgdW53cmFwcGVkU3JjID0gdW53cmFwUmVzb3VyY2VVcmwoc3JjKS50b1N0cmluZygpO1xuICBsZXQgc3RyaW5nVGFnID0gYDxzY3JpcHQgc3JjPVwiJHtodG1sRXNjYXBlVG9TdHJpbmcodW53cmFwcGVkU3JjKX1cImA7XG4gIGlmIChvcHRpb25zLmFzeW5jKSB7XG4gICAgc3RyaW5nVGFnICs9ICcgYXN5bmMnO1xuICB9XG4gIGlmIChvcHRpb25zLmN1c3RvbUVsZW1lbnQpIHtcbiAgICBzdHJpbmdUYWcgKz0gYCBjdXN0b20tZWxlbWVudD1cIiR7aHRtbEVzY2FwZVRvU3RyaW5nKFxuICAgICAgb3B0aW9ucy5jdXN0b21FbGVtZW50LFxuICAgICl9XCJgO1xuICB9XG4gIGlmIChvcHRpb25zLmRlZmVyKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgZGVmZXJgO1xuICB9XG4gIGlmIChvcHRpb25zLmlkKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgaWQ9XCIke2h0bWxFc2NhcGVUb1N0cmluZyhvcHRpb25zLmlkKX1cImA7XG4gIH1cbiAgaWYgKG9wdGlvbnMubm9uY2UpIHtcbiAgICBzdHJpbmdUYWcgKz0gYCBub25jZT1cIiR7aHRtbEVzY2FwZVRvU3RyaW5nKG9wdGlvbnMubm9uY2UpfVwiYDtcbiAgfVxuICBpZiAob3B0aW9ucy50eXBlKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgdHlwZT1cIiR7aHRtbEVzY2FwZVRvU3RyaW5nKG9wdGlvbnMudHlwZSl9XCJgO1xuICB9XG4gIGlmIChvcHRpb25zLmNyb3Nzb3JpZ2luKSB7XG4gICAgc3RyaW5nVGFnICs9IGAgY3Jvc3NvcmlnaW49XCIke2h0bWxFc2NhcGVUb1N0cmluZyhvcHRpb25zLmNyb3Nzb3JpZ2luKX1cImA7XG4gIH1cbiAgc3RyaW5nVGFnICs9ICc+XFx1MDAzQy9zY3JpcHQ+JztcbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChzdHJpbmdUYWcpO1xufVxuXG4vKipcbiAqIEhUTUwtZXNjYXBlcyB0aGUgZ2l2ZW4gdGV4dCAoYCZgLCBgPGAsIGA+YCwgYFwiYCBhbmQgYCdgKS5cbiAqL1xuZnVuY3Rpb24gaHRtbEVzY2FwZVRvU3RyaW5nKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGVzY2FwZWQgPSB0ZXh0XG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7Jyk7XG4gIHJldHVybiBlc2NhcGVkO1xufVxuXG4vKiogQ3JlYXRlcyBhIGBTYWZlSHRtbGAgdmFsdWUgYnkgY29uY2F0ZW5hdGluZyBtdWx0aXBsZSBgU2FmZUh0bWxgcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRIdG1scyhodG1sczogUmVhZG9ubHlBcnJheTxTYWZlSHRtbCB8IHN0cmluZz4pOiBTYWZlSHRtbCB7XG4gIHJldHVybiBqb2luSHRtbHMoJycsIGh0bWxzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFNhZmVIdG1sYCB2YWx1ZSBieSBjb25jYXRlbmF0aW5nIG11bHRpcGxlIGBTYWZlSHRtbGBzIGludGVybGVhdmVkXG4gKiB3aXRoIGEgc2VwYXJhdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gam9pbkh0bWxzKFxuICBzZXBhcmF0b3I6IFNhZmVIdG1sIHwgc3RyaW5nLFxuICBodG1sczogUmVhZG9ubHlBcnJheTxTYWZlSHRtbCB8IHN0cmluZz4sXG4pOiBTYWZlSHRtbCB7XG4gIGNvbnN0IHNlcGFyYXRvckh0bWwgPSBodG1sRXNjYXBlKHNlcGFyYXRvcik7XG4gIHJldHVybiBjcmVhdGVIdG1sSW50ZXJuYWwoXG4gICAgaHRtbHNcbiAgICAgIC5tYXAoKHZhbHVlKSA9PiB1bndyYXBIdG1sKGh0bWxFc2NhcGUodmFsdWUpKSlcbiAgICAgIC5qb2luKHVud3JhcEh0bWwoc2VwYXJhdG9ySHRtbCkudG9TdHJpbmcoKSksXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBTYWZlSHRtbGAgdGhhdCBjb250YWlucyBgPCFET0NUWVBFIGh0bWw+YC5cbiAqIFRoaXMgaXMgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgdGhlIGRlZmluaXRpb24gb2YgYSBUcnVzdGVkIFR5cGVcbiAqIHBvbGljeSB3aGVuIHNpbXBseSBpbXBvcnRpbmcgc2FmZXZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvY3R5cGVIdG1sKCk6IFNhZmVIdG1sIHtcbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbCgnPCFET0NUWVBFIGh0bWw+Jyk7XG59XG5cbi8qKlxuICogTm9uLWV4cG9ydGVkIHZlcnNpb24gb2YgYG5vZGVUb0h0bWxgLCB3aXRoIGFuIGV4cGxpY2l0IHRlbXBvcmFyeSByb290IHRvXG4gKiBhY2NvbW9kYXRlIGZvciB0aGUgc2FuaXRpemVyJ3MgdXNlciBjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVRvSHRtbEludGVybmFsKFxuICBub2RlOiBOb2RlLFxuICB0ZW1wb3JhcnlSb290OiBFbGVtZW50LFxuKTogU2FmZUh0bWwge1xuICB0ZW1wb3JhcnlSb290LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gIC8vIFhNTCBzZXJpYWxpemF0aW9uIGlzIHByZWZlcnJlZCBvdmVyIEhUTUwgc2VyaWFsaXphdGlvbiBhcyBpdCBpc1xuICAvLyBzdHJpY3RlciBhbmQgbWFrZXMgc3VyZSBhbGwgYXR0cmlidXRlcyBhcmUgcHJvcGVybHkgZXNjYXBlZCwgYXZvaWRpbmdcbiAgLy8gY2FzZXMgd2hlcmUgdGhlIHRyZWUgbWlnaHQgbXV0YXRlIHdoZW4gcGFyc2VkIGFnYWluIGxhdGVyIGR1ZSB0byB0aGVcbiAgLy8gY29tcGxleGl0aWVzIG9mIHRoZSBIVE1MIHBhcnNpbmcgYWxnb3JpdGhtXG4gIGxldCBzZXJpYWxpemVkTmV3VHJlZSA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGVtcG9yYXJ5Um9vdCk7XG4gIC8vIFdlIHJlbW92ZSB0aGUgb3V0ZXIgbW9zdCBlbGVtZW50IGFzIHRoaXMgaXMgdGhlIHNwYW4gbm9kZSBjcmVhdGVkIGFzXG4gIC8vIHRoZSByb290IGZvciB0aGUgc2FuaXRpemVkIHRyZWUgYW5kIGNvbnRhaW5zIGEgc3B1cmlvdXMgeG1sbnMgYXR0cmlidXRlXG4gIC8vIGZyb20gdGhlIFhNTCBzZXJpYWxpemF0aW9uIHN0ZXAuXG4gIHNlcmlhbGl6ZWROZXdUcmVlID0gc2VyaWFsaXplZE5ld1RyZWUuc2xpY2UoXG4gICAgc2VyaWFsaXplZE5ld1RyZWUuaW5kZXhPZignPicpICsgMSxcbiAgICBzZXJpYWxpemVkTmV3VHJlZS5sYXN0SW5kZXhPZignPC8nKSxcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChzZXJpYWxpemVkTmV3VHJlZSk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyBhIE5vZGUgaW50byBpdCdzIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gKlxuICogTm90ZTogdGhpcyBtZXRob2QgdXNlcyBzdHJpY3QgWE1MIHNlcmlhbGl6YXRpb24gdG8gbWl0aWdhdGUgbXV0YXRpb24gaXNzdWVzXG4gKiB3aGVuIHRoZSBodG1sIGlzIHRoZW4gcmUtcGFyc2VkIGJ5IHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVRvSHRtbChub2RlOiBOb2RlKTogU2FmZUh0bWwge1xuICBjb25zdCB0ZW1wUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgcmV0dXJuIG5vZGVUb0h0bWxJbnRlcm5hbChub2RlLCB0ZW1wUm9vdCk7XG59XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIFR5cGUgZm9yIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW4gU2FmZUh0bWwgYnVpbGRlcnMuIFNhZmVTdHlsZSBhbmQgU2FmZVVybCBhcmVcbiAqIGluIGZvciBsZWdhY3kgcmVhc29ucy5cbiAqL1xuZXhwb3J0IHR5cGUgQXR0cmlidXRlVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBTYWZlVXJsIHwgU2FmZVN0eWxlO1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgdW5pb24gb2YgdHlwZXMgdGhhdCBjYW4gc2Vuc2libHkgYmUgY29udmVydGVkIHRvIHN0cmluZ3NcbiAqIG9yIG1pZ2h0IGFscmVhZHkgYmUgU2FmZUh0bWwuXG4gKi9cbnR5cGUgVGV4dE9ySHRtbCA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBTYWZlSHRtbDtcblxuY29uc3QgVkFMSURfVEFHX09SX0FUVFJJQlVURV9OQU1FUyA9IC9eW2Etel1bYS16XFxkLV0qJC9pO1xuXG4vKipcbiAqIFRhZ3Mgd2hpY2ggYXJlIHVuc3VwcG9ydGVkIHZpYSBjcmVhdGVIdG1sKCkuIFRoZXkgbWlnaHQgYmVcbiAqIHN1cHBvcnRlZCB2aWEgYSB0YWctc3BlY2lmaWMgY3JlYXRlIG1ldGhvZC4gVGhlc2UgYXJlIHRhZ3Mgd2hpY2ggbWlnaHRcbiAqIHJlcXVpcmUgYSBUcnVzdGVkUmVzb3VyY2VVcmwgaW4gb25lIG9mIHRoZWlyIGF0dHJpYnV0ZXMgb3IgYSByZXN0cmljdGVkXG4gKiB0eXBlIGZvciB0aGVpciBjb250ZW50LlxuICovXG5jb25zdCBESVNBTExPV0VEX1RBR19OQU1FUyA9IFtcbiAgJ0FQUExFVCcsXG4gICdCQVNFJyxcbiAgJ0VNQkVEJyxcbiAgJ0lGUkFNRScsXG4gICdMSU5LJyxcbiAgJ01BVEgnLFxuICAnTUVUQScsXG4gICdPQkpFQ1QnLFxuICAnU0NSSVBUJyxcbiAgJ1NUWUxFJyxcbiAgJ1NWRycsXG4gICdURU1QTEFURScsXG5dO1xuXG4vKiogTGlzdCBvZiB2b2lkIHRhZ3MuICovXG5leHBvcnQgY29uc3QgVk9JRF9UQUdfTkFNRVMgPSBbXG4gICdBUkVBJyxcbiAgJ0JSJyxcbiAgJ0NPTCcsXG4gICdDT01NQU5EJyxcbiAgJ0hSJyxcbiAgJ0lNRycsXG4gICdJTlBVVCcsXG4gICdLRVlHRU4nLFxuICAnUEFSQU0nLFxuICAnU09VUkNFJyxcbiAgJ1RSQUNLJyxcbiAgJ1dCUicsXG5dO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdGhhdCBjYW4gY2F1c2UgdGhlIGV4ZWN1dGlvbiBvZiBqYXZhc2NyaXB0OiBVUkxzLlxuICovXG5jb25zdCBVUkxfQVRUUklCVVRFUyA9IFsnYWN0aW9uJywgJ2Zvcm1hY3Rpb24nLCAnaHJlZiddO1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSB0YWcgbmFtZSBpcyB2YWxpZCBhbmQgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIGNvbnRleHQuXG4gKiBFLmcuIFNUUk9ORyBpcyBmaW5lIGJ1dCBTQ1JJUFQgdGhyb3dzIGJlY2F1c2UgaXQgY2hhbmdlcyBjb250ZXh0LiBTZWVcbiAqIGNyZWF0ZUh0bWwgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIGFsbG93ZWQgdGFncy5cbiAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCB0YWcgbmFtZSBpcyBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVRhZ05hbWUodGFnTmFtZTogc3RyaW5nKSB7XG4gIGlmICghVkFMSURfVEFHX09SX0FUVFJJQlVURV9OQU1FUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERFVl9NT0RFID8gYEludmFsaWQgdGFnIG5hbWUgPCR7dGFnTmFtZX0+LmAgOiAnJyk7XG4gIH1cbiAgaWYgKERJU0FMTE9XRURfVEFHX05BTUVTLmluZGV4T2YodGFnTmFtZS50b1VwcGVyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBERVZfTU9ERSA/IGBUYWcgbmFtZSA8JHt0YWdOYW1lfT4gaXMgbm90IGFsbG93ZWQgZm9yIGNyZWF0ZUh0bWwuYCA6ICcnLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBuYW1lIGlzIGEgdm9pZCB0YWcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZvaWRUYWcodGFnTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBWT0lEX1RBR19OQU1FUy5pbmRleE9mKHRhZ05hbWUudG9VcHBlckNhc2UoKSkgIT09IC0xO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlSHRtbCBjb250ZW50IGNvbnNpc3Rpbmcgb2YgYSB0YWcgd2l0aCBvcHRpb25hbCBhdHRyaWJ1dGVzIGFuZFxuICogb3B0aW9uYWwgY29udGVudC5cbiAqIFRoaXMgaXMgcm91Z2hseSBlcXVpdmFsZW50IHRvIENsb3N1cmUncyBnb29nLmh0bWwuU2FmZUh0bWwuY3JlYXRlIGZ1bmN0aW9uLFxuICogd2l0aCBhIGZldyBkcm9wcGVkIGZlYXR1cmVzLCBsaWtlIENvbnN0IHN0cmluZ3MuIEl0IGlzIGRpc2NvdXJhZ2VkIGZvciBuZXdcbiAqIHVzYWdlcy4gUHJlZmVyIHVzaW5nIGEgcmVjb21tZW5kZWQgdGVtcGxhdGluZyBzeXN0ZW0gbGlrZSBMaXQgaW5zdGVhZC5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqIGNyZWF0ZUh0bWwoJ2JyJyk7XG4gKiBjcmVhdGVIdG1sKCdkaXYnLCB7J2NsYXNzJzogJ2EnfSk7XG4gKiBjcmVhdGVIdG1sKCdwJywge30sICdhJyk7XG4gKiBjcmVhdGVIdG1sKCdwJywge30sIGNyZWF0ZUh0bWwoJ2JyJykpO1xuICpcbiAqIGNyZWF0ZUh0bWwoJ3NwYW4nLCB7XG4gKiAgICdzdHlsZSc6IHsnbWFyZ2luJzogJzAnfVxuICogfSk7XG4gKlxuICogVG8gZ3VhcmFudGVlIFNhZmVIdG1sJ3MgdHlwZSBjb250cmFjdCBpcyB1cGhlbGQgdGhlcmUgYXJlIHJlc3RyaWN0aW9ucyBvblxuICogYXR0cmlidXRlIHZhbHVlcyBhbmQgdGFnIG5hbWVzLlxuICpcbiAqIC0gQXR0cmlidXRlcyB3aGljaCBjb250YWluIHNjcmlwdCBjb2RlIChlLmcuIG9uKikgYXJlIGRpc2FsbG93ZWQuXG4gKiAtIEZvciBhdHRyaWJ1dGVzIHdoaWNoIGFyZSBpbnRlcnByZXRlZCBhcyBVUkxzIChlLmcuIHNyYywgaHJlZiksIHRoZSBVUkxcbiAqIHdpbGwgYmUgc2FuaXRpemVkIHdpdGggamF2YXNjcmlwdDogVVJMcyBibG9ja2VkLlxuICogLSBUYWdzIHdoaWNoIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgZnVuY3Rpb24gYXJlIGFwcGxldCwgYmFzZSwgZW1iZWQsXG4gKiAgIGlmcmFtZSwgbGluaywgbWF0aCwgbWV0YSwgb2JqZWN0LCBzY3JpcHQsIHN0eWxlLCBzdmcsIGFuZCB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUh0bWwoXG4gIHRhZ05hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlcz86IHtbYXR0ck5hbWU6IHN0cmluZ106IEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkfSxcbiAgY29udGVudD86IFRleHRPckh0bWwgfCBUZXh0T3JIdG1sW10sXG4pOiBTYWZlSHRtbCB7XG4gIHZlcmlmeVRhZ05hbWUodGFnTmFtZSk7XG4gIGxldCByZXN1bHQgPSBgPCR7dGFnTmFtZX1gO1xuICBpZiAoYXR0cmlidXRlcykge1xuICAgIHJlc3VsdCArPSBzdHJpbmdpZnlBdHRyaWJ1dGVzKHRhZ05hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgIGNvbnRlbnQgPSBjb250ZW50ID09PSB1bmRlZmluZWQgPyBbXSA6IFtjb250ZW50XTtcbiAgfVxuXG4gIGlmIChpc1ZvaWRUYWcodGFnTmFtZSkpIHtcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWb2lkIHRhZyA8JHt0YWdOYW1lfT4gZG9lcyBub3QgYWxsb3cgY29udGVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ICs9ICc+JztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodG1sID0gY29uY2F0SHRtbHMoXG4gICAgICBjb250ZW50Lm1hcCgodmFsdWUpID0+XG4gICAgICAgIGlzSHRtbCh2YWx1ZSkgPyB2YWx1ZSA6IGh0bWxFc2NhcGUoU3RyaW5nKHZhbHVlKSksXG4gICAgICApLFxuICAgICk7XG4gICAgcmVzdWx0ICs9ICc+JyArIGh0bWwudG9TdHJpbmcoKSArICc8LycgKyB0YWdOYW1lICsgJz4nO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChyZXN1bHQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlSHRtbCByZXByZXNlbnRpbmcgYSBzdHlsZSB0YWcuIFRoZSB0eXBlIGF0dHJpYnV0ZSBpcyBzZXRcbiAqIHRvIFwidGV4dC9jc3NcIi5cbiAqIEBwYXJhbSBzdHlsZVNoZWV0IENvbnRlbnQgdG8gcHV0IGluc2lkZSB0aGUgdGFnLiBBcnJheSBlbGVtZW50cyBhcmVcbiAqICAgICBjb25jYXRlbmF0ZWQuXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBNYXBwaW5nIGZyb20gYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIHZhbHVlcy4gT25seVxuICogICAgIGF0dHJpYnV0ZSBuYW1lcyBjb25zaXN0aW5nIG9mIFthLXpBLVowLTktXSBhcmUgYWxsb3dlZC4gVmFsdWUgb2ZcbiAqICAgICB1bmRlZmluZWQgY2F1c2VzIHRoZSBhdHRyaWJ1dGUgdG8gYmUgb21pdHRlZC5cbiAqIEByZXR1cm4gVGhlIFNhZmVIdG1sIGNvbnRlbnQgd2l0aCB0aGUgdGFnLlxuICogQHRocm93cyB7IUVycm9yfSBJZiBpbnZhbGlkIGF0dHJpYnV0ZSBuYW1lIG9yIGF0dHJpYnV0ZSB2YWx1ZSBpcyBwcm92aWRlZCBvclxuICogICAgIGlmIGF0dHJpYnV0ZXMgY29udGFpbnMgdGhlIHR5cGUgYXR0cmlidXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVTaGVldFRvSHRtbChcbiAgc3R5bGVTaGVldDogU2FmZVN0eWxlU2hlZXQgfCBTYWZlU3R5bGVTaGVldFtdLFxuICBhdHRyaWJ1dGVzPzoge1thdHRyTmFtZTogc3RyaW5nXTogQXR0cmlidXRlVmFsdWUgfCB1bmRlZmluZWR9LFxuKTogU2FmZUh0bWwge1xuICBjb25zdCBjb21iaW5lZEF0dHJpYnV0ZXM6IHtbYXR0ck5hbWU6IHN0cmluZ106IEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkfSA9XG4gICAge307XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgY3VzdG9tQXR0ck5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21BdHRyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBjdXN0b21BdHRyTmFtZXNbaV07XG4gICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSAndHlwZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIERFVl9NT0RFXG4gICAgICAgICAgICA/IGBDYW5ub3Qgb3ZlcnJpZGUgdGhlICd0eXBlJyBhdHRyaWJ1dGUgd2l0aCB2YWx1ZSAke2F0dHJpYnV0ZXNbbmFtZV19LmBcbiAgICAgICAgICAgIDogJycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb21iaW5lZEF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgIH1cbiAgfVxuICBjb21iaW5lZEF0dHJpYnV0ZXNbJ3R5cGUnXSA9ICd0ZXh0L2Nzcyc7XG5cbiAgY29uc3Qgc3RyaW5naWZpZWRBdHRyaWJ1dGVzID0gc3RyaW5naWZ5QXR0cmlidXRlcyhcbiAgICAnc3R5bGUnLFxuICAgIGNvbWJpbmVkQXR0cmlidXRlcyxcbiAgKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVTaGVldCkpIHtcbiAgICBzdHlsZVNoZWV0ID0gY29uY2F0U3R5bGVTaGVldHMoc3R5bGVTaGVldCk7XG4gIH1cbiAgY29uc3Qgc3R5bGVDb250ZW50ID0gdW53cmFwU3R5bGVTaGVldChzdHlsZVNoZWV0KTtcbiAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChcbiAgICBgPHN0eWxlICR7c3RyaW5naWZpZWRBdHRyaWJ1dGVzfT4ke3N0eWxlQ29udGVudH08L3N0eWxlPmAsXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyB3aXRoIGF0dHJpYnV0ZXMgdG8gaW5zZXJ0IGFmdGVyIHRhZ05hbWUuXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGF0dHJpYnV0ZSB2YWx1ZSBpcyB1bnNhZmUgZm9yIHRoZSBnaXZlbiB0YWcgYW5kXG4gKiAgICAgYXR0cmlidXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlcyhcbiAgdGFnTmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiB7W2F0dHJOYW1lOiBzdHJpbmddOiBBdHRyaWJ1dGVWYWx1ZSB8IHVuZGVmaW5lZH0sXG4pOiBzdHJpbmcge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGNvbnN0IGF0dHJOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyTmFtZXNbaV07XG4gICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmICghVkFMSURfVEFHX09SX0FUVFJJQlVURV9OQU1FUy50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoREVWX01PREUgPyBgSW52YWxpZCBhdHRyaWJ1dGUgbmFtZSBcIiR7bmFtZX1cIi5gIDogJycpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdCArPSAnICcgKyBnZXRBdHRyTmFtZUFuZFZhbHVlKHRhZ05hbWUsIG5hbWUsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyTmFtZUFuZFZhbHVlKFxuICB0YWdOYW1lOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IEF0dHJpYnV0ZVZhbHVlLFxuKTogc3RyaW5nIHtcbiAgaWYgKC9eb24vaS50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgREVWX01PREVcbiAgICAgICAgPyBgQXR0cmlidXRlIFwiJHtuYW1lfSBpcyBmb3JiaWRkZW4uIElubGluZSBldmVudCBoYW5kbGVycyBjYW4gbGVhZCB0byBYU1MuIFBsZWFzZSB1c2UgdGhlICdhZGRFdmVudExpc3RlbmVyJyBBUEkgaW5zdGVhZC5gXG4gICAgICAgIDogJycsXG4gICAgKTtcbiAgfSBlbHNlIGlmIChVUkxfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUudG9Mb3dlckNhc2UoKSkgIT09IC0xKSB7XG4gICAgaWYgKGlzVXJsKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHNhbml0aXplSmF2YVNjcmlwdFVybChTdHJpbmcodmFsdWUpKSB8fCAnYWJvdXQ6aW52YWxpZCN6Q2xvc3VyZXonO1xuICAgIH1cbiAgfVxuICBpZiAoREVWX01PREUpIHtcbiAgICBpZiAoXG4gICAgICAhaXNVcmwodmFsdWUpICYmXG4gICAgICAhaXNIdG1sKHZhbHVlKSAmJlxuICAgICAgIWlzU3R5bGUodmFsdWUpICYmXG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBTdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGV4cGVjdGVkLCBnb3QgJHt0eXBlb2YgdmFsdWV9IHdpdGggdmFsdWUgJyR7dmFsdWV9JyBnaXZlbi5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGAke25hbWV9PVwiJHtodG1sRXNjYXBlKFN0cmluZyh2YWx1ZSkpfVwiYDtcbn1cbi8vIEVORC1JTlRFUk5BTFxuIl19
;return exports;});

//third_party/javascript/safevalues/builders/html_formatter.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview SafeHtml builder API to make it possible to use goog.getMsg
 * safely with HTML.
 * Generated from: third_party/javascript/safevalues/builders/html_formatter.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_formatter');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_formatter.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_html_builders_3 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_builders");
const tsickle_SafeHtml_4 = goog.requireType("goog.html.SafeHtml");
const tsickle_url_impl_5 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_SafeStyle_6 = goog.requireType("goog.html.SafeStyle");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
const html_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_builders');
/**
 * @record
 */
function HtmlReplacement() { }
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    HtmlReplacement.prototype.type;
    /**
     * @type {string}
     * @public
     */
    HtmlReplacement.prototype.html;
}
/**
 * @record
 */
function StartTagReplacement() { }
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    StartTagReplacement.prototype.type;
    /**
     * @type {string}
     * @public
     */
    StartTagReplacement.prototype.tagName;
    /**
     * @type {string}
     * @public
     */
    StartTagReplacement.prototype.attributes;
}
/**
 * @record
 */
function EndTagReplacement() { }
/* istanbul ignore if */
if (false) {
    /**
     * @type {string}
     * @public
     */
    EndTagReplacement.prototype.type;
    /**
     * @type {string}
     * @public
     */
    EndTagReplacement.prototype.tagName;
}
/** @typedef {(!HtmlReplacement|!StartTagReplacement|!EndTagReplacement)} */
var Replacement;
/**
 * Marker used for replacements.
 * @type {string}
 */
const MARKER = '_safevalues_format_marker_:';
/**
 * Formatter producing SafeHtml from a plain text format and HTML fragments.
 * Example usage:
 * const formatter = new HtmlFormatter();
 * const safeHtml = formatter.format(
 *     formatter.startTag('b') +
 *     'User input:' +
 *     formatter.endTag('b') +
 *     ' ' +
 *     formatter.text(userInput));
 * The most common usage is with goog.getMsg:
 * const MSG_USER_INPUT = goog.getMsg(
 *     '{$startLink}Learn more{$endLink} about {$userInput}', {
 *       'startLink': formatter.startTag('a', {'href': url}),
 *       'endLink': formatter.endTag('a'),
 *       'userInput': formatter.text(userInput)
 *     });
 * const safeHtml = formatter.format(MSG_USER_INPUT);
 * The formatting string should be constant with all variables processed by
 * formatter.text().
 * @final
 */
class HtmlFormatter {
    constructor() {
        this.replacements = new Map();
    }
    /**
     * Formats a plain text string with markers holding HTML fragments to
     * SafeHtml.
     * @public
     * @param {string} format
     * @return {!tsickle_SafeHtml_4}
     */
    format(format) {
        /** @type {!Array<string>} */
        const openedTags = [];
        /** @type {string} */
        const marker = (0, html_builders_1.htmlEscape)(MARKER).toString();
        /** @type {string} */
        const html = (0, html_builders_1.htmlEscape)(format)
            .toString()
            .replace(new RegExp(`\\{${marker}[\\w&#;]+\\}`, 'g'), (/**
         * @param {string} match
         * @return {string}
         */
        (match) => this.replaceFormattingString(openedTags, match)));
        if (openedTags.length !== 0) {
            if (dev_1.DEV_MODE) {
                throw new Error('Expected no unclosed tags, got <' + openedTags.join('>, <') + '>.');
            }
            else {
                throw new Error();
            }
        }
        return (0, html_impl_1.createHtmlInternal)(html);
    }
    /**
     * Replaces found formatting strings with saved tags.
     * @private
     * @param {!Array<string>} openedTags
     * @param {string} match
     * @return {string}
     */
    replaceFormattingString(openedTags, match) {
        /** @type {(undefined|!HtmlReplacement|!StartTagReplacement|!EndTagReplacement)} */
        const replacement = this.replacements.get(match);
        if (!replacement) {
            // Someone included a string looking like our internal marker in the
            // format.
            return match;
        }
        /** @type {string} */
        let result = '';
        switch (replacement.type) {
            case 'html':
                result = (/** @type {!HtmlReplacement} */ (replacement)).html;
                break;
            case 'startTag':
                result = `<${(/** @type {!StartTagReplacement} */ (replacement)).tagName}${(/** @type {!StartTagReplacement} */ (replacement)).attributes}>`;
                if (dev_1.DEV_MODE) {
                    if (!(0, html_builders_1.isVoidTag)((/** @type {!StartTagReplacement} */ (replacement)).tagName.toLowerCase())) {
                        openedTags.push((/** @type {!StartTagReplacement} */ (replacement)).tagName.toLowerCase());
                    }
                }
                break;
            case 'endTag':
                result = `</${(/** @type {!EndTagReplacement} */ (replacement)).tagName}>`;
                if (dev_1.DEV_MODE) {
                    /** @type {(undefined|string)} */
                    const lastTag = openedTags.pop();
                    if (lastTag !== (/** @type {!EndTagReplacement} */ (replacement)).tagName.toLowerCase()) {
                        throw new Error(`Expected </${lastTag}>, got </${(/** @type {!EndTagReplacement} */ (replacement)).tagName}>.`);
                    }
                }
                break;
            default:
                if (dev_1.DEV_MODE) {
                    checkExhaustive(replacement, 'type had an unknown value');
                }
        }
        return result;
    }
    /**
     * Saves a start tag and returns its marker.
     * @throws {!Error} If invalid tag name, attribute name, or attribute value is
     *     provided. This function accepts the same tags and attributes as
     *     safevalues.createHtml.
     * @public
     * @param {string} tagName
     * @param {(undefined|!Object<string,(undefined|string|number|!tsickle_url_impl_5.SafeUrl|!tsickle_SafeStyle_6)>)=} attributes
     *     Mapping from attribute names to their values. Only attribute names
     *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined
     * causes the attribute to be omitted.
     * @return {string}
     */
    startTag(tagName, attributes) {
        (0, html_builders_1.verifyTagName)(tagName);
        return this.storeReplacement({
            type: 'startTag',
            tagName,
            attributes: attributes !== undefined
                ? (0, html_builders_1.stringifyAttributes)(tagName, attributes)
                : '',
        });
    }
    /**
     * Saves an end tag and returns its marker.
     * @throws {!Error} If invalid tag name, attribute name, or attribute value is
     *     provided. This function accepts the same tags as {\@link
     *     safevalues.createHtml}.
     * @public
     * @param {string} tagName
     * @return {string}
     */
    endTag(tagName) {
        (0, html_builders_1.verifyTagName)(tagName);
        return this.storeReplacement({ type: 'endTag', tagName });
    }
    /**
     * Escapes a text, saves it and returns its marker.
     *
     * Wrapping any user input to .text() prevents the attacker with access to
     * the random number generator to duplicate tags used elsewhere in the format.
     * @public
     * @param {string} text
     * @return {string}
     */
    text(text) {
        return this.storeReplacement({
            type: 'html',
            html: (0, html_builders_1.htmlEscape)(text).toString(),
        });
    }
    /**
     * Saves SafeHtml and returns its marker.
     * @public
     * @param {!tsickle_SafeHtml_4} safeHtml
     * @return {string}
     */
    safeHtml(safeHtml) {
        return this.storeReplacement({
            type: 'html',
            html: (0, html_impl_1.unwrapHtml)(safeHtml).toString(),
        });
    }
    /**
     * Stores a replacement and returns its marker.
     * @private
     * @param {(!HtmlReplacement|!StartTagReplacement|!EndTagReplacement)} replacement
     * @return {string}
     */
    storeReplacement(replacement) {
        /** @type {string} */
        const marker = `{${MARKER}${this.replacements.size}_${getRandomString()}}`;
        this.replacements.set((0, html_builders_1.htmlEscape)(marker).toString(), replacement);
        return marker;
    }
}
exports.HtmlFormatter = HtmlFormatter;
/* istanbul ignore if */
if (false) {
    /**
     * @const {!Map<string, (!HtmlReplacement|!StartTagReplacement|!EndTagReplacement)>}
     * @private
     */
    HtmlFormatter.prototype.replacements;
}
/**
 * @return {string}
 */
function getRandomString() {
    return Math.random().toString(36).slice(2);
}
/**
 * @param {?} value
 * @param {string=} msg
 * @return {?}
 */
function checkExhaustive(value, msg = `unexpected value ${value}!`) {
    throw new Error(msg);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF9mb3JtYXR0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvaHRtbF9mb3JtYXR0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUEsd0ZBQTRDO0FBQzVDLGtHQUFnRjtBQUVoRix5R0FNeUI7Ozs7QUFFekIsOEJBR0M7Ozs7Ozs7SUFGQywrQkFBYTs7Ozs7SUFDYiwrQkFBYTs7Ozs7QUFHZixrQ0FJQzs7Ozs7OztJQUhDLG1DQUFpQjs7Ozs7SUFDakIsc0NBQWdCOzs7OztJQUNoQix5Q0FBbUI7Ozs7O0FBR3JCLGdDQUdDOzs7Ozs7O0lBRkMsaUNBQWU7Ozs7O0lBQ2Ysb0NBQWdCOzs7QUFHbEIsZ0JBQTZFOzs7OztNQUd2RSxNQUFNLEdBQUcsNkJBQTZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCNUMsTUFBYSxhQUFhO0lBQTFCO1FBQ21CLGlCQUFZLEdBQUcsSUFBSSxHQUFHLEVBQXVCLENBQUM7SUF3SWpFLENBQUM7Ozs7Ozs7O0lBbElDLE1BQU0sQ0FBQyxNQUFjOztjQUNiLFVBQVUsR0FBYSxFQUFFOztjQUN6QixNQUFNLEdBQUcsSUFBQSwwQkFBVSxFQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRTs7Y0FDdEMsSUFBSSxHQUFHLElBQUEsMEJBQVUsRUFBQyxNQUFNLENBQUM7YUFDNUIsUUFBUSxFQUFFO2FBQ1YsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sTUFBTSxjQUFjLEVBQUUsR0FBRyxDQUFDOzs7O1FBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUM5RCxJQUFJLENBQUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxFQUNoRDtRQUNILElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUM1QixJ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LElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztZQUMzQixJQUFJLEVBQUUsTUFBTTtZQUNaLElBQUksRUFBRSxJQUFBLDBCQUFVLEVBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFO1NBQ2xDLENBQUMsQ0FBQztJQUNMLENBQUM7Ozs7Ozs7SUFLRCxRQUFRLENBQUMsUUFBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7WUFDM0IsSUFBSSxFQUFFLE1BQU07WUFDWixJQUFJLEVBQUUsSUFBQSxzQkFBVSxFQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsRUFBRTtTQUN0QyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7O0lBS08sZ0JBQWdCLENBQUMsV0FBd0I7O2NBQ3pDLE1BQU0sR0FBRyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxlQUFlLEVBQUUsR0FBRztRQUMxRSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFBLDBCQUFVLEVBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDbEUsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGO0FBeklELHNDQXlJQzs7Ozs7OztJQXhJQyxxQ0FBK0Q7Ozs7O0FBMElqRSxTQUFTLGVBQWU7SUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QyxDQUFDOzs7Ozs7QUFFRCxTQUFTLGVBQWUsQ0FDdEIsS0FBWSxFQUNaLEdBQUcsR0FBRyxvQkFBb0IsS0FBSyxHQUFHO0lBRWxDLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNhZmVIdG1sIGJ1aWxkZXIgQVBJIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdvb2cuZ2V0TXNnXG4gKiBzYWZlbHkgd2l0aCBIVE1MLlxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uL2Vudmlyb25tZW50L2Rldic7XG5pbXBvcnQge2NyZWF0ZUh0bWxJbnRlcm5hbCwgU2FmZUh0bWwsIHVud3JhcEh0bWx9IGZyb20gJy4uL2ludGVybmFscy9odG1sX2ltcGwnO1xuXG5pbXBvcnQge1xuICBBdHRyaWJ1dGVWYWx1ZSxcbiAgaHRtbEVzY2FwZSxcbiAgaXNWb2lkVGFnLFxuICBzdHJpbmdpZnlBdHRyaWJ1dGVzLFxuICB2ZXJpZnlUYWdOYW1lLFxufSBmcm9tICcuL2h0bWxfYnVpbGRlcnMnO1xuXG5pbnRlcmZhY2UgSHRtbFJlcGxhY2VtZW50IHtcbiAgdHlwZTogJ2h0bWwnO1xuICBodG1sOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTdGFydFRhZ1JlcGxhY2VtZW50IHtcbiAgdHlwZTogJ3N0YXJ0VGFnJztcbiAgdGFnTmFtZTogc3RyaW5nO1xuICBhdHRyaWJ1dGVzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFbmRUYWdSZXBsYWNlbWVudCB7XG4gIHR5cGU6ICdlbmRUYWcnO1xuICB0YWdOYW1lOiBzdHJpbmc7XG59XG5cbnR5cGUgUmVwbGFjZW1lbnQgPSBIdG1sUmVwbGFjZW1lbnQgfCBTdGFydFRhZ1JlcGxhY2VtZW50IHwgRW5kVGFnUmVwbGFjZW1lbnQ7XG5cbi8qKiBNYXJrZXIgdXNlZCBmb3IgcmVwbGFjZW1lbnRzLiAqL1xuY29uc3QgTUFSS0VSID0gJ19zYWZldmFsdWVzX2Zvcm1hdF9tYXJrZXJfOic7XG5cbi8qKlxuICogRm9ybWF0dGVyIHByb2R1Y2luZyBTYWZlSHRtbCBmcm9tIGEgcGxhaW4gdGV4dCBmb3JtYXQgYW5kIEhUTUwgZnJhZ21lbnRzLlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBIdG1sRm9ybWF0dGVyKCk7XG4gKiBjb25zdCBzYWZlSHRtbCA9IGZvcm1hdHRlci5mb3JtYXQoXG4gKiAgICAgZm9ybWF0dGVyLnN0YXJ0VGFnKCdiJykgK1xuICogICAgICdVc2VyIGlucHV0OicgK1xuICogICAgIGZvcm1hdHRlci5lbmRUYWcoJ2InKSArXG4gKiAgICAgJyAnICtcbiAqICAgICBmb3JtYXR0ZXIudGV4dCh1c2VySW5wdXQpKTtcbiAqIFRoZSBtb3N0IGNvbW1vbiB1c2FnZSBpcyB3aXRoIGdvb2cuZ2V0TXNnOlxuICogY29uc3QgTVNHX1VTRVJfSU5QVVQgPSBnb29nLmdldE1zZyhcbiAqICAgICAneyRzdGFydExpbmt9TGVhcm4gbW9yZXskZW5kTGlua30gYWJvdXQgeyR1c2VySW5wdXR9Jywge1xuICogICAgICAgJ3N0YXJ0TGluayc6IGZvcm1hdHRlci5zdGFydFRhZygnYScsIHsnaHJlZic6IHVybH0pLFxuICogICAgICAgJ2VuZExpbmsnOiBmb3JtYXR0ZXIuZW5kVGFnKCdhJyksXG4gKiAgICAgICAndXNlcklucHV0JzogZm9ybWF0dGVyLnRleHQodXNlcklucHV0KVxuICogICAgIH0pO1xuICogY29uc3Qgc2FmZUh0bWwgPSBmb3JtYXR0ZXIuZm9ybWF0KE1TR19VU0VSX0lOUFVUKTtcbiAqIFRoZSBmb3JtYXR0aW5nIHN0cmluZyBzaG91bGQgYmUgY29uc3RhbnQgd2l0aCBhbGwgdmFyaWFibGVzIHByb2Nlc3NlZCBieVxuICogZm9ybWF0dGVyLnRleHQoKS5cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgY2xhc3MgSHRtbEZvcm1hdHRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVwbGFjZW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIFJlcGxhY2VtZW50PigpO1xuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgcGxhaW4gdGV4dCBzdHJpbmcgd2l0aCBtYXJrZXJzIGhvbGRpbmcgSFRNTCBmcmFnbWVudHMgdG9cbiAgICogU2FmZUh0bWwuXG4gICAqL1xuICBmb3JtYXQoZm9ybWF0OiBzdHJpbmcpOiBTYWZlSHRtbCB7XG4gICAgY29uc3Qgb3BlbmVkVGFnczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBtYXJrZXIgPSBodG1sRXNjYXBlKE1BUktFUikudG9TdHJpbmcoKTtcbiAgICBjb25zdCBodG1sID0gaHRtbEVzY2FwZShmb3JtYXQpXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXHske21hcmtlcn1bXFxcXHcmIztdK1xcXFx9YCwgJ2cnKSwgKG1hdGNoKSA9PlxuICAgICAgICB0aGlzLnJlcGxhY2VGb3JtYXR0aW5nU3RyaW5nKG9wZW5lZFRhZ3MsIG1hdGNoKSxcbiAgICAgICk7XG4gICAgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAoREVWX01PREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCBubyB1bmNsb3NlZCB0YWdzLCBnb3QgPCcgKyBvcGVuZWRUYWdzLmpvaW4oJz4sIDwnKSArICc+LicsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUh0bWxJbnRlcm5hbChodG1sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBmb3VuZCBmb3JtYXR0aW5nIHN0cmluZ3Mgd2l0aCBzYXZlZCB0YWdzLlxuICAgKi9cbiAgcHJpdmF0ZSByZXBsYWNlRm9ybWF0dGluZ1N0cmluZyhvcGVuZWRUYWdzOiBzdHJpbmdbXSwgbWF0Y2g6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSB0aGlzLnJlcGxhY2VtZW50cy5nZXQobWF0Y2gpO1xuICAgIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIFNvbWVvbmUgaW5jbHVkZWQgYSBzdHJpbmcgbG9va2luZyBsaWtlIG91ciBpbnRlcm5hbCBtYXJrZXIgaW4gdGhlXG4gICAgICAvLyBmb3JtYXQuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBzd2l0Y2ggKHJlcGxhY2VtZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXN1bHQgPSByZXBsYWNlbWVudC5odG1sO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YXJ0VGFnJzpcbiAgICAgICAgcmVzdWx0ID0gYDwke3JlcGxhY2VtZW50LnRhZ05hbWV9JHtyZXBsYWNlbWVudC5hdHRyaWJ1dGVzfT5gO1xuICAgICAgICBpZiAoREVWX01PREUpIHtcbiAgICAgICAgICBpZiAoIWlzVm9pZFRhZyhyZXBsYWNlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBvcGVuZWRUYWdzLnB1c2gocmVwbGFjZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmRUYWcnOlxuICAgICAgICByZXN1bHQgPSBgPC8ke3JlcGxhY2VtZW50LnRhZ05hbWV9PmA7XG4gICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgIGNvbnN0IGxhc3RUYWcgPSBvcGVuZWRUYWdzLnBvcCgpO1xuICAgICAgICAgIGlmIChsYXN0VGFnICE9PSByZXBsYWNlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEV4cGVjdGVkIDwvJHtsYXN0VGFnfT4sIGdvdCA8LyR7cmVwbGFjZW1lbnQudGFnTmFtZX0+LmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChERVZfTU9ERSkge1xuICAgICAgICAgIGNoZWNrRXhoYXVzdGl2ZShyZXBsYWNlbWVudCwgJ3R5cGUgaGFkIGFuIHVua25vd24gdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgc3RhcnQgdGFnIGFuZCByZXR1cm5zIGl0cyBtYXJrZXIuXG4gICAqIEBwYXJhbSB0YWdOYW1lXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gICAqICAgICBNYXBwaW5nIGZyb20gYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIHZhbHVlcy4gT25seSBhdHRyaWJ1dGUgbmFtZXNcbiAgICogICAgIGNvbnNpc3Rpbmcgb2YgW2EtekEtWjAtOS1dIGFyZSBhbGxvd2VkLiBWYWx1ZSBvZiBudWxsIG9yIHVuZGVmaW5lZFxuICAgKiBjYXVzZXMgdGhlIGF0dHJpYnV0ZSB0byBiZSBvbWl0dGVkLlxuICAgKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgdGFnIG5hbWUsIGF0dHJpYnV0ZSBuYW1lLCBvciBhdHRyaWJ1dGUgdmFsdWUgaXNcbiAgICogICAgIHByb3ZpZGVkLiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgdGFncyBhbmQgYXR0cmlidXRlcyBhc1xuICAgKiAgICAgc2FmZXZhbHVlcy5jcmVhdGVIdG1sLlxuICAgKi9cbiAgc3RhcnRUYWcoXG4gICAgdGFnTmFtZTogc3RyaW5nLFxuICAgIGF0dHJpYnV0ZXM/OiB7W2F0dHJOYW1lOiBzdHJpbmddOiBBdHRyaWJ1dGVWYWx1ZSB8IHVuZGVmaW5lZH0sXG4gICk6IHN0cmluZyB7XG4gICAgdmVyaWZ5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zdG9yZVJlcGxhY2VtZW50KHtcbiAgICAgIHR5cGU6ICdzdGFydFRhZycsXG4gICAgICB0YWdOYW1lLFxuICAgICAgYXR0cmlidXRlczpcbiAgICAgICAgYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBzdHJpbmdpZnlBdHRyaWJ1dGVzKHRhZ05hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgOiAnJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyBhbiBlbmQgdGFnIGFuZCByZXR1cm5zIGl0cyBtYXJrZXIuXG4gICAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCB0YWcgbmFtZSwgYXR0cmlidXRlIG5hbWUsIG9yIGF0dHJpYnV0ZSB2YWx1ZSBpc1xuICAgKiAgICAgcHJvdmlkZWQuIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSB0YWdzIGFzIHtAbGlua1xuICAgKiAgICAgc2FmZXZhbHVlcy5jcmVhdGVIdG1sfS5cbiAgICovXG4gIGVuZFRhZyh0YWdOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHZlcmlmeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVSZXBsYWNlbWVudCh7dHlwZTogJ2VuZFRhZycsIHRhZ05hbWV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGEgdGV4dCwgc2F2ZXMgaXQgYW5kIHJldHVybnMgaXRzIG1hcmtlci5cbiAgICpcbiAgICogV3JhcHBpbmcgYW55IHVzZXIgaW5wdXQgdG8gLnRleHQoKSBwcmV2ZW50cyB0aGUgYXR0YWNrZXIgd2l0aCBhY2Nlc3MgdG9cbiAgICogdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIGR1cGxpY2F0ZSB0YWdzIHVzZWQgZWxzZXdoZXJlIGluIHRoZSBmb3JtYXQuXG4gICAqL1xuICB0ZXh0KHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVSZXBsYWNlbWVudCh7XG4gICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICBodG1sOiBodG1sRXNjYXBlKHRleHQpLnRvU3RyaW5nKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgU2FmZUh0bWwgYW5kIHJldHVybnMgaXRzIG1hcmtlci5cbiAgICovXG4gIHNhZmVIdG1sKHNhZmVIdG1sOiBTYWZlSHRtbCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVSZXBsYWNlbWVudCh7XG4gICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICBodG1sOiB1bndyYXBIdG1sKHNhZmVIdG1sKS50b1N0cmluZygpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHJlcGxhY2VtZW50IGFuZCByZXR1cm5zIGl0cyBtYXJrZXIuXG4gICAqL1xuICBwcml2YXRlIHN0b3JlUmVwbGFjZW1lbnQocmVwbGFjZW1lbnQ6IFJlcGxhY2VtZW50KTogc3RyaW5nIHtcbiAgICBjb25zdCBtYXJrZXIgPSBgeyR7TUFSS0VSfSR7dGhpcy5yZXBsYWNlbWVudHMuc2l6ZX1fJHtnZXRSYW5kb21TdHJpbmcoKX19YDtcbiAgICB0aGlzLnJlcGxhY2VtZW50cy5zZXQoaHRtbEVzY2FwZShtYXJrZXIpLnRvU3RyaW5nKCksIHJlcGxhY2VtZW50KTtcbiAgICByZXR1cm4gbWFya2VyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpOiBzdHJpbmcge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhoYXVzdGl2ZShcbiAgdmFsdWU6IG5ldmVyLFxuICBtc2cgPSBgdW5leHBlY3RlZCB2YWx1ZSAke3ZhbHVlfSFgLFxuKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/inert_fragment.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/inert_fragment.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.inert_fragment');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/inert_fragment.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_range_1 = goog.requireType("google3.third_party.javascript.safevalues.dom.globals.range");
const tsickle_dev_2 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_SafeHtml_4 = goog.requireType("goog.html.SafeHtml");
const range_1 = goog.require('google3.third_party.javascript.safevalues.dom.globals.range');
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
/**
 * Returns a fragment that contains the parsed HTML for `dirtyHtml` without
 * executing any of the potential payload.
 * @param {string} dirtyHtml
 * @param {!Document} inertDocument
 * @return {!DocumentFragment}
 */
function createInertFragment(dirtyHtml, inertDocument) {
    if (dev_1.DEV_MODE) {
        // We are checking if the function was accidentally called with non-inert
        // document. One observable difference between live and inert documents
        // is that live document has a `defaultView` equal to `window`, while
        // inert document has a `defaultView` equal to `null`.
        if (inertDocument.defaultView) {
            throw new Error('createInertFragment called with non-inert document');
        }
    }
    /** @type {!Range} */
    const range = inertDocument.createRange();
    range.selectNode(inertDocument.body);
    // This call is only used to create an inert tree for the sanitizer to
    // further process and is never returned directly to the caller. We can't use
    // a reviewed conversion in order to avoid an import loop.
    /** @type {!tsickle_SafeHtml_4} */
    const temporarySafeHtml = (0, html_impl_1.createHtmlInternal)(dirtyHtml);
    return (0, range_1.createContextualFragment)(range, temporarySafeHtml);
}
exports.createInertFragment = createInertFragment;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5lcnRfZnJhZ21lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvaHRtbF9zYW5pdGl6ZXIvaW5lcnRfZnJhZ21lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsNEZBQWlFO0FBQ2pFLHdGQUErQztBQUMvQyxrR0FBNkQ7Ozs7Ozs7O0FBTTdELFNBQWdCLG1CQUFtQixDQUNqQyxTQUFpQixFQUNqQixhQUF1QjtJQUV2QixJQUFJLGNBQVEsRUFBRSxDQUFDO1FBQ2IseUVBQXlFO1FBQ3pFLHVFQUF1RTtRQUN2RSxxRUFBcUU7UUFDckUsc0RBQXNEO1FBQ3RELElBQUksYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztRQUN4RSxDQUFDO0lBQ0gsQ0FBQzs7VUFDSyxLQUFLLEdBQUcsYUFBYSxDQUFDLFdBQVcsRUFBRTtJQUN6QyxLQUFLLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7VUFLL0IsaUJBQWlCLEdBQUcsSUFBQSw4QkFBa0IsRUFBQyxTQUFTLENBQUM7SUFDdkQsT0FBTyxJQUFBLGdDQUF3QixFQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0FBQzVELENBQUM7QUFyQkQsa0RBcUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudH0gZnJvbSAnLi4vLi4vZG9tL2dsb2JhbHMvcmFuZ2UnO1xuaW1wb3J0IHtERVZfTU9ERX0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvZGV2JztcbmltcG9ydCB7Y3JlYXRlSHRtbEludGVybmFsfSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvaHRtbF9pbXBsJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnJhZ21lbnQgdGhhdCBjb250YWlucyB0aGUgcGFyc2VkIEhUTUwgZm9yIGBkaXJ0eUh0bWxgIHdpdGhvdXRcbiAqIGV4ZWN1dGluZyBhbnkgb2YgdGhlIHBvdGVudGlhbCBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5lcnRGcmFnbWVudChcbiAgZGlydHlIdG1sOiBzdHJpbmcsXG4gIGluZXJ0RG9jdW1lbnQ6IERvY3VtZW50LFxuKTogRG9jdW1lbnRGcmFnbWVudCB7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIC8vIFdlIGFyZSBjaGVja2luZyBpZiB0aGUgZnVuY3Rpb24gd2FzIGFjY2lkZW50YWxseSBjYWxsZWQgd2l0aCBub24taW5lcnRcbiAgICAvLyBkb2N1bWVudC4gT25lIG9ic2VydmFibGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGxpdmUgYW5kIGluZXJ0IGRvY3VtZW50c1xuICAgIC8vIGlzIHRoYXQgbGl2ZSBkb2N1bWVudCBoYXMgYSBgZGVmYXVsdFZpZXdgIGVxdWFsIHRvIGB3aW5kb3dgLCB3aGlsZVxuICAgIC8vIGluZXJ0IGRvY3VtZW50IGhhcyBhIGBkZWZhdWx0Vmlld2AgZXF1YWwgdG8gYG51bGxgLlxuICAgIGlmIChpbmVydERvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUluZXJ0RnJhZ21lbnQgY2FsbGVkIHdpdGggbm9uLWluZXJ0IGRvY3VtZW50Jyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJhbmdlID0gaW5lcnREb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZWxlY3ROb2RlKGluZXJ0RG9jdW1lbnQuYm9keSk7XG5cbiAgLy8gVGhpcyBjYWxsIGlzIG9ubHkgdXNlZCB0byBjcmVhdGUgYW4gaW5lcnQgdHJlZSBmb3IgdGhlIHNhbml0aXplciB0b1xuICAvLyBmdXJ0aGVyIHByb2Nlc3MgYW5kIGlzIG5ldmVyIHJldHVybmVkIGRpcmVjdGx5IHRvIHRoZSBjYWxsZXIuIFdlIGNhbid0IHVzZVxuICAvLyBhIHJldmlld2VkIGNvbnZlcnNpb24gaW4gb3JkZXIgdG8gYXZvaWQgYW4gaW1wb3J0IGxvb3AuXG4gIGNvbnN0IHRlbXBvcmFyeVNhZmVIdG1sID0gY3JlYXRlSHRtbEludGVybmFsKGRpcnR5SHRtbCk7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocmFuZ2UsIHRlbXBvcmFyeVNhZmVIdG1sKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/no_clobber.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Library that provides safe getters for different node properties and
 * checks for clobbering.
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/no_clobber.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.no_clobber');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/no_clobber.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Gets a reasonable nodeName, even for clobbered nodes.
 * @param {!Node} node
 * @return {string}
 */
function getNodeName(node) {
    /** @type {string} */
    const nodeName = node.nodeName;
    // If the property is clobbered, assume it is an `HTMLFormElement`.
    return typeof nodeName === 'string' ? nodeName : 'FORM';
}
exports.getNodeName = getNodeName;
/**
 * Returns true if the object passed is a Text node.
 * @param {!Node} node
 * @return {boolean}
 */
function isText(node) {
    // The property cannot get clobbered on Text nodes.
    return node.nodeType === 3; // Node.TEXT_NODE
}
exports.isText = isText;
/**
 * Returns true if the object passed is an Element node.
 * @param {!Node} node
 * @return {boolean}
 */
function isElement(node) {
    /** @type {number} */
    const nodeType = node.nodeType;
    // If the property is clobbered, we can assume it is an `HTMLFormElement`, and
    // thus an `Element`.
    return nodeType === 1 /* Node.ELEMENT_NODE */ || typeof nodeType !== 'number';
}
exports.isElement = isElement;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9fY2xvYmJlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9idWlsZGVycy9odG1sX3Nhbml0aXplci9ub19jbG9iYmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV0EsU0FBZ0IsV0FBVyxDQUFDLElBQVU7O1VBQzlCLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUTtJQUM5QixtRUFBbUU7SUFDbkUsT0FBTyxPQUFPLFFBQVEsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQzFELENBQUM7QUFKRCxrQ0FJQzs7Ozs7O0FBR0QsU0FBZ0IsTUFBTSxDQUFDLElBQVU7SUFDL0IsbURBQW1EO0lBQ25ELE9BQU8sSUFBSSxDQUFDLFFBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQyxpQkFBaUI7QUFDL0MsQ0FBQztBQUhELHdCQUdDOzs7Ozs7QUFHRCxTQUFnQixTQUFTLENBQUMsSUFBVTs7VUFDNUIsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRO0lBQzlCLDhFQUE4RTtJQUM5RSxxQkFBcUI7SUFDckIsT0FBTyxRQUFRLEtBQUssQ0FBQyxDQUFDLHVCQUF1QixJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUNoRixDQUFDO0FBTEQsOEJBS0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qKlxuICogTGlicmFyeSB0aGF0IHByb3ZpZGVzIHNhZmUgZ2V0dGVycyBmb3IgZGlmZmVyZW50IG5vZGUgcHJvcGVydGllcyBhbmRcbiAqIGNoZWNrcyBmb3IgY2xvYmJlcmluZy5cbiAqL1xuXG4vKiogR2V0cyBhIHJlYXNvbmFibGUgbm9kZU5hbWUsIGV2ZW4gZm9yIGNsb2JiZXJlZCBub2Rlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlTmFtZShub2RlOiBOb2RlKTogc3RyaW5nIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgY2xvYmJlcmVkLCBhc3N1bWUgaXQgaXMgYW4gYEhUTUxGb3JtRWxlbWVudGAuXG4gIHJldHVybiB0eXBlb2Ygbm9kZU5hbWUgPT09ICdzdHJpbmcnID8gbm9kZU5hbWUgOiAnRk9STSc7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaXMgYSBUZXh0IG5vZGUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0KG5vZGU6IE5vZGUpOiBub2RlIGlzIFRleHQge1xuICAvLyBUaGUgcHJvcGVydHkgY2Fubm90IGdldCBjbG9iYmVyZWQgb24gVGV4dCBub2Rlcy5cbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDM7IC8vIE5vZGUuVEVYVF9OT0RFXG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaXMgYW4gRWxlbWVudCBub2RlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBOb2RlKTogbm9kZSBpcyBFbGVtZW50IHtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgY2xvYmJlcmVkLCB3ZSBjYW4gYXNzdW1lIGl0IGlzIGFuIGBIVE1MRm9ybUVsZW1lbnRgLCBhbmRcbiAgLy8gdGh1cyBhbiBgRWxlbWVudGAuXG4gIHJldHVybiBub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLyB8fCB0eXBlb2Ygbm9kZVR5cGUgIT09ICdudW1iZXInO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/sanitizer_table.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/sanitizer_table.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/sanitizer_table.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Class for holding element and attribute policies used for sanitization.
 */
class SanitizerTable {
    /**
     * @public
     * @param {!ReadonlySet<string>} allowedElements
     * @param {!ReadonlyMap<string, !ReadonlyMap<string, !AttributePolicy>>} elementPolicies
     * @param {!ReadonlySet<string>} allowedGlobalAttributes
     * @param {!ReadonlyMap<string, !AttributePolicy>} globalAttributePolicies
     * @param {(undefined|!ReadonlySet<string>)=} globallyAllowedAttributePrefixes
     */
    constructor(allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies, globallyAllowedAttributePrefixes) {
        this.allowedElements = allowedElements;
        this.elementPolicies = elementPolicies;
        this.allowedGlobalAttributes = allowedGlobalAttributes;
        this.globalAttributePolicies = globalAttributePolicies;
        this.globallyAllowedAttributePrefixes = globallyAllowedAttributePrefixes;
    }
    /**
     * @public
     * @param {string} elementName
     * @return {boolean}
     */
    isAllowedElement(elementName) {
        // Note: `HTMLFormElement`s are always dropped, supporting them is very
        // costly because of the DOM clobberring they can cause. The additional code
        // size required to properly work around DOM clobberring issues is large and
        // shouldn't be put on every user of the sanitizer. Thoroughly review
        // b/210975025 and the CLs linked there before you start allowing form
        // elements.
        return (elementName !== 'FORM' &&
            (this.allowedElements.has(elementName) ||
                this.elementPolicies.has(elementName)));
    }
    /**
     * @public
     * @param {string} attributeName
     * @param {string} elementName
     * @return {!AttributePolicy}
     */
    getAttributePolicy(attributeName, elementName) {
        /** @type {(undefined|!ReadonlyMap<string, !AttributePolicy>)} */
        const elementPolicy = this.elementPolicies.get(elementName);
        if (elementPolicy?.has(attributeName)) {
            return (/** @type {!AttributePolicy} */ (elementPolicy.get(attributeName)));
        }
        if (this.allowedGlobalAttributes.has(attributeName)) {
            return { policyAction: AttributePolicyAction.KEEP };
        }
        /** @type {(undefined|!AttributePolicy)} */
        const globalPolicy = this.globalAttributePolicies.get(attributeName);
        if (globalPolicy) {
            return globalPolicy;
        }
        if (this.globallyAllowedAttributePrefixes &&
            [...this.globallyAllowedAttributePrefixes].some((/**
             * @param {string} prefix
             * @return {boolean}
             */
            (prefix) => attributeName.indexOf(prefix) === 0))) {
            return { policyAction: AttributePolicyAction.KEEP };
        }
        return { policyAction: AttributePolicyAction.DROP };
    }
}
exports.SanitizerTable = SanitizerTable;
/* istanbul ignore if */
if (false) {
    /**
     * @const {!ReadonlySet<string>}
     * @public
     */
    SanitizerTable.prototype.allowedElements;
    /**
     * @const {!ReadonlyMap<string, !ReadonlyMap<string, !AttributePolicy>>}
     * @public
     */
    SanitizerTable.prototype.elementPolicies;
    /**
     * @const {!ReadonlySet<string>}
     * @public
     */
    SanitizerTable.prototype.allowedGlobalAttributes;
    /**
     * @const {!ReadonlyMap<string, !AttributePolicy>}
     * @public
     */
    SanitizerTable.prototype.globalAttributePolicies;
    /**
     * @const {(undefined|!ReadonlySet<string>)}
     * @public
     */
    SanitizerTable.prototype.globallyAllowedAttributePrefixes;
}
/**
 * Holds information on how to sanitize the attributes of a particular element.
 * An element with an ElementPolicy specified is implicitly kept in the output.
 * @typedef {!ReadonlyMap<string, !AttributePolicy>}
 */
exports.ElementPolicy;
/**
 * Values derived from
 * https://godoc.corp.google.com/pkg/google3/third_party/safehtml/sanitizer/policy#AttributePolicy
 * @enum {number}
 */
const AttributePolicyAction = {
    DROP: 0,
    KEEP: 1,
    KEEP_AND_SANITIZE_URL: 2,
    KEEP_AND_NORMALIZE: 3,
    // This action is currently equivalent to KEEP as there is no style sanitizer.
    KEEP_AND_SANITIZE_STYLE: 4,
};
exports.AttributePolicyAction = AttributePolicyAction;
AttributePolicyAction[AttributePolicyAction.DROP] = 'DROP';
AttributePolicyAction[AttributePolicyAction.KEEP] = 'KEEP';
AttributePolicyAction[AttributePolicyAction.KEEP_AND_SANITIZE_URL] = 'KEEP_AND_SANITIZE_URL';
AttributePolicyAction[AttributePolicyAction.KEEP_AND_NORMALIZE] = 'KEEP_AND_NORMALIZE';
AttributePolicyAction[AttributePolicyAction.KEEP_AND_SANITIZE_STYLE] = 'KEEP_AND_SANITIZE_STYLE';
/**
 * Holds information on how to sanitize the values of a particular attribute.
 * @record
 */
function AttributePolicy() { }
exports.AttributePolicy = AttributePolicy;
/* istanbul ignore if */
if (false) {
    /**
     * @const {!AttributePolicyAction}
     * @public
     */
    AttributePolicy.prototype.policyAction;
    /**
     * @const {(undefined|!ReadonlyMap<string, !Set<string>>)}
     * @public
     */
    AttributePolicy.prototype.conditions;
}
// From the spec:
// https://html.spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname:~:text=name%20must%20not%20be%20any%20of%20the%20following%3A
/** @type {!Set<string>} */
const FORBIDDEN_CUSTOM_ELEMENT_NAMES = new Set([
    'ANNOTATION-XML',
    'COLOR-PROFILE',
    'FONT-FACE',
    'FONT-FACE-SRC',
    'FONT-FACE-URI',
    'FONT-FACE-FORMAT',
    'FONT-FACE-NAME',
    'MISSING-GLYPH',
]);
/**
 * Helper for checking if an element tag is a custom element.
 * @param {string} tag
 * @return {boolean}
 */
function isCustomElement(tag) {
    return (!FORBIDDEN_CUSTOM_ELEMENT_NAMES.has(tag.toUpperCase()) &&
        /^[a-z][-_.a-z0-9]*-[-_.a-z0-9]*$/i.test(tag));
}
exports.isCustomElement = isCustomElement;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FuaXRpemVyX3RhYmxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2J1aWxkZXJzL2h0bWxfc2FuaXRpemVyL3Nhbml0aXplcl90YWJsZS9zYW5pdGl6ZXJfdGFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQSxNQUFhLGNBQWM7Ozs7Ozs7OztJQUN6QixZQUNXLGVBQW9DLEVBQ3BDLGVBQW1ELEVBQ25ELHVCQUE0QyxFQUM1Qyx1QkFBNkQsRUFDN0QsZ0NBQXNEO1FBSnRELG9CQUFlLEdBQWYsZUFBZSxDQUFxQjtRQUNwQyxvQkFBZSxHQUFmLGVBQWUsQ0FBb0M7UUFDbkQsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUFxQjtRQUM1Qyw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXNDO1FBQzdELHFDQUFnQyxHQUFoQyxnQ0FBZ0MsQ0FBc0I7SUFDOUQsQ0FBQzs7Ozs7O0lBRUosZ0JBQWdCLENBQUMsV0FBbUI7UUFDbEMsdUVBQXVFO1FBQ3ZFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUUscUVBQXFFO1FBQ3JFLHNFQUFzRTtRQUN0RSxZQUFZO1FBQ1osT0FBTyxDQUNMLFdBQVcsS0FBSyxNQUFNO1lBQ3RCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO2dCQUNwQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUN6QyxDQUFDO0lBQ0osQ0FBQzs7Ozs7OztJQUVELGtCQUFrQixDQUNoQixhQUFxQixFQUNyQixXQUFtQjs7Y0FFYixhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQzNELElBQUksYUFBYSxFQUFFLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO1lBQ3RDLE9BQU8sa0NBQUEsYUFBYSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBQyxDQUFDO1FBQzNDLENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztZQUNwRCxPQUFPLEVBQUMsWUFBWSxFQUFFLHFCQUFxQixDQUFDLElBQUksRUFBQyxDQUFDO1FBQ3BELENBQUM7O2NBRUssWUFBWSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO1FBQ3BFLElBQUksWUFBWSxFQUFFLENBQUM7WUFDakIsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztRQUNELElBQ0UsSUFBSSxDQUFDLGdDQUFnQztZQUNyQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLENBQUMsSUFBSTs7OztZQUM3QyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQ2hELEVBQ0QsQ0FBQztZQUNELE9BQU8sRUFBQyxZQUFZLEVBQUUscUJBQXFCLENBQUMsSUFBSSxFQUFDLENBQUM7UUFDcEQsQ0FBQztRQUNELE9BQU8sRUFBQyxZQUFZLEVBQUUscUJBQXFCLENBQUMsSUFBSSxFQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBbERELHdDQWtEQzs7Ozs7OztJQWhERyx5Q0FBNkM7Ozs7O0lBQzdDLHlDQUE0RDs7Ozs7SUFDNUQsaURBQXFEOzs7OztJQUNyRCxpREFBc0U7Ozs7O0lBQ3RFLDBEQUErRDs7Ozs7OztBQWtEbkUsc0JBQWlFOzs7Ozs7QUFNakUsTUFBWSxxQkFBcUI7SUFDL0IsSUFBSSxHQUFBO0lBQ0osSUFBSSxHQUFBO0lBQ0oscUJBQXFCLEdBQUE7SUFDckIsa0JBQWtCLEdBQUE7O0lBRWxCLHVCQUF1QixHQUFBO0VBQ3hCOzs7Ozs7Ozs7OztBQUtELDhCQUtDOzs7Ozs7OztJQUpDLHVDQUE2Qzs7Ozs7SUFHN0MscUNBQXVEOzs7OztNQUtuRCw4QkFBOEIsR0FBRyxJQUFJLEdBQUcsQ0FBUztJQUNyRCxnQkFBZ0I7SUFDaEIsZUFBZTtJQUNmLFdBQVc7SUFDWCxlQUFlO0lBQ2YsZUFBZTtJQUNmLGtCQUFrQjtJQUNsQixnQkFBZ0I7SUFDaEIsZUFBZTtDQUNoQixDQUFDOzs7Ozs7QUFLRixTQUFnQixlQUFlLENBQUMsR0FBVztJQUN6QyxPQUFPLENBQ0wsQ0FBQyw4QkFBOEIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3RELG1DQUFtQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FDOUMsQ0FBQztBQUNKLENBQUM7QUFMRCwwQ0FLQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqIENsYXNzIGZvciBob2xkaW5nIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBwb2xpY2llcyB1c2VkIGZvciBzYW5pdGl6YXRpb24uICovXG5leHBvcnQgY2xhc3MgU2FuaXRpemVyVGFibGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBhbGxvd2VkRWxlbWVudHM6IFJlYWRvbmx5U2V0PHN0cmluZz4sXG4gICAgcmVhZG9ubHkgZWxlbWVudFBvbGljaWVzOiBSZWFkb25seU1hcDxzdHJpbmcsIEVsZW1lbnRQb2xpY3k+LFxuICAgIHJlYWRvbmx5IGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzOiBSZWFkb25seVNldDxzdHJpbmc+LFxuICAgIHJlYWRvbmx5IGdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzOiBSZWFkb25seU1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT4sXG4gICAgcmVhZG9ubHkgZ2xvYmFsbHlBbGxvd2VkQXR0cmlidXRlUHJlZml4ZXM/OiBSZWFkb25seVNldDxzdHJpbmc+LFxuICApIHt9XG5cbiAgaXNBbGxvd2VkRWxlbWVudChlbGVtZW50TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gTm90ZTogYEhUTUxGb3JtRWxlbWVudGBzIGFyZSBhbHdheXMgZHJvcHBlZCwgc3VwcG9ydGluZyB0aGVtIGlzIHZlcnlcbiAgICAvLyBjb3N0bHkgYmVjYXVzZSBvZiB0aGUgRE9NIGNsb2JiZXJyaW5nIHRoZXkgY2FuIGNhdXNlLiBUaGUgYWRkaXRpb25hbCBjb2RlXG4gICAgLy8gc2l6ZSByZXF1aXJlZCB0byBwcm9wZXJseSB3b3JrIGFyb3VuZCBET00gY2xvYmJlcnJpbmcgaXNzdWVzIGlzIGxhcmdlIGFuZFxuICAgIC8vIHNob3VsZG4ndCBiZSBwdXQgb24gZXZlcnkgdXNlciBvZiB0aGUgc2FuaXRpemVyLiBUaG9yb3VnaGx5IHJldmlld1xuICAgIC8vIGIvMjEwOTc1MDI1IGFuZCB0aGUgQ0xzIGxpbmtlZCB0aGVyZSBiZWZvcmUgeW91IHN0YXJ0IGFsbG93aW5nIGZvcm1cbiAgICAvLyBlbGVtZW50cy5cbiAgICByZXR1cm4gKFxuICAgICAgZWxlbWVudE5hbWUgIT09ICdGT1JNJyAmJlxuICAgICAgKHRoaXMuYWxsb3dlZEVsZW1lbnRzLmhhcyhlbGVtZW50TmFtZSkgfHxcbiAgICAgICAgdGhpcy5lbGVtZW50UG9saWNpZXMuaGFzKGVsZW1lbnROYW1lKSlcbiAgICApO1xuICB9XG5cbiAgZ2V0QXR0cmlidXRlUG9saWN5KFxuICAgIGF0dHJpYnV0ZU5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50TmFtZTogc3RyaW5nLFxuICApOiBBdHRyaWJ1dGVQb2xpY3kge1xuICAgIGNvbnN0IGVsZW1lbnRQb2xpY3kgPSB0aGlzLmVsZW1lbnRQb2xpY2llcy5nZXQoZWxlbWVudE5hbWUpO1xuICAgIGlmIChlbGVtZW50UG9saWN5Py5oYXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50UG9saWN5LmdldChhdHRyaWJ1dGVOYW1lKSE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICByZXR1cm4ge3BvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdsb2JhbFBvbGljeSA9IHRoaXMuZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuICAgIGlmIChnbG9iYWxQb2xpY3kpIHtcbiAgICAgIHJldHVybiBnbG9iYWxQb2xpY3k7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMuZ2xvYmFsbHlBbGxvd2VkQXR0cmlidXRlUHJlZml4ZXMgJiZcbiAgICAgIFsuLi50aGlzLmdsb2JhbGx5QWxsb3dlZEF0dHJpYnV0ZVByZWZpeGVzXS5zb21lKFxuICAgICAgICAocHJlZml4KSA9PiBhdHRyaWJ1dGVOYW1lLmluZGV4T2YocHJlZml4KSA9PT0gMCxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiB7cG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUH07XG4gICAgfVxuICAgIHJldHVybiB7cG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uRFJPUH07XG4gIH1cbn1cblxuLyoqXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gc2FuaXRpemUgdGhlIGF0dHJpYnV0ZXMgb2YgYSBwYXJ0aWN1bGFyIGVsZW1lbnQuXG4gKiBBbiBlbGVtZW50IHdpdGggYW4gRWxlbWVudFBvbGljeSBzcGVjaWZpZWQgaXMgaW1wbGljaXRseSBrZXB0IGluIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCB0eXBlIEVsZW1lbnRQb2xpY3kgPSBSZWFkb25seU1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT47XG5cbi8qKlxuICogVmFsdWVzIGRlcml2ZWQgZnJvbVxuICogaHR0cHM6Ly9nb2RvYy5jb3JwLmdvb2dsZS5jb20vcGtnL2dvb2dsZTMvdGhpcmRfcGFydHkvc2FmZWh0bWwvc2FuaXRpemVyL3BvbGljeSNBdHRyaWJ1dGVQb2xpY3lcbiAqL1xuZXhwb3J0IGVudW0gQXR0cmlidXRlUG9saWN5QWN0aW9uIHtcbiAgRFJPUCxcbiAgS0VFUCxcbiAgS0VFUF9BTkRfU0FOSVRJWkVfVVJMLFxuICBLRUVQX0FORF9OT1JNQUxJWkUsXG4gIC8vIFRoaXMgYWN0aW9uIGlzIGN1cnJlbnRseSBlcXVpdmFsZW50IHRvIEtFRVAgYXMgdGhlcmUgaXMgbm8gc3R5bGUgc2FuaXRpemVyLlxuICBLRUVQX0FORF9TQU5JVElaRV9TVFlMRSxcbn1cblxuLyoqXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gc2FuaXRpemUgdGhlIHZhbHVlcyBvZiBhIHBhcnRpY3VsYXIgYXR0cmlidXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF0dHJpYnV0ZVBvbGljeSB7XG4gIHJlYWRvbmx5IHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uO1xuICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBvbmx5IGFsbG93ZWQgaWYgdGhlIGF0dHJpYnV0ZXMgKHVzZWQgYXMgdGhlIGtleXMgaW5cbiAgLy8gdGhlIG1hcCkgaXMgZXF1YWwgdG8gb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNldC5cbiAgcmVhZG9ubHkgY29uZGl0aW9ucz86IFJlYWRvbmx5TWFwPHN0cmluZywgU2V0PHN0cmluZz4+O1xufVxuXG4vLyBGcm9tIHRoZSBzcGVjOlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY3VzdG9tLWVsZW1lbnRzLmh0bWwjcHJvZC1wb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZTp+OnRleHQ9bmFtZSUyMG11c3QlMjBub3QlMjBiZSUyMGFueSUyMG9mJTIwdGhlJTIwZm9sbG93aW5nJTNBXG5jb25zdCBGT1JCSURERU5fQ1VTVE9NX0VMRU1FTlRfTkFNRVMgPSBuZXcgU2V0PHN0cmluZz4oW1xuICAnQU5OT1RBVElPTi1YTUwnLFxuICAnQ09MT1ItUFJPRklMRScsXG4gICdGT05ULUZBQ0UnLFxuICAnRk9OVC1GQUNFLVNSQycsXG4gICdGT05ULUZBQ0UtVVJJJyxcbiAgJ0ZPTlQtRkFDRS1GT1JNQVQnLFxuICAnRk9OVC1GQUNFLU5BTUUnLFxuICAnTUlTU0lORy1HTFlQSCcsXG5dKTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNoZWNraW5nIGlmIGFuIGVsZW1lbnQgdGFnIGlzIGEgY3VzdG9tIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhRk9SQklEREVOX0NVU1RPTV9FTEVNRU5UX05BTUVTLmhhcyh0YWcudG9VcHBlckNhc2UoKSkgJiZcbiAgICAvXlthLXpdWy1fLmEtejAtOV0qLVstXy5hLXowLTldKiQvaS50ZXN0KHRhZylcbiAgKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/* GENERATED CODE, DO NOT MODIFY */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.default_sanitizer_table');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_pure_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.pure");
const tsickle_sanitizer_table_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table");
const pure_1 = goog.require('google3.third_party.javascript.safevalues.internals.pure');
const sanitizer_table_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table');
/** @type {!ReadonlyArray<string>} */
const ALLOWED_ELEMENTS = [
    'ARTICLE',
    'SECTION',
    'NAV',
    'ASIDE',
    'H1',
    'H2',
    'H3',
    'H4',
    'H5',
    'H6',
    'HEADER',
    'FOOTER',
    'ADDRESS',
    'P',
    'HR',
    'PRE',
    'BLOCKQUOTE',
    'OL',
    'UL',
    'LH',
    'LI',
    'DL',
    'DT',
    'DD',
    'FIGURE',
    'FIGCAPTION',
    'MAIN',
    'DIV',
    'EM',
    'STRONG',
    'SMALL',
    'S',
    'CITE',
    'Q',
    'DFN',
    'ABBR',
    'RUBY',
    'RB',
    'RT',
    'RTC',
    'RP',
    'DATA',
    'TIME',
    'CODE',
    'VAR',
    'SAMP',
    'KBD',
    'SUB',
    'SUP',
    'I',
    'B',
    'U',
    'MARK',
    'BDI',
    'BDO',
    'SPAN',
    'BR',
    'WBR',
    'INS',
    'DEL',
    'PICTURE',
    'PARAM',
    'TRACK',
    'MAP',
    'TABLE',
    'CAPTION',
    'COLGROUP',
    'COL',
    'TBODY',
    'THEAD',
    'TFOOT',
    'TR',
    'TD',
    'TH',
    'SELECT',
    'DATALIST',
    'OPTGROUP',
    'OPTION',
    'OUTPUT',
    'PROGRESS',
    'METER',
    'FIELDSET',
    'LEGEND',
    'DETAILS',
    'SUMMARY',
    'MENU',
    'DIALOG',
    'SLOT',
    'CANVAS',
    'FONT',
    'CENTER',
    'ACRONYM',
    'BASEFONT',
    'BIG',
    'DIR',
    'HGROUP',
    'STRIKE',
    'TT',
];
/** @type {!ReadonlyArray<!Array<?>>} */
const ELEMENT_POLICIES = [
    [
        'A',
        new Map([
            [
                'href',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL,
                },
            ],
        ]),
    ],
    [
        'AREA',
        new Map([
            [
                'href',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL,
                },
            ],
        ]),
    ],
    [
        'LINK',
        new Map([
            [
                'href',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL,
                    conditions: new Map([
                        [
                            'rel',
                            new Set([
                                'alternate',
                                'author',
                                'bookmark',
                                'canonical',
                                'cite',
                                'help',
                                'icon',
                                'license',
                                'next',
                                'prefetch',
                                'dns-prefetch',
                                'prerender',
                                'preconnect',
                                'preload',
                                'prev',
                                'search',
                                'subresource',
                            ]),
                        ],
                    ]),
                },
            ],
        ]),
    ],
    [
        'SOURCE',
        new Map([
            [
                'src',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
            [
                'srcset',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
        ]),
    ],
    [
        'IMG',
        new Map([
            [
                'src',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
            [
                'srcset',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
        ]),
    ],
    [
        'VIDEO',
        new Map([
            [
                'src',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
        ]),
    ],
    [
        'AUDIO',
        new Map([
            [
                'src',
                {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                },
            ],
        ]),
    ],
];
/** @type {!ReadonlyArray<string>} */
const ALLOWED_GLOBAL_ATTRIBUTES = [
    'title',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-current',
    'aria-disabled',
    'aria-dropeffect',
    'aria-expanded',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-label',
    'aria-level',
    'aria-live',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
    'alt',
    'align',
    'autocapitalize',
    'autocomplete',
    'autocorrect',
    'autofocus',
    'autoplay',
    'bgcolor',
    'border',
    'cellpadding',
    'cellspacing',
    'checked',
    'color',
    'cols',
    'colspan',
    'controls',
    'datetime',
    'disabled',
    'download',
    'draggable',
    'enctype',
    'face',
    'formenctype',
    'frameborder',
    'height',
    'hreflang',
    'hidden',
    'ismap',
    'label',
    'lang',
    'loop',
    'max',
    'maxlength',
    'media',
    'minlength',
    'min',
    'multiple',
    'muted',
    'nonce',
    'open',
    'placeholder',
    'preload',
    'rel',
    'required',
    'reversed',
    'role',
    'rows',
    'rowspan',
    'selected',
    'shape',
    'size',
    'sizes',
    'slot',
    'span',
    'spellcheck',
    'start',
    'step',
    'summary',
    'translate',
    'type',
    'valign',
    'value',
    'width',
    'wrap',
    'itemscope',
    'itemtype',
    'itemid',
    'itemprop',
    'itemref',
];
/** @type {!ReadonlyArray<!Array<?>>} */
const GLOBAL_ATTRIBUTE_POLICIES = [
    [
        'dir',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_NORMALIZE,
            conditions: (0, pure_1.pure)((/**
             * @return {!Map<string, !Set<string>>}
             */
            () => {
                return new Map([
                    ['dir', new Set(['auto', 'ltr', 'rtl'])],
                ]);
            })),
        },
    ],
    [
        'async',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_NORMALIZE,
            conditions: (0, pure_1.pure)((/**
             * @return {!Map<string, !Set<string>>}
             */
            () => {
                return new Map([
                    ['async', new Set(['async'])],
                ]);
            })),
        },
    ],
    [
        'cite',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL,
        },
    ],
    [
        'loading',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_NORMALIZE,
            conditions: (0, pure_1.pure)((/**
             * @return {!Map<string, !Set<string>>}
             */
            () => {
                return new Map([
                    ['loading', new Set(['eager', 'lazy'])],
                ]);
            })),
        },
    ],
    [
        'poster',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL,
        },
    ],
    [
        'target',
        {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_NORMALIZE,
            conditions: (0, pure_1.pure)((/**
             * @return {!Map<string, !Set<string>>}
             */
            () => {
                return new Map([
                    ['target', new Set(['_self', '_blank'])],
                ]);
            })),
        },
    ],
];
/**
 * Sanitizer table for the default sanitizer configuration
 * // BEGIN-INTERNAL
 * This SanitizerTable was generated from the checked in html contract:
 *  webutil/html/types/codegen/html5_contract.textpb
 *
 * You can regenerate this file with:
 * webutil/html/types/codegen/update_generated_source_files.sh  // END-INTERNAL
 * @type {!tsickle_sanitizer_table_2.SanitizerTable}
 */
exports.defaultSanitizerTable = new sanitizer_table_1.SanitizerTable(new Set(ALLOWED_ELEMENTS), new Map(ELEMENT_POLICIES), new Set(ALLOWED_GLOBAL_ATTRIBUTES), new Map(GLOBAL_ATTRIBUTE_POLICIES));
// BEGIN-INTERNAL
/**
 * This is similar to the default sanitizer configuration, but tries to allow as
 * many things while still guaranteeing the security of the output.
 *
 * This configuration does not protect against go/dom-clobbering.
 *
 * We construct it directly rather than relying on the `HtmlSanitizerBuilder` to
 * make sure that the compiler knows it can be dead-code eliminated when unused.
 * @type {!tsickle_sanitizer_table_2.SanitizerTable}
 */
exports.lenientSanitizerTable = new sanitizer_table_1.SanitizerTable(new Set(ALLOWED_ELEMENTS.concat(['BUTTON', 'INPUT'])), new Map(ELEMENT_POLICIES), new Set((0, pure_1.pure)((/**
 * @return {!Array<string>}
 */
() => ALLOWED_GLOBAL_ATTRIBUTES.concat(['class', 'id', 'name'])))), new Map((0, pure_1.pure)((/**
 * @return {!Array<!Array<?>>}
 */
() => GLOBAL_ATTRIBUTE_POLICIES.concat([
    // safevalues doesn't have a style sanitizer
    ['style', { policyAction: sanitizer_table_1.AttributePolicyAction.KEEP }],
])))));
/**
 * This is also similar to the default sanitizer configuration, but tries to be
 * even more lenient than the lenientSanitizerTable while still guaranteeing
 * that the output cannot cause XSS in modern browsers. This should only be
 * used when absolutely necessary. See go/super-lenient-sanitizer for more
 * information.
 *
 * We construct it directly rather than relying on the `HtmlSanitizerBuilder` to
 * make sure that the compiler knows it can be dead-code eliminated when unused.
 * @type {!tsickle_sanitizer_table_2.SanitizerTable}
 */
exports.superLenientSanitizerTable = new sanitizer_table_1.SanitizerTable(new Set((0, pure_1.pure)((/**
 * @return {!Array<string>}
 */
() => ALLOWED_ELEMENTS.concat([
    'STYLE',
    'TITLE',
    'INPUT',
    'TEXTAREA',
    'BUTTON',
    'LABEL',
])))), new Map(ELEMENT_POLICIES), new Set((0, pure_1.pure)((/**
 * @return {!Array<string>}
 */
() => ALLOWED_GLOBAL_ATTRIBUTES.concat([
    'class',
    'id',
    'tabindex',
    'contenteditable',
    'name',
])))), new Map((0, pure_1.pure)((/**
 * @return {!Array<!Array<?>>}
 */
() => GLOBAL_ATTRIBUTE_POLICIES.concat([
    // safevalues doesn't have a style sanitizer
    ['style', { policyAction: sanitizer_table_1.AttributePolicyAction.KEEP }],
])))), new Set(['data-', 'aria-']));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdF9zYW5pdGl6ZXJfdGFibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvaHRtbF9zYW5pdGl6ZXIvc2FuaXRpemVyX3RhYmxlL2RlZmF1bHRfc2FuaXRpemVyX3RhYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0Esd0ZBQTZDO0FBRTdDLDRJQUsyQjs7TUFFckIsZ0JBQWdCLEdBQXNCO0lBQzFDLFNBQVM7SUFDVCxTQUFTO0lBQ1QsS0FBSztJQUNMLE9BQU87SUFDUCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixRQUFRO0lBQ1IsUUFBUTtJQUNSLFNBQVM7SUFDVCxHQUFHO0lBQ0gsSUFBSTtJQUNKLEtBQUs7SUFDTCxZQUFZO0lBQ1osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLFFBQVE7SUFDUixZQUFZO0lBQ1osTUFBTTtJQUNOLEtBQUs7SUFDTCxJQUFJO0lBQ0osUUFBUTtJQUNSLE9BQU87SUFDUCxHQUFHO0lBQ0gsTUFBTTtJQUNOLEdBQUc7SUFDSCxLQUFLO0lBQ0wsTUFBTTtJQUNOLE1BQU07SUFDTixJQUFJO0lBQ0osSUFBSTtJQUNKLEtBQUs7SUFDTCxJQUFJO0lBQ0osTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sS0FBSztJQUNMLE1BQU07SUFDTixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxNQUFNO0lBQ04sS0FBSztJQUNMLEtBQUs7SUFDTCxNQUFNO0lBQ04sSUFBSTtJQUNKLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJ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MUQsSUFBSSxHQUFHLENBQ0wsSUFBQSxXQUFJOzs7QUFBQyxHQUFHLEVBQUUsQ0FDUixnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7SUFDdEIsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsVUFBVTtJQUNWLFFBQVE7SUFDUixPQUFPO0NBQ1IsQ0FBQyxFQUNILENBQ0YsRUFDRCxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUN6QixJQUFJLEdBQUcsQ0FDTCxJQUFBLFdBQUk7OztBQUFDLEdBQUcsRUFBRSxDQUNSLHlCQUF5QixDQUFDLE1BQU0sQ0FBQztJQUMvQixPQUFPO0lBQ1AsSUFBSTtJQUNKLFVBQVU7SUFDVixpQkFBaUI7SUFDakIsTUFBTTtDQUNQLENBQUMsRUFDSCxDQUNGLEVBQ0QsSUFBSSxHQUFHLENBQ0wsSUFBQSxXQUFJOzs7QUFBQyxHQUFHLEVBQUUsQ0FDUix5QkFBeUIsQ0FBQyxNQUFNLENBQUM7SUFDL0IsNENBQTRDO0lBQzVDLENBQUMsT0FBTyxFQUFFLEVBQUMsWUFBWSxFQUFFLHVDQUFxQixDQUFDLElBQUksRUFBQyxDQUFDO0NBQ3RELENBQUMsRUFDSCxDQUNGLEVBQ0QsSUFBSSxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FDNUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8qIEdFTkVSQVRFRCBDT0RFLCBETyBOT1QgTU9ESUZZICovXG5cbmltcG9ydCB7cHVyZX0gZnJvbSAnLi4vLi4vLi4vaW50ZXJuYWxzL3B1cmUnO1xuXG5pbXBvcnQge1xuICBBdHRyaWJ1dGVQb2xpY3ksXG4gIEF0dHJpYnV0ZVBvbGljeUFjdGlvbixcbiAgRWxlbWVudFBvbGljeSxcbiAgU2FuaXRpemVyVGFibGUsXG59IGZyb20gJy4vc2FuaXRpemVyX3RhYmxlJztcblxuY29uc3QgQUxMT1dFRF9FTEVNRU5UUzogcmVhZG9ubHkgc3RyaW5nW10gPSBbXG4gICdBUlRJQ0xFJyxcbiAgJ1NFQ1RJT04nLFxuICAnTkFWJyxcbiAgJ0FTSURFJyxcbiAgJ0gxJyxcbiAgJ0gyJyxcbiAgJ0gzJyxcbiAgJ0g0JyxcbiAgJ0g1JyxcbiAgJ0g2JyxcbiAgJ0hFQURFUicsXG4gICdGT09URVInLFxuICAnQUREUkVTUycsXG4gICdQJyxcbiAgJ0hSJyxcbiAgJ1BSRScsXG4gICdCTE9DS1FVT1RFJyxcbiAgJ09MJyxcbiAgJ1VMJyxcbiAgJ0xIJyxcbiAgJ0xJJyxcbiAgJ0RMJyxcbiAgJ0RUJyxcbiAgJ0REJyxcbiAgJ0ZJR1VSRScsXG4gICdGSUdDQVBUSU9OJyxcbiAgJ01BSU4nLFxuICAnRElWJyxcbiAgJ0VNJyxcbiAgJ1NUUk9ORycsXG4gICdTTUFMTCcsXG4gICdTJyxcbiAgJ0NJVEUnLFxuICAnUScsXG4gICdERk4nLFxuICAnQUJCUicsXG4gICdSVUJZJyxcbiAgJ1JCJyxcbiAgJ1JUJyxcbiAgJ1JUQycsXG4gICdSUCcsXG4gICdEQVRBJyxcbiAgJ1RJTUUnLFxuICAnQ09ERScsXG4gICdWQVInLFxuICAnU0FNUCcsXG4gICdLQkQnLFxuICAnU1VCJyxcbiAgJ1NVUCcsXG4gICdJJyxcbiAgJ0InLFxuICAnVScsXG4gICdNQVJLJyxcbiAgJ0JESScsXG4gICdCRE8nLFxuICAnU1BBTicsXG4gICdCUicsXG4gICdXQlInLFxuICAnSU5TJyxcbiAgJ0RFTCcsXG4gICdQSUNUVVJFJyxcbiAgJ1BBUkFNJyxcbiAgJ1RSQUNLJyxcbiAgJ01BUCcsXG4gICdUQUJMRScsXG4gICdDQVBUSU9OJyxcbiAgJ0NPTEdST1VQJyxcbiAgJ0NPTCcsXG4gICdUQk9EWScsXG4gICdUSEVBRCcsXG4gICdURk9PVCcsXG4gICdUUicsXG4gICdURCcsXG4gICdUSCcsXG4gICdTRUxFQ1QnLFxuICAnREFUQUxJU1QnLFxuICAnT1BUR1JPVVAnLFxuICAnT1BUSU9OJyxcbiAgJ09VVFBVVCcsXG4gICdQUk9HUkVTUycsXG4gICdNRVRFUicsXG4gICdGSUVMRFNFVCcsXG4gICdMRUdFTkQnLFxuICAnREVUQUlMUycsXG4gICdTVU1NQVJZJyxcbiAgJ01FTlUnLFxuICAnRElBTE9HJyxcbiAgJ1NMT1QnLFxuICAnQ0FOVkFTJyxcbiAgJ0ZPTlQnLFxuICAnQ0VOVEVSJyxcbiAgJ0FDUk9OWU0nLFxuICAnQkFTRUZPTlQnLFxuICAnQklHJyxcbiAgJ0RJUicsXG4gICdIR1JPVVAnLFxuICAnU1RSSUtFJyxcbiAgJ1RUJyxcbl07XG5cbmNvbnN0IEVMRU1FTlRfUE9MSUNJRVM6IFJlYWRvbmx5QXJyYXk8W3N0cmluZywgRWxlbWVudFBvbGljeV0+ID0gW1xuICBbXG4gICAgJ0EnLFxuICAgIG5ldyBNYXA8c3RyaW5nLCBBdHRyaWJ1dGVQb2xpY3k+KFtcbiAgICAgIFtcbiAgICAgICAgJ2hyZWYnLFxuICAgICAgICB7XG4gICAgICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUF9BTkRfU0FOSVRJWkVfVVJMLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICBdKSxcbiAgXSxcbiAgW1xuICAgICdBUkVBJyxcbiAgICBuZXcgTWFwPHN0cmluZywgQXR0cmlidXRlUG9saWN5PihbXG4gICAgICBbXG4gICAgICAgICdocmVmJyxcbiAgICAgICAge1xuICAgICAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX1NBTklUSVpFX1VSTCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgXSksXG4gIF0sXG4gIFtcbiAgICAnTElOSycsXG4gICAgbmV3IE1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT4oW1xuICAgICAgW1xuICAgICAgICAnaHJlZicsXG4gICAgICAgIHtcbiAgICAgICAgICBwb2xpY3lBY3Rpb246IEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5LRUVQX0FORF9TQU5JVElaRV9VUkwsXG4gICAgICAgICAgY29uZGl0aW9uczogbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PihbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdyZWwnLFxuICAgICAgICAgICAgICBuZXcgU2V0PHN0cmluZz4oW1xuICAgICAgICAgICAgICAgICdhbHRlcm5hdGUnLFxuICAgICAgICAgICAgICAgICdhdXRob3InLFxuICAgICAgICAgICAgICAgICdib29rbWFyaycsXG4gICAgICAgICAgICAgICAgJ2Nhbm9uaWNhbCcsXG4gICAgICAgICAgICAgICAgJ2NpdGUnLFxuICAgICAgICAgICAgICAgICdoZWxwJyxcbiAgICAgICAgICAgICAgICAnaWNvbicsXG4gICAgICAgICAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAgICAgICAgICduZXh0JyxcbiAgICAgICAgICAgICAgICAncHJlZmV0Y2gnLFxuICAgICAgICAgICAgICAgICdkbnMtcHJlZmV0Y2gnLFxuICAgICAgICAgICAgICAgICdwcmVyZW5kZXInLFxuICAgICAgICAgICAgICAgICdwcmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAncHJlbG9hZCcsXG4gICAgICAgICAgICAgICAgJ3ByZXYnLFxuICAgICAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgICdzdWJyZXNvdXJjZScsXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgXSksXG4gIF0sXG4gIFtcbiAgICAnU09VUkNFJyxcbiAgICBuZXcgTWFwPHN0cmluZywgQXR0cmlidXRlUG9saWN5PihbXG4gICAgICBbXG4gICAgICAgICdzcmMnLFxuICAgICAgICB7XG4gICAgICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdzcmNzZXQnLFxuICAgICAgICB7XG4gICAgICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgXSksXG4gIF0sXG4gIFtcbiAgICAnSU1HJyxcbiAgICBuZXcgTWFwPHN0cmluZywgQXR0cmlidXRlUG9saWN5PihbXG4gICAgICBbXG4gICAgICAgICdzcmMnLFxuICAgICAgICB7XG4gICAgICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdzcmNzZXQnLFxuICAgICAgICB7XG4gICAgICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgXSksXG4gIF0sXG4gIFtcbiAgICAnVklERU8nLFxuICAgIG5ldyBNYXA8c3RyaW5nLCBBdHRyaWJ1dGVQb2xpY3k+KFtcbiAgICAgIFtcbiAgICAgICAgJ3NyYycsXG4gICAgICAgIHtcbiAgICAgICAgICBwb2xpY3lBY3Rpb246IEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5LRUVQLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICBdKSxcbiAgXSxcbiAgW1xuICAgICdBVURJTycsXG4gICAgbmV3IE1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT4oW1xuICAgICAgW1xuICAgICAgICAnc3JjJyxcbiAgICAgICAge1xuICAgICAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIF0pLFxuICBdLFxuXTtcblxuY29uc3QgQUxMT1dFRF9HTE9CQUxfQVRUUklCVVRFUzogcmVhZG9ubHkgc3RyaW5nW10gPSBbXG4gICd0aXRsZScsXG4gICdhcmlhLWF0b21pYycsXG4gICdhcmlhLWF1dG9jb21wbGV0ZScsXG4gICdhcmlhLWJ1c3knLFxuICAnYXJpYS1jaGVja2VkJyxcbiAgJ2FyaWEtY3VycmVudCcsXG4gICdhcmlhLWRpc2FibGVkJyxcbiAgJ2FyaWEtZHJvcGVmZmVjdCcsXG4gICdhcmlhLWV4cGFuZGVkJyxcbiAgJ2FyaWEtaGFzcG9wdXAnLFxuICAnYXJpYS1oaWRkZW4nLFxuICAnYXJpYS1pbnZhbGlkJyxcbiAgJ2FyaWEtbGFiZWwnLFxuICAnYXJpYS1sZXZlbCcsXG4gICdhcmlhLWxpdmUnLFxuICAnYXJpYS1tdWx0aWxpbmUnLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnLFxuICAnYXJpYS1vcmllbnRhdGlvbicsXG4gICdhcmlhLXBvc2luc2V0JyxcbiAgJ2FyaWEtcHJlc3NlZCcsXG4gICdhcmlhLXJlYWRvbmx5JyxcbiAgJ2FyaWEtcmVsZXZhbnQnLFxuICAnYXJpYS1yZXF1aXJlZCcsXG4gICdhcmlhLXNlbGVjdGVkJyxcbiAgJ2FyaWEtc2V0c2l6ZScsXG4gICdhcmlhLXNvcnQnLFxuICAnYXJpYS12YWx1ZW1heCcsXG4gICdhcmlhLXZhbHVlbWluJyxcbiAgJ2FyaWEtdmFsdWVub3cnLFxuICAnYXJpYS12YWx1ZXRleHQnLFxuICAnYWx0JyxcbiAgJ2FsaWduJyxcbiAgJ2F1dG9jYXBpdGFsaXplJyxcbiAgJ2F1dG9jb21wbGV0ZScsXG4gICdhdXRvY29ycmVjdCcsXG4gICdhdXRvZm9jdXMnLFxuICAnYXV0b3BsYXknLFxuICAnYmdjb2xvcicsXG4gICdib3JkZXInLFxuICAnY2VsbHBhZGRpbmcnLFxuICAnY2VsbHNwYWNpbmcnLFxuICAnY2hlY2tlZCcsXG4gICdjb2xvcicsXG4gICdjb2xzJyxcbiAgJ2NvbHNwYW4nLFxuICAnY29udHJvbHMnLFxuICAnZGF0ZXRpbWUnLFxuICAnZGlzYWJsZWQnLFxuICAnZG93bmxvYWQnLFxuICAnZHJhZ2dhYmxlJyxcbiAgJ2VuY3R5cGUnLFxuICAnZmFjZScsXG4gICdmb3JtZW5jdHlwZScsXG4gICdmcmFtZWJvcmRlcicsXG4gICdoZWlnaHQnLFxuICAnaHJlZmxhbmcnLFxuICAnaGlkZGVuJyxcbiAgJ2lzbWFwJyxcbiAgJ2xhYmVsJyxcbiAgJ2xhbmcnLFxuICAnbG9vcCcsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21lZGlhJyxcbiAgJ21pbmxlbmd0aCcsXG4gICdtaW4nLFxuICAnbXVsdGlwbGUnLFxuICAnbXV0ZWQnLFxuICAnbm9uY2UnLFxuICAnb3BlbicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdwcmVsb2FkJyxcbiAgJ3JlbCcsXG4gICdyZXF1aXJlZCcsXG4gICdyZXZlcnNlZCcsXG4gICdyb2xlJyxcbiAgJ3Jvd3MnLFxuICAncm93c3BhbicsXG4gICdzZWxlY3RlZCcsXG4gICdzaGFwZScsXG4gICdzaXplJyxcbiAgJ3NpemVzJyxcbiAgJ3Nsb3QnLFxuICAnc3BhbicsXG4gICdzcGVsbGNoZWNrJyxcbiAgJ3N0YXJ0JyxcbiAgJ3N0ZXAnLFxuICAnc3VtbWFyeScsXG4gICd0cmFuc2xhdGUnLFxuICAndHlwZScsXG4gICd2YWxpZ24nLFxuICAndmFsdWUnLFxuICAnd2lkdGgnLFxuICAnd3JhcCcsXG4gICdpdGVtc2NvcGUnLFxuICAnaXRlbXR5cGUnLFxuICAnaXRlbWlkJyxcbiAgJ2l0ZW1wcm9wJyxcbiAgJ2l0ZW1yZWYnLFxuXTtcblxuY29uc3QgR0xPQkFMX0FUVFJJQlVURV9QT0xJQ0lFUzogUmVhZG9ubHlBcnJheTxbc3RyaW5nLCBBdHRyaWJ1dGVQb2xpY3ldPiA9IFtcbiAgW1xuICAgICdkaXInLFxuICAgIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX05PUk1BTElaRSxcbiAgICAgIGNvbmRpdGlvbnM6IHB1cmUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PihbXG4gICAgICAgICAgWydkaXInLCBuZXcgU2V0PHN0cmluZz4oWydhdXRvJywgJ2x0cicsICdydGwnXSldLFxuICAgICAgICBdKTtcbiAgICAgIH0pLFxuICAgIH0sXG4gIF0sXG4gIFtcbiAgICAnYXN5bmMnLFxuICAgIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX05PUk1BTElaRSxcbiAgICAgIGNvbmRpdGlvbnM6IHB1cmUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PihbXG4gICAgICAgICAgWydhc3luYycsIG5ldyBTZXQ8c3RyaW5nPihbJ2FzeW5jJ10pXSxcbiAgICAgICAgXSk7XG4gICAgICB9KSxcbiAgICB9LFxuICBdLFxuICBbXG4gICAgJ2NpdGUnLFxuICAgIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX1NBTklUSVpFX1VSTCxcbiAgICB9LFxuICBdLFxuICBbXG4gICAgJ2xvYWRpbmcnLFxuICAgIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX05PUk1BTElaRSxcbiAgICAgIGNvbmRpdGlvbnM6IHB1cmUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PihbXG4gICAgICAgICAgWydsb2FkaW5nJywgbmV3IFNldDxzdHJpbmc+KFsnZWFnZXInLCAnbGF6eSddKV0sXG4gICAgICAgIF0pO1xuICAgICAgfSksXG4gICAgfSxcbiAgXSxcbiAgW1xuICAgICdwb3N0ZXInLFxuICAgIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX1NBTklUSVpFX1VSTCxcbiAgICB9LFxuICBdLFxuICBbXG4gICAgJ3RhcmdldCcsXG4gICAge1xuICAgICAgcG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUF9BTkRfTk9STUFMSVpFLFxuICAgICAgY29uZGl0aW9uczogcHVyZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwPHN0cmluZywgU2V0PHN0cmluZz4+KFtcbiAgICAgICAgICBbJ3RhcmdldCcsIG5ldyBTZXQ8c3RyaW5nPihbJ19zZWxmJywgJ19ibGFuayddKV0sXG4gICAgICAgIF0pO1xuICAgICAgfSksXG4gICAgfSxcbiAgXSxcbl07XG5cbi8qKlxuICogU2FuaXRpemVyIHRhYmxlIGZvciB0aGUgZGVmYXVsdCBzYW5pdGl6ZXIgY29uZmlndXJhdGlvblxuICogLy8gQkVHSU4tSU5URVJOQUxcbiAqIFRoaXMgU2FuaXRpemVyVGFibGUgd2FzIGdlbmVyYXRlZCBmcm9tIHRoZSBjaGVja2VkIGluIGh0bWwgY29udHJhY3Q6XG4gKiAgd2VidXRpbC9odG1sL3R5cGVzL2NvZGVnZW4vaHRtbDVfY29udHJhY3QudGV4dHBiXG4gKlxuICogWW91IGNhbiByZWdlbmVyYXRlIHRoaXMgZmlsZSB3aXRoOlxuICogd2VidXRpbC9odG1sL3R5cGVzL2NvZGVnZW4vdXBkYXRlX2dlbmVyYXRlZF9zb3VyY2VfZmlsZXMuc2ggIC8vIEVORC1JTlRFUk5BTFxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFNhbml0aXplclRhYmxlID0gbmV3IFNhbml0aXplclRhYmxlKFxuICBuZXcgU2V0KEFMTE9XRURfRUxFTUVOVFMpLFxuICBuZXcgTWFwKEVMRU1FTlRfUE9MSUNJRVMpLFxuICBuZXcgU2V0KEFMTE9XRURfR0xPQkFMX0FUVFJJQlVURVMpLFxuICBuZXcgTWFwKEdMT0JBTF9BVFRSSUJVVEVfUE9MSUNJRVMpLFxuKTtcblxuLy8gQkVHSU4tSU5URVJOQUxcbi8qKlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIHRoZSBkZWZhdWx0IHNhbml0aXplciBjb25maWd1cmF0aW9uLCBidXQgdHJpZXMgdG8gYWxsb3cgYXNcbiAqIG1hbnkgdGhpbmdzIHdoaWxlIHN0aWxsIGd1YXJhbnRlZWluZyB0aGUgc2VjdXJpdHkgb2YgdGhlIG91dHB1dC5cbiAqXG4gKiBUaGlzIGNvbmZpZ3VyYXRpb24gZG9lcyBub3QgcHJvdGVjdCBhZ2FpbnN0IGdvL2RvbS1jbG9iYmVyaW5nLlxuICpcbiAqIFdlIGNvbnN0cnVjdCBpdCBkaXJlY3RseSByYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBgSHRtbFNhbml0aXplckJ1aWxkZXJgIHRvXG4gKiBtYWtlIHN1cmUgdGhhdCB0aGUgY29tcGlsZXIga25vd3MgaXQgY2FuIGJlIGRlYWQtY29kZSBlbGltaW5hdGVkIHdoZW4gdW51c2VkLlxuICovXG5leHBvcnQgY29uc3QgbGVuaWVudFNhbml0aXplclRhYmxlID0gbmV3IFNhbml0aXplclRhYmxlKFxuICBuZXcgU2V0KEFMTE9XRURfRUxFTUVOVFMuY29uY2F0KFsnQlVUVE9OJywgJ0lOUFVUJ10pKSxcbiAgbmV3IE1hcChFTEVNRU5UX1BPTElDSUVTKSxcbiAgbmV3IFNldChcbiAgICBwdXJlKCgpID0+IEFMTE9XRURfR0xPQkFMX0FUVFJJQlVURVMuY29uY2F0KFsnY2xhc3MnLCAnaWQnLCAnbmFtZSddKSksXG4gICksXG4gIG5ldyBNYXAoXG4gICAgcHVyZSgoKSA9PlxuICAgICAgR0xPQkFMX0FUVFJJQlVURV9QT0xJQ0lFUy5jb25jYXQoW1xuICAgICAgICAvLyBzYWZldmFsdWVzIGRvZXNuJ3QgaGF2ZSBhIHN0eWxlIHNhbml0aXplclxuICAgICAgICBbJ3N0eWxlJywge3BvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVB9XSxcbiAgICAgIF0pLFxuICAgICksXG4gICksXG4pO1xuXG4vKipcbiAqIFRoaXMgaXMgYWxzbyBzaW1pbGFyIHRvIHRoZSBkZWZhdWx0IHNhbml0aXplciBjb25maWd1cmF0aW9uLCBidXQgdHJpZXMgdG8gYmVcbiAqIGV2ZW4gbW9yZSBsZW5pZW50IHRoYW4gdGhlIGxlbmllbnRTYW5pdGl6ZXJUYWJsZSB3aGlsZSBzdGlsbCBndWFyYW50ZWVpbmdcbiAqIHRoYXQgdGhlIG91dHB1dCBjYW5ub3QgY2F1c2UgWFNTIGluIG1vZGVybiBicm93c2Vycy4gVGhpcyBzaG91bGQgb25seSBiZVxuICogdXNlZCB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5LiBTZWUgZ28vc3VwZXItbGVuaWVudC1zYW5pdGl6ZXIgZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uLlxuICpcbiAqIFdlIGNvbnN0cnVjdCBpdCBkaXJlY3RseSByYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBgSHRtbFNhbml0aXplckJ1aWxkZXJgIHRvXG4gKiBtYWtlIHN1cmUgdGhhdCB0aGUgY29tcGlsZXIga25vd3MgaXQgY2FuIGJlIGRlYWQtY29kZSBlbGltaW5hdGVkIHdoZW4gdW51c2VkLlxuICovXG5leHBvcnQgY29uc3Qgc3VwZXJMZW5pZW50U2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gIG5ldyBTZXQoXG4gICAgcHVyZSgoKSA9PlxuICAgICAgQUxMT1dFRF9FTEVNRU5UUy5jb25jYXQoW1xuICAgICAgICAnU1RZTEUnLFxuICAgICAgICAnVElUTEUnLFxuICAgICAgICAnSU5QVVQnLFxuICAgICAgICAnVEVYVEFSRUEnLFxuICAgICAgICAnQlVUVE9OJyxcbiAgICAgICAgJ0xBQkVMJyxcbiAgICAgIF0pLFxuICAgICksXG4gICksXG4gIG5ldyBNYXAoRUxFTUVOVF9QT0xJQ0lFUyksXG4gIG5ldyBTZXQoXG4gICAgcHVyZSgoKSA9PlxuICAgICAgQUxMT1dFRF9HTE9CQUxfQVRUUklCVVRFUy5jb25jYXQoW1xuICAgICAgICAnY2xhc3MnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAndGFiaW5kZXgnLFxuICAgICAgICAnY29udGVudGVkaXRhYmxlJyxcbiAgICAgICAgJ25hbWUnLFxuICAgICAgXSksXG4gICAgKSxcbiAgKSxcbiAgbmV3IE1hcChcbiAgICBwdXJlKCgpID0+XG4gICAgICBHTE9CQUxfQVRUUklCVVRFX1BPTElDSUVTLmNvbmNhdChbXG4gICAgICAgIC8vIHNhZmV2YWx1ZXMgZG9lc24ndCBoYXZlIGEgc3R5bGUgc2FuaXRpemVyXG4gICAgICAgIFsnc3R5bGUnLCB7cG9saWN5QWN0aW9uOiBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUH1dLFxuICAgICAgXSksXG4gICAgKSxcbiAgKSxcbiAgbmV3IFNldChbJ2RhdGEtJywgJ2FyaWEtJ10pLFxuKTtcbi8vIEVORC1JTlRFUk5BTFxuIl19
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_html_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_pure_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.pure");
const tsickle_secrets_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.secrets");
const tsickle_html_builders_5 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_builders");
const tsickle_url_builders_6 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_inert_fragment_7 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.inert_fragment");
const tsickle_no_clobber_8 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.no_clobber");
const tsickle_default_sanitizer_table_9 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.default_sanitizer_table");
const tsickle_sanitizer_table_10 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table");
const tsickle_SafeHtml_11 = goog.requireType("goog.html.SafeHtml");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const pure_1 = goog.require('google3.third_party.javascript.safevalues.internals.pure');
const secrets_1 = goog.require('google3.third_party.javascript.safevalues.internals.secrets');
const html_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_builders');
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
const inert_fragment_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.inert_fragment');
const no_clobber_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.no_clobber');
const default_sanitizer_table_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.default_sanitizer_table');
const sanitizer_table_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table');
// BEGIN-INTERNAL
const default_sanitizer_table_2 = default_sanitizer_table_1;
/**
 * An HTML5-compliant markup sanitizer that produces SafeHtml markup.
 *
 * You can build sanitizers with a custom configuration using the
 * HtmlSanitizerBuilder. // BEGIN-INTERNAL
 *
 * For any questions: go/safehtml-yaqs
 * Design document: go/ts-safehtml-sanitizer // END-INTERNAL
 * @record
 */
function HtmlSanitizer() { }
exports.HtmlSanitizer = HtmlSanitizer;
/* istanbul ignore if */
if (false) {
    /**
     * @public
     * @param {string} html
     * @return {!tsickle_SafeHtml_11}
     */
    HtmlSanitizer.prototype.sanitize = function (html) { };
    /**
     * @public
     * @param {string} html
     * @return {!DocumentFragment}
     */
    HtmlSanitizer.prototype.sanitizeToFragment = function (html) { };
    /**
     * @public
     * @param {string} html
     * @return {!tsickle_SafeHtml_11}
     */
    HtmlSanitizer.prototype.sanitizeAssertUnchanged = function (html) { };
}
/**
 * Implementation for `HtmlSanitizer`
 * @implements {HtmlSanitizer}
 */
class HtmlSanitizerImpl {
    /**
     * @public
     * @param {!tsickle_sanitizer_table_10.SanitizerTable} sanitizerTable
     * @param {!Object} token
     */
    constructor(sanitizerTable, token) {
        this.sanitizerTable = sanitizerTable;
        this.changes = [];
        (0, secrets_1.ensureTokenIsValid)(token);
    }
    /**
     * @public
     * @param {string} html
     * @return {!tsickle_SafeHtml_11}
     */
    sanitizeAssertUnchanged(html) {
        if (dev_1.DEV_MODE) {
            this.changes = [];
        }
        /** @type {!tsickle_SafeHtml_11} */
        const sanitizedHtml = this.sanitize(html);
        if (dev_1.DEV_MODE && this.changes.length !== 0) {
            throw new Error(`Unexpected change to HTML value as a result of sanitization. ` +
                `Input: "${html}", sanitized output: "${sanitizedHtml}"\n` +
                `List of changes:${this.changes.join('\n')}`);
        }
        return sanitizedHtml;
    }
    /**
     * @public
     * @param {string} html
     * @return {!tsickle_SafeHtml_11}
     */
    sanitize(html) {
        /** @type {!Document} */
        const inertDocument = document.implementation.createHTMLDocument('');
        return (0, html_builders_1.nodeToHtmlInternal)(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);
    }
    /**
     * @public
     * @param {string} html
     * @return {!DocumentFragment}
     */
    sanitizeToFragment(html) {
        /** @type {!Document} */
        const inertDocument = document.implementation.createHTMLDocument('');
        return this.sanitizeToFragmentInternal(html, inertDocument);
    }
    /**
     * @private
     * @param {string} html
     * @param {!Document} inertDocument
     * @return {!DocumentFragment}
     */
    sanitizeToFragmentInternal(html, inertDocument) {
        /** @type {!DocumentFragment} */
        const dirtyFragment = (0, inert_fragment_1.createInertFragment)(html, inertDocument);
        /** @type {!TreeWalker} */
        const treeWalker = document.createTreeWalker(dirtyFragment, 5 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT */, (/** @type {(function(!Node): number|{acceptNode: function(!Node): number})} */ ((/** @type {*} */ (
        // IE10 and IE11 won't accept a proper `NodeFilter` interface, and
        // expect the filtering function to be passed directly. It seems that
        // other browsers also do not mind getting the function directly. see
        // https://stackoverflow.com/q/38245898
        ((/**
         * @param {!Node} n
         * @return {number}
         */
        (n) => this.nodeFilter(n))))))), 
        // tslint:disable-next-line:ban-ts-suppressions  // LINE-INTERNAL
        // @ts-ignore: error TS2554: Expected 1-3 arguments, but got 4.
        false);
        // `nextNode` is called so we skip the root `DocumentFragment`.
        /** @type {(null|!Node)} */
        let currentNode = treeWalker.nextNode();
        // We create a root element to attach all the children of the body to. We
        // use div as it as a semantic-free, generic container and does not
        // represent anything. This is removed when we serialize the tree back
        // into a string.
        /** @type {!DocumentFragment} */
        const sanitizedFragment = inertDocument.createDocumentFragment();
        /** @type {!Node} */
        let sanitizedParent = sanitizedFragment;
        while (currentNode !== null) {
            /** @type {?} */
            let sanitizedNode;
            if ((0, no_clobber_1.isText)(currentNode)) {
                sanitizedNode = this.sanitizeTextNode(currentNode);
            }
            else if ((0, no_clobber_1.isElement)(currentNode)) {
                sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);
            }
            else {
                /** @type {string} */
                let message = '';
                if (dev_1.DEV_MODE) {
                    message = 'Node is not of type text or element';
                }
                throw new Error(message);
            }
            sanitizedParent.appendChild(sanitizedNode);
            // Advance iterator while keeping track of the sanitized parent for the
            // current node
            currentNode = treeWalker.firstChild();
            if (currentNode) {
                sanitizedParent = sanitizedNode;
            }
            else {
                while (!(currentNode = treeWalker.nextSibling())) {
                    if (!(currentNode = treeWalker.parentNode())) {
                        break;
                    }
                    sanitizedParent = (/** @type {!ParentNode} */ (sanitizedParent.parentNode));
                }
            }
        }
        return sanitizedFragment;
    }
    /**
     * @private
     * @param {!Text} textNode
     * @return {!Text}
     */
    sanitizeTextNode(textNode) {
        return document.createTextNode(textNode.data);
    }
    /**
     * @private
     * @param {!Element} elementNode
     * @param {!Document} inertDocument
     * @return {!Element}
     */
    sanitizeElementNode(elementNode, inertDocument) {
        /** @type {string} */
        const elementName = (0, no_clobber_1.getNodeName)(elementNode);
        /** @type {!HTMLElement} */
        const newNode = inertDocument.createElement(elementName);
        /** @type {!NamedNodeMap} */
        const dirtyAttributes = elementNode.attributes;
        for (const { name, value } of dirtyAttributes) {
            /** @type {!tsickle_sanitizer_table_10.AttributePolicy} */
            const policy = this.sanitizerTable.getAttributePolicy(name, elementName);
            if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {
                this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);
                continue;
            }
            switch (policy.policyAction) {
                case sanitizer_table_1.AttributePolicyAction.KEEP:
                    setAttribute(newNode, name, value);
                    break;
                case sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_URL:
                    /** @type {string} */
                    const sanitizedAttrUrl = (0, url_builders_1.restrictivelySanitizeUrl)(value);
                    if (sanitizedAttrUrl !== value) {
                        this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:"${value}" was sanitized to: "${sanitizedAttrUrl}"`);
                    }
                    setAttribute(newNode, name, sanitizedAttrUrl);
                    break;
                case sanitizer_table_1.AttributePolicyAction.KEEP_AND_NORMALIZE:
                    // We don't consider changing the case of an attribute value to be a
                    // semantic change
                    setAttribute(newNode, name, value.toLowerCase());
                    break;
                case sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:
                    setAttribute(newNode, name, value);
                    break;
                case sanitizer_table_1.AttributePolicyAction.DROP:
                    this.recordChange(`Attribute: ${name} was dropped`);
                    break;
                default:
                    if (dev_1.DEV_MODE) {
                        checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');
                    }
            }
        }
        return newNode;
    }
    /**
     * @public
     * @param {!Node} node
     * @return {number}
     */
    nodeFilter(node) {
        if ((0, no_clobber_1.isText)(node)) {
            return 1; // NodeFilter.FILTER_ACCEPT
        }
        else if (!(0, no_clobber_1.isElement)(node)) {
            // Getting a node that is neither an `Element` or a `Text` node. This is
            // likely due to something that is not supposed to be an element in user
            // code but recognized as such by the TreeWalker (e.g. a polyfill for
            // other kind of nodes). Since we can't recognize it as an element, we
            // drop the node, but we don't record it as a meaningful change.
            return 2; // NodeFilter.FILTER_REJECT
        }
        /** @type {string} */
        const nodeName = (0, no_clobber_1.getNodeName)(node);
        if (nodeName === null) {
            this.recordChange(`Node name was null for node: ${node}`);
            return 2; // NodeFilter.FILTER_REJECT
        }
        if (this.sanitizerTable.isAllowedElement(nodeName)) {
            return 1; // NodeFilter.FILTER_ACCEPT
        }
        this.recordChange(`Element: ${nodeName} was dropped`);
        return 2; // NodeFilter.FILTER_REJECT
    }
    /**
     * @private
     * @param {string} errorMessage
     * @return {void}
     */
    recordChange(errorMessage) {
        if (dev_1.DEV_MODE) {
            this.changes.push(errorMessage);
        }
    }
    /**
     * @private
     * @param {(undefined|!ReadonlyMap<string, !Set<string>>)} conditions
     * @param {!NamedNodeMap} attrs
     * @return {boolean}
     */
    satisfiesAllConditions(conditions, attrs) {
        if (!conditions) {
            return true;
        }
        for (const [attrName__tsickle_destructured_1, expectedValues__tsickle_destructured_2] of conditions) {
            const attrName = /** @type {string} */ (attrName__tsickle_destructured_1);
            const expectedValues = /** @type {!Set<string>} */ (expectedValues__tsickle_destructured_2);
            /** @type {(undefined|string)} */
            const value = attrs.getNamedItem(attrName)?.value;
            if (value && !expectedValues.has(value)) {
                return false;
            }
        }
        return true;
    }
}
exports.HtmlSanitizerImpl = HtmlSanitizerImpl;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!Array<string>}
     * @private
     */
    HtmlSanitizerImpl.prototype.changes;
    /**
     * @const {!tsickle_sanitizer_table_10.SanitizerTable}
     * @private
     */
    HtmlSanitizerImpl.prototype.sanitizerTable;
}
/**
 * @noinline Helper to save on codesize.
 * @param {!Element} el
 * @param {string} name
 * @param {string} value
 * @return {void}
 */
function setAttribute(el, name, value) {
    el.setAttribute(name, value);
}
/** @type {!HtmlSanitizerImpl} */
const defaultHtmlSanitizer = (0, pure_1.pure)((/**
 * @return {!HtmlSanitizerImpl}
 */
() => new HtmlSanitizerImpl(default_sanitizer_table_1.defaultSanitizerTable, secrets_1.secretToken)));
/**
 * Sanitizes untrusted html using the default sanitizer configuration.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function sanitizeHtml(html) {
    return defaultHtmlSanitizer.sanitize(html);
}
exports.sanitizeHtml = sanitizeHtml;
/**
 * Sanitizes untrusted html using the default sanitizer configuration. Throws
 * an error if the html was changed.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function sanitizeHtmlAssertUnchanged(html) {
    return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);
}
exports.sanitizeHtmlAssertUnchanged = sanitizeHtmlAssertUnchanged;
/**
 * Sanitizes untrusted html using the default sanitizer configuration. Throws
 * an error if the html was changed.
 * @param {string} html
 * @return {!DocumentFragment}
 */
function sanitizeHtmlToFragment(html) {
    return defaultHtmlSanitizer.sanitizeToFragment(html);
}
exports.sanitizeHtmlToFragment = sanitizeHtmlToFragment;
// BEGIN-INTERNAL
/** @type {!HtmlSanitizerImpl} */
const lenientHtmlSanitizer = (0, pure_1.pure)((/**
 * @return {!HtmlSanitizerImpl}
 */
() => new HtmlSanitizerImpl(default_sanitizer_table_2.lenientSanitizerTable, secrets_1.secretToken)));
/**
 * Sanitize the given HTML fragment in as lenient of a way as possible while
 * still guaranteeing that the output is safe.
 *
 * This sanitizer does not protect against go/dom-clobbering. Use the normal
 * sanitizer instead if possible.
 *
 * If at all possible, prefer using `sanitizeHtml` over this method.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function lenientlySanitizeHtml(html) {
    return lenientHtmlSanitizer.sanitize(html);
}
exports.lenientlySanitizeHtml = lenientlySanitizeHtml;
/**
 * Like `sanitizeHtmlAssertUnchanged` but using the lenient sanitizer.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function lenientlySanitizeHtmlAssertUnchanged(html) {
    return lenientHtmlSanitizer.sanitizeAssertUnchanged(html);
}
exports.lenientlySanitizeHtmlAssertUnchanged = lenientlySanitizeHtmlAssertUnchanged;
/** @type {!HtmlSanitizerImpl} */
const superLenientHtmlSanitizer = (0, pure_1.pure)((/**
 * @return {!HtmlSanitizerImpl}
 */
() => new HtmlSanitizerImpl(default_sanitizer_table_2.superLenientSanitizerTable, secrets_1.secretToken)));
/**
 * Sanitize the given HTML fragment in an extremely lenient way while
 * still guaranteeing that the output cannot lead to XSS in modern browsers.
 *
 * If at all possible, prefer using `sanitizeHtml` or `lenientlySanitizeHtml`
 * over this method.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function superLenientlySanitizeHtml(html) {
    return superLenientHtmlSanitizer.sanitize(html);
}
exports.superLenientlySanitizeHtml = superLenientlySanitizeHtml;
/**
 * Like `superLenientlySanitizeHtml` but it throws an exception if the output
 * is changed.
 * @param {string} html
 * @return {!tsickle_SafeHtml_11}
 */
function superLenientlySanitizeHtmlAssertUnchanged(html) {
    return superLenientHtmlSanitizer.sanitizeAssertUnchanged(html);
}
exports.superLenientlySanitizeHtmlAssertUnchanged = superLenientlySanitizeHtmlAssertUnchanged;
// END-INTERNAL
/**
 * @param {?} value
 * @param {string=} msg
 * @return {?}
 */
function checkExhaustive(value, msg = `unexpected value ${value}!`) {
    throw new Error(msg);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF9zYW5pdGl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvaHRtbF9zYW5pdGl6ZXIvaHRtbF9zYW5pdGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHdGQUErQztBQUUvQyx3RkFBMEM7QUFDMUMsOEZBQXdFO0FBQ3hFLHlHQUFvRDtBQUNwRCx1R0FBeUQ7QUFFekQsMEhBQXFEO0FBQ3JELGtIQUE0RDtBQUM1RCw0SkFBZ0Y7QUFDaEYsNElBRzJDOztBQUczQyw0REFHbUQ7Ozs7Ozs7Ozs7O0FBWW5ELDRCQUlDOzs7Ozs7Ozs7SUFIQyx1REFBaUM7Ozs7OztJQUNqQyxpRUFBbUQ7Ozs7OztJQUNuRCxzRUFBZ0Q7Ozs7OztBQUlsRCxNQUFhLGlCQUFpQjs7Ozs7O0lBRTVCLFlBQ21CLGNBQThCLEVBQy9DLEtBQWE7UUFESSxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFGekMsWUFBTyxHQUFhLEVBQUUsQ0FBQztRQUs3QixJQUFBLDRCQUFrQixFQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVCLENBQUM7Ozs7OztJQUVELHVCQUF1QixDQUFDLElBQVk7UUFDbEMsSUFBSSxjQUFRLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7O2NBQ0ssYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQ3pDLElBQUksY0FBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzFDLE1BQU0sSUFBSSxLQUFLLENBQ2IsK0RBQStEO2dCQUM3RCxXQUFXLElBQUkseUJBQXlCLGFBQWEsS0FBSztnQkFDMUQsbUJBQW1CLElBQUksQ0FBQyxPQUFPLENB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U0FBZ0IseUNBQXlDLENBQ3ZELElBQVk7SUFFWixPQUFPLHlCQUF5QixDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFKRCw4RkFJQzs7Ozs7OztBQUdELFNBQVMsZUFBZSxDQUN0QixLQUFZLEVBQ1osR0FBRyxHQUFHLG9CQUFvQixLQUFLLEdBQUc7SUFFbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudC9kZXYnO1xuaW1wb3J0IHtTYWZlSHRtbH0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL2h0bWxfaW1wbCc7XG5pbXBvcnQge3B1cmV9IGZyb20gJy4uLy4uL2ludGVybmFscy9wdXJlJztcbmltcG9ydCB7ZW5zdXJlVG9rZW5Jc1ZhbGlkLCBzZWNyZXRUb2tlbn0gZnJvbSAnLi4vLi4vaW50ZXJuYWxzL3NlY3JldHMnO1xuaW1wb3J0IHtub2RlVG9IdG1sSW50ZXJuYWx9IGZyb20gJy4uL2h0bWxfYnVpbGRlcnMnO1xuaW1wb3J0IHtyZXN0cmljdGl2ZWx5U2FuaXRpemVVcmx9IGZyb20gJy4uL3VybF9idWlsZGVycyc7XG5cbmltcG9ydCB7Y3JlYXRlSW5lcnRGcmFnbWVudH0gZnJvbSAnLi9pbmVydF9mcmFnbWVudCc7XG5pbXBvcnQge2dldE5vZGVOYW1lLCBpc0VsZW1lbnQsIGlzVGV4dH0gZnJvbSAnLi9ub19jbG9iYmVyJztcbmltcG9ydCB7ZGVmYXVsdFNhbml0aXplclRhYmxlfSBmcm9tICcuL3Nhbml0aXplcl90YWJsZS9kZWZhdWx0X3Nhbml0aXplcl90YWJsZSc7XG5pbXBvcnQge1xuICBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24sXG4gIFNhbml0aXplclRhYmxlLFxufSBmcm9tICcuL3Nhbml0aXplcl90YWJsZS9zYW5pdGl6ZXJfdGFibGUnO1xuXG4vLyBCRUdJTi1JTlRFUk5BTFxuaW1wb3J0IHtcbiAgbGVuaWVudFNhbml0aXplclRhYmxlLFxuICBzdXBlckxlbmllbnRTYW5pdGl6ZXJUYWJsZSxcbn0gZnJvbSAnLi9zYW5pdGl6ZXJfdGFibGUvZGVmYXVsdF9zYW5pdGl6ZXJfdGFibGUnO1xuLy8gRU5ELUlOVEVSTkFMXG5cbi8qKlxuICogQW4gSFRNTDUtY29tcGxpYW50IG1hcmt1cCBzYW5pdGl6ZXIgdGhhdCBwcm9kdWNlcyBTYWZlSHRtbCBtYXJrdXAuXG4gKlxuICogWW91IGNhbiBidWlsZCBzYW5pdGl6ZXJzIHdpdGggYSBjdXN0b20gY29uZmlndXJhdGlvbiB1c2luZyB0aGVcbiAqIEh0bWxTYW5pdGl6ZXJCdWlsZGVyLiAvLyBCRUdJTi1JTlRFUk5BTFxuICpcbiAqIEZvciBhbnkgcXVlc3Rpb25zOiBnby9zYWZlaHRtbC15YXFzXG4gKiBEZXNpZ24gZG9jdW1lbnQ6IGdvL3RzLXNhZmVodG1sLXNhbml0aXplciAvLyBFTkQtSU5URVJOQUxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIdG1sU2FuaXRpemVyIHtcbiAgc2FuaXRpemUoaHRtbDogc3RyaW5nKTogU2FmZUh0bWw7XG4gIHNhbml0aXplVG9GcmFnbWVudChodG1sOiBzdHJpbmcpOiBEb2N1bWVudEZyYWdtZW50O1xuICBzYW5pdGl6ZUFzc2VydFVuY2hhbmdlZChodG1sOiBzdHJpbmcpOiBTYWZlSHRtbDtcbn1cblxuLyoqIEltcGxlbWVudGF0aW9uIGZvciBgSHRtbFNhbml0aXplcmAgKi9cbmV4cG9ydCBjbGFzcyBIdG1sU2FuaXRpemVySW1wbCBpbXBsZW1lbnRzIEh0bWxTYW5pdGl6ZXIge1xuICBwcml2YXRlIGNoYW5nZXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2FuaXRpemVyVGFibGU6IFNhbml0aXplclRhYmxlLFxuICAgIHRva2VuOiBvYmplY3QsXG4gICkge1xuICAgIGVuc3VyZVRva2VuSXNWYWxpZCh0b2tlbik7XG4gIH1cblxuICBzYW5pdGl6ZUFzc2VydFVuY2hhbmdlZChodG1sOiBzdHJpbmcpOiBTYWZlSHRtbCB7XG4gICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IHRoaXMuc2FuaXRpemUoaHRtbCk7XG4gICAgaWYgKERFVl9NT0RFICYmIHRoaXMuY2hhbmdlcy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgY2hhbmdlIHRvIEhUTUwgdmFsdWUgYXMgYSByZXN1bHQgb2Ygc2FuaXRpemF0aW9uLiBgICtcbiAgICAgICAgICBgSW5wdXQ6IFwiJHtodG1sfVwiLCBzYW5pdGl6ZWQgb3V0cHV0OiBcIiR7c2FuaXRpemVkSHRtbH1cIlxcbmAgK1xuICAgICAgICAgIGBMaXN0IG9mIGNoYW5nZXM6JHt0aGlzLmNoYW5nZXMuam9pbignXFxuJyl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWRIdG1sO1xuICB9XG5cbiAgc2FuaXRpemUoaHRtbDogc3RyaW5nKTogU2FmZUh0bWwge1xuICAgIGNvbnN0IGluZXJ0RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuXG4gICAgcmV0dXJuIG5vZGVUb0h0bWxJbnRlcm5hbChcbiAgICAgIHRoaXMuc2FuaXRpemVUb0ZyYWdtZW50SW50ZXJuYWwoaHRtbCwgaW5lcnREb2N1bWVudCksXG4gICAgICBpbmVydERvY3VtZW50LmJvZHksXG4gICAgKTtcbiAgfVxuXG4gIHNhbml0aXplVG9GcmFnbWVudChodG1sOiBzdHJpbmcpOiBEb2N1bWVudEZyYWdtZW50IHtcbiAgICBjb25zdCBpbmVydERvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZVRvRnJhZ21lbnRJbnRlcm5hbChodG1sLCBpbmVydERvY3VtZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVUb0ZyYWdtZW50SW50ZXJuYWwoXG4gICAgaHRtbDogc3RyaW5nLFxuICAgIGluZXJ0RG9jdW1lbnQ6IERvY3VtZW50LFxuICApOiBEb2N1bWVudEZyYWdtZW50IHtcbiAgICBjb25zdCBkaXJ0eUZyYWdtZW50ID0gY3JlYXRlSW5lcnRGcmFnbWVudChodG1sLCBpbmVydERvY3VtZW50KTtcblxuICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgZGlydHlGcmFnbWVudCxcbiAgICAgIDUgLyogTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCAqLyxcbiAgICAgIC8vIElFMTAgYW5kIElFMTEgd29uJ3QgYWNjZXB0IGEgcHJvcGVyIGBOb2RlRmlsdGVyYCBpbnRlcmZhY2UsIGFuZFxuICAgICAgLy8gZXhwZWN0IHRoZSBmaWx0ZXJpbmcgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIGRpcmVjdGx5LiBJdCBzZWVtcyB0aGF0XG4gICAgICAvLyBvdGhlciBicm93c2VycyBhbHNvIGRvIG5vdCBtaW5kIGdldHRpbmcgdGhlIGZ1bmN0aW9uIGRpcmVjdGx5LiBzZWVcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zODI0NTg5OFxuICAgICAgKChuOiBOb2RlKSA9PiB0aGlzLm5vZGVGaWx0ZXIobikpIGFzIHVua25vd24gYXMgTm9kZUZpbHRlcixcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHMtc3VwcHJlc3Npb25zICAvLyBMSU5FLUlOVEVSTkFMXG4gICAgICAvLyBAdHMtaWdub3JlOiBlcnJvciBUUzI1NTQ6IEV4cGVjdGVkIDEtMyBhcmd1bWVudHMsIGJ1dCBnb3QgNC5cbiAgICAgIGZhbHNlLCAvLyBUaGlzIGlzIHJlcXVpcmVkIGluIElFIGFuZCBpZ25vcmVkIGluIG90aGVyIGJyb3dzZXJzLlxuICAgICk7XG5cbiAgICAvLyBgbmV4dE5vZGVgIGlzIGNhbGxlZCBzbyB3ZSBza2lwIHRoZSByb290IGBEb2N1bWVudEZyYWdtZW50YC5cbiAgICBsZXQgY3VycmVudE5vZGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG4gICAgLy8gV2UgY3JlYXRlIGEgcm9vdCBlbGVtZW50IHRvIGF0dGFjaCBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBib2R5IHRvLiBXZVxuICAgIC8vIHVzZSBkaXYgYXMgaXQgYXMgYSBzZW1hbnRpYy1mcmVlLCBnZW5lcmljIGNvbnRhaW5lciBhbmQgZG9lcyBub3RcbiAgICAvLyByZXByZXNlbnQgYW55dGhpbmcuIFRoaXMgaXMgcmVtb3ZlZCB3aGVuIHdlIHNlcmlhbGl6ZSB0aGUgdHJlZSBiYWNrXG4gICAgLy8gaW50byBhIHN0cmluZy5cbiAgICBjb25zdCBzYW5pdGl6ZWRGcmFnbWVudCA9IGluZXJ0RG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGxldCBzYW5pdGl6ZWRQYXJlbnQ6IE5vZGUgPSBzYW5pdGl6ZWRGcmFnbWVudDtcblxuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHNhbml0aXplZE5vZGU7XG5cbiAgICAgIGlmIChpc1RleHQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHNhbml0aXplZE5vZGUgPSB0aGlzLnNhbml0aXplVGV4dE5vZGUoY3VycmVudE5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHNhbml0aXplZE5vZGUgPSB0aGlzLnNhbml0aXplRWxlbWVudE5vZGUoY3VycmVudE5vZGUsIGluZXJ0RG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKERFVl9NT0RFKSB7XG4gICAgICAgICAgbWVzc2FnZSA9ICdOb2RlIGlzIG5vdCBvZiB0eXBlIHRleHQgb3IgZWxlbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBzYW5pdGl6ZWRQYXJlbnQuYXBwZW5kQ2hpbGQoc2FuaXRpemVkTm9kZSk7XG5cbiAgICAgIC8vIEFkdmFuY2UgaXRlcmF0b3Igd2hpbGUga2VlcGluZyB0cmFjayBvZiB0aGUgc2FuaXRpemVkIHBhcmVudCBmb3IgdGhlXG4gICAgICAvLyBjdXJyZW50IG5vZGVcbiAgICAgIGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCk7XG4gICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgc2FuaXRpemVkUGFyZW50ID0gc2FuaXRpemVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlICghKGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5uZXh0U2libGluZygpKSkge1xuICAgICAgICAgIGlmICghKGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5wYXJlbnROb2RlKCkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FuaXRpemVkUGFyZW50ID0gc2FuaXRpemVkUGFyZW50LnBhcmVudE5vZGUhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWRGcmFnbWVudDtcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVUZXh0Tm9kZSh0ZXh0Tm9kZTogVGV4dCk6IFRleHQge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0Tm9kZS5kYXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVFbGVtZW50Tm9kZShcbiAgICBlbGVtZW50Tm9kZTogRWxlbWVudCxcbiAgICBpbmVydERvY3VtZW50OiBEb2N1bWVudCxcbiAgKTogRWxlbWVudCB7XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBnZXROb2RlTmFtZShlbGVtZW50Tm9kZSk7XG4gICAgY29uc3QgbmV3Tm9kZSA9IGluZXJ0RG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50TmFtZSk7XG4gICAgY29uc3QgZGlydHlBdHRyaWJ1dGVzID0gZWxlbWVudE5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB2YWx1ZX0gb2YgZGlydHlBdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBwb2xpY3kgPSB0aGlzLnNhbml0aXplclRhYmxlLmdldEF0dHJpYnV0ZVBvbGljeShuYW1lLCBlbGVtZW50TmFtZSk7XG4gICAgICBpZiAoIXRoaXMuc2F0aXNmaWVzQWxsQ29uZGl0aW9ucyhwb2xpY3kuY29uZGl0aW9ucywgZGlydHlBdHRyaWJ1dGVzKSkge1xuICAgICAgICB0aGlzLnJlY29yZENoYW5nZShcbiAgICAgICAgICBgTm90IGFsbCBjb25kaXRpb25zIHNhdGlzZmllZCBmb3IgYXR0cmlidXRlOiAke25hbWV9LmAsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHBvbGljeS5wb2xpY3lBY3Rpb24pIHtcbiAgICAgICAgY2FzZSBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUDpcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUobmV3Tm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5LRUVQX0FORF9TQU5JVElaRV9VUkw6XG4gICAgICAgICAgY29uc3Qgc2FuaXRpemVkQXR0clVybCA9IHJlc3RyaWN0aXZlbHlTYW5pdGl6ZVVybCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHNhbml0aXplZEF0dHJVcmwgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENoYW5nZShcbiAgICAgICAgICAgICAgYFVybCBpbiBhdHRyaWJ1dGUgJHtuYW1lfSB3YXMgbW9kaWZpZWQgZHVyaW5nIHNhbml0aXphdGlvbi4gT3JpZ2luYWwgdXJsOlwiJHt2YWx1ZX1cIiB3YXMgc2FuaXRpemVkIHRvOiBcIiR7c2FuaXRpemVkQXR0clVybH1cImAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEF0dHJpYnV0ZShuZXdOb2RlLCBuYW1lLCBzYW5pdGl6ZWRBdHRyVXJsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24uS0VFUF9BTkRfTk9STUFMSVpFOlxuICAgICAgICAgIC8vIFdlIGRvbid0IGNvbnNpZGVyIGNoYW5naW5nIHRoZSBjYXNlIG9mIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byBiZSBhXG4gICAgICAgICAgLy8gc2VtYW50aWMgY2hhbmdlXG4gICAgICAgICAgc2V0QXR0cmlidXRlKG5ld05vZGUsIG5hbWUsIHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5LRUVQX0FORF9TQU5JVElaRV9TVFlMRTpcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUobmV3Tm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5EUk9QOlxuICAgICAgICAgIHRoaXMucmVjb3JkQ2hhbmdlKGBBdHRyaWJ1dGU6ICR7bmFtZX0gd2FzIGRyb3BwZWRgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoREVWX01PREUpIHtcbiAgICAgICAgICAgIGNoZWNrRXhoYXVzdGl2ZShcbiAgICAgICAgICAgICAgcG9saWN5LnBvbGljeUFjdGlvbixcbiAgICAgICAgICAgICAgJ1VuaGFuZGxlZCBBdHRyaWJ1dGVQb2xpY3lBY3Rpb24gY2FzZScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBub2RlRmlsdGVyKG5vZGU6IE5vZGUpOiBudW1iZXIge1xuICAgIGlmIChpc1RleHQobm9kZSkpIHtcbiAgICAgIHJldHVybiAxOyAvLyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFRcbiAgICB9IGVsc2UgaWYgKCFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIEdldHRpbmcgYSBub2RlIHRoYXQgaXMgbmVpdGhlciBhbiBgRWxlbWVudGAgb3IgYSBgVGV4dGAgbm9kZS4gVGhpcyBpc1xuICAgICAgLy8gbGlrZWx5IGR1ZSB0byBzb21ldGhpbmcgdGhhdCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgYW4gZWxlbWVudCBpbiB1c2VyXG4gICAgICAvLyBjb2RlIGJ1dCByZWNvZ25pemVkIGFzIHN1Y2ggYnkgdGhlIFRyZWVXYWxrZXIgKGUuZy4gYSBwb2x5ZmlsbCBmb3JcbiAgICAgIC8vIG90aGVyIGtpbmQgb2Ygbm9kZXMpLiBTaW5jZSB3ZSBjYW4ndCByZWNvZ25pemUgaXQgYXMgYW4gZWxlbWVudCwgd2VcbiAgICAgIC8vIGRyb3AgdGhlIG5vZGUsIGJ1dCB3ZSBkb24ndCByZWNvcmQgaXQgYXMgYSBtZWFuaW5nZnVsIGNoYW5nZS5cbiAgICAgIHJldHVybiAyOyAvLyBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1RcbiAgICB9XG5cbiAgICBjb25zdCBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG5vZGUpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yZWNvcmRDaGFuZ2UoYE5vZGUgbmFtZSB3YXMgbnVsbCBmb3Igbm9kZTogJHtub2RlfWApO1xuICAgICAgcmV0dXJuIDI7IC8vIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVFxuICAgIH1cblxuICAgIGlmICh0aGlzLnNhbml0aXplclRhYmxlLmlzQWxsb3dlZEVsZW1lbnQobm9kZU5hbWUpKSB7XG4gICAgICByZXR1cm4gMTsgLy8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUXG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRDaGFuZ2UoYEVsZW1lbnQ6ICR7bm9kZU5hbWV9IHdhcyBkcm9wcGVkYCk7XG4gICAgcmV0dXJuIDI7IC8vIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVFxuICB9XG5cbiAgcHJpdmF0ZSByZWNvcmRDaGFuZ2UoZXJyb3JNZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBpZiAoREVWX01PREUpIHtcbiAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzYXRpc2ZpZXNBbGxDb25kaXRpb25zKFxuICAgIGNvbmRpdGlvbnM6IFJlYWRvbmx5TWFwPHN0cmluZywgU2V0PHN0cmluZz4+IHwgdW5kZWZpbmVkLFxuICAgIGF0dHJzOiBOYW1lZE5vZGVNYXAsXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmICghY29uZGl0aW9ucykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIGV4cGVjdGVkVmFsdWVzXSBvZiBjb25kaXRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJzLmdldE5hbWVkSXRlbShhdHRyTmFtZSk/LnZhbHVlO1xuICAgICAgaWYgKHZhbHVlICYmICFleHBlY3RlZFZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKiogQG5vaW5saW5lIEhlbHBlciB0byBzYXZlIG9uIGNvZGVzaXplLiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsOiBFbGVtZW50LCBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdEh0bWxTYW5pdGl6ZXIgPSBwdXJlKFxuICAoKSA9PiBuZXcgSHRtbFNhbml0aXplckltcGwoZGVmYXVsdFNhbml0aXplclRhYmxlLCBzZWNyZXRUb2tlbiksXG4pO1xuXG4vKiogU2FuaXRpemVzIHVudHJ1c3RlZCBodG1sIHVzaW5nIHRoZSBkZWZhdWx0IHNhbml0aXplciBjb25maWd1cmF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplSHRtbChodG1sOiBzdHJpbmcpOiBTYWZlSHRtbCB7XG4gIHJldHVybiBkZWZhdWx0SHRtbFNhbml0aXplci5zYW5pdGl6ZShodG1sKTtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgdW50cnVzdGVkIGh0bWwgdXNpbmcgdGhlIGRlZmF1bHQgc2FuaXRpemVyIGNvbmZpZ3VyYXRpb24uIFRocm93c1xuICogYW4gZXJyb3IgaWYgdGhlIGh0bWwgd2FzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQoaHRtbDogc3RyaW5nKTogU2FmZUh0bWwge1xuICByZXR1cm4gZGVmYXVsdEh0bWxTYW5pdGl6ZXIuc2FuaXRpemVBc3NlcnRVbmNoYW5nZWQoaHRtbCk7XG59XG5cbi8qKlxuICogU2FuaXRpemVzIHVudHJ1c3RlZCBodG1sIHVzaW5nIHRoZSBkZWZhdWx0IHNhbml0aXplciBjb25maWd1cmF0aW9uLiBUaHJvd3NcbiAqIGFuIGVycm9yIGlmIHRoZSBodG1sIHdhcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIdG1sVG9GcmFnbWVudChodG1sOiBzdHJpbmcpOiBEb2N1bWVudEZyYWdtZW50IHtcbiAgcmV0dXJuIGRlZmF1bHRIdG1sU2FuaXRpemVyLnNhbml0aXplVG9GcmFnbWVudChodG1sKTtcbn1cblxuLy8gQkVHSU4tSU5URVJOQUxcbmNvbnN0IGxlbmllbnRIdG1sU2FuaXRpemVyID0gcHVyZShcbiAgKCkgPT4gbmV3IEh0bWxTYW5pdGl6ZXJJbXBsKGxlbmllbnRTYW5pdGl6ZXJUYWJsZSwgc2VjcmV0VG9rZW4pLFxuKTtcblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgZ2l2ZW4gSFRNTCBmcmFnbWVudCBpbiBhcyBsZW5pZW50IG9mIGEgd2F5IGFzIHBvc3NpYmxlIHdoaWxlXG4gKiBzdGlsbCBndWFyYW50ZWVpbmcgdGhhdCB0aGUgb3V0cHV0IGlzIHNhZmUuXG4gKlxuICogVGhpcyBzYW5pdGl6ZXIgZG9lcyBub3QgcHJvdGVjdCBhZ2FpbnN0IGdvL2RvbS1jbG9iYmVyaW5nLiBVc2UgdGhlIG5vcm1hbFxuICogc2FuaXRpemVyIGluc3RlYWQgaWYgcG9zc2libGUuXG4gKlxuICogSWYgYXQgYWxsIHBvc3NpYmxlLCBwcmVmZXIgdXNpbmcgYHNhbml0aXplSHRtbGAgb3ZlciB0aGlzIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmllbnRseVNhbml0aXplSHRtbChodG1sOiBzdHJpbmcpOiBTYWZlSHRtbCB7XG4gIHJldHVybiBsZW5pZW50SHRtbFNhbml0aXplci5zYW5pdGl6ZShodG1sKTtcbn1cblxuLyoqIExpa2UgYHNhbml0aXplSHRtbEFzc2VydFVuY2hhbmdlZGAgYnV0IHVzaW5nIHRoZSBsZW5pZW50IHNhbml0aXplci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5pZW50bHlTYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQoaHRtbDogc3RyaW5nKTogU2FmZUh0bWwge1xuICByZXR1cm4gbGVuaWVudEh0bWxTYW5pdGl6ZXIuc2FuaXRpemVBc3NlcnRVbmNoYW5nZWQoaHRtbCk7XG59XG5cbmNvbnN0IHN1cGVyTGVuaWVudEh0bWxTYW5pdGl6ZXIgPSBwdXJlKFxuICAoKSA9PiBuZXcgSHRtbFNhbml0aXplckltcGwoc3VwZXJMZW5pZW50U2FuaXRpemVyVGFibGUsIHNlY3JldFRva2VuKSxcbik7XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIGdpdmVuIEhUTUwgZnJhZ21lbnQgaW4gYW4gZXh0cmVtZWx5IGxlbmllbnQgd2F5IHdoaWxlXG4gKiBzdGlsbCBndWFyYW50ZWVpbmcgdGhhdCB0aGUgb3V0cHV0IGNhbm5vdCBsZWFkIHRvIFhTUyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gKlxuICogSWYgYXQgYWxsIHBvc3NpYmxlLCBwcmVmZXIgdXNpbmcgYHNhbml0aXplSHRtbGAgb3IgYGxlbmllbnRseVNhbml0aXplSHRtbGBcbiAqIG92ZXIgdGhpcyBtZXRob2QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBlckxlbmllbnRseVNhbml0aXplSHRtbChodG1sOiBzdHJpbmcpOiBTYWZlSHRtbCB7XG4gIHJldHVybiBzdXBlckxlbmllbnRIdG1sU2FuaXRpemVyLnNhbml0aXplKGh0bWwpO1xufVxuXG4vKipcbiAqIExpa2UgYHN1cGVyTGVuaWVudGx5U2FuaXRpemVIdG1sYCBidXQgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgb3V0cHV0XG4gKiBpcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VwZXJMZW5pZW50bHlTYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQoXG4gIGh0bWw6IHN0cmluZyxcbik6IFNhZmVIdG1sIHtcbiAgcmV0dXJuIHN1cGVyTGVuaWVudEh0bWxTYW5pdGl6ZXIuc2FuaXRpemVBc3NlcnRVbmNoYW5nZWQoaHRtbCk7XG59XG4vLyBFTkQtSU5URVJOQUxcblxuZnVuY3Rpb24gY2hlY2tFeGhhdXN0aXZlKFxuICB2YWx1ZTogbmV2ZXIsXG4gIG1zZyA9IGB1bmV4cGVjdGVkIHZhbHVlICR7dmFsdWV9IWAsXG4pOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuIl19
;return exports;});

//third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer_builder.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer_builder.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer_builder');
var module = module || { id: 'third_party/javascript/safevalues/builders/html_sanitizer/html_sanitizer_builder.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_secrets_1 = goog.requireType("google3.third_party.javascript.safevalues.internals.secrets");
const tsickle_html_sanitizer_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer");
const tsickle_default_sanitizer_table_3 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.default_sanitizer_table");
const tsickle_sanitizer_table_4 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table");
const secrets_1 = goog.require('google3.third_party.javascript.safevalues.internals.secrets');
const html_sanitizer_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer');
const default_sanitizer_table_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.default_sanitizer_table');
const sanitizer_table_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.sanitizer_table.sanitizer_table');
/**
 * This class allows modifications to the default sanitizer configuration.
 */
class HtmlSanitizerBuilder {
    /**
     * @public
     */
    constructor() {
        // To denote if the builder has called build() and therefore should make no
        // further changes to the sanitizer table.
        this.calledBuild = false;
        this.sanitizerTable = default_sanitizer_table_1.defaultSanitizerTable;
    }
    /**
     * Builder option to restrict allowed elements to a smaller subset.
     * @public
     * @param {!ReadonlySet<string>} elementSet
     * @return {!HtmlSanitizerBuilder}
     */
    onlyAllowElements(elementSet) {
        /** @type {!Set<string>} */
        const allowedElements = new Set();
        /** @type {!Map<string, !ReadonlyMap<string, !tsickle_sanitizer_table_4.AttributePolicy>>} */
        const allowedElementPolicies = new Map();
        for (let element of elementSet) {
            element = element.toUpperCase();
            if (!this.sanitizerTable.isAllowedElement(element)) {
                throw new Error(`Element: ${element}, is not allowed by html5_contract.textpb`);
            }
            /** @type {(undefined|!ReadonlyMap<string, !tsickle_sanitizer_table_4.AttributePolicy>)} */
            const elementPolicy = this.sanitizerTable.elementPolicies.get(element);
            if (elementPolicy !== undefined) {
                allowedElementPolicies.set(element, elementPolicy);
            }
            else {
                allowedElements.add(element);
            }
        }
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * Builder option to allow a set of custom elements. Must be called either
     * without or after `onlyAllowElements` - will be overwritten otherwise.
     * Custom elements must contain a dash.
     * @public
     * @param {string} element
     * @param {(undefined|!ReadonlySet<string>)=} allowedAttributes
     * @return {!HtmlSanitizerBuilder}
     */
    allowCustomElement(element, allowedAttributes) {
        /** @type {!Set<string>} */
        const allowedElements = new Set(this.sanitizerTable.allowedElements);
        /** @type {!Map<string, !ReadonlyMap<string, !tsickle_sanitizer_table_4.AttributePolicy>>} */
        const allowedElementPolicies = new Map(this.sanitizerTable.elementPolicies);
        element = element.toUpperCase();
        if (!(0, sanitizer_table_1.isCustomElement)(element)) {
            throw new Error(`Element: ${element} is not a custom element`);
        }
        if (allowedAttributes) {
            /** @type {!Map<string, !tsickle_sanitizer_table_4.AttributePolicy>} */
            const elementPolicy = new Map();
            for (const attribute of allowedAttributes) {
                elementPolicy.set(attribute, {
                    policyAction: sanitizer_table_1.AttributePolicyAction.KEEP,
                });
            }
            allowedElementPolicies.set(element, elementPolicy);
        }
        else {
            allowedElements.add(element);
        }
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * Builder option to restrict allowed attributes to a smaller subset.
     *
     * If the attribute isn't currently allowed then it won't be added.
     * @public
     * @param {!ReadonlySet<string>} attributeSet
     * @return {!HtmlSanitizerBuilder}
     */
    onlyAllowAttributes(attributeSet) {
        /** @type {!Set<string>} */
        const allowedGlobalAttributes = new Set();
        /** @type {!Map<string, !tsickle_sanitizer_table_4.AttributePolicy>} */
        const globalAttributePolicies = new Map();
        /** @type {!Map<string, !ReadonlyMap<string, !tsickle_sanitizer_table_4.AttributePolicy>>} */
        const elementPolicies = new Map();
        for (const attribute of attributeSet) {
            if (this.sanitizerTable.allowedGlobalAttributes.has(attribute)) {
                allowedGlobalAttributes.add(attribute);
            }
            if (this.sanitizerTable.globalAttributePolicies.has(attribute)) {
                globalAttributePolicies.set(attribute, (/** @type {!tsickle_sanitizer_table_4.AttributePolicy} */ (this.sanitizerTable.globalAttributePolicies.get(attribute))));
            }
        }
        for (const [elementName__tsickle_destructured_1, originalElementPolicy__tsickle_destructured_2] of this.sanitizerTable.elementPolicies.entries()) {
            const elementName = /** @type {string} */ (elementName__tsickle_destructured_1);
            const originalElementPolicy = /** @type {!ReadonlyMap<string, !tsickle_sanitizer_table_4.AttributePolicy>} */ (originalElementPolicy__tsickle_destructured_2);
            /** @type {!Map<string, !tsickle_sanitizer_table_4.AttributePolicy>} */
            const newElementPolicy = new Map();
            for (const [attribute__tsickle_destructured_3, attributePolicy__tsickle_destructured_4] of originalElementPolicy.entries()) {
                const attribute = /** @type {string} */ (attribute__tsickle_destructured_3);
                const attributePolicy = /** @type {!tsickle_sanitizer_table_4.AttributePolicy} */ (attributePolicy__tsickle_destructured_4);
                if (attributeSet.has(attribute)) {
                    newElementPolicy.set(attribute, attributePolicy);
                }
            }
            elementPolicies.set(elementName, newElementPolicy);
        }
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies);
        return this;
    }
    /**
     * Allows the set of data attributes passed.
     *
     * These values must be prefixed with "data-"
     *
     * If called with onlyAllowElements or onlyAllowAttributes, those methods must
     * be called first.
     * @public
     * @param {!Array<string>} attributes
     * @return {!HtmlSanitizerBuilder}
     */
    allowDataAttributes(attributes) {
        /** @type {!Set<string>} */
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        for (const attribute of attributes) {
            if (attribute.indexOf('data-') !== 0) {
                throw new Error(`data attribute: ${attribute} does not begin with the prefix "data-"`);
            }
            allowedGlobalAttributes.add(attribute);
        }
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * Preserves style attributes. Note that the sanitizer won't parse and
     * sanitize the values but keep them as they are. In particular this means
     * that the code will be able to call functions that could do undesirable
     * things (e.g. `url` to trigger a network request), as well as any custom
     * properties or functions defined by the application.
     * @public
     * @return {!HtmlSanitizerBuilder}
     */
    allowStyleAttributes() {
        /** @type {!Map<string, !tsickle_sanitizer_table_4.AttributePolicy>} */
        const globalAttributePolicies = new Map(this.sanitizerTable.globalAttributePolicies);
        globalAttributePolicies.set('style', {
            policyAction: sanitizer_table_1.AttributePolicyAction.KEEP_AND_SANITIZE_STYLE,
        });
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, this.sanitizerTable.allowedGlobalAttributes, globalAttributePolicies);
        return this;
    }
    /**
     * Preserves the class attribute on all elements. This means contents can
     * adopt CSS styles from other page elements and possibly mask themselves as
     * legitimate UI elements, which can lead to phishing.
     * @public
     * @return {!HtmlSanitizerBuilder}
     */
    allowClassAttributes() {
        /** @type {!Set<string>} */
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        allowedGlobalAttributes.add('class');
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * Preserves id attributes. This carries moderate risk as it allows an
     * element to override other elements with the same ID.
     * @public
     * @return {!HtmlSanitizerBuilder}
     */
    allowIdAttributes() {
        /** @type {!Set<string>} */
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        allowedGlobalAttributes.add('id');
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * Preserves (some) attributes that reference existing ids. This carries a
     * moderate security risk, because sanitized content can create semantic
     * associations with existing elements in the page, regardless of the layout.
     * This could be used to override the label associated with a form input by a
     * screen reader, and facilitate phishing.
     * @public
     * @return {!HtmlSanitizerBuilder}
     */
    allowIdReferenceAttributes() {
        /** @type {!Set<string>} */
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        // TODO(b/190693339): Generate this subtable from the contract.
        allowedGlobalAttributes
            .add('aria-activedescendant')
            .add('aria-controls')
            .add('aria-labelledby')
            .add('aria-owns')
            .add('for')
            .add('list');
        this.sanitizerTable = new sanitizer_table_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);
        return this;
    }
    /**
     * @public
     * @return {!tsickle_html_sanitizer_2.HtmlSanitizer}
     */
    build() {
        if (this.calledBuild) {
            throw new Error('this sanitizer has already called build');
        }
        this.calledBuild = true;
        return new html_sanitizer_1.HtmlSanitizerImpl(this.sanitizerTable, secrets_1.secretToken);
    }
}
exports.HtmlSanitizerBuilder = HtmlSanitizerBuilder;
/* istanbul ignore if */
if (false) {
    /**
     * @type {!tsickle_sanitizer_table_4.SanitizerTable}
     * @private
     */
    HtmlSanitizerBuilder.prototype.sanitizerTable;
    /**
     * @type {boolean}
     * @private
     */
    HtmlSanitizerBuilder.prototype.calledBuild;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF9zYW5pdGl6ZXJfYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2phdmFzY3JpcHQvc2FmZXZhbHVlcy9idWlsZGVycy9odG1sX3Nhbml0aXplci9odG1sX3Nhbml0aXplcl9idWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLDhGQUFvRDtBQUVwRCwwSEFBa0U7QUFDbEUsNEpBQWdGO0FBQ2hGLDRJQU0yQzs7OztBQUczQyxNQUFhLG9CQUFvQjs7OztJQU0vQjs7O1FBRlEsZ0JBQVcsR0FBRyxLQUFLLENBQUM7UUFHMUIsSUFBSSxDQUFDLGNBQWMsR0FBRywrQ0FBcUIsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7O0lBR0QsaUJBQWlCLENBQUMsVUFBK0I7O2NBQ3pDLGVBQWUsR0FBRyxJQUFJLEdBQUcsRUFBVTs7Y0FDbkMsc0JBQXNCLEdBQUcsSUFBSSxHQUFHLEVBQXlCO1FBQy9ELEtBQUssSUFBSSxPQUFPLElBQUksVUFBVSxFQUFFLENBQUM7WUFDL0IsT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2dCQUNuRCxNQUFNLElBQUksS0FBSyxDQUNiLFlBQVksT0FBTywyQ0FBMkMsQ0FDL0QsQ0FBQztZQUNKLENBQUM7O2tCQUVLLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO1lBQ3RFLElBQUksYUFBYSxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUNoQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQ3JELENBQUM7aUJBQU0sQ0FBQztnQkFDTixlQUFlLENBQUMsR0FB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LElBQUksQ0FBQztJQUNkLENBQUM7Ozs7Ozs7Ozs7SUFTRCwwQkFBMEI7O2NBQ2xCLHVCQUF1QixHQUFHLElBQUksR0FBRyxDQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUM1Qzs7UUFFRCx1QkFBdUI7YUFDcEIsR0FBRyxDQUFDLHVCQUF1QixDQUFDO2FBQzVCLEdBQUcsQ0FBQyxlQUFlLENBQUM7YUFDcEIsR0FBRyxDQUFDLGlCQUFpQixDQUFDO2FBQ3RCLEdBQUcsQ0FBQyxXQUFXLENBQUM7YUFDaEIsR0FBRyxDQUFDLEtBQUssQ0FBQzthQUNWLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxnQ0FBYyxDQUN0QyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFDbkMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQ25DLHVCQUF1QixFQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUM1QyxDQUFDO1FBQ0YsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDOzs7OztJQUVELEtBQUs7UUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFDN0QsQ0FBQztRQUNELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxrQ0FBaUIsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLHFCQUFXLENBQUMsQ0FBQztJQUNqRSxDQUFDO0NBQ0Y7QUE3UEQsb0RBNlBDOzs7Ozs7O0lBNVBDLDhDQUF1Qzs7Ozs7SUFHdkMsMkNBQTRCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge3NlY3JldFRva2VufSBmcm9tICcuLi8uLi9pbnRlcm5hbHMvc2VjcmV0cyc7XG5cbmltcG9ydCB7SHRtbFNhbml0aXplciwgSHRtbFNhbml0aXplckltcGx9IGZyb20gJy4vaHRtbF9zYW5pdGl6ZXInO1xuaW1wb3J0IHtkZWZhdWx0U2FuaXRpemVyVGFibGV9IGZyb20gJy4vc2FuaXRpemVyX3RhYmxlL2RlZmF1bHRfc2FuaXRpemVyX3RhYmxlJztcbmltcG9ydCB7XG4gIEF0dHJpYnV0ZVBvbGljeSxcbiAgQXR0cmlidXRlUG9saWN5QWN0aW9uLFxuICBFbGVtZW50UG9saWN5LFxuICBTYW5pdGl6ZXJUYWJsZSxcbiAgaXNDdXN0b21FbGVtZW50LFxufSBmcm9tICcuL3Nhbml0aXplcl90YWJsZS9zYW5pdGl6ZXJfdGFibGUnO1xuXG4vKiogVGhpcyBjbGFzcyBhbGxvd3MgbW9kaWZpY2F0aW9ucyB0byB0aGUgZGVmYXVsdCBzYW5pdGl6ZXIgY29uZmlndXJhdGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBIdG1sU2FuaXRpemVyQnVpbGRlciB7XG4gIHByaXZhdGUgc2FuaXRpemVyVGFibGU6IFNhbml0aXplclRhYmxlO1xuICAvLyBUbyBkZW5vdGUgaWYgdGhlIGJ1aWxkZXIgaGFzIGNhbGxlZCBidWlsZCgpIGFuZCB0aGVyZWZvcmUgc2hvdWxkIG1ha2Ugbm9cbiAgLy8gZnVydGhlciBjaGFuZ2VzIHRvIHRoZSBzYW5pdGl6ZXIgdGFibGUuXG4gIHByaXZhdGUgY2FsbGVkQnVpbGQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNhbml0aXplclRhYmxlID0gZGVmYXVsdFNhbml0aXplclRhYmxlO1xuICB9XG5cbiAgLyoqIEJ1aWxkZXIgb3B0aW9uIHRvIHJlc3RyaWN0IGFsbG93ZWQgZWxlbWVudHMgdG8gYSBzbWFsbGVyIHN1YnNldC4gKi9cbiAgb25seUFsbG93RWxlbWVudHMoZWxlbWVudFNldDogUmVhZG9ubHlTZXQ8c3RyaW5nPik6IEh0bWxTYW5pdGl6ZXJCdWlsZGVyIHtcbiAgICBjb25zdCBhbGxvd2VkRWxlbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBhbGxvd2VkRWxlbWVudFBvbGljaWVzID0gbmV3IE1hcDxzdHJpbmcsIEVsZW1lbnRQb2xpY3k+KCk7XG4gICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50U2V0KSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCF0aGlzLnNhbml0aXplclRhYmxlLmlzQWxsb3dlZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFbGVtZW50OiAke2VsZW1lbnR9LCBpcyBub3QgYWxsb3dlZCBieSBodG1sNV9jb250cmFjdC50ZXh0cGJgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50UG9saWN5ID0gdGhpcy5zYW5pdGl6ZXJUYWJsZS5lbGVtZW50UG9saWNpZXMuZ2V0KGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnRQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGxvd2VkRWxlbWVudFBvbGljaWVzLnNldChlbGVtZW50LCBlbGVtZW50UG9saWN5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93ZWRFbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zYW5pdGl6ZXJUYWJsZSA9IG5ldyBTYW5pdGl6ZXJUYWJsZShcbiAgICAgIGFsbG93ZWRFbGVtZW50cyxcbiAgICAgIGFsbG93ZWRFbGVtZW50UG9saWNpZXMsXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5nbG9iYWxBdHRyaWJ1dGVQb2xpY2llcyxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkZXIgb3B0aW9uIHRvIGFsbG93IGEgc2V0IG9mIGN1c3RvbSBlbGVtZW50cy4gTXVzdCBiZSBjYWxsZWQgZWl0aGVyXG4gICAqIHdpdGhvdXQgb3IgYWZ0ZXIgYG9ubHlBbGxvd0VsZW1lbnRzYCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW4gb3RoZXJ3aXNlLlxuICAgKiBDdXN0b20gZWxlbWVudHMgbXVzdCBjb250YWluIGEgZGFzaC5cbiAgICovXG4gIGFsbG93Q3VzdG9tRWxlbWVudChcbiAgICBlbGVtZW50OiBzdHJpbmcsXG4gICAgYWxsb3dlZEF0dHJpYnV0ZXM/OiBSZWFkb25seVNldDxzdHJpbmc+LFxuICApOiBIdG1sU2FuaXRpemVyQnVpbGRlciB7XG4gICAgY29uc3QgYWxsb3dlZEVsZW1lbnRzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkRWxlbWVudHMsXG4gICAgKTtcbiAgICBjb25zdCBhbGxvd2VkRWxlbWVudFBvbGljaWVzID0gbmV3IE1hcDxzdHJpbmcsIEVsZW1lbnRQb2xpY3k+KFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5lbGVtZW50UG9saWNpZXMsXG4gICAgKTtcblxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFpc0N1c3RvbUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudDogJHtlbGVtZW50fSBpcyBub3QgYSBjdXN0b20gZWxlbWVudGApO1xuICAgIH1cblxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZWxlbWVudFBvbGljeSA9IG5ldyBNYXA8c3RyaW5nLCBBdHRyaWJ1dGVQb2xpY3k+KCk7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhbGxvd2VkQXR0cmlidXRlcykge1xuICAgICAgICBlbGVtZW50UG9saWN5LnNldChhdHRyaWJ1dGUsIHtcbiAgICAgICAgICBwb2xpY3lBY3Rpb246IEF0dHJpYnV0ZVBvbGljeUFjdGlvbi5LRUVQLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFsbG93ZWRFbGVtZW50UG9saWNpZXMuc2V0KGVsZW1lbnQsIGVsZW1lbnRQb2xpY3kpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxvd2VkRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gICAgICBhbGxvd2VkRWxlbWVudHMsXG4gICAgICBhbGxvd2VkRWxlbWVudFBvbGljaWVzLFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkR2xvYmFsQXR0cmlidXRlcyxcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZGVyIG9wdGlvbiB0byByZXN0cmljdCBhbGxvd2VkIGF0dHJpYnV0ZXMgdG8gYSBzbWFsbGVyIHN1YnNldC5cbiAgICpcbiAgICogSWYgdGhlIGF0dHJpYnV0ZSBpc24ndCBjdXJyZW50bHkgYWxsb3dlZCB0aGVuIGl0IHdvbid0IGJlIGFkZGVkLlxuICAgKi9cbiAgb25seUFsbG93QXR0cmlidXRlcyhhdHRyaWJ1dGVTZXQ6IFJlYWRvbmx5U2V0PHN0cmluZz4pOiBIdG1sU2FuaXRpemVyQnVpbGRlciB7XG4gICAgY29uc3QgYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVQb2xpY2llcyA9IG5ldyBNYXA8c3RyaW5nLCBBdHRyaWJ1dGVQb2xpY3k+KCk7XG4gICAgY29uc3QgZWxlbWVudFBvbGljaWVzID0gbmV3IE1hcDxzdHJpbmcsIEVsZW1lbnRQb2xpY3k+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVTZXQpIHtcbiAgICAgIGlmICh0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGUpKSB7XG4gICAgICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2FuaXRpemVyVGFibGUuZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMuaGFzKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMuc2V0KFxuICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICB0aGlzLnNhbml0aXplclRhYmxlLmdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzLmdldChhdHRyaWJ1dGUpISxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtcbiAgICAgIGVsZW1lbnROYW1lLFxuICAgICAgb3JpZ2luYWxFbGVtZW50UG9saWN5LFxuICAgIF0gb2YgdGhpcy5zYW5pdGl6ZXJUYWJsZS5lbGVtZW50UG9saWNpZXMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBuZXdFbGVtZW50UG9saWN5ID0gbmV3IE1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT4oKTtcblxuICAgICAgZm9yIChjb25zdCBbXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgYXR0cmlidXRlUG9saWN5LFxuICAgICAgXSBvZiBvcmlnaW5hbEVsZW1lbnRQb2xpY3kuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVTZXQuaGFzKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBuZXdFbGVtZW50UG9saWN5LnNldChhdHRyaWJ1dGUsIGF0dHJpYnV0ZVBvbGljeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQb2xpY2llcy5zZXQoZWxlbWVudE5hbWUsIG5ld0VsZW1lbnRQb2xpY3kpO1xuICAgIH1cblxuICAgIHRoaXMuc2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRFbGVtZW50cyxcbiAgICAgIGVsZW1lbnRQb2xpY2llcyxcbiAgICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLFxuICAgICAgZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHNldCBvZiBkYXRhIGF0dHJpYnV0ZXMgcGFzc2VkLlxuICAgKlxuICAgKiBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBwcmVmaXhlZCB3aXRoIFwiZGF0YS1cIlxuICAgKlxuICAgKiBJZiBjYWxsZWQgd2l0aCBvbmx5QWxsb3dFbGVtZW50cyBvciBvbmx5QWxsb3dBdHRyaWJ1dGVzLCB0aG9zZSBtZXRob2RzIG11c3RcbiAgICogYmUgY2FsbGVkIGZpcnN0LlxuICAgKi9cbiAgYWxsb3dEYXRhQXR0cmlidXRlcyhhdHRyaWJ1dGVzOiBzdHJpbmdbXSk6IEh0bWxTYW5pdGl6ZXJCdWlsZGVyIHtcbiAgICBjb25zdCBhbGxvd2VkR2xvYmFsQXR0cmlidXRlcyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLmluZGV4T2YoJ2RhdGEtJykgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBkYXRhIGF0dHJpYnV0ZTogJHthdHRyaWJ1dGV9IGRvZXMgbm90IGJlZ2luIHdpdGggdGhlIHByZWZpeCBcImRhdGEtXCJgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMuYWRkKGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHRoaXMuc2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRFbGVtZW50cyxcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuZWxlbWVudFBvbGljaWVzLFxuICAgICAgYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHJlc2VydmVzIHN0eWxlIGF0dHJpYnV0ZXMuIE5vdGUgdGhhdCB0aGUgc2FuaXRpemVyIHdvbid0IHBhcnNlIGFuZFxuICAgKiBzYW5pdGl6ZSB0aGUgdmFsdWVzIGJ1dCBrZWVwIHRoZW0gYXMgdGhleSBhcmUuIEluIHBhcnRpY3VsYXIgdGhpcyBtZWFuc1xuICAgKiB0aGF0IHRoZSBjb2RlIHdpbGwgYmUgYWJsZSB0byBjYWxsIGZ1bmN0aW9ucyB0aGF0IGNvdWxkIGRvIHVuZGVzaXJhYmxlXG4gICAqIHRoaW5ncyAoZS5nLiBgdXJsYCB0byB0cmlnZ2VyIGEgbmV0d29yayByZXF1ZXN0KSwgYXMgd2VsbCBhcyBhbnkgY3VzdG9tXG4gICAqIHByb3BlcnRpZXMgb3IgZnVuY3Rpb25zIGRlZmluZWQgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgYWxsb3dTdHlsZUF0dHJpYnV0ZXMoKTogSHRtbFNhbml0aXplckJ1aWxkZXIge1xuICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzID0gbmV3IE1hcDxzdHJpbmcsIEF0dHJpYnV0ZVBvbGljeT4oXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzLFxuICAgICk7XG4gICAgZ2xvYmFsQXR0cmlidXRlUG9saWNpZXMuc2V0KCdzdHlsZScsIHtcbiAgICAgIHBvbGljeUFjdGlvbjogQXR0cmlidXRlUG9saWN5QWN0aW9uLktFRVBfQU5EX1NBTklUSVpFX1NUWUxFLFxuICAgIH0pO1xuICAgIHRoaXMuc2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRFbGVtZW50cyxcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuZWxlbWVudFBvbGljaWVzLFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkR2xvYmFsQXR0cmlidXRlcyxcbiAgICAgIGdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHJlc2VydmVzIHRoZSBjbGFzcyBhdHRyaWJ1dGUgb24gYWxsIGVsZW1lbnRzLiBUaGlzIG1lYW5zIGNvbnRlbnRzIGNhblxuICAgKiBhZG9wdCBDU1Mgc3R5bGVzIGZyb20gb3RoZXIgcGFnZSBlbGVtZW50cyBhbmQgcG9zc2libHkgbWFzayB0aGVtc2VsdmVzIGFzXG4gICAqIGxlZ2l0aW1hdGUgVUkgZWxlbWVudHMsIHdoaWNoIGNhbiBsZWFkIHRvIHBoaXNoaW5nLlxuICAgKi9cbiAgYWxsb3dDbGFzc0F0dHJpYnV0ZXMoKTogSHRtbFNhbml0aXplckJ1aWxkZXIge1xuICAgIGNvbnN0IGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkR2xvYmFsQXR0cmlidXRlcyxcbiAgICApO1xuICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLmFkZCgnY2xhc3MnKTtcbiAgICB0aGlzLnNhbml0aXplclRhYmxlID0gbmV3IFNhbml0aXplclRhYmxlKFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkRWxlbWVudHMsXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmVsZW1lbnRQb2xpY2llcyxcbiAgICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5nbG9iYWxBdHRyaWJ1dGVQb2xpY2llcyxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXNlcnZlcyBpZCBhdHRyaWJ1dGVzLiBUaGlzIGNhcnJpZXMgbW9kZXJhdGUgcmlzayBhcyBpdCBhbGxvd3MgYW5cbiAgICogZWxlbWVudCB0byBvdmVycmlkZSBvdGhlciBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIElELlxuICAgKi9cbiAgYWxsb3dJZEF0dHJpYnV0ZXMoKTogSHRtbFNhbml0aXplckJ1aWxkZXIge1xuICAgIGNvbnN0IGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkR2xvYmFsQXR0cmlidXRlcyxcbiAgICApO1xuICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLmFkZCgnaWQnKTtcbiAgICB0aGlzLnNhbml0aXplclRhYmxlID0gbmV3IFNhbml0aXplclRhYmxlKFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5hbGxvd2VkRWxlbWVudHMsXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmVsZW1lbnRQb2xpY2llcyxcbiAgICAgIGFsbG93ZWRHbG9iYWxBdHRyaWJ1dGVzLFxuICAgICAgdGhpcy5zYW5pdGl6ZXJUYWJsZS5nbG9iYWxBdHRyaWJ1dGVQb2xpY2llcyxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXNlcnZlcyAoc29tZSkgYXR0cmlidXRlcyB0aGF0IHJlZmVyZW5jZSBleGlzdGluZyBpZHMuIFRoaXMgY2FycmllcyBhXG4gICAqIG1vZGVyYXRlIHNlY3VyaXR5IHJpc2ssIGJlY2F1c2Ugc2FuaXRpemVkIGNvbnRlbnQgY2FuIGNyZWF0ZSBzZW1hbnRpY1xuICAgKiBhc3NvY2lhdGlvbnMgd2l0aCBleGlzdGluZyBlbGVtZW50cyBpbiB0aGUgcGFnZSwgcmVnYXJkbGVzcyBvZiB0aGUgbGF5b3V0LlxuICAgKiBUaGlzIGNvdWxkIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCBhIGZvcm0gaW5wdXQgYnkgYVxuICAgKiBzY3JlZW4gcmVhZGVyLCBhbmQgZmFjaWxpdGF0ZSBwaGlzaGluZy5cbiAgICovXG4gIGFsbG93SWRSZWZlcmVuY2VBdHRyaWJ1dGVzKCk6IEh0bWxTYW5pdGl6ZXJCdWlsZGVyIHtcbiAgICBjb25zdCBhbGxvd2VkR2xvYmFsQXR0cmlidXRlcyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgKTtcbiAgICAvLyBUT0RPKGIvMTkwNjkzMzM5KTogR2VuZXJhdGUgdGhpcyBzdWJ0YWJsZSBmcm9tIHRoZSBjb250cmFjdC5cbiAgICBhbGxvd2VkR2xvYmFsQXR0cmlidXRlc1xuICAgICAgLmFkZCgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JylcbiAgICAgIC5hZGQoJ2FyaWEtY29udHJvbHMnKVxuICAgICAgLmFkZCgnYXJpYS1sYWJlbGxlZGJ5JylcbiAgICAgIC5hZGQoJ2FyaWEtb3ducycpXG4gICAgICAuYWRkKCdmb3InKVxuICAgICAgLmFkZCgnbGlzdCcpO1xuICAgIHRoaXMuc2FuaXRpemVyVGFibGUgPSBuZXcgU2FuaXRpemVyVGFibGUoXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmFsbG93ZWRFbGVtZW50cyxcbiAgICAgIHRoaXMuc2FuaXRpemVyVGFibGUuZWxlbWVudFBvbGljaWVzLFxuICAgICAgYWxsb3dlZEdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgICB0aGlzLnNhbml0aXplclRhYmxlLmdsb2JhbEF0dHJpYnV0ZVBvbGljaWVzLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBidWlsZCgpOiBIdG1sU2FuaXRpemVyIHtcbiAgICBpZiAodGhpcy5jYWxsZWRCdWlsZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIHNhbml0aXplciBoYXMgYWxyZWFkeSBjYWxsZWQgYnVpbGQnKTtcbiAgICB9XG4gICAgdGhpcy5jYWxsZWRCdWlsZCA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FuaXRpemVySW1wbCh0aGlzLnNhbml0aXplclRhYmxlLCBzZWNyZXRUb2tlbik7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/resource_url_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/resource_url_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.resource_url_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/resource_url_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_resource_url_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_script_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_string_literal_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_TrustedResourceUrl_5 = goog.requireType("goog.html.TrustedResourceUrl");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
/**
 * Type that we know how to interpolate
 * @typedef {(string|number|boolean)}
 */
var Primitive;
/**
 * Check whether the base url contains a valid origin,
 *
 * A string for an origin must contain only alphanumeric or any of the
 * following: `-.:`, and must not be an IP address. Remember that, as per the
 * documentation for TrustedResourceUrl, the origin must be trustworthy.
 *
 * @param {string} base The base url that contains an origin.
 * @return {boolean}
 */
function hasValidOrigin(base) {
    if (!(/^https:\/\//.test(base) || /^\/\//.test(base))) {
        return false;
    }
    /** @type {number} */
    const originStart = base.indexOf('//') + 2;
    /** @type {number} */
    const originEnd = base.indexOf('/', originStart);
    // If the base url only contains the prefix (e.g. //), or the slash
    // for the origin is right after the prefix (e.g. ///), the origin is
    // missing.
    if (originEnd <= originStart) {
        throw new Error(`Can't interpolate data in a url's origin, ` +
            `Please make sure to fully specify the origin, terminated with '/'.`);
    }
    /** @type {string} */
    const origin = base.substring(originStart, originEnd);
    if (!/^[0-9a-z.:-]+$/i.test(origin)) {
        throw new Error('The origin contains unsupported characters.');
    }
    if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {
        throw new Error('Invalid port number.');
    }
    if (!/(^|\.)[a-z][^.]*$/i.test(origin)) {
        throw new Error('The top-level domain must start with a letter.');
    }
    return true;
}
/**
 * Check whether the base url contains a valid about url at its beginning.
 *
 * An about url is either exactly 'about:blank' or 'about:blank#<str>' where
 * <str> can be an arbitrary string.
 *
 * @param {string} base The base url.
 * @return {boolean}
 */
function isValidAboutUrl(base) {
    if (!/^about:blank/.test(base)) {
        return false;
    }
    if (base !== 'about:blank' && !/^about:blank#/.test(base)) {
        throw new Error('The about url is invalid.');
    }
    return true;
}
/**
 * Check whether the base url contains a valid path start at its beginning.
 *
 * A valid path start is either a '/' or a '/' followed by at least one
 * character that is not '/' or '\'.
 *
 * @param {string} base The base url.
 * @return {boolean}
 */
function isValidPathStart(base) {
    if (!/^\//.test(base)) {
        return false;
    }
    if (base === '/' ||
        (base.length > 1 && base[1] !== '/' && base[1] !== '\\')) {
        return true;
    }
    throw new Error('The path start in the url is invalid.');
}
/**
 * Check whether the base url contains a valid relative path start at its
 * beginning.
 *
 * A valid relative path start is a non empty string that has no ':', '/' nor
 * '\', and that is followed by a '/'.
 *
 * @param {string} base The base url.
 * @return {boolean}
 */
function isValidRelativePathStart(base) {
    // Using the RegExp syntax as the native JS RegExp syntax is not well handled
    // by some downstream bundlers with this regex.
    return new RegExp('^[^:\\s\\\\/]+/').test(base);
}
/**
 * Splits an url into segments using '?' and '#' delimiters.
 *
 * The URL can later be put back together by concatenating the returned segments
 * like: path + params + hash. Note that the delimiters '?' and '#' will
 * already be included in 'params' and 'hash' values respectively when these are
 * not empty.
 *
 * @param {string} url The url to split.
 * @return {{path: string, params: string, hash: string}}
 */
function getUrlSegments(url) {
    /** @type {!Array<string>} */
    const segments = url.split(/\?|#/);
    /** @type {string} */
    const params = /\?/.test(url) ? '?' + segments[1] : '';
    /** @type {string} */
    const hash = /#/.test(url) ? '#' + (params ? segments[2] : segments[1]) : '';
    return { path: segments[0], params, hash };
}
/**
 * Builds TrustedResourceUrl from a template literal.
 *
 * This factory is a template literal tag function. It should be called with
 * a template literal, with or without embedded expressions. For example,
 *               trustedResourceUrl`//example.com/${bar}`;
 * or
 *               trustedResourceUrl`//example.com`;
 *
 * When this function is called with a template literal without any embedded
 * expressions, the template string may contain anything as the whole URL is
 * a compile-time string constant.
 *
 * When this function is called with a template literal that contains embedded
 * expressions, the template must start with one of the following:
 * - `https://<origin>/`
 * - `//<origin>/`
 * - `/<pathStart>`
 * - `<relativePathStart>/`
 * - `about:blank`
 * - `data:`
 *
 * `<origin>` must contain only alphanumeric or any of the following: `-.:`.
 * Remember that, as per the documentation for TrustedResourceUrl, the origin
 * must be trustworthy. An origin of "example.com" could be set with this
 * method, but would tie the security of your site to the security of
 * example.com. Similarly, formats that potentially cover redirects hosted
 * on a trusted origin are problematic, since that could lead to untrusted
 * origins.
 *
 * `<pathStart>` is either an empty string, or a non empty string that does not
 * start with '/' or '\'.
 * In other words, `/<pathStart>` is either a '/' or a
 * '/' followed by at least one character that is not '/' or '\'.
 *
 * `<relativePathStart> is a non empty string that has no ':', '/' nor '\'.
 *
 * `data:` (data URL) does not allow embedded expressions in the template
 * literal input.
 *
 * All embedded expressions are URL encoded when they are interpolated. Do not
 * embed expressions that are already URL encoded as they will be double encoded
 * by the builder.
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @param {...(string|number|boolean)} rest This represents the template's embedded expressions.
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function trustedResourceUrl(templateObj, ...rest) {
    // Check if templateObj is actually from a template literal.
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, rest.length);
    }
    if (rest.length === 0) {
        return (0, resource_url_impl_1.createResourceUrlInternal)(templateObj[0]);
    }
    /** @type {string} */
    const base = templateObj[0].toLowerCase();
    if (dev_1.DEV_MODE) {
        if (/^data:/.test(base)) {
            throw new Error('Data URLs cannot have expressions in the template literal input.');
        }
        if (!hasValidOrigin(base) &&
            !isValidPathStart(base) &&
            !isValidRelativePathStart(base) &&
            !isValidAboutUrl(base)) {
            throw new Error('Trying to interpolate expressions in an unsupported url format.');
        }
    }
    /** @type {string} */
    let url = templateObj[0];
    for (let i = 0; i < rest.length; i++) {
        url += encodeURIComponent(rest[i]) + templateObj[i + 1];
    }
    return (0, resource_url_impl_1.createResourceUrlInternal)(url);
}
exports.trustedResourceUrl = trustedResourceUrl;
/**
 * Creates a new TrustedResourceUrl with params added to the URL's search
 * parameters.
 *
 * @param {!tsickle_TrustedResourceUrl_5} trustedUrl
 * @param {(!Map<string, (null|string|number|boolean|!Array<(null|string|number|boolean)>)>|!Map<string, string>)} params What to add to the URL. Parameters with value `null` or
 * `undefined` are skipped. Both keys and values will be encoded. Do not pass
 * pre-encoded values as this will result them being double encoded. If the
 * value is an array then the same parameter is added for every element in the
 * array.
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function appendParams(trustedUrl, 
// LINE-EXTERNAL params: Map<string, Primitive|null|Array<Primitive|null>>):
// BEGIN-INTERNAL
// Explicit type union for compatibility with the Closure compiler since it
// doesn't support covariance.
params) {
    /** @type {{path: string, params: string, hash: string}} */
    const urlSegments = getUrlSegments((0, resource_url_impl_1.unwrapResourceUrl)(trustedUrl).toString());
    /** @type {string} */
    let urlParams = urlSegments.params;
    /** @type {string} */
    let separator = urlParams.length ? '&' : '?';
    // for-of has a big polyfill.
    // tslint:disable-next-line:ban-iterable-foreach
    params.forEach((/**
     * @param {(null|string|number|boolean|!Array<(null|string|number|boolean)>)} value
     * @param {string} key
     * @return {void}
     */
    (value, key) => {
        /** @type {!Array<(null|string|number|boolean)>} */
        const values = value instanceof Array ? value : [value];
        for (let i = 0; i < values.length; i++) {
            /** @type {(null|string|number|boolean)} */
            const v = values[i];
            if (v === null || v === undefined) {
                continue;
            }
            urlParams +=
                separator +
                    encodeURIComponent(key) +
                    '=' +
                    encodeURIComponent(String(v));
            separator = '&';
        }
    }));
    return (0, resource_url_impl_1.createResourceUrlInternal)(urlSegments.path + urlParams + urlSegments.hash);
}
exports.appendParams = appendParams;
/** @type {!RegExp} */
const BEFORE_FRAGMENT_REGEXP = /[^#]*/;
/**
 * Creates a new TrustedResourceUrl based on an existing one but with the
 * addition of a fragment (the part after `#`). If the URL already has a
 * fragment, it is replaced with the new one.
 * @param {!tsickle_TrustedResourceUrl_5} trustedUrl
 * @param {string} fragment The fragment to add to the URL, verbatim, without the leading
 * `#`. No additional escaping is applied.
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function replaceFragment(trustedUrl, fragment) {
    /** @type {string} */
    const urlString = (0, resource_url_impl_1.unwrapResourceUrl)(trustedUrl).toString();
    return (0, resource_url_impl_1.createResourceUrlInternal)((/** @type {!RegExpExecArray} */ (BEFORE_FRAGMENT_REGEXP.exec(urlString)))[0] + '#' + fragment);
}
exports.replaceFragment = replaceFragment;
/**
 * Creates a new TrustedResourceUrl based on an existing one with a single
 * subpath segment added to the end of the existing path and prior to any query
 * parameters and/or fragments that already exist in the URL.
 * @param {!tsickle_TrustedResourceUrl_5} trustedUrl
 * @param {string} pathSegment The singular sub path being added to the URL. Do not pass
 *     a pre-encoded value as this will result in it being double encoded.
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function appendPathSegment(trustedUrl, pathSegment) {
    /** @type {{path: string, params: string, hash: string}} */
    const urlSegments = getUrlSegments((0, resource_url_impl_1.unwrapResourceUrl)(trustedUrl).toString());
    /** @type {string} */
    const separator = urlSegments.path.slice(-1) === '/' ? '' : '/';
    /** @type {string} */
    const newPath = urlSegments.path + separator + encodeURIComponent(pathSegment);
    return (0, resource_url_impl_1.createResourceUrlInternal)(newPath + urlSegments.params + urlSegments.hash);
}
exports.appendPathSegment = appendPathSegment;
/**
 * Creates a `TrustedResourceUrl` by generating a `Blob` from a
 * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.
 *
 * Caller must call `URL.revokeObjectURL()` on the stringified url to
 * release the underlying `Blob`.
 * @param {!tsickle_script_impl_3.SafeScript} safeScript
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function objectUrlFromScript(safeScript) {
    /** @type {string} */
    const scriptContent = (0, script_impl_1.unwrapScript)(safeScript).toString();
    /** @type {!Blob} */
    const blob = new Blob([scriptContent], { type: 'text/javascript' });
    return (0, resource_url_impl_1.createResourceUrlInternal)(URL.createObjectURL(blob));
}
exports.objectUrlFromScript = objectUrlFromScript;
/**
 * A function to safely retrieve the base URI from the Window object and set it
 * at the beginning of a given path-relative (starts with "/") resource url.
 *
 * @param {!tsickle_TrustedResourceUrl_5} pathRelativeUrl The resource to which the origin shall be prepended.
 * @return {!tsickle_TrustedResourceUrl_5}
 */
function toAbsoluteResourceUrl(pathRelativeUrl) {
    /** @type {string} */
    const originalUrl = (0, resource_url_impl_1.unwrapResourceUrl)(pathRelativeUrl).toString();
    /** @type {!URL} */
    const qualifiedUrl = new URL(originalUrl, window.document.baseURI);
    return (0, resource_url_impl_1.createResourceUrlInternal)(qualifiedUrl.toString());
}
exports.toAbsoluteResourceUrl = toAbsoluteResourceUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2VfdXJsX2J1aWxkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2J1aWxkZXJzL3Jlc291cmNlX3VybF9idWlsZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0ZBQTRDO0FBQzVDLGtIQUl3QztBQUN4QyxzR0FBa0U7QUFDbEUsNEdBQW1FOzs7OztBQUduRSxjQUEyQzs7Ozs7Ozs7Ozs7QUFXM0MsU0FBUyxjQUFjLENBQUMsSUFBWTtJQUNsQyxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3RELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7VUFFSyxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDOztVQUNwQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDO0lBQ2hELG1FQUFtRTtJQUNuRSxxRUFBcUU7SUFDckUsV0FBVztJQUNYLElBQUksU0FBUyxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQzdCLE1BQU0sSUFBSSxLQUFLLENBQ2IsNENBQTRDO1lBQzFDLG9FQUFvRSxDQUN2RSxDQUFDO0lBQ0osQ0FBQzs7VUFFSyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDO0lBQ3JELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUNELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJ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QUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUM1RCxDQUFDO0FBSkQsc0RBSUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uL2Vudmlyb25tZW50L2Rldic7XG5pbXBvcnQge1xuICBjcmVhdGVSZXNvdXJjZVVybEludGVybmFsLFxuICBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIHVud3JhcFJlc291cmNlVXJsLFxufSBmcm9tICcuLi9pbnRlcm5hbHMvcmVzb3VyY2VfdXJsX2ltcGwnO1xuaW1wb3J0IHtTYWZlU2NyaXB0LCB1bndyYXBTY3JpcHR9IGZyb20gJy4uL2ludGVybmFscy9zY3JpcHRfaW1wbCc7XG5pbXBvcnQge2Fzc2VydElzVGVtcGxhdGVPYmplY3R9IGZyb20gJy4uL2ludGVybmFscy9zdHJpbmdfbGl0ZXJhbCc7XG5cbi8qKiBUeXBlIHRoYXQgd2Uga25vdyBob3cgdG8gaW50ZXJwb2xhdGUgKi9cbnR5cGUgUHJpbWl0aXZlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBiYXNlIHVybCBjb250YWlucyBhIHZhbGlkIG9yaWdpbixcbiAqXG4gKiBBIHN0cmluZyBmb3IgYW4gb3JpZ2luIG11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBvciBhbnkgb2YgdGhlXG4gKiBmb2xsb3dpbmc6IGAtLjpgLCBhbmQgbXVzdCBub3QgYmUgYW4gSVAgYWRkcmVzcy4gUmVtZW1iZXIgdGhhdCwgYXMgcGVyIHRoZVxuICogZG9jdW1lbnRhdGlvbiBmb3IgVHJ1c3RlZFJlc291cmNlVXJsLCB0aGUgb3JpZ2luIG11c3QgYmUgdHJ1c3R3b3J0aHkuXG4gKlxuICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgdXJsIHRoYXQgY29udGFpbnMgYW4gb3JpZ2luLlxuICovXG5mdW5jdGlvbiBoYXNWYWxpZE9yaWdpbihiYXNlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCEoL15odHRwczpcXC9cXC8vLnRlc3QoYmFzZSkgfHwgL15cXC9cXC8vLnRlc3QoYmFzZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luU3RhcnQgPSBiYXNlLmluZGV4T2YoJy8vJykgKyAyO1xuICBjb25zdCBvcmlnaW5FbmQgPSBiYXNlLmluZGV4T2YoJy8nLCBvcmlnaW5TdGFydCk7XG4gIC8vIElmIHRoZSBiYXNlIHVybCBvbmx5IGNvbnRhaW5zIHRoZSBwcmVmaXggKGUuZy4gLy8pLCBvciB0aGUgc2xhc2hcbiAgLy8gZm9yIHRoZSBvcmlnaW4gaXMgcmlnaHQgYWZ0ZXIgdGhlIHByZWZpeCAoZS5nLiAvLy8pLCB0aGUgb3JpZ2luIGlzXG4gIC8vIG1pc3NpbmcuXG4gIGlmIChvcmlnaW5FbmQgPD0gb3JpZ2luU3RhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2FuJ3QgaW50ZXJwb2xhdGUgZGF0YSBpbiBhIHVybCdzIG9yaWdpbiwgYCArXG4gICAgICAgIGBQbGVhc2UgbWFrZSBzdXJlIHRvIGZ1bGx5IHNwZWNpZnkgdGhlIG9yaWdpbiwgdGVybWluYXRlZCB3aXRoICcvJy5gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBvcmlnaW4gPSBiYXNlLnN1YnN0cmluZyhvcmlnaW5TdGFydCwgb3JpZ2luRW5kKTtcbiAgaWYgKCEvXlswLTlhLXouOi1dKyQvaS50ZXN0KG9yaWdpbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcmlnaW4gY29udGFpbnMgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycy4nKTtcbiAgfVxuICBpZiAoIS9eW146XSooOlswLTldKyk/JC9pLnRlc3Qob3JpZ2luKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb3J0IG51bWJlci4nKTtcbiAgfVxuICBpZiAoIS8oXnxcXC4pW2Etel1bXi5dKiQvaS50ZXN0KG9yaWdpbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0b3AtbGV2ZWwgZG9tYWluIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBiYXNlIHVybCBjb250YWlucyBhIHZhbGlkIGFib3V0IHVybCBhdCBpdHMgYmVnaW5uaW5nLlxuICpcbiAqIEFuIGFib3V0IHVybCBpcyBlaXRoZXIgZXhhY3RseSAnYWJvdXQ6YmxhbmsnIG9yICdhYm91dDpibGFuayM8c3RyPicgd2hlcmVcbiAqIDxzdHI+IGNhbiBiZSBhbiBhcmJpdHJhcnkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHVybC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFib3V0VXJsKGJhc2U6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIS9eYWJvdXQ6YmxhbmsvLnRlc3QoYmFzZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJhc2UgIT09ICdhYm91dDpibGFuaycgJiYgIS9eYWJvdXQ6YmxhbmsjLy50ZXN0KGJhc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWJvdXQgdXJsIGlzIGludmFsaWQuJyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYmFzZSB1cmwgY29udGFpbnMgYSB2YWxpZCBwYXRoIHN0YXJ0IGF0IGl0cyBiZWdpbm5pbmcuXG4gKlxuICogQSB2YWxpZCBwYXRoIHN0YXJ0IGlzIGVpdGhlciBhICcvJyBvciBhICcvJyBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmVcbiAqIGNoYXJhY3RlciB0aGF0IGlzIG5vdCAnLycgb3IgJ1xcJy5cbiAqXG4gKiBAcGFyYW0gYmFzZSBUaGUgYmFzZSB1cmwuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRQYXRoU3RhcnQoYmFzZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghL15cXC8vLnRlc3QoYmFzZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFxuICAgIGJhc2UgPT09ICcvJyB8fFxuICAgIChiYXNlLmxlbmd0aCA+IDEgJiYgYmFzZVsxXSAhPT0gJy8nICYmIGJhc2VbMV0gIT09ICdcXFxcJylcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGF0aCBzdGFydCBpbiB0aGUgdXJsIGlzIGludmFsaWQuJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgYmFzZSB1cmwgY29udGFpbnMgYSB2YWxpZCByZWxhdGl2ZSBwYXRoIHN0YXJ0IGF0IGl0c1xuICogYmVnaW5uaW5nLlxuICpcbiAqIEEgdmFsaWQgcmVsYXRpdmUgcGF0aCBzdGFydCBpcyBhIG5vbiBlbXB0eSBzdHJpbmcgdGhhdCBoYXMgbm8gJzonLCAnLycgbm9yXG4gKiAnXFwnLCBhbmQgdGhhdCBpcyBmb2xsb3dlZCBieSBhICcvJy5cbiAqXG4gKiBAcGFyYW0gYmFzZSBUaGUgYmFzZSB1cmwuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZWxhdGl2ZVBhdGhTdGFydChiYXNlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gVXNpbmcgdGhlIFJlZ0V4cCBzeW50YXggYXMgdGhlIG5hdGl2ZSBKUyBSZWdFeHAgc3ludGF4IGlzIG5vdCB3ZWxsIGhhbmRsZWRcbiAgLy8gYnkgc29tZSBkb3duc3RyZWFtIGJ1bmRsZXJzIHdpdGggdGhpcyByZWdleC5cbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ15bXjpcXFxcc1xcXFxcXFxcL10rLycpLnRlc3QoYmFzZSk7XG59XG5cbi8qKlxuICogU3BsaXRzIGFuIHVybCBpbnRvIHNlZ21lbnRzIHVzaW5nICc/JyBhbmQgJyMnIGRlbGltaXRlcnMuXG4gKlxuICogVGhlIFVSTCBjYW4gbGF0ZXIgYmUgcHV0IGJhY2sgdG9nZXRoZXIgYnkgY29uY2F0ZW5hdGluZyB0aGUgcmV0dXJuZWQgc2VnbWVudHNcbiAqIGxpa2U6IHBhdGggKyBwYXJhbXMgKyBoYXNoLiBOb3RlIHRoYXQgdGhlIGRlbGltaXRlcnMgJz8nIGFuZCAnIycgd2lsbFxuICogYWxyZWFkeSBiZSBpbmNsdWRlZCBpbiAncGFyYW1zJyBhbmQgJ2hhc2gnIHZhbHVlcyByZXNwZWN0aXZlbHkgd2hlbiB0aGVzZSBhcmVcbiAqIG5vdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gdXJsIFRoZSB1cmwgdG8gc3BsaXQuXG4gKi9cbmZ1bmN0aW9uIGdldFVybFNlZ21lbnRzKHVybDogc3RyaW5nKToge1xuICBwYXRoOiBzdHJpbmc7XG4gIHBhcmFtczogc3RyaW5nO1xuICBoYXNoOiBzdHJpbmc7XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSB1cmwuc3BsaXQoL1xcP3wjLyk7XG4gIGNvbnN0IHBhcmFtcyA9IC9cXD8vLnRlc3QodXJsKSA/ICc/JyArIHNlZ21lbnRzWzFdIDogJyc7XG4gIGNvbnN0IGhhc2ggPSAvIy8udGVzdCh1cmwpID8gJyMnICsgKHBhcmFtcyA/IHNlZ21lbnRzWzJdIDogc2VnbWVudHNbMV0pIDogJyc7XG4gIHJldHVybiB7cGF0aDogc2VnbWVudHNbMF0sIHBhcmFtcywgaGFzaH07XG59XG5cbi8qKlxuICogQnVpbGRzIFRydXN0ZWRSZXNvdXJjZVVybCBmcm9tIGEgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgaXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZyBmdW5jdGlvbi4gSXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG4gKiBhIHRlbXBsYXRlIGxpdGVyYWwsIHdpdGggb3Igd2l0aG91dCBlbWJlZGRlZCBleHByZXNzaW9ucy4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICAgICAgICAgIHRydXN0ZWRSZXNvdXJjZVVybGAvL2V4YW1wbGUuY29tLyR7YmFyfWA7XG4gKiBvclxuICogICAgICAgICAgICAgICB0cnVzdGVkUmVzb3VyY2VVcmxgLy9leGFtcGxlLmNvbWA7XG4gKlxuICogV2hlbiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGEgdGVtcGxhdGUgbGl0ZXJhbCB3aXRob3V0IGFueSBlbWJlZGRlZFxuICogZXhwcmVzc2lvbnMsIHRoZSB0ZW1wbGF0ZSBzdHJpbmcgbWF5IGNvbnRhaW4gYW55dGhpbmcgYXMgdGhlIHdob2xlIFVSTCBpc1xuICogYSBjb21waWxlLXRpbWUgc3RyaW5nIGNvbnN0YW50LlxuICpcbiAqIFdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIHRlbXBsYXRlIGxpdGVyYWwgdGhhdCBjb250YWlucyBlbWJlZGRlZFxuICogZXhwcmVzc2lvbnMsIHRoZSB0ZW1wbGF0ZSBtdXN0IHN0YXJ0IHdpdGggb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIGBodHRwczovLzxvcmlnaW4+L2BcbiAqIC0gYC8vPG9yaWdpbj4vYFxuICogLSBgLzxwYXRoU3RhcnQ+YFxuICogLSBgPHJlbGF0aXZlUGF0aFN0YXJ0Pi9gXG4gKiAtIGBhYm91dDpibGFua2BcbiAqIC0gYGRhdGE6YFxuICpcbiAqIGA8b3JpZ2luPmAgbXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIG9yIGFueSBvZiB0aGUgZm9sbG93aW5nOiBgLS46YC5cbiAqIFJlbWVtYmVyIHRoYXQsIGFzIHBlciB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgVHJ1c3RlZFJlc291cmNlVXJsLCB0aGUgb3JpZ2luXG4gKiBtdXN0IGJlIHRydXN0d29ydGh5LiBBbiBvcmlnaW4gb2YgXCJleGFtcGxlLmNvbVwiIGNvdWxkIGJlIHNldCB3aXRoIHRoaXNcbiAqIG1ldGhvZCwgYnV0IHdvdWxkIHRpZSB0aGUgc2VjdXJpdHkgb2YgeW91ciBzaXRlIHRvIHRoZSBzZWN1cml0eSBvZlxuICogZXhhbXBsZS5jb20uIFNpbWlsYXJseSwgZm9ybWF0cyB0aGF0IHBvdGVudGlhbGx5IGNvdmVyIHJlZGlyZWN0cyBob3N0ZWRcbiAqIG9uIGEgdHJ1c3RlZCBvcmlnaW4gYXJlIHByb2JsZW1hdGljLCBzaW5jZSB0aGF0IGNvdWxkIGxlYWQgdG8gdW50cnVzdGVkXG4gKiBvcmlnaW5zLlxuICpcbiAqIGA8cGF0aFN0YXJ0PmAgaXMgZWl0aGVyIGFuIGVtcHR5IHN0cmluZywgb3IgYSBub24gZW1wdHkgc3RyaW5nIHRoYXQgZG9lcyBub3RcbiAqIHN0YXJ0IHdpdGggJy8nIG9yICdcXCcuXG4gKiBJbiBvdGhlciB3b3JkcywgYC88cGF0aFN0YXJ0PmAgaXMgZWl0aGVyIGEgJy8nIG9yIGFcbiAqICcvJyBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgbm90ICcvJyBvciAnXFwnLlxuICpcbiAqIGA8cmVsYXRpdmVQYXRoU3RhcnQ+IGlzIGEgbm9uIGVtcHR5IHN0cmluZyB0aGF0IGhhcyBubyAnOicsICcvJyBub3IgJ1xcJy5cbiAqXG4gKiBgZGF0YTpgIChkYXRhIFVSTCkgZG9lcyBub3QgYWxsb3cgZW1iZWRkZWQgZXhwcmVzc2lvbnMgaW4gdGhlIHRlbXBsYXRlXG4gKiBsaXRlcmFsIGlucHV0LlxuICpcbiAqIEFsbCBlbWJlZGRlZCBleHByZXNzaW9ucyBhcmUgVVJMIGVuY29kZWQgd2hlbiB0aGV5IGFyZSBpbnRlcnBvbGF0ZWQuIERvIG5vdFxuICogZW1iZWQgZXhwcmVzc2lvbnMgdGhhdCBhcmUgYWxyZWFkeSBVUkwgZW5jb2RlZCBhcyB0aGV5IHdpbGwgYmUgZG91YmxlIGVuY29kZWRcbiAqIGJ5IHRoZSBidWlsZGVyLlxuICpcbiAqIEBwYXJhbSB0ZW1wbGF0ZU9iaiBUaGlzIGNvbnRhaW5zIHRoZSBsaXRlcmFsIHBhcnQgb2YgdGhlIHRlbXBsYXRlIGxpdGVyYWwuXG4gKiBAcGFyYW0gcmVzdCBUaGlzIHJlcHJlc2VudHMgdGhlIHRlbXBsYXRlJ3MgZW1iZWRkZWQgZXhwcmVzc2lvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkUmVzb3VyY2VVcmwoXG4gIHRlbXBsYXRlT2JqOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSxcbiAgLi4ucmVzdDogUHJpbWl0aXZlW11cbik6IFRydXN0ZWRSZXNvdXJjZVVybCB7XG4gIC8vIENoZWNrIGlmIHRlbXBsYXRlT2JqIGlzIGFjdHVhbGx5IGZyb20gYSB0ZW1wbGF0ZSBsaXRlcmFsLlxuICBpZiAoREVWX01PREUpIHtcbiAgICBhc3NlcnRJc1RlbXBsYXRlT2JqZWN0KHRlbXBsYXRlT2JqLCByZXN0Lmxlbmd0aCk7XG4gIH1cblxuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY3JlYXRlUmVzb3VyY2VVcmxJbnRlcm5hbCh0ZW1wbGF0ZU9ialswXSk7XG4gIH1cblxuICBjb25zdCBiYXNlID0gdGVtcGxhdGVPYmpbMF0udG9Mb3dlckNhc2UoKTtcblxuICBpZiAoREVWX01PREUpIHtcbiAgICBpZiAoL15kYXRhOi8udGVzdChiYXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGF0YSBVUkxzIGNhbm5vdCBoYXZlIGV4cHJlc3Npb25zIGluIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIGlucHV0LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFoYXNWYWxpZE9yaWdpbihiYXNlKSAmJlxuICAgICAgIWlzVmFsaWRQYXRoU3RhcnQoYmFzZSkgJiZcbiAgICAgICFpc1ZhbGlkUmVsYXRpdmVQYXRoU3RhcnQoYmFzZSkgJiZcbiAgICAgICFpc1ZhbGlkQWJvdXRVcmwoYmFzZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RyeWluZyB0byBpbnRlcnBvbGF0ZSBleHByZXNzaW9ucyBpbiBhbiB1bnN1cHBvcnRlZCB1cmwgZm9ybWF0LicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB1cmwgPSB0ZW1wbGF0ZU9ialswXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdXJsICs9IGVuY29kZVVSSUNvbXBvbmVudChyZXN0W2ldKSArIHRlbXBsYXRlT2JqW2kgKyAxXTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVzb3VyY2VVcmxJbnRlcm5hbCh1cmwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVHJ1c3RlZFJlc291cmNlVXJsIHdpdGggcGFyYW1zIGFkZGVkIHRvIHRoZSBVUkwncyBzZWFyY2hcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHBhcmFtcyBXaGF0IHRvIGFkZCB0byB0aGUgVVJMLiBQYXJhbWV0ZXJzIHdpdGggdmFsdWUgYG51bGxgIG9yXG4gKiBgdW5kZWZpbmVkYCBhcmUgc2tpcHBlZC4gQm90aCBrZXlzIGFuZCB2YWx1ZXMgd2lsbCBiZSBlbmNvZGVkLiBEbyBub3QgcGFzc1xuICogcHJlLWVuY29kZWQgdmFsdWVzIGFzIHRoaXMgd2lsbCByZXN1bHQgdGhlbSBiZWluZyBkb3VibGUgZW5jb2RlZC4gSWYgdGhlXG4gKiB2YWx1ZSBpcyBhbiBhcnJheSB0aGVuIHRoZSBzYW1lIHBhcmFtZXRlciBpcyBhZGRlZCBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGVcbiAqIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUGFyYW1zKFxuICB0cnVzdGVkVXJsOiBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIC8vIExJTkUtRVhURVJOQUwgcGFyYW1zOiBNYXA8c3RyaW5nLCBQcmltaXRpdmV8bnVsbHxBcnJheTxQcmltaXRpdmV8bnVsbD4+KTpcbiAgLy8gQkVHSU4tSU5URVJOQUxcbiAgLy8gRXhwbGljaXQgdHlwZSB1bmlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBDbG9zdXJlIGNvbXBpbGVyIHNpbmNlIGl0XG4gIC8vIGRvZXNuJ3Qgc3VwcG9ydCBjb3ZhcmlhbmNlLlxuICBwYXJhbXM6XG4gICAgfCBNYXA8c3RyaW5nLCBQcmltaXRpdmUgfCBudWxsIHwgQXJyYXk8UHJpbWl0aXZlIHwgbnVsbD4+XG4gICAgfCBNYXA8c3RyaW5nLCBzdHJpbmc+LFxuKTogLy8gRU5ELUlOVEVSTkFMXG5UcnVzdGVkUmVzb3VyY2VVcmwge1xuICBjb25zdCB1cmxTZWdtZW50cyA9IGdldFVybFNlZ21lbnRzKHVud3JhcFJlc291cmNlVXJsKHRydXN0ZWRVcmwpLnRvU3RyaW5nKCkpO1xuXG4gIGxldCB1cmxQYXJhbXMgPSB1cmxTZWdtZW50cy5wYXJhbXM7XG4gIGxldCBzZXBhcmF0b3IgPSB1cmxQYXJhbXMubGVuZ3RoID8gJyYnIDogJz8nO1xuICAvLyBmb3Itb2YgaGFzIGEgYmlnIHBvbHlmaWxsLlxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuLWl0ZXJhYmxlLWZvcmVhY2hcbiAgcGFyYW1zLmZvckVhY2goXG4gICAgKHZhbHVlOiBQcmltaXRpdmUgfCBudWxsIHwgQXJyYXk8UHJpbWl0aXZlIHwgbnVsbD4sIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdXJsUGFyYW1zICs9XG4gICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgJz0nICtcbiAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHYpKTtcbiAgICAgICAgc2VwYXJhdG9yID0gJyYnO1xuICAgICAgfVxuICAgIH0sXG4gICk7XG4gIHJldHVybiBjcmVhdGVSZXNvdXJjZVVybEludGVybmFsKFxuICAgIHVybFNlZ21lbnRzLnBhdGggKyB1cmxQYXJhbXMgKyB1cmxTZWdtZW50cy5oYXNoLFxuICApO1xufVxuXG5jb25zdCBCRUZPUkVfRlJBR01FTlRfUkVHRVhQID0gL1teI10qLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFRydXN0ZWRSZXNvdXJjZVVybCBiYXNlZCBvbiBhbiBleGlzdGluZyBvbmUgYnV0IHdpdGggdGhlXG4gKiBhZGRpdGlvbiBvZiBhIGZyYWdtZW50ICh0aGUgcGFydCBhZnRlciBgI2ApLiBJZiB0aGUgVVJMIGFscmVhZHkgaGFzIGFcbiAqIGZyYWdtZW50LCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBuZXcgb25lLlxuICogQHBhcmFtIGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBhZGQgdG8gdGhlIFVSTCwgdmVyYmF0aW0sIHdpdGhvdXQgdGhlIGxlYWRpbmdcbiAqIGAjYC4gTm8gYWRkaXRpb25hbCBlc2NhcGluZyBpcyBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUZyYWdtZW50KFxuICB0cnVzdGVkVXJsOiBUcnVzdGVkUmVzb3VyY2VVcmwsXG4gIGZyYWdtZW50OiBzdHJpbmcsXG4pIHtcbiAgY29uc3QgdXJsU3RyaW5nID0gdW53cmFwUmVzb3VyY2VVcmwodHJ1c3RlZFVybCkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIGNyZWF0ZVJlc291cmNlVXJsSW50ZXJuYWwoXG4gICAgQkVGT1JFX0ZSQUdNRU5UX1JFR0VYUC5leGVjKHVybFN0cmluZykhWzBdICsgJyMnICsgZnJhZ21lbnQsXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBUcnVzdGVkUmVzb3VyY2VVcmwgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb25lIHdpdGggYSBzaW5nbGVcbiAqIHN1YnBhdGggc2VnbWVudCBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBleGlzdGluZyBwYXRoIGFuZCBwcmlvciB0byBhbnkgcXVlcnlcbiAqIHBhcmFtZXRlcnMgYW5kL29yIGZyYWdtZW50cyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gdGhlIFVSTC5cbiAqIEBwYXJhbSBwYXRoU2VnbWVudCBUaGUgc2luZ3VsYXIgc3ViIHBhdGggYmVpbmcgYWRkZWQgdG8gdGhlIFVSTC4gRG8gbm90IHBhc3NcbiAqICAgICBhIHByZS1lbmNvZGVkIHZhbHVlIGFzIHRoaXMgd2lsbCByZXN1bHQgaW4gaXQgYmVpbmcgZG91YmxlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRQYXRoU2VnbWVudChcbiAgdHJ1c3RlZFVybDogVHJ1c3RlZFJlc291cmNlVXJsLFxuICBwYXRoU2VnbWVudDogc3RyaW5nLFxuKTogVHJ1c3RlZFJlc291cmNlVXJsIHtcbiAgY29uc3QgdXJsU2VnbWVudHMgPSBnZXRVcmxTZWdtZW50cyh1bndyYXBSZXNvdXJjZVVybCh0cnVzdGVkVXJsKS50b1N0cmluZygpKTtcblxuICBjb25zdCBzZXBhcmF0b3IgPSB1cmxTZWdtZW50cy5wYXRoLnNsaWNlKC0xKSA9PT0gJy8nID8gJycgOiAnLyc7XG4gIGNvbnN0IG5ld1BhdGggPVxuICAgIHVybFNlZ21lbnRzLnBhdGggKyBzZXBhcmF0b3IgKyBlbmNvZGVVUklDb21wb25lbnQocGF0aFNlZ21lbnQpO1xuXG4gIHJldHVybiBjcmVhdGVSZXNvdXJjZVVybEludGVybmFsKFxuICAgIG5ld1BhdGggKyB1cmxTZWdtZW50cy5wYXJhbXMgKyB1cmxTZWdtZW50cy5oYXNoLFxuICApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgVHJ1c3RlZFJlc291cmNlVXJsYCBieSBnZW5lcmF0aW5nIGEgYEJsb2JgIGZyb20gYVxuICogYFNhZmVTY3JpcHRgIGFuZCB0aGVuIGNhbGxpbmcgYFVSTC5jcmVhdGVPYmplY3RVUkxgIHdpdGggdGhhdCBgQmxvYmAuXG4gKlxuICogQ2FsbGVyIG11c3QgY2FsbCBgVVJMLnJldm9rZU9iamVjdFVSTCgpYCBvbiB0aGUgc3RyaW5naWZpZWQgdXJsIHRvXG4gKiByZWxlYXNlIHRoZSB1bmRlcmx5aW5nIGBCbG9iYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdFVybEZyb21TY3JpcHQoXG4gIHNhZmVTY3JpcHQ6IFNhZmVTY3JpcHQsXG4pOiBUcnVzdGVkUmVzb3VyY2VVcmwge1xuICBjb25zdCBzY3JpcHRDb250ZW50ID0gdW53cmFwU2NyaXB0KHNhZmVTY3JpcHQpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbc2NyaXB0Q29udGVudF0sIHt0eXBlOiAndGV4dC9qYXZhc2NyaXB0J30pO1xuICByZXR1cm4gY3JlYXRlUmVzb3VyY2VVcmxJbnRlcm5hbChVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIHNhZmVseSByZXRyaWV2ZSB0aGUgYmFzZSBVUkkgZnJvbSB0aGUgV2luZG93IG9iamVjdCBhbmQgc2V0IGl0XG4gKiBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgZ2l2ZW4gcGF0aC1yZWxhdGl2ZSAoc3RhcnRzIHdpdGggXCIvXCIpIHJlc291cmNlIHVybC5cbiAqXG4gKiBAcGFyYW0gcGF0aFJlbGF0aXZlVXJsIFRoZSByZXNvdXJjZSB0byB3aGljaCB0aGUgb3JpZ2luIHNoYWxsIGJlIHByZXBlbmRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQWJzb2x1dGVSZXNvdXJjZVVybChwYXRoUmVsYXRpdmVVcmw6IFRydXN0ZWRSZXNvdXJjZVVybCkge1xuICBjb25zdCBvcmlnaW5hbFVybCA9IHVud3JhcFJlc291cmNlVXJsKHBhdGhSZWxhdGl2ZVVybCkudG9TdHJpbmcoKTtcbiAgY29uc3QgcXVhbGlmaWVkVXJsID0gbmV3IFVSTChvcmlnaW5hbFVybCwgd2luZG93LmRvY3VtZW50LmJhc2VVUkkpO1xuICByZXR1cm4gY3JlYXRlUmVzb3VyY2VVcmxJbnRlcm5hbChxdWFsaWZpZWRVcmwudG9TdHJpbmcoKSk7XG59XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/builders/script_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/script_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.script_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/script_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_script_impl_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_string_literal_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
/** @typedef {(string|number|boolean)} */
var Primitive;
/** @typedef {(string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?|!Object<string,(null|string|number|boolean|?)>)>|!Object<string,(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?)>|?)>)} */
var Serializable;
/**
 * Creates a SafeScript object from a template literal (without any embedded
 * expressions).
 *
 * This function is a template literal tag function. It should be called with
 * a template literal that does not contain any expressions. For example,
 *                           safeScript`foo`;
 *
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @param {...string} emptyArgs Expressions that evaluate to the empty string to enable
 *     inline comments.
 * @return {!tsickle_script_impl_2.SafeScript}
 */
function safeScript(templateObj, ...emptyArgs) {
    if (dev_1.DEV_MODE) {
        if (emptyArgs.some((/**
         * @param {string} a
         * @return {boolean}
         */
        (a) => a !== ''))) {
            throw new Error('safeScript only allows empty string expressions ' +
                'to enable inline comments.');
        }
        (0, string_literal_1.assertIsTemplateObject)(templateObj, emptyArgs.length);
    }
    return (0, script_impl_1.createScriptInternal)(templateObj.join(''));
}
exports.safeScript = safeScript;
/**
 * Creates a `SafeScript` value by concatenating multiple `SafeScript`s.
 * @param {!ReadonlyArray<!tsickle_script_impl_2.SafeScript>} scripts
 * @return {!tsickle_script_impl_2.SafeScript}
 */
function concatScripts(scripts) {
    return (0, script_impl_1.createScriptInternal)(scripts.map(script_impl_1.unwrapScript).join(''));
}
exports.concatScripts = concatScripts;
/**
 * Converts a serializable value into JSON that is safe to interpolate into a
 * script context. In particular it escapes < characters so that a value of
 * "&lt/script>" doesn't break out of the context.
 * @param {(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?|!Object<string,(null|string|number|boolean|?)>)>|!Object<string,(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?)>|?)>)} value The value to serialize.
 * @return {!tsickle_script_impl_2.SafeScript}
 */
function valueAsScript(value) {
    return (0, script_impl_1.createScriptInternal)(JSON.stringify(value).replace(/</g, '\\u003C'));
}
exports.valueAsScript = valueAsScript;
/**
 * Creates a `SafeScript` object from a template literal (without any embedded
 * expressions) along with additional arguments that the script should have
 * access to. These arguments will be JSON-encoded and passed to the script as
 * a function call.
 * \@example
 * ```ts
 * safeScriptWithArgs`function (name, props) {
 *  console.log(name + ' is ' + props.age);
 * }`('Bob', { 'age': 42 })
 * ```
 * would return a `SafeScript` that represents the following code:
 * ```js
 * (function (name, props) {
 *  console.log(name + ' is ' + props.age);
 * })("Bob",{"age":42})
 * ```
 * \@note Be careful when passing objects as arguments, as unquoted property
 * names may be changed during compilation.
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 * @param {...string} emptyArgs Expressions that evaluate to the empty string to enable
 *     inline comments.
 * @return {function(...(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?|!Object<string,(null|string|number|boolean|?)>)>|!Object<string,(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?)>|?)>)): !tsickle_script_impl_2.SafeScript}
 */
function safeScriptWithArgs(templateObj, ...emptyArgs) {
    if (dev_1.DEV_MODE) {
        if (emptyArgs.some((/**
         * @param {string} a
         * @return {boolean}
         */
        (a) => a !== ''))) {
            throw new Error('safeScriptWithArgs only allows empty string expressions ' +
                'to enable inline comments.');
        }
        (0, string_literal_1.assertIsTemplateObject)(templateObj, emptyArgs.length);
    }
    return (/**
     * @param {...(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?|!Object<string,(null|string|number|boolean|?)>)>|!Object<string,(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?)>|?)>)} argValues
     * @return {!tsickle_script_impl_2.SafeScript}
     */
    (...argValues) => {
        /** @type {!Array<string>} */
        const values = argValues.map((/**
         * @param {(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?|!Object<string,(null|string|number|boolean|?)>)>|!Object<string,(null|string|number|boolean|!ReadonlyArray<(null|string|number|boolean|?)>|?)>)} v
         * @return {string}
         */
        (v) => valueAsScript(v).toString()));
        return (0, script_impl_1.createScriptInternal)(`(${templateObj.join('')})(${values.join(',')})`);
    });
}
exports.safeScriptWithArgs = safeScriptWithArgs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NyaXB0X2J1aWxkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL2J1aWxkZXJzL3NjcmlwdF9idWlsZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHdGQUE0QztBQUM1QyxzR0FJa0M7QUFDbEMsNEdBQW1FOztBQUVuRSxjQUEyQzs7QUFDM0MsaUJBR2tEOzs7Ozs7Ozs7Ozs7OztBQWNsRCxTQUFnQixVQUFVLENBQ3hCLFdBQWlDLEVBQ2pDLEdBQUcsU0FBNEI7SUFFL0IsSUFBSSxjQUFRLEVBQUUsQ0FBQztRQUNiLElBQUksU0FBUyxDQUFDLElBQUk7Ozs7UUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBQyxFQUFFLENBQUM7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FDYixrREFBa0Q7Z0JBQ2hELDRCQUE0QixDQUMvQixDQUFDO1FBQ0osQ0FBQztRQUNELElBQUEsdUNBQXNCLEVBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQ0QsT0FBTyxJQUFBLGtDQUFvQixFQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBZEQsZ0NBY0M7Ozs7OztBQUdELFNBQWdCLGFBQWEsQ0FBQyxPQUE4QjtJQUMxRCxPQUFPLElBQUEsa0NBQW9CLEVBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQywwQkFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQUZELHNDQUVDOzs7Ozs7OztBQVFELFNBQWdCLGFBQWEsQ0FBQyxLQUEwQjtJQUN0RCxPQUFPLElBQUEsa0NBQW9CLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDOUUsQ0FBQztBQUZELHNDQUVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJELFNBQWdCLGtCQUFrQixDQUNoQyxXQUFpQyxFQUNqQyxHQUFHLFNBQTRCO0lBRS9CLElBQUksY0FBUSxFQUFFLENBQUM7UUFDYixJQUFJLFNBQVMsQ0FBQyxJQUFJOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUMsRUFBRSxDQUFDO1lBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQ2IsMERBQTBEO2dCQUN4RCw0QkFBNEIsQ0FDL0IsQ0FBQztRQUNKLENBQUM7UUFDRCxJQUFBLHVDQUFzQixFQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUNEOzs7O0lBQU8sQ0FBQyxHQUFHLFNBQTZDLEVBQUUsRUFBRTs7Y0FDcEQsTUFBTSxHQUFHLFNBQVMsQ0FBQyxHQUFHOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBQztRQUNoRSxPQUFPLElBQUEsa0NBQW9CLEVBQ3pCLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQ2pELENBQUM7SUFDSixDQUFDLEVBQUM7QUFDSixDQUFDO0FBbkJELGdEQW1CQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtERVZfTU9ERX0gZnJvbSAnLi4vZW52aXJvbm1lbnQvZGV2JztcbmltcG9ydCB7XG4gIGNyZWF0ZVNjcmlwdEludGVybmFsLFxuICBTYWZlU2NyaXB0LFxuICB1bndyYXBTY3JpcHQsXG59IGZyb20gJy4uL2ludGVybmFscy9zY3JpcHRfaW1wbCc7XG5pbXBvcnQge2Fzc2VydElzVGVtcGxhdGVPYmplY3R9IGZyb20gJy4uL2ludGVybmFscy9zdHJpbmdfbGl0ZXJhbCc7XG5cbnR5cGUgUHJpbWl0aXZlID0gbnVtYmVyIHwgc3RyaW5nIHwgYm9vbGVhbjtcbnR5cGUgU2VyaWFsaXphYmxlID1cbiAgfCBQcmltaXRpdmVcbiAgfCBSZWFkb25seUFycmF5PFNlcmlhbGl6YWJsZSB8IG51bGw+XG4gIHwge3JlYWRvbmx5IFtrZXk6IHN0cmluZ106IFNlcmlhbGl6YWJsZSB8IG51bGx9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTYWZlU2NyaXB0IG9iamVjdCBmcm9tIGEgdGVtcGxhdGUgbGl0ZXJhbCAod2l0aG91dCBhbnkgZW1iZWRkZWRcbiAqIGV4cHJlc3Npb25zKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgdGVtcGxhdGUgbGl0ZXJhbCB0YWcgZnVuY3Rpb24uIEl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aFxuICogYSB0ZW1wbGF0ZSBsaXRlcmFsIHRoYXQgZG9lcyBub3QgY29udGFpbiBhbnkgZXhwcmVzc2lvbnMuIEZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBzYWZlU2NyaXB0YGZvb2A7XG4gKlxuICogQHBhcmFtIHRlbXBsYXRlT2JqIFRoaXMgY29udGFpbnMgdGhlIGxpdGVyYWwgcGFydCBvZiB0aGUgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqIEBwYXJhbSBlbXB0eUFyZ3MgRXhwcmVzc2lvbnMgdGhhdCBldmFsdWF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nIHRvIGVuYWJsZVxuICogICAgIGlubGluZSBjb21tZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTY3JpcHQoXG4gIHRlbXBsYXRlT2JqOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSxcbiAgLi4uZW1wdHlBcmdzOiBSZWFkb25seUFycmF5PCcnPlxuKTogU2FmZVNjcmlwdCB7XG4gIGlmIChERVZfTU9ERSkge1xuICAgIGlmIChlbXB0eUFyZ3Muc29tZSgoYSkgPT4gYSAhPT0gJycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzYWZlU2NyaXB0IG9ubHkgYWxsb3dzIGVtcHR5IHN0cmluZyBleHByZXNzaW9ucyAnICtcbiAgICAgICAgICAndG8gZW5hYmxlIGlubGluZSBjb21tZW50cy4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNUZW1wbGF0ZU9iamVjdCh0ZW1wbGF0ZU9iaiwgZW1wdHlBcmdzLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNjcmlwdEludGVybmFsKHRlbXBsYXRlT2JqLmpvaW4oJycpKTtcbn1cblxuLyoqIENyZWF0ZXMgYSBgU2FmZVNjcmlwdGAgdmFsdWUgYnkgY29uY2F0ZW5hdGluZyBtdWx0aXBsZSBgU2FmZVNjcmlwdGBzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdFNjcmlwdHMoc2NyaXB0czogcmVhZG9ubHkgU2FmZVNjcmlwdFtdKTogU2FmZVNjcmlwdCB7XG4gIHJldHVybiBjcmVhdGVTY3JpcHRJbnRlcm5hbChzY3JpcHRzLm1hcCh1bndyYXBTY3JpcHQpLmpvaW4oJycpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNlcmlhbGl6YWJsZSB2YWx1ZSBpbnRvIEpTT04gdGhhdCBpcyBzYWZlIHRvIGludGVycG9sYXRlIGludG8gYVxuICogc2NyaXB0IGNvbnRleHQuIEluIHBhcnRpY3VsYXIgaXQgZXNjYXBlcyA8IGNoYXJhY3RlcnMgc28gdGhhdCBhIHZhbHVlIG9mXG4gKiBcIiZsdC9zY3JpcHQ+XCIgZG9lc24ndCBicmVhayBvdXQgb2YgdGhlIGNvbnRleHQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlQXNTY3JpcHQodmFsdWU6IFNlcmlhbGl6YWJsZSB8IG51bGwpOiBTYWZlU2NyaXB0IHtcbiAgcmV0dXJuIGNyZWF0ZVNjcmlwdEludGVybmFsKEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC88L2csICdcXFxcdTAwM0MnKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBTYWZlU2NyaXB0YCBvYmplY3QgZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWwgKHdpdGhvdXQgYW55IGVtYmVkZGVkXG4gKiBleHByZXNzaW9ucykgYWxvbmcgd2l0aCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHRoZSBzY3JpcHQgc2hvdWxkIGhhdmVcbiAqIGFjY2VzcyB0by4gVGhlc2UgYXJndW1lbnRzIHdpbGwgYmUgSlNPTi1lbmNvZGVkIGFuZCBwYXNzZWQgdG8gdGhlIHNjcmlwdCBhc1xuICogYSBmdW5jdGlvbiBjYWxsLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBzYWZlU2NyaXB0V2l0aEFyZ3NgZnVuY3Rpb24gKG5hbWUsIHByb3BzKSB7XG4gKiAgY29uc29sZS5sb2cobmFtZSArICcgaXMgJyArIHByb3BzLmFnZSk7XG4gKiB9YCgnQm9iJywgeyAnYWdlJzogNDIgfSlcbiAqIGBgYFxuICogd291bGQgcmV0dXJuIGEgYFNhZmVTY3JpcHRgIHRoYXQgcmVwcmVzZW50cyB0aGUgZm9sbG93aW5nIGNvZGU6XG4gKiBgYGBqc1xuICogKGZ1bmN0aW9uIChuYW1lLCBwcm9wcykge1xuICogIGNvbnNvbGUubG9nKG5hbWUgKyAnIGlzICcgKyBwcm9wcy5hZ2UpO1xuICogfSkoXCJCb2JcIix7XCJhZ2VcIjo0Mn0pXG4gKiBgYGBcbiAqIEBub3RlIEJlIGNhcmVmdWwgd2hlbiBwYXNzaW5nIG9iamVjdHMgYXMgYXJndW1lbnRzLCBhcyB1bnF1b3RlZCBwcm9wZXJ0eVxuICogbmFtZXMgbWF5IGJlIGNoYW5nZWQgZHVyaW5nIGNvbXBpbGF0aW9uLlxuICogQHBhcmFtIHRlbXBsYXRlT2JqIFRoaXMgY29udGFpbnMgdGhlIGxpdGVyYWwgcGFydCBvZiB0aGUgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqIEBwYXJhbSBlbXB0eUFyZ3MgRXhwcmVzc2lvbnMgdGhhdCBldmFsdWF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nIHRvIGVuYWJsZVxuICogICAgIGlubGluZSBjb21tZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTY3JpcHRXaXRoQXJncyhcbiAgdGVtcGxhdGVPYmo6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICAuLi5lbXB0eUFyZ3M6IFJlYWRvbmx5QXJyYXk8Jyc+XG4pOiAoLi4uYXJnVmFsdWVzOiBSZWFkb25seUFycmF5PFNlcmlhbGl6YWJsZSB8IG51bGw+KSA9PiBTYWZlU2NyaXB0IHtcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgaWYgKGVtcHR5QXJncy5zb21lKChhKSA9PiBhICE9PSAnJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NhZmVTY3JpcHRXaXRoQXJncyBvbmx5IGFsbG93cyBlbXB0eSBzdHJpbmcgZXhwcmVzc2lvbnMgJyArXG4gICAgICAgICAgJ3RvIGVuYWJsZSBpbmxpbmUgY29tbWVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGFzc2VydElzVGVtcGxhdGVPYmplY3QodGVtcGxhdGVPYmosIGVtcHR5QXJncy5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAoLi4uYXJnVmFsdWVzOiBSZWFkb25seUFycmF5PFNlcmlhbGl6YWJsZSB8IG51bGw+KSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gYXJnVmFsdWVzLm1hcCgodikgPT4gdmFsdWVBc1NjcmlwdCh2KS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gY3JlYXRlU2NyaXB0SW50ZXJuYWwoXG4gICAgICBgKCR7dGVtcGxhdGVPYmouam9pbignJyl9KSgke3ZhbHVlcy5qb2luKCcsJyl9KWAsXG4gICAgKTtcbiAgfTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/builders/style_builders.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/builders/style_builders.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.builders.style_builders');
var module = module || { id: 'third_party/javascript/safevalues/builders/style_builders.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_dev_1 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const tsickle_string_literal_2 = goog.requireType("google3.third_party.javascript.safevalues.internals.string_literal");
const tsickle_style_impl_3 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_impl");
const tsickle_url_impl_4 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_SafeStyle_5 = goog.requireType("goog.html.SafeStyle");
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
const string_literal_1 = goog.require('google3.third_party.javascript.safevalues.internals.string_literal');
const style_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_impl');
/**
 * Creates a SafeStyle object from a template literal (without any embedded
 * expressions).
 *
 * ` style` should be in the format
 * ` name: value; [name: value; ...]` and must not have any < or >
 * characters in it. This is so that SafeStyle's contract is preserved,
 * allowing the SafeStyle to correctly be interpreted as a sequence of CSS
 * declarations and without affecting the syntactic structure of any
 * surrounding CSS and HTML.
 *
 * This function is a template literal tag function. It should be called with
 * a template literal that does not contain any expressions. For example,
 *                          safeStyle`foo`;
 * This function first checks if it is called with a literal template, and
 * then performs basic sanity checks on the format of ` style`
 * but does not constrain the format of ` name} and {\@code value`, except
 * for disallowing tag characters.
 *
 * @deprecated Inline styles do not pose a security risk with modern browsers
 *     anymore, so there's no need to use this function. Please use native
 *     style properties on the element or string functions instead.
 *     See go/deleting-safestyle for more information.
 *     Reach out to http://yaqs/ise-web if you have any questions.
 * @param {!TemplateStringsArray} templateObj This contains the literal part of the template literal.
 *
 * @param {...(string|number|!tsickle_url_impl_4.SafeUrl)} rest
 * @return {!tsickle_SafeStyle_5}
 */
function safeStyle(templateObj, ...rest) {
    if (dev_1.DEV_MODE) {
        (0, string_literal_1.assertIsTemplateObject)(templateObj, rest.length);
    }
    /** @type {string} */
    let stringifiedStyle = templateObj[0];
    for (let i = 0; i < templateObj.length - 1; i++) {
        stringifiedStyle += String(rest[i]) + templateObj[i + 1];
    }
    if (/[<>]/.test(stringifiedStyle)) {
        throw new Error('Forbidden characters in style string: ' + stringifiedStyle);
    }
    if (dev_1.DEV_MODE) {
        if (stringifiedStyle.length === 0) {
            return (0, style_impl_1.createStyleInternal)(stringifiedStyle);
        }
        if (!/;$/.test(stringifiedStyle)) {
            throw new Error('Style string does not end with ";": ' + stringifiedStyle);
        }
        if (!/:/.test(stringifiedStyle)) {
            throw new Error('Style string should contain one or more ":": ' + stringifiedStyle);
        }
    }
    return (0, style_impl_1.createStyleInternal)(stringifiedStyle);
}
exports.safeStyle = safeStyle;
/**
 * Creates a `SafeStyle` value from a string.
 *
 * @deprecated Note: This function only exists for compatibility reasons to help
 *     migrate away from `SafeStyle`
 *     See go/deleting-safestyle for more information.
 *     Reach out to http://yaqs/ise-web if you have any questions.
 * @param {string} style
 * @return {!tsickle_SafeStyle_5}
 */
function styleForMigration(style) {
    return (0, style_impl_1.createStyleInternal)(style);
}
exports.styleForMigration = styleForMigration;
/**
 * Creates a `SafeStyle` value by concatenating multiple `SafeStyle`s.
 *
 * @deprecated Inline styles do not pose a security risk with modern browsers
 *     anymore, so there's no need to use this function. Please use native
 *     style properties on the element or string functions instead.
 *     See go/deleting-safestyle for more information.
 *     Reach out to http://yaqs/ise-web if you have any questions.
 * @param {!ReadonlyArray<!tsickle_SafeStyle_5>} styles
 * @return {!tsickle_SafeStyle_5}
 */
function concatStyles(styles) {
    return (0, style_impl_1.createStyleInternal)(styles.map(style_impl_1.unwrapStyle).join(''));
}
exports.concatStyles = concatStyles;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGVfYnVpbGRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvYnVpbGRlcnMvc3R5bGVfYnVpbGRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLHdGQUE0QztBQUM1Qyw0R0FBbUU7QUFDbkUsb0dBSWlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QmpDLFNBQWdCLFNBQVMsQ0FDdkIsV0FBaUMsRUFDakMsR0FBRyxJQUFzQztJQUV6QyxJQUFJLGNBQVEsRUFBRSxDQUFDO1FBQ2IsSUFBQSx1Q0FBc0IsRUFBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7O1FBRUcsZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUNyQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNoRCxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBQ0QsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztRQUNsQyxNQUFNLElBQUksS0FBSyxDQUNiLHdDQUF3QyxHQUFHLGdCQUFnQixDQUM1RCxDQUFDO0lBQ0osQ0FBQztJQUNELElBQUksY0FBUSxFQUFFLENBQUM7UUFDYixJQUFJLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNsQyxPQUFPLElBQUEsZ0NBQW1CLEVBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQ2Isc0NBQXNDLEdBQUcsZ0JBQWdCLENBQzFELENBQUM7UUFDSixDQUFDO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQ2IsK0NBQStDLEdBQUcsZ0JBQWdCLENBQ25FLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sSUFBQSxnQ0FBbUIsRUFBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFwQ0QsOEJBb0NDOzs7Ozs7Ozs7OztBQVVELFNBQWdCLGlCQUFpQixDQUFDLEtBQWE7SUFDN0MsT0FBTyxJQUFBLGdDQUFtQixFQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFGRCw4Q0FFQzs7Ozs7Ozs7Ozs7O0FBV0QsU0FBZ0IsWUFBWSxDQUFDLE1BQTRCO0lBQ3ZELE9BQU8sSUFBQSxnQ0FBbUIsRUFBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHdCQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMvRCxDQUFDO0FBRkQsb0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7REVWX01PREV9IGZyb20gJy4uL2Vudmlyb25tZW50L2Rldic7XG5pbXBvcnQge2Fzc2VydElzVGVtcGxhdGVPYmplY3R9IGZyb20gJy4uL2ludGVybmFscy9zdHJpbmdfbGl0ZXJhbCc7XG5pbXBvcnQge1xuICBjcmVhdGVTdHlsZUludGVybmFsLFxuICBTYWZlU3R5bGUsXG4gIHVud3JhcFN0eWxlLFxufSBmcm9tICcuLi9pbnRlcm5hbHMvc3R5bGVfaW1wbCc7XG5pbXBvcnQge1NhZmVVcmx9IGZyb20gJy4uL2ludGVybmFscy91cmxfaW1wbCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNhZmVTdHlsZSBvYmplY3QgZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWwgKHdpdGhvdXQgYW55IGVtYmVkZGVkXG4gKiBleHByZXNzaW9ucykuXG4gKlxuICogYCBzdHlsZWAgc2hvdWxkIGJlIGluIHRoZSBmb3JtYXRcbiAqIGAgbmFtZTogdmFsdWU7IFtuYW1lOiB2YWx1ZTsgLi4uXWAgYW5kIG11c3Qgbm90IGhhdmUgYW55IDwgb3IgPlxuICogY2hhcmFjdGVycyBpbiBpdC4gVGhpcyBpcyBzbyB0aGF0IFNhZmVTdHlsZSdzIGNvbnRyYWN0IGlzIHByZXNlcnZlZCxcbiAqIGFsbG93aW5nIHRoZSBTYWZlU3R5bGUgdG8gY29ycmVjdGx5IGJlIGludGVycHJldGVkIGFzIGEgc2VxdWVuY2Ugb2YgQ1NTXG4gKiBkZWNsYXJhdGlvbnMgYW5kIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBzeW50YWN0aWMgc3RydWN0dXJlIG9mIGFueVxuICogc3Vycm91bmRpbmcgQ1NTIGFuZCBIVE1MLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZyBmdW5jdGlvbi4gSXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG4gKiBhIHRlbXBsYXRlIGxpdGVyYWwgdGhhdCBkb2VzIG5vdCBjb250YWluIGFueSBleHByZXNzaW9ucy4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVN0eWxlYGZvb2A7XG4gKiBUaGlzIGZ1bmN0aW9uIGZpcnN0IGNoZWNrcyBpZiBpdCBpcyBjYWxsZWQgd2l0aCBhIGxpdGVyYWwgdGVtcGxhdGUsIGFuZFxuICogdGhlbiBwZXJmb3JtcyBiYXNpYyBzYW5pdHkgY2hlY2tzIG9uIHRoZSBmb3JtYXQgb2YgYCBzdHlsZWBcbiAqIGJ1dCBkb2VzIG5vdCBjb25zdHJhaW4gdGhlIGZvcm1hdCBvZiBgIG5hbWV9IGFuZCB7QGNvZGUgdmFsdWVgLCBleGNlcHRcbiAqIGZvciBkaXNhbGxvd2luZyB0YWcgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGVPYmogVGhpcyBjb250YWlucyB0aGUgbGl0ZXJhbCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsLlxuICpcbiAqIEBkZXByZWNhdGVkIElubGluZSBzdHlsZXMgZG8gbm90IHBvc2UgYSBzZWN1cml0eSByaXNrIHdpdGggbW9kZXJuIGJyb3dzZXJzXG4gKiAgICAgYW55bW9yZSwgc28gdGhlcmUncyBubyBuZWVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uLiBQbGVhc2UgdXNlIG5hdGl2ZVxuICogICAgIHN0eWxlIHByb3BlcnRpZXMgb24gdGhlIGVsZW1lbnQgb3Igc3RyaW5nIGZ1bmN0aW9ucyBpbnN0ZWFkLlxuICogICAgIFNlZSBnby9kZWxldGluZy1zYWZlc3R5bGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAgICAgUmVhY2ggb3V0IHRvIGh0dHA6Ly95YXFzL2lzZS13ZWIgaWYgeW91IGhhdmUgYW55IHF1ZXN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHlsZShcbiAgdGVtcGxhdGVPYmo6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICAuLi5yZXN0OiBBcnJheTxzdHJpbmcgfCBTYWZlVXJsIHwgbnVtYmVyPlxuKTogU2FmZVN0eWxlIHtcbiAgaWYgKERFVl9NT0RFKSB7XG4gICAgYXNzZXJ0SXNUZW1wbGF0ZU9iamVjdCh0ZW1wbGF0ZU9iaiwgcmVzdC5sZW5ndGgpO1xuICB9XG5cbiAgbGV0IHN0cmluZ2lmaWVkU3R5bGUgPSB0ZW1wbGF0ZU9ialswXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZU9iai5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBzdHJpbmdpZmllZFN0eWxlICs9IFN0cmluZyhyZXN0W2ldKSArIHRlbXBsYXRlT2JqW2kgKyAxXTtcbiAgfVxuICBpZiAoL1s8Pl0vLnRlc3Qoc3RyaW5naWZpZWRTdHlsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRm9yYmlkZGVuIGNoYXJhY3RlcnMgaW4gc3R5bGUgc3RyaW5nOiAnICsgc3RyaW5naWZpZWRTdHlsZSxcbiAgICApO1xuICB9XG4gIGlmIChERVZfTU9ERSkge1xuICAgIGlmIChzdHJpbmdpZmllZFN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0eWxlSW50ZXJuYWwoc3RyaW5naWZpZWRTdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCEvOyQvLnRlc3Qoc3RyaW5naWZpZWRTdHlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1N0eWxlIHN0cmluZyBkb2VzIG5vdCBlbmQgd2l0aCBcIjtcIjogJyArIHN0cmluZ2lmaWVkU3R5bGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghLzovLnRlc3Qoc3RyaW5naWZpZWRTdHlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1N0eWxlIHN0cmluZyBzaG91bGQgY29udGFpbiBvbmUgb3IgbW9yZSBcIjpcIjogJyArIHN0cmluZ2lmaWVkU3R5bGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVTdHlsZUludGVybmFsKHN0cmluZ2lmaWVkU3R5bGUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2FmZVN0eWxlYCB2YWx1ZSBmcm9tIGEgc3RyaW5nLlxuICpcbiAqIEBkZXByZWNhdGVkIE5vdGU6IFRoaXMgZnVuY3Rpb24gb25seSBleGlzdHMgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucyB0byBoZWxwXG4gKiAgICAgbWlncmF0ZSBhd2F5IGZyb20gYFNhZmVTdHlsZWBcbiAqICAgICBTZWUgZ28vZGVsZXRpbmctc2FmZXN0eWxlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICAgIFJlYWNoIG91dCB0byBodHRwOi8veWFxcy9pc2Utd2ViIGlmIHlvdSBoYXZlIGFueSBxdWVzdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZUZvck1pZ3JhdGlvbihzdHlsZTogc3RyaW5nKTogU2FmZVN0eWxlIHtcbiAgcmV0dXJuIGNyZWF0ZVN0eWxlSW50ZXJuYWwoc3R5bGUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2FmZVN0eWxlYCB2YWx1ZSBieSBjb25jYXRlbmF0aW5nIG11bHRpcGxlIGBTYWZlU3R5bGVgcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBJbmxpbmUgc3R5bGVzIGRvIG5vdCBwb3NlIGEgc2VjdXJpdHkgcmlzayB3aXRoIG1vZGVybiBicm93c2Vyc1xuICogICAgIGFueW1vcmUsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byB1c2UgdGhpcyBmdW5jdGlvbi4gUGxlYXNlIHVzZSBuYXRpdmVcbiAqICAgICBzdHlsZSBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50IG9yIHN0cmluZyBmdW5jdGlvbnMgaW5zdGVhZC5cbiAqICAgICBTZWUgZ28vZGVsZXRpbmctc2FmZXN0eWxlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICAgIFJlYWNoIG91dCB0byBodHRwOi8veWFxcy9pc2Utd2ViIGlmIHlvdSBoYXZlIGFueSBxdWVzdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdHlsZXMoc3R5bGVzOiByZWFkb25seSBTYWZlU3R5bGVbXSk6IFNhZmVTdHlsZSB7XG4gIHJldHVybiBjcmVhdGVTdHlsZUludGVybmFsKHN0eWxlcy5tYXAodW53cmFwU3R5bGUpLmpvaW4oJycpKTtcbn1cbiJdfQ==
;return exports;});

//third_party/javascript/safevalues/reporting/reporting.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/reporting/reporting.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.reporting.reporting');
var module = module || { id: 'third_party/javascript/safevalues/reporting/reporting.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_html_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_builders");
const tsickle_html_sanitizer_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer");
const tsickle_dev_3 = goog.requireType("google3.third_party.javascript.safevalues.environment.dev");
const html_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_builders');
const html_sanitizer_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer');
const dev_1 = goog.require('google3.third_party.javascript.safevalues.environment.dev');
/**
 * If {\@link legacyUnsafeHtml} is being used with a
 * `reportingId` to enable reporting, the percentage of sampled calls that
 * will be checked for active content. The key is the first character of the
 * `reportingId` and the float is the proportion of requests (in the range
 * 0.0-1.0).
 * @type {!Object<string,number>}
 */
const REPORTING_ID_PREFIX_TO_SAMPLING_RATE = {
    '0': 1.0,
    '1': 1.0,
};
/**
 * If {\@link legacyUnsafeHtml} is being used with a
 * `reportingId` to enable reporting, the percentage of sampled calls that
 * will trigger a heartbeat report to notify us that the function is being
 * called. The key is the first character of the `reportingId` and the float
 * is the proportion of requests (in the range 0.0-1.0).
 *
 * Note: This means that effectively samplingRate*heartbeatRate calls will send
 * a heartbeat.
 * @type {!Object<string,number>}
 */
const REPORTING_ID_PREFIX_TO_HEARTBEAT_RATE = {
    '0': 0.1,
    '1': 0.1,
};
/**
 * Options for configuring reporting used for {\@link legacyUnsafeHtml}.
 * @record
 */
function ReportingOptions() { }
exports.ReportingOptions = ReportingOptions;
/* istanbul ignore if */
if (false) {
    /**
     * A unique ID that identifies the callsite of a specific legacy conversion.
     * If this option is set, the legacy conversion becomes a report-only legacy
     * conversion that logs whether the callsite can be converted to a safer
     * alternative to the go/security-collector. See
     * go/report-only-safehtml-legacy-exemptions for more details on this design
     * and project.
     *
     * This is set via LSC and should not be manually changed.
     * @type {string}
     * @public
     */
    ReportingOptions.prototype.reportingId;
    /**
     * Override {\@link DEFAULT_SAMPLING_RATE} for this specific
     * legacy conversion. It is generally not necessary to use this override
     * unless this legacy conversion is triggering a massive number of reports and
     * it is necessary to decrease the sampling rate to decrease the number of
     * reports.
     * @type {(undefined|number)}
     * @public
     */
    ReportingOptions.prototype.samplingRate;
    /**
     * Override {\@link DEFAULT_HEARTBEAT_RATE} for this specific
     * legacy conversion. It is generally not necessary to use this override
     * unless this legacy conversion is triggering a massive number of reports and
     * it is necessary to decrease the sampling rate to decrease the number of
     * reports.
     * @type {(undefined|number)}
     * @public
     */
    ReportingOptions.prototype.heartbeatRate;
    /**
     * Override for how reports associated with this legacy conversion will be
     * sent to the go/security-collector. It is generally not necessary to use
     * this override unless a caller needs to change how reports are collected
     * (e.g. choosing to collect them via a service's own collection
     * infrastructure).
     * @type {(undefined|function(string, string): void)}
     * @public
     */
    ReportingOptions.prototype.sendReport;
}
/**
 * Passes through the given HTML string unchanged, but logs metadata about
 * whether various transformations would have changed the input to the security
 * collector.
 *
 * Note that this purposefully does not return a SafeHtml and is meant to be
 * used in scenarios where we do not want to introduce a legacy conversion.
 * @param {string} s
 * @param {(undefined|!ReportingOptions)=} options
 * @return {string}
 */
function reportOnlyHtmlPassthrough(s, options) {
    if (!options || !isCallSampled(options) || isReportingDisabled()) {
        return s;
    }
    if (isBrowserIncompatibleWithSanitizing()) {
        // Avoid sanitization for browsers that are incompatible with the sanitizer
        // so that this function never crashes.
        return s;
    }
    maybeSendHeartbeat(options);
    /** @type {boolean} */
    const changedBySanitizing = isChangedBySanitizing(s, options);
    if (!changedBySanitizing) {
        // Note: If something gets changed by the sanitizer, it will also
        // inevitably get changed by escaping as the sanitizer will always
        // preserve single text nodes.
        isChangedByEscaping(s, options);
    }
    return s;
}
exports.reportOnlyHtmlPassthrough = reportOnlyHtmlPassthrough;
/**
 * @return {boolean}
 */
function isBrowserIncompatibleWithSanitizing() {
    // Currently the only known incompatibility is cobalt which doesn't support
    // document.createDocumentFragment. See b/28115809. This method of detecting
    // if DocumentFragment is supported is based on
    // google3/chrome/dongle/web_framework/app_cobalt/polyfills/document_fragment.ts?rcl=482322361
    // TODO(b/255336776): Remove this once the sanitizer is able to run on Cobalt
    return !('DocumentFragment' in window);
}
/**
 * @param {!ReportingOptions} options
 * @return {boolean}
 */
function isCallSampled(options) {
    return (Math.random() <
        (options.samplingRate ??
            REPORTING_ID_PREFIX_TO_SAMPLING_RATE[options.reportingId[0]] ??
            0.0));
}
/**
 * @return {boolean}
 */
function isReportingDisabled() {
    // Note that if it is undefined, then that means reporting should be enabled
    return window['SAFEVALUES_REPORTING'] === false;
}
/**
 * @param {!ReportingOptions} options
 * @return {void}
 */
function maybeSendHeartbeat(options) {
    if (Math.random() <
        (options.heartbeatRate ??
            REPORTING_ID_PREFIX_TO_HEARTBEAT_RATE[options.reportingId[0]] ??
            0.0)) {
        // Report a heartbeat signifying that the legacy conversion is being called
        reportLegacyConversion(options, ReportingType.HEARTBEAT);
    }
}
/**
 * @param {string} s
 * @param {!ReportingOptions} options
 * @return {boolean}
 */
function isChangedByEscaping(s, options) {
    if ((0, html_builders_1.htmlEscape)(s).toString() !== s) {
        // The legacy conversion is being used with something other than plain
        // text
        reportLegacyConversion(options, ReportingType.HTML_CHANGED_BY_ESCAPING);
        return true;
    }
    return false;
}
/**
 * @param {string} s
 * @param {!ReportingOptions} options
 * @return {boolean}
 */
function isChangedBySanitizing(s, options) {
    // First try checking if it is changed by the super lenient sanitizer. If it
    // is changed by the super lenient sanitizer, report that and return true.
    try {
        (0, html_sanitizer_1.superLenientlySanitizeHtmlAssertUnchanged)(s);
        // Continue
    }
    catch (e) {
        // A regex that matches corp domains to ensure that we only record
        // additional data if the request is in dev mode AND is an internal request
        // from a Googler. External facing domains should never be added to this
        // list.
        /** @type {!RegExp} */
        const corpRe = /([.]corp[.]google[.]com|[.]proxy[.]googleprod[.]com|[.]googlers[.]com)$/;
        if (dev_1.DEV_MODE &&
            corpRe.test(window.location.hostname) &&
            e instanceof Error) {
            reportLegacyConversion(options, ReportingType.HTML_CHANGED_BY_SUPER_LENIENT_SANITIZING, (/** @type {!Error} */ (e)).message);
        }
        else {
            reportLegacyConversion(options, ReportingType.HTML_CHANGED_BY_SUPER_LENIENT_SANITIZING);
        }
        return true;
    }
    // If it isn't changed by the super lenient sanitizer, fall back to the
    // relaxed sanitizer.
    try {
        (0, html_sanitizer_1.lenientlySanitizeHtmlAssertUnchanged)(s);
        // Continue
    }
    catch {
        reportLegacyConversion(options, ReportingType.HTML_CHANGED_BY_RELAXED_SANITIZING);
        return true;
    }
    // If it isn't changed by the relaxed sanitizer, see if it is changed by the
    // strict sanitizer. If possible we'd rather migrate legacy conversions to the
    // strict sanitizer.
    try {
        (0, html_sanitizer_1.sanitizeHtmlAssertUnchanged)(s);
        // Continue
    }
    catch {
        reportLegacyConversion(options, ReportingType.HTML_CHANGED_BY_SANITIZING);
        return true;
    }
    // It wasn't changed by either sanitizer
    return false;
}
/**
 * The type of the report
 * @enum {string}
 */
const ReportingType = {
    // The type if the report signifies just that the legacy conversion was
    // called.
    HEARTBEAT: "HEARTBEAT",
    // The type if the report signifies that the legacy conversion code crashed.
    CRASHED: "CRASHED",
    // The type if the report signifies that escaping the input changed it.
    HTML_CHANGED_BY_ESCAPING: "H_ESCAPE",
    // The type if the report signifies that sanitizing the input with the strict
    // sanitizer changed it.
    HTML_CHANGED_BY_SANITIZING: "H_SANITIZE",
    // The type if the report signifies that sanitizing the input with the relaxed
    // sanitizer changed it.
    HTML_CHANGED_BY_RELAXED_SANITIZING: "H_RSANITIZE",
    // The type if the report signifies that sanitizing the input with the super
    // lenient sanitizer changed it.
    HTML_CHANGED_BY_SUPER_LENIENT_SANITIZING: "H_SLSANITIZE",
};
/**
 * @param {!ReportingOptions} options
 * @param {!ReportingType} type
 * @param {(undefined|string)=} additionalData
 * @return {void}
 */
function reportLegacyConversion(options, type, additionalData) {
    /** @type {?} */
    let sendReport = undefined;
    if (exports.TEST_ONLY.sendReport) {
        sendReport = exports.TEST_ONLY.sendReport;
    }
    else if (typeof window !== 'undefined' &&
        window.navigator &&
        window.navigator.sendBeacon !== undefined) {
        sendReport = navigator.sendBeacon.bind(navigator);
    }
    else {
        sendReport = sendBeaconPolyfill;
    }
    /** @type {!ReportingPayload} */
    const payload = {
        'host': window.location.hostname,
        'type': type,
        'additionalData': additionalData,
    };
    sendReport('https://csp.withgoogle.com/csp/lcreport/' + options.reportingId, JSON.stringify(payload));
}
/**
 * A very naive polyfill for navigator.sendBeacon for browsers that don't
 * support navigator.sendBeacon.
 * @param {string} url
 * @param {string} body
 * @return {void}
 */
function sendBeaconPolyfill(url, body) {
    /** @type {!XMLHttpRequest} */
    const req = new XMLHttpRequest();
    req.open('POST', url);
    req.setRequestHeader('Content-Type', 'application/json');
    req.send(body);
}
/**
 * @record
 */
function TestOnlyOptions() { }
/* istanbul ignore if */
if (false) {
    /**
     * @type {(undefined|function(string, string): void)}
     * @public
     */
    TestOnlyOptions.prototype.sendReport;
    /**
     * @type {function(): void}
     * @public
     */
    TestOnlyOptions.prototype.reset;
}
/** @type {!TestOnlyOptions} */
exports.TEST_ONLY = {
    reset: (/**
     * @return {void}
     */
    () => {
        exports.TEST_ONLY.sendReport = undefined;
    }),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVwb3J0aW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGhpcmRfcGFydHkvamF2YXNjcmlwdC9zYWZldmFsdWVzL3JlcG9ydGluZy9yZXBvcnRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx5R0FBcUQ7QUFDckQsMEhBSW1EO0FBQ25ELHdGQUE0Qzs7Ozs7Ozs7O01BZXRDLG9DQUFvQyxHQUE4QjtJQUN0RSxHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0NBQ1Q7Ozs7Ozs7Ozs7OztNQVlLLHFDQUFxQyxHQUE4QjtJQUN2RSxHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0NBQ1Q7Ozs7O0FBS0QsK0JBdUNDOzs7Ozs7Ozs7Ozs7Ozs7O0lBNUJDLHVDQUFvQjs7Ozs7Ozs7OztJQVNwQix3Q0FBc0I7Ozs7Ozs7Ozs7SUFTdEIseUNBQXVCOzs7Ozs7Ozs7O0lBU3ZCLHNDQUFpRDs7Ozs7Ozs7Ozs7OztBQVduRCxTQUFnQix5QkFBeUIsQ0FDdkMsQ0FBUyxFQUNULE9BQTBCO0lBRTFCLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksbUJBQW1CLEVBQUUsRUFBRSxDQUFDO1FBQ2pFLE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUNELElBQUksbUNBQW1DLEVBQUUsRUFBRSxDQUFDO1FBQzFDLDJFQUEyRTtRQUMzRSx1Q0FBdUM7UUFDdkMsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0Qsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7O1VBQ3RCLG1CQUFtQixHQUFHLHFCQUFxQixDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7SUFDN0QsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7Ozs7UUFJekIsbUJBQW1CLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lB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Y0FBYyxFQUFFO0lBQ2hDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUN6RCxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pCLENBQUM7Ozs7QUFFRCw4QkFHQzs7Ozs7OztJQUZDLHFDQUFpRDs7Ozs7SUFDakQsZ0NBQWtCOzs7QUFFUCxRQUFBLFNBQVMsR0FBb0I7SUFDeEMsS0FBSzs7O0lBQUUsR0FBRyxFQUFFO1FBQ1YsaUJBQVMsQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO0lBQ25DLENBQUMsQ0FBQTtDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQge2h0bWxFc2NhcGV9IGZyb20gJy4uL2J1aWxkZXJzL2h0bWxfYnVpbGRlcnMnO1xuaW1wb3J0IHtcbiAgbGVuaWVudGx5U2FuaXRpemVIdG1sQXNzZXJ0VW5jaGFuZ2VkLFxuICBzYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQsXG4gIHN1cGVyTGVuaWVudGx5U2FuaXRpemVIdG1sQXNzZXJ0VW5jaGFuZ2VkLFxufSBmcm9tICcuLi9idWlsZGVycy9odG1sX3Nhbml0aXplci9odG1sX3Nhbml0aXplcic7XG5pbXBvcnQge0RFVl9NT0RFfSBmcm9tICcuLi9lbnZpcm9ubWVudC9kZXYnO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBTQUZFVkFMVUVTX1JFUE9SVElORz86IGJvb2xlYW47XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB7QGxpbmsgbGVnYWN5VW5zYWZlSHRtbH0gaXMgYmVpbmcgdXNlZCB3aXRoIGFcbiAqIGByZXBvcnRpbmdJZGAgdG8gZW5hYmxlIHJlcG9ydGluZywgdGhlIHBlcmNlbnRhZ2Ugb2Ygc2FtcGxlZCBjYWxscyB0aGF0XG4gKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGFjdGl2ZSBjb250ZW50LiBUaGUga2V5IGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gKiBgcmVwb3J0aW5nSWRgIGFuZCB0aGUgZmxvYXQgaXMgdGhlIHByb3BvcnRpb24gb2YgcmVxdWVzdHMgKGluIHRoZSByYW5nZVxuICogMC4wLTEuMCkuXG4gKi9cbmNvbnN0IFJFUE9SVElOR19JRF9QUkVGSVhfVE9fU0FNUExJTkdfUkFURToge1tpbmRleDogc3RyaW5nXTogbnVtYmVyfSA9IHtcbiAgJzAnOiAxLjAsXG4gICcxJzogMS4wLFxufTtcblxuLyoqXG4gKiBJZiB7QGxpbmsgbGVnYWN5VW5zYWZlSHRtbH0gaXMgYmVpbmcgdXNlZCB3aXRoIGFcbiAqIGByZXBvcnRpbmdJZGAgdG8gZW5hYmxlIHJlcG9ydGluZywgdGhlIHBlcmNlbnRhZ2Ugb2Ygc2FtcGxlZCBjYWxscyB0aGF0XG4gKiB3aWxsIHRyaWdnZXIgYSBoZWFydGJlYXQgcmVwb3J0IHRvIG5vdGlmeSB1cyB0aGF0IHRoZSBmdW5jdGlvbiBpcyBiZWluZ1xuICogY2FsbGVkLiBUaGUga2V5IGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGByZXBvcnRpbmdJZGAgYW5kIHRoZSBmbG9hdFxuICogaXMgdGhlIHByb3BvcnRpb24gb2YgcmVxdWVzdHMgKGluIHRoZSByYW5nZSAwLjAtMS4wKS5cbiAqXG4gKiBOb3RlOiBUaGlzIG1lYW5zIHRoYXQgZWZmZWN0aXZlbHkgc2FtcGxpbmdSYXRlKmhlYXJ0YmVhdFJhdGUgY2FsbHMgd2lsbCBzZW5kXG4gKiBhIGhlYXJ0YmVhdC5cbiAqL1xuY29uc3QgUkVQT1JUSU5HX0lEX1BSRUZJWF9UT19IRUFSVEJFQVRfUkFURToge1tpbmRleDogc3RyaW5nXTogbnVtYmVyfSA9IHtcbiAgJzAnOiAwLjEsXG4gICcxJzogMC4xLFxufTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25maWd1cmluZyByZXBvcnRpbmcgdXNlZCBmb3Ige0BsaW5rIGxlZ2FjeVVuc2FmZUh0bWx9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlcG9ydGluZ09wdGlvbnMge1xuICAvKipcbiAgICogQSB1bmlxdWUgSUQgdGhhdCBpZGVudGlmaWVzIHRoZSBjYWxsc2l0ZSBvZiBhIHNwZWNpZmljIGxlZ2FjeSBjb252ZXJzaW9uLlxuICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBsZWdhY3kgY29udmVyc2lvbiBiZWNvbWVzIGEgcmVwb3J0LW9ubHkgbGVnYWN5XG4gICAqIGNvbnZlcnNpb24gdGhhdCBsb2dzIHdoZXRoZXIgdGhlIGNhbGxzaXRlIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBzYWZlclxuICAgKiBhbHRlcm5hdGl2ZSB0byB0aGUgZ28vc2VjdXJpdHktY29sbGVjdG9yLiBTZWVcbiAgICogZ28vcmVwb3J0LW9ubHktc2FmZWh0bWwtbGVnYWN5LWV4ZW1wdGlvbnMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGRlc2lnblxuICAgKiBhbmQgcHJvamVjdC5cbiAgICpcbiAgICogVGhpcyBpcyBzZXQgdmlhIExTQyBhbmQgc2hvdWxkIG5vdCBiZSBtYW51YWxseSBjaGFuZ2VkLlxuICAgKi9cbiAgcmVwb3J0aW5nSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcnJpZGUge0BsaW5rIERFRkFVTFRfU0FNUExJTkdfUkFURX0gZm9yIHRoaXMgc3BlY2lmaWNcbiAgICogbGVnYWN5IGNvbnZlcnNpb24uIEl0IGlzIGdlbmVyYWxseSBub3QgbmVjZXNzYXJ5IHRvIHVzZSB0aGlzIG92ZXJyaWRlXG4gICAqIHVubGVzcyB0aGlzIGxlZ2FjeSBjb252ZXJzaW9uIGlzIHRyaWdnZXJpbmcgYSBtYXNzaXZlIG51bWJlciBvZiByZXBvcnRzIGFuZFxuICAgKiBpdCBpcyBuZWNlc3NhcnkgdG8gZGVjcmVhc2UgdGhlIHNhbXBsaW5nIHJhdGUgdG8gZGVjcmVhc2UgdGhlIG51bWJlciBvZlxuICAgKiByZXBvcnRzLlxuICAgKi9cbiAgc2FtcGxpbmdSYXRlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB7QGxpbmsgREVGQVVMVF9IRUFSVEJFQVRfUkFURX0gZm9yIHRoaXMgc3BlY2lmaWNcbiAgICogbGVnYWN5IGNvbnZlcnNpb24uIEl0IGlzIGdlbmVyYWxseSBub3QgbmVjZXNzYXJ5IHRvIHVzZSB0aGlzIG92ZXJyaWRlXG4gICAqIHVubGVzcyB0aGlzIGxlZ2FjeSBjb252ZXJzaW9uIGlzIHRyaWdnZXJpbmcgYSBtYXNzaXZlIG51bWJlciBvZiByZXBvcnRzIGFuZFxuICAgKiBpdCBpcyBuZWNlc3NhcnkgdG8gZGVjcmVhc2UgdGhlIHNhbXBsaW5nIHJhdGUgdG8gZGVjcmVhc2UgdGhlIG51bWJlciBvZlxuICAgKiByZXBvcnRzLlxuICAgKi9cbiAgaGVhcnRiZWF0UmF0ZT86IG51bWJlcjtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgZm9yIGhvdyByZXBvcnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxlZ2FjeSBjb252ZXJzaW9uIHdpbGwgYmVcbiAgICogc2VudCB0byB0aGUgZ28vc2VjdXJpdHktY29sbGVjdG9yLiBJdCBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSB0byB1c2VcbiAgICogdGhpcyBvdmVycmlkZSB1bmxlc3MgYSBjYWxsZXIgbmVlZHMgdG8gY2hhbmdlIGhvdyByZXBvcnRzIGFyZSBjb2xsZWN0ZWRcbiAgICogKGUuZy4gY2hvb3NpbmcgdG8gY29sbGVjdCB0aGVtIHZpYSBhIHNlcnZpY2UncyBvd24gY29sbGVjdGlvblxuICAgKiBpbmZyYXN0cnVjdHVyZSkuXG4gICAqL1xuICBzZW5kUmVwb3J0PzogKHVybDogc3RyaW5nLCBkYXRhOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUGFzc2VzIHRocm91Z2ggdGhlIGdpdmVuIEhUTUwgc3RyaW5nIHVuY2hhbmdlZCwgYnV0IGxvZ3MgbWV0YWRhdGEgYWJvdXRcbiAqIHdoZXRoZXIgdmFyaW91cyB0cmFuc2Zvcm1hdGlvbnMgd291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBpbnB1dCB0byB0aGUgc2VjdXJpdHlcbiAqIGNvbGxlY3Rvci5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBwdXJwb3NlZnVsbHkgZG9lcyBub3QgcmV0dXJuIGEgU2FmZUh0bWwgYW5kIGlzIG1lYW50IHRvIGJlXG4gKiB1c2VkIGluIHNjZW5hcmlvcyB3aGVyZSB3ZSBkbyBub3Qgd2FudCB0byBpbnRyb2R1Y2UgYSBsZWdhY3kgY29udmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE9ubHlIdG1sUGFzc3Rocm91Z2goXG4gIHM6IHN0cmluZyxcbiAgb3B0aW9ucz86IFJlcG9ydGluZ09wdGlvbnMsXG4pOiBzdHJpbmcge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzQ2FsbFNhbXBsZWQob3B0aW9ucykgfHwgaXNSZXBvcnRpbmdEaXNhYmxlZCgpKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgaWYgKGlzQnJvd3NlckluY29tcGF0aWJsZVdpdGhTYW5pdGl6aW5nKCkpIHtcbiAgICAvLyBBdm9pZCBzYW5pdGl6YXRpb24gZm9yIGJyb3dzZXJzIHRoYXQgYXJlIGluY29tcGF0aWJsZSB3aXRoIHRoZSBzYW5pdGl6ZXJcbiAgICAvLyBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gbmV2ZXIgY3Jhc2hlcy5cbiAgICByZXR1cm4gcztcbiAgfVxuICBtYXliZVNlbmRIZWFydGJlYXQob3B0aW9ucyk7XG4gIGNvbnN0IGNoYW5nZWRCeVNhbml0aXppbmcgPSBpc0NoYW5nZWRCeVNhbml0aXppbmcocywgb3B0aW9ucyk7XG4gIGlmICghY2hhbmdlZEJ5U2FuaXRpemluZykge1xuICAgIC8vIE5vdGU6IElmIHNvbWV0aGluZyBnZXRzIGNoYW5nZWQgYnkgdGhlIHNhbml0aXplciwgaXQgd2lsbCBhbHNvXG4gICAgLy8gaW5ldml0YWJseSBnZXQgY2hhbmdlZCBieSBlc2NhcGluZyBhcyB0aGUgc2FuaXRpemVyIHdpbGwgYWx3YXlzXG4gICAgLy8gcHJlc2VydmUgc2luZ2xlIHRleHQgbm9kZXMuXG4gICAgaXNDaGFuZ2VkQnlFc2NhcGluZyhzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gaXNCcm93c2VySW5jb21wYXRpYmxlV2l0aFNhbml0aXppbmcoKTogYm9vbGVhbiB7XG4gIC8vIEN1cnJlbnRseSB0aGUgb25seSBrbm93biBpbmNvbXBhdGliaWxpdHkgaXMgY29iYWx0IHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxuICAvLyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50LiBTZWUgYi8yODExNTgwOS4gVGhpcyBtZXRob2Qgb2YgZGV0ZWN0aW5nXG4gIC8vIGlmIERvY3VtZW50RnJhZ21lbnQgaXMgc3VwcG9ydGVkIGlzIGJhc2VkIG9uXG4gIC8vIGdvb2dsZTMvY2hyb21lL2RvbmdsZS93ZWJfZnJhbWV3b3JrL2FwcF9jb2JhbHQvcG9seWZpbGxzL2RvY3VtZW50X2ZyYWdtZW50LnRzP3JjbD00ODIzMjIzNjFcbiAgLy8gVE9ETyhiLzI1NTMzNjc3Nik6IFJlbW92ZSB0aGlzIG9uY2UgdGhlIHNhbml0aXplciBpcyBhYmxlIHRvIHJ1biBvbiBDb2JhbHRcbiAgcmV0dXJuICEoJ0RvY3VtZW50RnJhZ21lbnQnIGluIHdpbmRvdyk7XG59XG5cbmZ1bmN0aW9uIGlzQ2FsbFNhbXBsZWQob3B0aW9uczogUmVwb3J0aW5nT3B0aW9ucyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIE1hdGgucmFuZG9tKCkgPFxuICAgIChvcHRpb25zLnNhbXBsaW5nUmF0ZSA/P1xuICAgICAgUkVQT1JUSU5HX0lEX1BSRUZJWF9UT19TQU1QTElOR19SQVRFW29wdGlvbnMucmVwb3J0aW5nSWRbMF1dID8/XG4gICAgICAwLjApXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVwb3J0aW5nRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gIC8vIE5vdGUgdGhhdCBpZiBpdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhhdCBtZWFucyByZXBvcnRpbmcgc2hvdWxkIGJlIGVuYWJsZWRcbiAgcmV0dXJuIHdpbmRvd1snU0FGRVZBTFVFU19SRVBPUlRJTkcnXSA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1heWJlU2VuZEhlYXJ0YmVhdChvcHRpb25zOiBSZXBvcnRpbmdPcHRpb25zKSB7XG4gIGlmIChcbiAgICBNYXRoLnJhbmRvbSgpIDxcbiAgICAob3B0aW9ucy5oZWFydGJlYXRSYXRlID8/XG4gICAgICBSRVBPUlRJTkdfSURfUFJFRklYX1RPX0hFQVJUQkVBVF9SQVRFW29wdGlvbnMucmVwb3J0aW5nSWRbMF1dID8/XG4gICAgICAwLjApXG4gICkge1xuICAgIC8vIFJlcG9ydCBhIGhlYXJ0YmVhdCBzaWduaWZ5aW5nIHRoYXQgdGhlIGxlZ2FjeSBjb252ZXJzaW9uIGlzIGJlaW5nIGNhbGxlZFxuICAgIHJlcG9ydExlZ2FjeUNvbnZlcnNpb24ob3B0aW9ucywgUmVwb3J0aW5nVHlwZS5IRUFSVEJFQVQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hhbmdlZEJ5RXNjYXBpbmcoczogc3RyaW5nLCBvcHRpb25zOiBSZXBvcnRpbmdPcHRpb25zKTogYm9vbGVhbiB7XG4gIGlmIChodG1sRXNjYXBlKHMpLnRvU3RyaW5nKCkgIT09IHMpIHtcbiAgICAvLyBUaGUgbGVnYWN5IGNvbnZlcnNpb24gaXMgYmVpbmcgdXNlZCB3aXRoIHNvbWV0aGluZyBvdGhlciB0aGFuIHBsYWluXG4gICAgLy8gdGV4dFxuICAgIHJlcG9ydExlZ2FjeUNvbnZlcnNpb24ob3B0aW9ucywgUmVwb3J0aW5nVHlwZS5IVE1MX0NIQU5HRURfQllfRVNDQVBJTkcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDaGFuZ2VkQnlTYW5pdGl6aW5nKHM6IHN0cmluZywgb3B0aW9uczogUmVwb3J0aW5nT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAvLyBGaXJzdCB0cnkgY2hlY2tpbmcgaWYgaXQgaXMgY2hhbmdlZCBieSB0aGUgc3VwZXIgbGVuaWVudCBzYW5pdGl6ZXIuIElmIGl0XG4gIC8vIGlzIGNoYW5nZWQgYnkgdGhlIHN1cGVyIGxlbmllbnQgc2FuaXRpemVyLCByZXBvcnQgdGhhdCBhbmQgcmV0dXJuIHRydWUuXG4gIHRyeSB7XG4gICAgc3VwZXJMZW5pZW50bHlTYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQocyk7XG4gICAgLy8gQ29udGludWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEEgcmVnZXggdGhhdCBtYXRjaGVzIGNvcnAgZG9tYWlucyB0byBlbnN1cmUgdGhhdCB3ZSBvbmx5IHJlY29yZFxuICAgIC8vIGFkZGl0aW9uYWwgZGF0YSBpZiB0aGUgcmVxdWVzdCBpcyBpbiBkZXYgbW9kZSBBTkQgaXMgYW4gaW50ZXJuYWwgcmVxdWVzdFxuICAgIC8vIGZyb20gYSBHb29nbGVyLiBFeHRlcm5hbCBmYWNpbmcgZG9tYWlucyBzaG91bGQgbmV2ZXIgYmUgYWRkZWQgdG8gdGhpc1xuICAgIC8vIGxpc3QuXG4gICAgY29uc3QgY29ycFJlID1cbiAgICAgIC8oWy5dY29ycFsuXWdvb2dsZVsuXWNvbXxbLl1wcm94eVsuXWdvb2dsZXByb2RbLl1jb218Wy5dZ29vZ2xlcnNbLl1jb20pJC87XG4gICAgaWYgKFxuICAgICAgREVWX01PREUgJiZcbiAgICAgIGNvcnBSZS50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkgJiZcbiAgICAgIGUgaW5zdGFuY2VvZiBFcnJvclxuICAgICkge1xuICAgICAgcmVwb3J0TGVnYWN5Q29udmVyc2lvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgUmVwb3J0aW5nVHlwZS5IVE1MX0NIQU5HRURfQllfU1VQRVJfTEVOSUVOVF9TQU5JVElaSU5HLFxuICAgICAgICBlLm1lc3NhZ2UsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnRMZWdhY3lDb252ZXJzaW9uKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBSZXBvcnRpbmdUeXBlLkhUTUxfQ0hBTkdFRF9CWV9TVVBFUl9MRU5JRU5UX1NBTklUSVpJTkcsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIGl0IGlzbid0IGNoYW5nZWQgYnkgdGhlIHN1cGVyIGxlbmllbnQgc2FuaXRpemVyLCBmYWxsIGJhY2sgdG8gdGhlXG4gIC8vIHJlbGF4ZWQgc2FuaXRpemVyLlxuICB0cnkge1xuICAgIGxlbmllbnRseVNhbml0aXplSHRtbEFzc2VydFVuY2hhbmdlZChzKTtcbiAgICAvLyBDb250aW51ZVxuICB9IGNhdGNoIHtcbiAgICByZXBvcnRMZWdhY3lDb252ZXJzaW9uKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIFJlcG9ydGluZ1R5cGUuSFRNTF9DSEFOR0VEX0JZX1JFTEFYRURfU0FOSVRJWklORyxcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgaXQgaXNuJ3QgY2hhbmdlZCBieSB0aGUgcmVsYXhlZCBzYW5pdGl6ZXIsIHNlZSBpZiBpdCBpcyBjaGFuZ2VkIGJ5IHRoZVxuICAvLyBzdHJpY3Qgc2FuaXRpemVyLiBJZiBwb3NzaWJsZSB3ZSdkIHJhdGhlciBtaWdyYXRlIGxlZ2FjeSBjb252ZXJzaW9ucyB0byB0aGVcbiAgLy8gc3RyaWN0IHNhbml0aXplci5cbiAgdHJ5IHtcbiAgICBzYW5pdGl6ZUh0bWxBc3NlcnRVbmNoYW5nZWQocyk7XG4gICAgLy8gQ29udGludWVcbiAgfSBjYXRjaCB7XG4gICAgcmVwb3J0TGVnYWN5Q29udmVyc2lvbihvcHRpb25zLCBSZXBvcnRpbmdUeXBlLkhUTUxfQ0hBTkdFRF9CWV9TQU5JVElaSU5HKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEl0IHdhc24ndCBjaGFuZ2VkIGJ5IGVpdGhlciBzYW5pdGl6ZXJcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSByZXBvcnRcbiAqL1xuZW51bSBSZXBvcnRpbmdUeXBlIHtcbiAgLy8gVGhlIHR5cGUgaWYgdGhlIHJlcG9ydCBzaWduaWZpZXMganVzdCB0aGF0IHRoZSBsZWdhY3kgY29udmVyc2lvbiB3YXNcbiAgLy8gY2FsbGVkLlxuICBIRUFSVEJFQVQgPSAnSEVBUlRCRUFUJyxcblxuICAvLyBUaGUgdHlwZSBpZiB0aGUgcmVwb3J0IHNpZ25pZmllcyB0aGF0IHRoZSBsZWdhY3kgY29udmVyc2lvbiBjb2RlIGNyYXNoZWQuXG4gIENSQVNIRUQgPSAnQ1JBU0hFRCcsXG5cbiAgLy8gVGhlIHR5cGUgaWYgdGhlIHJlcG9ydCBzaWduaWZpZXMgdGhhdCBlc2NhcGluZyB0aGUgaW5wdXQgY2hhbmdlZCBpdC5cbiAgSFRNTF9DSEFOR0VEX0JZX0VTQ0FQSU5HID0gJ0hfRVNDQVBFJyxcblxuICAvLyBUaGUgdHlwZSBpZiB0aGUgcmVwb3J0IHNpZ25pZmllcyB0aGF0IHNhbml0aXppbmcgdGhlIGlucHV0IHdpdGggdGhlIHN0cmljdFxuICAvLyBzYW5pdGl6ZXIgY2hhbmdlZCBpdC5cbiAgSFRNTF9DSEFOR0VEX0JZX1NBTklUSVpJTkcgPSAnSF9TQU5JVElaRScsXG5cbiAgLy8gVGhlIHR5cGUgaWYgdGhlIHJlcG9ydCBzaWduaWZpZXMgdGhhdCBzYW5pdGl6aW5nIHRoZSBpbnB1dCB3aXRoIHRoZSByZWxheGVkXG4gIC8vIHNhbml0aXplciBjaGFuZ2VkIGl0LlxuICBIVE1MX0NIQU5HRURfQllfUkVMQVhFRF9TQU5JVElaSU5HID0gJ0hfUlNBTklUSVpFJyxcblxuICAvLyBUaGUgdHlwZSBpZiB0aGUgcmVwb3J0IHNpZ25pZmllcyB0aGF0IHNhbml0aXppbmcgdGhlIGlucHV0IHdpdGggdGhlIHN1cGVyXG4gIC8vIGxlbmllbnQgc2FuaXRpemVyIGNoYW5nZWQgaXQuXG4gIEhUTUxfQ0hBTkdFRF9CWV9TVVBFUl9MRU5JRU5UX1NBTklUSVpJTkcgPSAnSF9TTFNBTklUSVpFJyxcbn1cblxuZGVjbGFyZSBpbnRlcmZhY2UgUmVwb3J0aW5nUGF5bG9hZCB7XG4gIGhvc3Q6IHN0cmluZztcbiAgdHlwZTogUmVwb3J0aW5nVHlwZTtcbiAgYWRkaXRpb25hbERhdGE/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHJlcG9ydExlZ2FjeUNvbnZlcnNpb24oXG4gIG9wdGlvbnM6IFJlcG9ydGluZ09wdGlvbnMsXG4gIHR5cGU6IFJlcG9ydGluZ1R5cGUsXG4gIGFkZGl0aW9uYWxEYXRhPzogc3RyaW5nLFxuKSB7XG4gIGxldCBzZW5kUmVwb3J0ID0gdW5kZWZpbmVkO1xuICBpZiAoVEVTVF9PTkxZLnNlbmRSZXBvcnQpIHtcbiAgICBzZW5kUmVwb3J0ID0gVEVTVF9PTkxZLnNlbmRSZXBvcnQ7XG4gIH0gZWxzZSBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgd2luZG93Lm5hdmlnYXRvci5zZW5kQmVhY29uICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgc2VuZFJlcG9ydCA9IG5hdmlnYXRvci5zZW5kQmVhY29uLmJpbmQobmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBzZW5kUmVwb3J0ID0gc2VuZEJlYWNvblBvbHlmaWxsO1xuICB9XG4gIGNvbnN0IHBheWxvYWQ6IFJlcG9ydGluZ1BheWxvYWQgPSB7XG4gICAgJ2hvc3QnOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgJ3R5cGUnOiB0eXBlLFxuICAgICdhZGRpdGlvbmFsRGF0YSc6IGFkZGl0aW9uYWxEYXRhLFxuICB9O1xuICBzZW5kUmVwb3J0KFxuICAgICdodHRwczovL2NzcC53aXRoZ29vZ2xlLmNvbS9jc3AvbGNyZXBvcnQvJyArIG9wdGlvbnMucmVwb3J0aW5nSWQsXG4gICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICk7XG59XG5cbi8qKlxuICogQSB2ZXJ5IG5haXZlIHBvbHlmaWxsIGZvciBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBuYXZpZ2F0b3Iuc2VuZEJlYWNvbi5cbiAqL1xuZnVuY3Rpb24gc2VuZEJlYWNvblBvbHlmaWxsKHVybDogc3RyaW5nLCBib2R5OiBzdHJpbmcpIHtcbiAgY29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vcGVuKCdQT1NUJywgdXJsKTtcbiAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIHJlcS5zZW5kKGJvZHkpO1xufVxuXG5pbnRlcmZhY2UgVGVzdE9ubHlPcHRpb25zIHtcbiAgc2VuZFJlcG9ydD86ICh1cmw6IHN0cmluZywgYm9keTogc3RyaW5nKSA9PiB2b2lkO1xuICByZXNldDogKCkgPT4gdm9pZDtcbn1cbmV4cG9ydCBjb25zdCBURVNUX09OTFk6IFRlc3RPbmx5T3B0aW9ucyA9IHtcbiAgcmVzZXQ6ICgpID0+IHtcbiAgICBURVNUX09OTFkuc2VuZFJlcG9ydCA9IHVuZGVmaW5lZDtcbiAgfSxcbn07XG4iXX0=
;return exports;});

//third_party/javascript/safevalues/index.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview added by tsickle
 * Generated from: third_party/javascript/safevalues/index.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.third_party.javascript.safevalues.index');
var module = module || { id: 'third_party/javascript/safevalues/index.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_attribute_builders_1 = goog.requireType("google3.third_party.javascript.safevalues.builders.attribute_builders");
const tsickle_document_fragment_builders_2 = goog.requireType("google3.third_party.javascript.safevalues.builders.document_fragment_builders");
const tsickle_html_builders_3 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_builders");
const tsickle_html_formatter_4 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_formatter");
const tsickle_html_sanitizer_5 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer");
const tsickle_html_sanitizer_builder_6 = goog.requireType("google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer_builder");
const tsickle_resource_url_builders_7 = goog.requireType("google3.third_party.javascript.safevalues.builders.resource_url_builders");
const tsickle_script_builders_8 = goog.requireType("google3.third_party.javascript.safevalues.builders.script_builders");
const tsickle_style_builders_9 = goog.requireType("google3.third_party.javascript.safevalues.builders.style_builders");
const tsickle_style_sheet_builders_10 = goog.requireType("google3.third_party.javascript.safevalues.builders.style_sheet_builders");
const tsickle_url_builders_11 = goog.requireType("google3.third_party.javascript.safevalues.builders.url_builders");
const tsickle_attribute_impl_12 = goog.requireType("google3.third_party.javascript.safevalues.internals.attribute_impl");
const tsickle_html_impl_13 = goog.requireType("google3.third_party.javascript.safevalues.internals.html_impl");
const tsickle_resource_url_impl_14 = goog.requireType("google3.third_party.javascript.safevalues.internals.resource_url_impl");
const tsickle_script_impl_15 = goog.requireType("google3.third_party.javascript.safevalues.internals.script_impl");
const tsickle_style_impl_16 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_impl");
const tsickle_style_sheet_impl_17 = goog.requireType("google3.third_party.javascript.safevalues.internals.style_sheet_impl");
const tsickle_url_impl_18 = goog.requireType("google3.third_party.javascript.safevalues.internals.url_impl");
const tsickle_reporting_19 = goog.requireType("google3.third_party.javascript.safevalues.reporting.reporting");
/** Safe builders */
const attribute_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.attribute_builders');
exports.safeAttrPrefix = attribute_builders_1.safeAttrPrefix;
const document_fragment_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.document_fragment_builders');
exports.htmlFragment = document_fragment_builders_1.htmlFragment;
exports.htmlToNode = document_fragment_builders_1.htmlToNode;
exports.svgFragment = document_fragment_builders_1.svgFragment;
const html_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_builders');
exports.concatHtmls = html_builders_1.concatHtmls;
exports.createHtml = html_builders_1.createHtml;
exports.doctypeHtml = html_builders_1.doctypeHtml;
exports.htmlEscape = html_builders_1.htmlEscape;
exports.joinHtmls = html_builders_1.joinHtmls;
exports.nodeToHtml = html_builders_1.nodeToHtml;
exports.scriptToHtml = html_builders_1.scriptToHtml;
exports.scriptUrlToHtml = html_builders_1.scriptUrlToHtml;
// BEGIN-INTERNAL
// TODO(b/333544967): Prettier removes the comment on the last line, so we have
// to disable the formatting here.
// prettier-ignore
const html_builders_2 = html_builders_1;
exports.styleSheetToHtml = html_builders_2.styleSheetToHtml;
// END-INTERNAL
const html_formatter_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_formatter'); // LINE-INTERNAL
exports.HtmlFormatter = html_formatter_1.HtmlFormatter;
// LINE-INTERNAL
const html_sanitizer_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer');
exports.sanitizeHtml = html_sanitizer_1.sanitizeHtml;
exports.sanitizeHtmlAssertUnchanged = html_sanitizer_1.sanitizeHtmlAssertUnchanged;
exports.sanitizeHtmlToFragment = html_sanitizer_1.sanitizeHtmlToFragment;
/** @typedef {!tsickle_html_sanitizer_5.HtmlSanitizer} */
exports.HtmlSanitizer; // re-export typedef
const html_sanitizer_builder_1 = goog.require('google3.third_party.javascript.safevalues.builders.html_sanitizer.html_sanitizer_builder');
exports.HtmlSanitizerBuilder = html_sanitizer_builder_1.HtmlSanitizerBuilder;
const resource_url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.resource_url_builders');
exports.appendParams = resource_url_builders_1.appendParams;
exports.appendPathSegment = resource_url_builders_1.appendPathSegment;
exports.objectUrlFromScript = resource_url_builders_1.objectUrlFromScript;
exports.replaceFragment = resource_url_builders_1.replaceFragment;
exports.toAbsoluteResourceUrl = resource_url_builders_1.toAbsoluteResourceUrl;
exports.trustedResourceUrl = resource_url_builders_1.trustedResourceUrl;
const script_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.script_builders');
exports.concatScripts = script_builders_1.concatScripts;
exports.safeScript = script_builders_1.safeScript;
exports.safeScriptWithArgs = script_builders_1.safeScriptWithArgs;
exports.valueAsScript = script_builders_1.valueAsScript;
// BEGIN-INTERNAL
const style_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.style_builders');
exports.concatStyles = style_builders_1.concatStyles;
exports.safeStyle = style_builders_1.safeStyle;
exports.styleForMigration = style_builders_1.styleForMigration;
// END-INTERNAL
const style_sheet_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.style_sheet_builders');
exports.concatStyleSheets = style_sheet_builders_1.concatStyleSheets;
exports.safeStyleRule = style_sheet_builders_1.safeStyleRule;
exports.safeStyleSheet = style_sheet_builders_1.safeStyleSheet;
// BEGIN-INTERNAL
const url_builders_1 = goog.require('google3.third_party.javascript.safevalues.builders.url_builders');
exports.SanitizableUrlScheme = url_builders_1.SanitizableUrlScheme;
exports.addJavaScriptUrlSanitizationCallback = url_builders_1.addJavaScriptUrlSanitizationCallback;
exports.fromMediaSource = url_builders_1.fromMediaSource;
exports.fromTrustedResourceUrl = url_builders_1.fromTrustedResourceUrl;
exports.objectUrlFromSafeSource = url_builders_1.objectUrlFromSafeSource;
exports.removeJavaScriptUrlSanitizationCallback = url_builders_1.removeJavaScriptUrlSanitizationCallback;
exports.safeUrl = url_builders_1.safeUrl;
exports.sanitizeUrl = url_builders_1.sanitizeUrl;
exports.trySanitizeUrl = url_builders_1.trySanitizeUrl;
/** @typedef {!tsickle_url_builders_11.Scheme} */
exports.Scheme; // re-export typedef
// END-INTERNAL
/** Types, constants and unwrappers */
const attribute_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.attribute_impl');
exports.SafeAttributePrefix = attribute_impl_1.SafeAttributePrefix;
exports.unwrapAttributePrefix = attribute_impl_1.unwrapAttributePrefix;
const html_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.html_impl');
exports.EMPTY_HTML = html_impl_1.EMPTY_HTML;
exports.SafeHtml = html_impl_1.SafeHtml;
exports.isHtml = html_impl_1.isHtml;
exports.unwrapHtml = html_impl_1.unwrapHtml;
const resource_url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.resource_url_impl');
exports.TrustedResourceUrl = resource_url_impl_1.TrustedResourceUrl;
exports.isResourceUrl = resource_url_impl_1.isResourceUrl;
exports.unwrapResourceUrl = resource_url_impl_1.unwrapResourceUrl;
const script_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.script_impl');
exports.EMPTY_SCRIPT = script_impl_1.EMPTY_SCRIPT;
exports.SafeScript = script_impl_1.SafeScript;
exports.isScript = script_impl_1.isScript;
exports.unwrapScript = script_impl_1.unwrapScript;
// BEGIN-INTERNAL
const style_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_impl');
exports.SafeStyle = style_impl_1.SafeStyle;
exports.isStyle = style_impl_1.isStyle;
exports.unwrapStyle = style_impl_1.unwrapStyle;
// END-INTERNAL
const style_sheet_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.style_sheet_impl');
exports.SafeStyleSheet = style_sheet_impl_1.SafeStyleSheet;
exports.isStyleSheet = style_sheet_impl_1.isStyleSheet;
exports.unwrapStyleSheet = style_sheet_impl_1.unwrapStyleSheet;
// BEGIN-INTERNAL
const url_impl_1 = goog.require('google3.third_party.javascript.safevalues.internals.url_impl');
exports.ABOUT_BLANK = url_impl_1.ABOUT_BLANK;
exports.INNOCUOUS_URL = url_impl_1.INNOCUOUS_URL;
exports.SafeUrl = url_impl_1.SafeUrl;
exports.isUrl = url_impl_1.isUrl;
exports.unwrapUrl = url_impl_1.unwrapUrl;
// END-INTERNAL
const reporting_1 = goog.require('google3.third_party.javascript.safevalues.reporting.reporting'); // LINE-INTERNAL
exports.reportOnlyHtmlPassthrough = reporting_1.reportOnlyHtmlPassthrough;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L3NhZmV2YWx1ZXMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLG1IQUE2RDtBQUFyRCw4Q0FBQSxjQUFjLENBQUE7QUFDdEIsbUlBSStDO0FBSDdDLG9EQUFBLFlBQVksQ0FBQTtBQUNaLGtEQUFBLFVBQVUsQ0FBQTtBQUNWLG1EQUFBLFdBQVcsQ0FBQTtBQUViLHlHQVNrQztBQVJoQyxzQ0FBQSxXQUFXLENBQUE7QUFDWCxxQ0FBQSxVQUFVLENBQUE7QUFDVixzQ0FBQSxXQUFXLENBQUE7QUFDWCxxQ0FBQSxVQUFVLENBQUE7QUFDVixvQ0FBQSxTQUFTLENBQUE7QUFDVCxxQ0FBQSxVQUFVLENBQUE7QUFDVix1Q0FBQSxZQUFZLENBQUE7QUFDWiwwQ0FBQSxlQUFlLENBQUE7Ozs7O0FBT2pCLHdDQUEwRDtBQUFsRCwyQ0FBQSxnQkFBZ0IsQ0FBQTs7QUFHeEIsMkdBQXdELENBQUMsZ0JBQWdCO0FBQWpFLHlDQUFBLGFBQWEsQ0FBQTs7QUFDckIsMEhBS2tEO0FBSmhELHdDQUFBLFlBQVksQ0FBQTtBQUNaLHVEQUFBLDJCQUEyQixDQUFBO0FBQzNCLGtEQUFBLHNCQUFzQixDQUFBOzs7QUFHeEIsMElBQXNGO0FBQTlFLHdEQUFBLG9CQUFvQixDQUFBO0FBQzVCLHlIQU8wQztBQU54QywrQ0FBQSxZQUFZLENBQUE7QUFDWixvREFBQSxpQkFBaUIsQ0FBQTtBQUNqQixzREFBQSxtQkFBbUIsQ0FBQTtBQUNuQixrREFBQSxlQUFlLENBQUE7QUFDZix3REFBQSxxQkFBcUIsQ0FBQTtBQUNyQixxREFBQSxrQkFBa0IsQ0FBQTtBQUVwQiw2R0FLb0M7QUFKbEMsMENBQUEsYUFBYSxDQUFBO0FBQ2IsdUNBQUEsVUFBVSxDQUFBO0FBQ1YsK0NBQUEsa0JBQWtCLENBQUE7QUFDbEIsMENBQUEsYUFBYSxDQUFBOztBQUdmLDJHQUltQztBQUhqQyx3Q0FBQSxZQUFZLENBQUE7QUFDWixxQ0FBQSxTQUFTLENBQUE7QUFDVCw2Q0FBQSxpQkFBaUIsQ0FBQTs7QUFHbkIsdUhBSXlDO0FBSHZDLG1EQUFBLGlCQUFpQixDQUFBO0FBQ2pCLCtDQUFBLGFBQWEsQ0FBQTtBQUNiLGdEQUFBLGNBQWMsQ0FBQTs7QUFHaEIsdUdBV2lDO0FBVi9CLDhDQUFBLG9CQUFvQixDQUFBO0FBQ3BCLDhEQUFBLG9DQUFvQyxDQUFBO0FBQ3BDLHlDQUFBLGVBQWUsQ0FBQTtBQUNmLGdEQUFBLHNCQUFzQixDQUFBO0FBQ3RCLGlEQUFBLHVCQUF1QixDQUFBO0FBQ3ZCLGlFQUFBLHVDQUF1QyxDQUFBO0FBQ3ZDLGlDQUFBLE9BQU8sQ0FBQTtBQUNQLHFDQUFBLFdBQVcsQ0FBQTtBQUNYLHdDQUFBLGNBQWMsQ0FBQTs7Ozs7QUFLaEIsNEdBR29DO0FBRmxDLCtDQUFBLG1CQUFtQixDQUFBO0FBQ25CLGlEQUFBLHFCQUFxQixDQUFBO0FBRXZCLGtHQUErRTtBQUF2RSxpQ0FBQSxVQUFVLENBQUE7QUFBRSwrQkFBQSxRQUFRLENBQUE7QUFBRSw2QkFBQSxNQUFNLENBQUE7QUFBRSxpQ0FBQSxVQUFVLENBQUE7QUFDaEQsa0hBSXVDO0FBSHJDLGlEQUFBLGtCQUFrQixDQUFBO0FBQ2xCLDRDQUFBLGFBQWEsQ0FBQTtBQUNiLGdEQUFBLGlCQUFpQixDQUFBO0FBRW5CLHNHQUtpQztBQUovQixxQ0FBQSxZQUFZLENBQUE7QUFDWixtQ0FBQSxVQUFVLENBQUE7QUFDVixpQ0FBQSxRQUFRLENBQUE7QUFDUixxQ0FBQSxZQUFZLENBQUE7O0FBR2Qsb0dBQXVFO0FBQS9ELGlDQUFBLFNBQVMsQ0FBQTtBQUFFLCtCQUFBLE9BQU8sQ0FBQTtBQUFFLG1DQUFBLFdBQVcsQ0FBQTs7QUFFdkMsZ0hBSXNDO0FBSHBDLDRDQUFBLGNBQWMsQ0FBQTtBQUNkLDBDQUFBLFlBQVksQ0FBQTtBQUNaLDhDQUFBLGdCQUFnQixDQUFBOztBQUdsQixnR0FNOEI7QUFMNUIsaUNBQUEsV0FBVyxDQUFBO0FBQ1gsbUNBQUEsYUFBYSxDQUFBO0FBQ2IsNkJBQUEsT0FBTyxDQUFBO0FBQ1AsMkJBQUEsS0FBSyxDQUFBO0FBQ0wsK0JBQUEsU0FBUyxDQUFBOztBQUdYLGtHQUFnRSxDQUFDLGdCQUFnQjtBQUF6RSxnREFBQSx5QkFBeUIsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqIFNhZmUgYnVpbGRlcnMgKi9cbmV4cG9ydCB7c2FmZUF0dHJQcmVmaXh9IGZyb20gJy4vYnVpbGRlcnMvYXR0cmlidXRlX2J1aWxkZXJzJztcbmV4cG9ydCB7XG4gIGh0bWxGcmFnbWVudCxcbiAgaHRtbFRvTm9kZSxcbiAgc3ZnRnJhZ21lbnQsXG59IGZyb20gJy4vYnVpbGRlcnMvZG9jdW1lbnRfZnJhZ21lbnRfYnVpbGRlcnMnO1xuZXhwb3J0IHtcbiAgY29uY2F0SHRtbHMsXG4gIGNyZWF0ZUh0bWwsIC8vIExJTkUtSU5URVJOQUxcbiAgZG9jdHlwZUh0bWwsXG4gIGh0bWxFc2NhcGUsXG4gIGpvaW5IdG1scyxcbiAgbm9kZVRvSHRtbCxcbiAgc2NyaXB0VG9IdG1sLFxuICBzY3JpcHRVcmxUb0h0bWwsXG59IGZyb20gJy4vYnVpbGRlcnMvaHRtbF9idWlsZGVycyc7XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vLyBUT0RPKGIvMzMzNTQ0OTY3KTogUHJldHRpZXIgcmVtb3ZlcyB0aGUgY29tbWVudCBvbiB0aGUgbGFzdCBsaW5lLCBzbyB3ZSBoYXZlXG4vLyB0byBkaXNhYmxlIHRoZSBmb3JtYXR0aW5nIGhlcmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7c3R5bGVTaGVldFRvSHRtbH0gZnJvbSAnLi9idWlsZGVycy9odG1sX2J1aWxkZXJzJztcbi8vIEVORC1JTlRFUk5BTFxuXG5leHBvcnQge0h0bWxGb3JtYXR0ZXJ9IGZyb20gJy4vYnVpbGRlcnMvaHRtbF9mb3JtYXR0ZXInOyAvLyBMSU5FLUlOVEVSTkFMXG5leHBvcnQge1xuICBzYW5pdGl6ZUh0bWwsXG4gIHNhbml0aXplSHRtbEFzc2VydFVuY2hhbmdlZCxcbiAgc2FuaXRpemVIdG1sVG9GcmFnbWVudCxcbiAgdHlwZSBIdG1sU2FuaXRpemVyLFxufSBmcm9tICcuL2J1aWxkZXJzL2h0bWxfc2FuaXRpemVyL2h0bWxfc2FuaXRpemVyJztcbmV4cG9ydCB7SHRtbFNhbml0aXplckJ1aWxkZXJ9IGZyb20gJy4vYnVpbGRlcnMvaHRtbF9zYW5pdGl6ZXIvaHRtbF9zYW5pdGl6ZXJfYnVpbGRlcic7XG5leHBvcnQge1xuICBhcHBlbmRQYXJhbXMsXG4gIGFwcGVuZFBhdGhTZWdtZW50LFxuICBvYmplY3RVcmxGcm9tU2NyaXB0LFxuICByZXBsYWNlRnJhZ21lbnQsXG4gIHRvQWJzb2x1dGVSZXNvdXJjZVVybCxcbiAgdHJ1c3RlZFJlc291cmNlVXJsLFxufSBmcm9tICcuL2J1aWxkZXJzL3Jlc291cmNlX3VybF9idWlsZGVycyc7XG5leHBvcnQge1xuICBjb25jYXRTY3JpcHRzLFxuICBzYWZlU2NyaXB0LFxuICBzYWZlU2NyaXB0V2l0aEFyZ3MsXG4gIHZhbHVlQXNTY3JpcHQsXG59IGZyb20gJy4vYnVpbGRlcnMvc2NyaXB0X2J1aWxkZXJzJztcbi8vIEJFR0lOLUlOVEVSTkFMXG5leHBvcnQge1xuICBjb25jYXRTdHlsZXMsXG4gIHNhZmVTdHlsZSxcbiAgc3R5bGVGb3JNaWdyYXRpb24sXG59IGZyb20gJy4vYnVpbGRlcnMvc3R5bGVfYnVpbGRlcnMnO1xuLy8gRU5ELUlOVEVSTkFMXG5leHBvcnQge1xuICBjb25jYXRTdHlsZVNoZWV0cyxcbiAgc2FmZVN0eWxlUnVsZSwgLy8gTElORS1JTlRFUk5BTFxuICBzYWZlU3R5bGVTaGVldCxcbn0gZnJvbSAnLi9idWlsZGVycy9zdHlsZV9zaGVldF9idWlsZGVycyc7XG4vLyBCRUdJTi1JTlRFUk5BTFxuZXhwb3J0IHtcbiAgU2FuaXRpemFibGVVcmxTY2hlbWUsXG4gIGFkZEphdmFTY3JpcHRVcmxTYW5pdGl6YXRpb25DYWxsYmFjayxcbiAgZnJvbU1lZGlhU291cmNlLFxuICBmcm9tVHJ1c3RlZFJlc291cmNlVXJsLFxuICBvYmplY3RVcmxGcm9tU2FmZVNvdXJjZSxcbiAgcmVtb3ZlSmF2YVNjcmlwdFVybFNhbml0aXphdGlvbkNhbGxiYWNrLFxuICBzYWZlVXJsLFxuICBzYW5pdGl6ZVVybCxcbiAgdHJ5U2FuaXRpemVVcmwsXG4gIHR5cGUgU2NoZW1lLFxufSBmcm9tICcuL2J1aWxkZXJzL3VybF9idWlsZGVycyc7XG4vLyBFTkQtSU5URVJOQUxcbi8qKiBUeXBlcywgY29uc3RhbnRzIGFuZCB1bndyYXBwZXJzICovXG5leHBvcnQge1xuICBTYWZlQXR0cmlidXRlUHJlZml4LFxuICB1bndyYXBBdHRyaWJ1dGVQcmVmaXgsXG59IGZyb20gJy4vaW50ZXJuYWxzL2F0dHJpYnV0ZV9pbXBsJztcbmV4cG9ydCB7RU1QVFlfSFRNTCwgU2FmZUh0bWwsIGlzSHRtbCwgdW53cmFwSHRtbH0gZnJvbSAnLi9pbnRlcm5hbHMvaHRtbF9pbXBsJztcbmV4cG9ydCB7XG4gIFRydXN0ZWRSZXNvdXJjZVVybCxcbiAgaXNSZXNvdXJjZVVybCxcbiAgdW53cmFwUmVzb3VyY2VVcmwsXG59IGZyb20gJy4vaW50ZXJuYWxzL3Jlc291cmNlX3VybF9pbXBsJztcbmV4cG9ydCB7XG4gIEVNUFRZX1NDUklQVCxcbiAgU2FmZVNjcmlwdCxcbiAgaXNTY3JpcHQsXG4gIHVud3JhcFNjcmlwdCxcbn0gZnJvbSAnLi9pbnRlcm5hbHMvc2NyaXB0X2ltcGwnO1xuLy8gQkVHSU4tSU5URVJOQUxcbmV4cG9ydCB7U2FmZVN0eWxlLCBpc1N0eWxlLCB1bndyYXBTdHlsZX0gZnJvbSAnLi9pbnRlcm5hbHMvc3R5bGVfaW1wbCc7XG4vLyBFTkQtSU5URVJOQUxcbmV4cG9ydCB7XG4gIFNhZmVTdHlsZVNoZWV0LFxuICBpc1N0eWxlU2hlZXQsXG4gIHVud3JhcFN0eWxlU2hlZXQsXG59IGZyb20gJy4vaW50ZXJuYWxzL3N0eWxlX3NoZWV0X2ltcGwnO1xuLy8gQkVHSU4tSU5URVJOQUxcbmV4cG9ydCB7XG4gIEFCT1VUX0JMQU5LLFxuICBJTk5PQ1VPVVNfVVJMLFxuICBTYWZlVXJsLFxuICBpc1VybCxcbiAgdW53cmFwVXJsLFxufSBmcm9tICcuL2ludGVybmFscy91cmxfaW1wbCc7XG4vLyBFTkQtSU5URVJOQUxcbmV4cG9ydCB7cmVwb3J0T25seUh0bWxQYXNzdGhyb3VnaH0gZnJvbSAnLi9yZXBvcnRpbmcvcmVwb3J0aW5nJzsgLy8gTElORS1JTlRFUk5BTFxuXG4vLyBCRUdJTi1JTlRFUk5BTFxuZ29vZy50c01pZ3JhdGlvbk5hbWVkRXhwb3J0c1NoaW0oJ3NhZmV2YWx1ZXMnKTtcbmdvb2cudHNNaWdyYXRpb25FeHBvcnRzU2hpbURlY2xhcmVMZWdhY3lOYW1lc3BhY2UoKTtcbi8vIEVORC1JTlRFUk5BTFxuIl19
;return exports;});

//learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/worker.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/worker.ts
 * @suppress {checkTypes} added by tsickle
 * @suppress {extraRequire} added by tsickle
 * @suppress {missingRequire} added by tsickle
 * @suppress {uselessCode} added by tsickle
 * @suppress {suspiciousCode} added by tsickle
 * @suppress {missingReturn} added by tsickle
 * @suppress {unusedPrivateMembers} added by tsickle
 * @suppress {missingOverride} added by tsickle
 * @suppress {const} added by tsickle
 */
goog.module('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.worker');
var module = module || { id: 'learning/brain/mobile/lite/tooling/model_graph_visualizer/module/worker/worker.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safevalues_1 = goog.requireType("google3.third_party.javascript.safevalues.index");
const tsickle_dom_2 = goog.requireType("google3.third_party.javascript.safevalues.dom.index");
const tsickle_input_graph_3 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.input_graph");
const tsickle_model_graph_4 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.model_graph");
const tsickle_types_5 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.types");
const tsickle_utils_6 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils");
const tsickle_visualizer_config_7 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.visualizer_config");
const tsickle_worker_events_8 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events");
const tsickle_generated_flags_9 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.common.flags.generated_flags");
const tsickle_dagre_types_10 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.dagre_types");
const tsickle_graph_expander_11 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_expander");
const tsickle_graph_layout_12 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout");
const tsickle_graph_processor_13 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_processor");
const tsickle_identical_groups_finder_14 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.identical_groups_finder");
const tsickle_utils_15 = goog.requireType("google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.utils");
// taze: ExtendableMessageEvent, ServiceWorkerGlobalScope from //third_party/javascript/node_modules/typescript:webworker
const safevalues_1 = goog.require('google3.third_party.javascript.safevalues.index');
const dom_1 = goog.require('google3.third_party.javascript.safevalues.dom.index');
const utils_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.utils');
const worker_events_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.common.worker_events');
const generated_flags_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.common.flags.generated_flags');
const graph_expander_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_expander');
const graph_layout_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_layout');
const graph_processor_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.graph_processor');
const identical_groups_finder_1 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.identical_groups_finder');
const utils_2 = goog.require('google3.learning.brain.mobile.lite.tooling.model_graph_visualizer.module.worker.utils');
try {
    // Load deps from gstatic for internal version.
    if (!generated_flags_1.IS_EXTERNAL) {
        dom_1.safeWorker.importScripts(self, (0, safevalues_1.trustedResourceUrl) `https://www.gstatic.com/external_hosted/dagre/dagre.min.js`);
        dom_1.safeWorker.importScripts(self, (0, safevalues_1.trustedResourceUrl) `https://www.gstatic.com/external_hosted/threejs-r134/three.min.js`);
        dom_1.safeWorker.importScripts(self, (0, safevalues_1.trustedResourceUrl) `https://www.gstatic.com/external_hosted/d3/v5/d3.min.js`);
    }
    // For external version, the dependencies will be concatenated with this file.
}
catch (e) {
    console.error(`Failed to import libs: ${e}`);
}
// <rendererId + ModelGraphId> -> ModelGraph
/** @type {?} */
const MODEL_GRAPHS_CACHE = {};
self.addEventListener('message', (/**
 * @param {!Event} event
 * @return {void}
 */
(event) => {
    /** @type {(!tsickle_worker_events_8.ProcessGraphRequest|!tsickle_worker_events_8.ProcessGraphResponse|!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest|!tsickle_worker_events_8.ExpandOrCollapseGroupNodeResponse|!tsickle_worker_events_8.RelayoutGraphRequest|!tsickle_worker_events_8.RelayoutGraphResponse|!tsickle_worker_events_8.LocateNodeRequest|!tsickle_worker_events_8.LocateNodeResponse|!tsickle_worker_events_8.UpdateProcessingProgressRequest|!tsickle_worker_events_8.PreparePopupRequest|!tsickle_worker_events_8.PreparePopupResponse)} */
    const workerEvent = (/** @type {(!tsickle_worker_events_8.ProcessGraphRequest|!tsickle_worker_events_8.ProcessGraphResponse|!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest|!tsickle_worker_events_8.ExpandOrCollapseGroupNodeResponse|!tsickle_worker_events_8.RelayoutGraphRequest|!tsickle_worker_events_8.RelayoutGraphResponse|!tsickle_worker_events_8.LocateNodeRequest|!tsickle_worker_events_8.LocateNodeResponse|!tsickle_worker_events_8.UpdateProcessingProgressRequest|!tsickle_worker_events_8.PreparePopupRequest|!tsickle_worker_events_8.PreparePopupResponse)} */ (((/** @type {?} */ (event))).data));
    switch (workerEvent.eventType) {
        // Handle processing input graph.
        case worker_events_1.WorkerEventType.PROCESS_GRAPH_REQ: {
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const modelGraph = handleProcessGraph((/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).paneId, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).graph, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).showOnNodeItemTypes, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).nodeDataProviderRuns, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).config, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).groupNodeChildrenCountThreshold, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).flattenLayers);
            cacheModelGraph(modelGraph, (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).paneId);
            /** @type {!tsickle_worker_events_8.ProcessGraphResponse} */
            const resp = {
                eventType: worker_events_1.WorkerEventType.PROCESS_GRAPH_RESP,
                modelGraph,
                paneId: (/** @type {!tsickle_worker_events_8.ProcessGraphRequest} */ (workerEvent)).paneId,
            };
            postMessage(resp);
            break;
        }
        case worker_events_1.WorkerEventType.PREPARE_POPUP_REQ: {
            // Clone the model graph from the pane to a graph for the renderer id
            // (the renderer id for the model graph in the popup).
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const modelGraph = getCachedModelGraph((/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).modelGraphId, (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).paneId);
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const clonedModelGraph = (/** @type {!tsickle_model_graph_4.ModelGraph} */ (JSON.parse(JSON.stringify(modelGraph))));
            cacheModelGraph(clonedModelGraph, (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).rendererId);
            /** @type {!tsickle_worker_events_8.PreparePopupResponse} */
            const resp = {
                eventType: worker_events_1.WorkerEventType.PREPARE_POPUP_RESP,
                modelGraph,
                paneId: (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).paneId,
                rendererId: (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).rendererId,
                groupNodeId: (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).groupNodeId,
                initialPosition: (/** @type {!tsickle_worker_events_8.PreparePopupRequest} */ (workerEvent)).initialPosition,
            };
            postMessage(resp);
            break;
        }
        case worker_events_1.WorkerEventType.EXPAND_OR_COLLAPSE_GROUP_NODE_REQ: {
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const modelGraph = getCachedModelGraph((/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).modelGraphId, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).rendererId);
            /** @type {!Array<string>} */
            let deepestExpandedGroupNodeIds = [];
            if ((/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).expand) {
                deepestExpandedGroupNodeIds = handleExpandGroupNode(modelGraph, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).groupNodeId, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).showOnNodeItemTypes, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).nodeDataProviderRuns, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).all === true);
            }
            else {
                deepestExpandedGroupNodeIds = handleCollapseGroupNode(modelGraph, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).groupNodeId, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).showOnNodeItemTypes, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).nodeDataProviderRuns, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).all === true);
            }
            cacheModelGraph(modelGraph, (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).rendererId);
            /** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeResponse} */
            const resp = {
                eventType: worker_events_1.WorkerEventType.EXPAND_OR_COLLAPSE_GROUP_NODE_RESP,
                modelGraph,
                expanded: (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).expand,
                groupNodeId: (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).groupNodeId,
                rendererId: (/** @type {!tsickle_worker_events_8.ExpandOrCollapseGroupNodeRequest} */ (workerEvent)).rendererId,
                deepestExpandedGroupNodeIds,
            };
            postMessage(resp);
            break;
        }
        case worker_events_1.WorkerEventType.RELAYOUT_GRAPH_REQ: {
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const modelGraph = getCachedModelGraph((/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).modelGraphId, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).rendererId);
            handleReLayoutGraph(modelGraph, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).showOnNodeItemTypes, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).nodeDataProviderRuns, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).targetDeepestGroupNodeIdsToExpand, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).clearAllExpandStates);
            cacheModelGraph(modelGraph, (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).rendererId);
            /** @type {!tsickle_worker_events_8.RelayoutGraphResponse} */
            const resp = {
                eventType: worker_events_1.WorkerEventType.RELAYOUT_GRAPH_RESP,
                modelGraph,
                selectedNodeId: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).selectedNodeId,
                rendererId: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).rendererId,
                forRestoringUiState: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).forRestoringUiState,
                rectToZoomFit: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).rectToZoomFit,
                forRestoringSnapshotAfterTogglingFlattenLayers: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).forRestoringSnapshotAfterTogglingFlattenLayers,
                targetDeepestGroupNodeIdsToExpand: (/** @type {!tsickle_worker_events_8.RelayoutGraphRequest} */ (workerEvent)).targetDeepestGroupNodeIdsToExpand,
            };
            postMessage(resp);
            break;
        }
        case worker_events_1.WorkerEventType.LOCATE_NODE_REQ: {
            /** @type {!tsickle_model_graph_4.ModelGraph} */
            const modelGraph = getCachedModelGraph((/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).modelGraphId, (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).rendererId);
            /** @type {!Array<string>} */
            const deepestExpandedGroupNodeIds = handleLocateNode(modelGraph, (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).showOnNodeItemTypes, (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).nodeDataProviderRuns, (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).nodeId);
            cacheModelGraph(modelGraph, (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).rendererId);
            /** @type {!tsickle_worker_events_8.LocateNodeResponse} */
            const resp = {
                eventType: worker_events_1.WorkerEventType.LOCATE_NODE_RESP,
                modelGraph,
                nodeId: (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).nodeId,
                rendererId: (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).rendererId,
                deepestExpandedGroupNodeIds,
                noNodeShake: (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).noNodeShake,
                select: (/** @type {!tsickle_worker_events_8.LocateNodeRequest} */ (workerEvent)).select,
            };
            postMessage(resp);
            break;
        }
        default:
            break;
    }
}));
/**
 * @param {string} paneId
 * @param {!tsickle_input_graph_3.Graph} graph
 * @param {?} showItemOnNodeTypes
 * @param {?} nodeDataProviderRuns
 * @param {(undefined|!tsickle_visualizer_config_7.VisualizerConfig)=} config
 * @param {(undefined|number)=} groupNodeChildrenCountThreshold
 * @param {(undefined|boolean)=} flattenLayers
 * @return {!tsickle_model_graph_4.ModelGraph}
 */
function handleProcessGraph(paneId, graph, showItemOnNodeTypes, nodeDataProviderRuns, config, groupNodeChildrenCountThreshold, flattenLayers) {
    /** @type {(undefined|string)} */
    let error = undefined;
    // Processes the given input graph `Graph` into a `ModelGraph`.
    /** @type {!tsickle_graph_processor_13.GraphProcessor} */
    const processor = new graph_processor_1.GraphProcessor(paneId, graph, config, showItemOnNodeTypes, {}, groupNodeChildrenCountThreshold, false, flattenLayers);
    /** @type {!tsickle_model_graph_4.ModelGraph} */
    const modelGraph = processor.process();
    // Check nodes with empty ids.
    if (modelGraph.nodesById[''] != null) {
        error =
            'Some nodes have empty strings as ids which will cause layout failures. See console for details.';
        console.warn('Nodes with empty ids', modelGraph.nodesById['']);
    }
    // Do the initial layout.
    if (!error) {
        /** @type {!tsickle_graph_layout_12.GraphLayout} */
        const layout = new graph_layout_1.GraphLayout(modelGraph, dagre, showItemOnNodeTypes, nodeDataProviderRuns);
        try {
            layout.layout();
        }
        catch (e) {
            error = `Failed to layout graph: ${e}`;
        }
    }
    (0, utils_2.updateProcessingProgress)(paneId, worker_events_1.ProcessingLabel.LAYING_OUT_ROOT_LAYER, error);
    // Find identical groups.
    /** @type {!tsickle_identical_groups_finder_14.IdenticalGroupsFinder} */
    const identicalGroupsFinder = new identical_groups_finder_1.IdenticalGroupsFinder(modelGraph);
    identicalGroupsFinder.markIdenticalGroups();
    (0, utils_2.updateProcessingProgress)(paneId, worker_events_1.ProcessingLabel.FINDING_IDENTICAL_LAYERS);
    return modelGraph;
}
/**
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {(undefined|string)} groupNodeId
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {boolean} all
 * @return {!Array<string>}
 */
function handleExpandGroupNode(modelGraph, groupNodeId, showOnNodeItemTypes, nodeDataProviderRuns, all) {
    /** @type {!tsickle_graph_expander_11.GraphExpander} */
    const expander = new graph_expander_1.GraphExpander(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns);
    // Expane group node.
    if (groupNodeId != null) {
        /** @type {(undefined|!Array<string>)} */
        let deepestExpandedGroupNodeId = undefined;
        /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
        const groupNode = modelGraph.nodesById[groupNodeId];
        if (groupNode && (0, utils_1.isGroupNode)(groupNode)) {
            (/** @type {!tsickle_model_graph_4.GroupNode} */ (groupNode)).expanded = true;
            // Recursively expand child group node if there is only one child.
            /** @type {!tsickle_model_graph_4.GroupNode} */
            let curGroupNode = groupNode;
            while (true) {
                /** @type {!Array<string>} */
                const childrenIds = curGroupNode.nsChildrenIds || [];
                if (childrenIds.length === 1) {
                    /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
                    const child = modelGraph.nodesById[childrenIds[0]];
                    if (child && (0, utils_1.isGroupNode)(child)) {
                        (/** @type {!tsickle_model_graph_4.GroupNode} */ (child)).expanded = true;
                        curGroupNode = child;
                    }
                }
                else {
                    break;
                }
            }
            // Get the deepest expanded group nodes from the curGroupNode and we will
            // be doing relayout from there.
            /** @type {!Array<string>} */
            const ids = [];
            (0, utils_1.getDeepestExpandedGroupNodeIds)(curGroupNode, modelGraph, ids);
            deepestExpandedGroupNodeId = ids.length === 0 ? [curGroupNode.id] : ids;
            // Clear layout data for all nodes under curGroupNode.
            //
            // This is necessary because the node overlay might have been changed so
            // we need to re-calculate the node sizes.
            for (const nodeId of curGroupNode.descendantsNodeIds || []) {
                /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
                const node = modelGraph.nodesById[nodeId];
                node.width = undefined;
                node.height = undefined;
            }
        }
        if (all) {
            for (const childNodeId of ((/** @type {!tsickle_model_graph_4.GroupNode} */ (groupNode))).descendantsNodeIds ||
                []) {
                /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
                const node = modelGraph.nodesById[childNodeId];
                if ((0, utils_1.isGroupNode)(node)) {
                    (/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).expanded = true;
                }
            }
            deepestExpandedGroupNodeId = undefined;
        }
        expander.reLayoutGraph(deepestExpandedGroupNodeId);
        /** @type {!Array<string>} */
        const ids = [];
        (0, utils_1.getDeepestExpandedGroupNodeIds)(undefined, modelGraph, ids);
        return ids;
    }
    // Expand all group nodes in the graph.
    else {
        return expander.expandAllGroups();
    }
}
/**
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {(undefined|string)} groupNodeId
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {boolean} all
 * @return {!Array<string>}
 */
function handleCollapseGroupNode(modelGraph, groupNodeId, showOnNodeItemTypes, nodeDataProviderRuns, all) {
    /** @type {!tsickle_graph_expander_11.GraphExpander} */
    const expander = new graph_expander_1.GraphExpander(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns);
    if (groupNodeId != null) {
        if (all) {
            /** @type {!tsickle_model_graph_4.GroupNode} */
            const groupNode = (/** @type {!tsickle_model_graph_4.GroupNode} */ (modelGraph.nodesById[groupNodeId]));
            for (const childNodeId of groupNode.descendantsNodeIds || []) {
                /** @type {(!tsickle_model_graph_4.OpNode|!tsickle_model_graph_4.GroupNode)} */
                const node = modelGraph.nodesById[childNodeId];
                if ((0, utils_1.isGroupNode)(node)) {
                    (/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).expanded = false;
                    (/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).width = undefined;
                    (/** @type {!tsickle_model_graph_4.GroupNode} */ (node)).height = undefined;
                    delete modelGraph.edgesByGroupNodeIds[node.id];
                }
            }
        }
        return expander.collapseGroupNode(groupNodeId);
    }
    else {
        return expander.collapseAllGroup();
    }
}
/**
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {(undefined|!Array<string>)=} targetDeepestGroupNodeIdsToExpand
 * @param {(undefined|boolean)=} clearAllExpandStates
 * @return {void}
 */
function handleReLayoutGraph(modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, targetDeepestGroupNodeIdsToExpand, clearAllExpandStates) {
    /** @type {!tsickle_graph_expander_11.GraphExpander} */
    const expander = new graph_expander_1.GraphExpander(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns);
    expander.reLayoutGraph(targetDeepestGroupNodeIdsToExpand, clearAllExpandStates);
}
/**
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {?} showOnNodeItemTypes
 * @param {?} nodeDataProviderRuns
 * @param {string} nodeId
 * @return {!Array<string>}
 */
function handleLocateNode(modelGraph, showOnNodeItemTypes, nodeDataProviderRuns, nodeId) {
    /** @type {!tsickle_graph_expander_11.GraphExpander} */
    const expander = new graph_expander_1.GraphExpander(modelGraph, dagre, showOnNodeItemTypes, nodeDataProviderRuns);
    return expander.expandToRevealNode(nodeId);
}
/**
 * @param {!tsickle_model_graph_4.ModelGraph} modelGraph
 * @param {string} rendererId
 * @return {void}
 */
function cacheModelGraph(modelGraph, rendererId) {
    MODEL_GRAPHS_CACHE[getModelGraphKey(modelGraph.id, rendererId)] = modelGraph;
}
/**
 * @param {string} modelGraphId
 * @param {string} rendererId
 * @return {!tsickle_model_graph_4.ModelGraph}
 */
function getCachedModelGraph(modelGraphId, rendererId) {
    /** @type {!tsickle_model_graph_4.ModelGraph} */
    const cachedModelGraph = MODEL_GRAPHS_CACHE[getModelGraphKey(modelGraphId, rendererId)];
    if (cachedModelGraph == null) {
        throw new Error(`ModelGraph with id "${modelGraphId}" not found for rendererId "${rendererId}"`);
    }
    return cachedModelGraph;
}
/**
 * @param {string} modelGraphId
 * @param {string} rendererId
 * @return {string}
 */
function getModelGraphKey(modelGraphId, rendererId) {
    return `${modelGraphId}___${rendererId}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGVhcm5pbmcvYnJhaW4vbW9iaWxlL2xpdGUvdG9vbGluZy9tb2RlbF9ncmFwaF92aXN1YWxpemVyL21vZHVsZS93b3JrZXIvd29ya2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EscUZBQThDO0FBQzlDLGtGQUEwQztBQUsxQyxzSEFBNEU7QUFFNUUsc0lBU2lDO0FBRWpDLHlJQUErRDtBQUUvRCx3SUFBK0M7QUFDL0Msb0lBQTJDO0FBQzNDLDBJQUFpRDtBQUNqRCwwSkFBZ0U7QUFDaEUsc0hBQWlEO0FBSWpELElBQUksQ0FBQztJQUNILCtDQUErQztJQUMvQyxJQUFJLENBQUMsNkJBQVcsRUFBRSxDQUFDO1FBQ2pCLGdCQUFVLENBQUMsYUFBYSxDQUN0QixJQUFJLEVBQ0osSUFBQSwrQkFBa0IsRUFBQSw0REFBNEQsQ0FDL0UsQ0FBQztRQUNGLGdCQUFVLENBQUMsYUFBYSxDQUN0QixJQUFJLEVBQ0osSUFBQSwrQkFBa0IsRUFBQSxtRUFBbUUsQ0FDdEYsQ0FBQztRQUNGLGdCQUFVLENBQUMsYUFBYSxDQUN0QixJQUFJLEVBQ0osSUFBQSwrQkFBa0IsRUFBQSx5REFBeUQsQ0FDNUUsQ0FBQztJQUNKLENBQUM7SUFDRCw4RUFBOEU7QUFDaEYsQ0FBQztBQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7SUFDWCxPQUFPLENBQUMsS0FBSyxDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9DLENBQUM7OztNQUtLLGtCQUFrQixHQUErQixFQUFFO0FBRXpELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTOzs7O0FBQUUsQ0FBQyxLQUFZLEVBQUUsRUFBRTs7VUFDMUMsV0FBVyxHQUFHLDJpQkFBQSxDQUFDLG1CQUFBLEtBQUssRUFBMEIsQ0FBQyxDQUFD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Ly8gdGF6ZTogRXh0ZW5kYWJsZU1lc3NhZ2VFdmVudCwgU2VydmljZVdvcmtlckdsb2JhbFNjb3BlIGZyb20gLy90aGlyZF9wYXJ0eS9qYXZhc2NyaXB0L25vZGVfbW9kdWxlcy90eXBlc2NyaXB0OndlYndvcmtlclxuaW1wb3J0IHt0cnVzdGVkUmVzb3VyY2VVcmx9IGZyb20gJ3NhZmV2YWx1ZXMnO1xuaW1wb3J0IHtzYWZlV29ya2VyfSBmcm9tICdzYWZldmFsdWVzL2RvbSc7XG5cbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uL2NvbW1vbi9pbnB1dF9ncmFwaCc7XG5pbXBvcnQge0dyb3VwTm9kZSwgTW9kZWxHcmFwaH0gZnJvbSAnLi4vY29tbW9uL21vZGVsX2dyYXBoJztcbmltcG9ydCB7Tm9kZURhdGFQcm92aWRlclJ1bkRhdGEsIFNob3dPbk5vZGVJdGVtRGF0YX0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7Z2V0RGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzLCBpc0dyb3VwTm9kZX0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7VmlzdWFsaXplckNvbmZpZ30gZnJvbSAnLi4vY29tbW9uL3Zpc3VhbGl6ZXJfY29uZmlnJztcbmltcG9ydCB7XG4gIEV4cGFuZE9yQ29sbGFwc2VHcm91cE5vZGVSZXNwb25zZSxcbiAgTG9jYXRlTm9kZVJlc3BvbnNlLFxuICBQcmVwYXJlUG9wdXBSZXNwb25zZSxcbiAgUHJvY2Vzc0dyYXBoUmVzcG9uc2UsXG4gIFByb2Nlc3NpbmdMYWJlbCxcbiAgUmVsYXlvdXRHcmFwaFJlc3BvbnNlLFxuICBXb3JrZXJFdmVudCxcbiAgV29ya2VyRXZlbnRUeXBlLFxufSBmcm9tICcuLi9jb21tb24vd29ya2VyX2V2ZW50cyc7XG5cbmltcG9ydCB7SVNfRVhURVJOQUx9IGZyb20gJy4uLy4uL2NvbW1vbi9mbGFncy9nZW5lcmF0ZWRfZmxhZ3MnO1xuaW1wb3J0IHtEYWdyZX0gZnJvbSAnLi9kYWdyZV90eXBlcyc7XG5pbXBvcnQge0dyYXBoRXhwYW5kZXJ9IGZyb20gJy4vZ3JhcGhfZXhwYW5kZXInO1xuaW1wb3J0IHtHcmFwaExheW91dH0gZnJvbSAnLi9ncmFwaF9sYXlvdXQnO1xuaW1wb3J0IHtHcmFwaFByb2Nlc3Nvcn0gZnJvbSAnLi9ncmFwaF9wcm9jZXNzb3InO1xuaW1wb3J0IHtJZGVudGljYWxHcm91cHNGaW5kZXJ9IGZyb20gJy4vaWRlbnRpY2FsX2dyb3Vwc19maW5kZXInO1xuaW1wb3J0IHt1cGRhdGVQcm9jZXNzaW5nUHJvZ3Jlc3N9IGZyb20gJy4vdXRpbHMnO1xuXG5kZWNsYXJlIGNvbnN0IHNlbGY6IFNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZTtcblxudHJ5IHtcbiAgLy8gTG9hZCBkZXBzIGZyb20gZ3N0YXRpYyBmb3IgaW50ZXJuYWwgdmVyc2lvbi5cbiAgaWYgKCFJU19FWFRFUk5BTCkge1xuICAgIHNhZmVXb3JrZXIuaW1wb3J0U2NyaXB0cyhcbiAgICAgIHNlbGYsXG4gICAgICB0cnVzdGVkUmVzb3VyY2VVcmxgaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZXh0ZXJuYWxfaG9zdGVkL2RhZ3JlL2RhZ3JlLm1pbi5qc2AsXG4gICAgKTtcbiAgICBzYWZlV29ya2VyLmltcG9ydFNjcmlwdHMoXG4gICAgICBzZWxmLFxuICAgICAgdHJ1c3RlZFJlc291cmNlVXJsYGh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2V4dGVybmFsX2hvc3RlZC90aHJlZWpzLXIxMzQvdGhyZWUubWluLmpzYCxcbiAgICApO1xuICAgIHNhZmVXb3JrZXIuaW1wb3J0U2NyaXB0cyhcbiAgICAgIHNlbGYsXG4gICAgICB0cnVzdGVkUmVzb3VyY2VVcmxgaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZXh0ZXJuYWxfaG9zdGVkL2QzL3Y1L2QzLm1pbi5qc2AsXG4gICAgKTtcbiAgfVxuICAvLyBGb3IgZXh0ZXJuYWwgdmVyc2lvbiwgdGhlIGRlcGVuZGVuY2llcyB3aWxsIGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoaXMgZmlsZS5cbn0gY2F0Y2ggKGUpIHtcbiAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGltcG9ydCBsaWJzOiAke2V9YCk7XG59XG5cbmRlY2xhcmUgdmFyIGRhZ3JlOiBEYWdyZTtcblxuLy8gPHJlbmRlcmVySWQgKyBNb2RlbEdyYXBoSWQ+IC0+IE1vZGVsR3JhcGhcbmNvbnN0IE1PREVMX0dSQVBIU19DQUNIRTogUmVjb3JkPHN0cmluZywgTW9kZWxHcmFwaD4gPSB7fTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50OiBFdmVudCkgPT4ge1xuICBjb25zdCB3b3JrZXJFdmVudCA9IChldmVudCBhcyBFeHRlbmRhYmxlTWVzc2FnZUV2ZW50KS5kYXRhIGFzIFdvcmtlckV2ZW50O1xuICBzd2l0Y2ggKHdvcmtlckV2ZW50LmV2ZW50VHlwZSkge1xuICAgIC8vIEhhbmRsZSBwcm9jZXNzaW5nIGlucHV0IGdyYXBoLlxuICAgIGNhc2UgV29ya2VyRXZlbnRUeXBlLlBST0NFU1NfR1JBUEhfUkVROiB7XG4gICAgICBjb25zdCBtb2RlbEdyYXBoID0gaGFuZGxlUHJvY2Vzc0dyYXBoKFxuICAgICAgICB3b3JrZXJFdmVudC5wYW5lSWQsXG4gICAgICAgIHdvcmtlckV2ZW50LmdyYXBoLFxuICAgICAgICB3b3JrZXJFdmVudC5zaG93T25Ob2RlSXRlbVR5cGVzLFxuICAgICAgICB3b3JrZXJFdmVudC5ub2RlRGF0YVByb3ZpZGVyUnVucyxcbiAgICAgICAgd29ya2VyRXZlbnQuY29uZmlnLFxuICAgICAgICB3b3JrZXJFdmVudC5ncm91cE5vZGVDaGlsZHJlbkNvdW50VGhyZXNob2xkLFxuICAgICAgICB3b3JrZXJFdmVudC5mbGF0dGVuTGF5ZXJzLFxuICAgICAgKTtcbiAgICAgIGNhY2hlTW9kZWxHcmFwaChtb2RlbEdyYXBoLCB3b3JrZXJFdmVudC5wYW5lSWQpO1xuICAgICAgY29uc3QgcmVzcDogUHJvY2Vzc0dyYXBoUmVzcG9uc2UgPSB7XG4gICAgICAgIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLlBST0NFU1NfR1JBUEhfUkVTUCxcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICAgcGFuZUlkOiB3b3JrZXJFdmVudC5wYW5lSWQsXG4gICAgICB9O1xuICAgICAgcG9zdE1lc3NhZ2UocmVzcCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBXb3JrZXJFdmVudFR5cGUuUFJFUEFSRV9QT1BVUF9SRVE6IHtcbiAgICAgIC8vIENsb25lIHRoZSBtb2RlbCBncmFwaCBmcm9tIHRoZSBwYW5lIHRvIGEgZ3JhcGggZm9yIHRoZSByZW5kZXJlciBpZFxuICAgICAgLy8gKHRoZSByZW5kZXJlciBpZCBmb3IgdGhlIG1vZGVsIGdyYXBoIGluIHRoZSBwb3B1cCkuXG4gICAgICBjb25zdCBtb2RlbEdyYXBoID0gZ2V0Q2FjaGVkTW9kZWxHcmFwaChcbiAgICAgICAgd29ya2VyRXZlbnQubW9kZWxHcmFwaElkLFxuICAgICAgICB3b3JrZXJFdmVudC5wYW5lSWQsXG4gICAgICApO1xuICAgICAgY29uc3QgY2xvbmVkTW9kZWxHcmFwaCA9IEpTT04ucGFyc2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KG1vZGVsR3JhcGgpLFxuICAgICAgKSBhcyBNb2RlbEdyYXBoO1xuICAgICAgY2FjaGVNb2RlbEdyYXBoKGNsb25lZE1vZGVsR3JhcGgsIHdvcmtlckV2ZW50LnJlbmRlcmVySWQpO1xuXG4gICAgICBjb25zdCByZXNwOiBQcmVwYXJlUG9wdXBSZXNwb25zZSA9IHtcbiAgICAgICAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuUFJFUEFSRV9QT1BVUF9SRVNQLFxuICAgICAgICBtb2RlbEdyYXBoLFxuICAgICAgICBwYW5lSWQ6IHdvcmtlckV2ZW50LnBhbmVJZCxcbiAgICAgICAgcmVuZGVyZXJJZDogd29ya2VyRXZlbnQucmVuZGVyZXJJZCxcbiAgICAgICAgZ3JvdXBOb2RlSWQ6IHdvcmtlckV2ZW50Lmdyb3VwTm9kZUlkLFxuICAgICAgICBpbml0aWFsUG9zaXRpb246IHdvcmtlckV2ZW50LmluaXRpYWxQb3NpdGlvbixcbiAgICAgIH07XG4gICAgICBwb3N0TWVzc2FnZShyZXNwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFdvcmtlckV2ZW50VHlwZS5FWFBBTkRfT1JfQ09MTEFQU0VfR1JPVVBfTk9ERV9SRVE6IHtcbiAgICAgIGNvbnN0IG1vZGVsR3JhcGggPSBnZXRDYWNoZWRNb2RlbEdyYXBoKFxuICAgICAgICB3b3JrZXJFdmVudC5tb2RlbEdyYXBoSWQsXG4gICAgICAgIHdvcmtlckV2ZW50LnJlbmRlcmVySWQsXG4gICAgICApO1xuICAgICAgbGV0IGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGlmICh3b3JrZXJFdmVudC5leHBhbmQpIHtcbiAgICAgICAgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzID0gaGFuZGxlRXhwYW5kR3JvdXBOb2RlKFxuICAgICAgICAgIG1vZGVsR3JhcGgsXG4gICAgICAgICAgd29ya2VyRXZlbnQuZ3JvdXBOb2RlSWQsXG4gICAgICAgICAgd29ya2VyRXZlbnQuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgICB3b3JrZXJFdmVudC5ub2RlRGF0YVByb3ZpZGVyUnVucyxcbiAgICAgICAgICB3b3JrZXJFdmVudC5hbGwgPT09IHRydWUsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMgPSBoYW5kbGVDb2xsYXBzZUdyb3VwTm9kZShcbiAgICAgICAgICBtb2RlbEdyYXBoLFxuICAgICAgICAgIHdvcmtlckV2ZW50Lmdyb3VwTm9kZUlkLFxuICAgICAgICAgIHdvcmtlckV2ZW50LnNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgICAgICAgd29ya2VyRXZlbnQubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICAgICAgd29ya2VyRXZlbnQuYWxsID09PSB0cnVlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FjaGVNb2RlbEdyYXBoKG1vZGVsR3JhcGgsIHdvcmtlckV2ZW50LnJlbmRlcmVySWQpO1xuICAgICAgY29uc3QgcmVzcDogRXhwYW5kT3JDb2xsYXBzZUdyb3VwTm9kZVJlc3BvbnNlID0ge1xuICAgICAgICBldmVudFR5cGU6IFdvcmtlckV2ZW50VHlwZS5FWFBBTkRfT1JfQ09MTEFQU0VfR1JPVVBfTk9ERV9SRVNQLFxuICAgICAgICBtb2RlbEdyYXBoLFxuICAgICAgICBleHBhbmRlZDogd29ya2VyRXZlbnQuZXhwYW5kLFxuICAgICAgICBncm91cE5vZGVJZDogd29ya2VyRXZlbnQuZ3JvdXBOb2RlSWQsXG4gICAgICAgIHJlbmRlcmVySWQ6IHdvcmtlckV2ZW50LnJlbmRlcmVySWQsXG4gICAgICAgIGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcyxcbiAgICAgIH07XG4gICAgICBwb3N0TWVzc2FnZShyZXNwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFdvcmtlckV2ZW50VHlwZS5SRUxBWU9VVF9HUkFQSF9SRVE6IHtcbiAgICAgIGNvbnN0IG1vZGVsR3JhcGggPSBnZXRDYWNoZWRNb2RlbEdyYXBoKFxuICAgICAgICB3b3JrZXJFdmVudC5tb2RlbEdyYXBoSWQsXG4gICAgICAgIHdvcmtlckV2ZW50LnJlbmRlcmVySWQsXG4gICAgICApO1xuICAgICAgaGFuZGxlUmVMYXlvdXRHcmFwaChcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICAgd29ya2VyRXZlbnQuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgd29ya2VyRXZlbnQubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICAgIHdvcmtlckV2ZW50LnRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZCxcbiAgICAgICAgd29ya2VyRXZlbnQuY2xlYXJBbGxFeHBhbmRTdGF0ZXMsXG4gICAgICApO1xuICAgICAgY2FjaGVNb2RlbEdyYXBoKG1vZGVsR3JhcGgsIHdvcmtlckV2ZW50LnJlbmRlcmVySWQpO1xuICAgICAgY29uc3QgcmVzcDogUmVsYXlvdXRHcmFwaFJlc3BvbnNlID0ge1xuICAgICAgICBldmVudFR5cGU6IFdvcmtlckV2ZW50VHlwZS5SRUxBWU9VVF9HUkFQSF9SRVNQLFxuICAgICAgICBtb2RlbEdyYXBoLFxuICAgICAgICBzZWxlY3RlZE5vZGVJZDogd29ya2VyRXZlbnQuc2VsZWN0ZWROb2RlSWQsXG4gICAgICAgIHJlbmRlcmVySWQ6IHdvcmtlckV2ZW50LnJlbmRlcmVySWQsXG4gICAgICAgIGZvclJlc3RvcmluZ1VpU3RhdGU6IHdvcmtlckV2ZW50LmZvclJlc3RvcmluZ1VpU3RhdGUsXG4gICAgICAgIHJlY3RUb1pvb21GaXQ6IHdvcmtlckV2ZW50LnJlY3RUb1pvb21GaXQsXG4gICAgICAgIGZvclJlc3RvcmluZ1NuYXBzaG90QWZ0ZXJUb2dnbGluZ0ZsYXR0ZW5MYXllcnM6XG4gICAgICAgICAgd29ya2VyRXZlbnQuZm9yUmVzdG9yaW5nU25hcHNob3RBZnRlclRvZ2dsaW5nRmxhdHRlbkxheWVycyxcbiAgICAgICAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kOlxuICAgICAgICAgIHdvcmtlckV2ZW50LnRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZCxcbiAgICAgIH07XG4gICAgICBwb3N0TWVzc2FnZShyZXNwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFdvcmtlckV2ZW50VHlwZS5MT0NBVEVfTk9ERV9SRVE6IHtcbiAgICAgIGNvbnN0IG1vZGVsR3JhcGggPSBnZXRDYWNoZWRNb2RlbEdyYXBoKFxuICAgICAgICB3b3JrZXJFdmVudC5tb2RlbEdyYXBoSWQsXG4gICAgICAgIHdvcmtlckV2ZW50LnJlbmRlcmVySWQsXG4gICAgICApO1xuICAgICAgY29uc3QgZGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzID0gaGFuZGxlTG9jYXRlTm9kZShcbiAgICAgICAgbW9kZWxHcmFwaCxcbiAgICAgICAgd29ya2VyRXZlbnQuc2hvd09uTm9kZUl0ZW1UeXBlcyxcbiAgICAgICAgd29ya2VyRXZlbnQubm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICAgICAgIHdvcmtlckV2ZW50Lm5vZGVJZCxcbiAgICAgICk7XG4gICAgICBjYWNoZU1vZGVsR3JhcGgobW9kZWxHcmFwaCwgd29ya2VyRXZlbnQucmVuZGVyZXJJZCk7XG4gICAgICBjb25zdCByZXNwOiBMb2NhdGVOb2RlUmVzcG9uc2UgPSB7XG4gICAgICAgIGV2ZW50VHlwZTogV29ya2VyRXZlbnRUeXBlLkxPQ0FURV9OT0RFX1JFU1AsXG4gICAgICAgIG1vZGVsR3JhcGgsXG4gICAgICAgIG5vZGVJZDogd29ya2VyRXZlbnQubm9kZUlkLFxuICAgICAgICByZW5kZXJlcklkOiB3b3JrZXJFdmVudC5yZW5kZXJlcklkLFxuICAgICAgICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZHMsXG4gICAgICAgIG5vTm9kZVNoYWtlOiB3b3JrZXJFdmVudC5ub05vZGVTaGFrZSxcbiAgICAgICAgc2VsZWN0OiB3b3JrZXJFdmVudC5zZWxlY3QsXG4gICAgICB9O1xuICAgICAgcG9zdE1lc3NhZ2UocmVzcCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59KTtcblxuZnVuY3Rpb24gaGFuZGxlUHJvY2Vzc0dyYXBoKFxuICBwYW5lSWQ6IHN0cmluZyxcbiAgZ3JhcGg6IEdyYXBoLFxuICBzaG93SXRlbU9uTm9kZVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+LFxuICBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJ1bkRhdGE+LFxuICBjb25maWc/OiBWaXN1YWxpemVyQ29uZmlnLFxuICBncm91cE5vZGVDaGlsZHJlbkNvdW50VGhyZXNob2xkPzogbnVtYmVyLFxuICBmbGF0dGVuTGF5ZXJzPzogYm9vbGVhbixcbik6IE1vZGVsR3JhcGgge1xuICBsZXQgZXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIGlucHV0IGdyYXBoIGBHcmFwaGAgaW50byBhIGBNb2RlbEdyYXBoYC5cbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IEdyYXBoUHJvY2Vzc29yKFxuICAgIHBhbmVJZCxcbiAgICBncmFwaCxcbiAgICBjb25maWcsXG4gICAgc2hvd0l0ZW1Pbk5vZGVUeXBlcyxcbiAgICB7fSxcbiAgICBncm91cE5vZGVDaGlsZHJlbkNvdW50VGhyZXNob2xkLFxuICAgIGZhbHNlLFxuICAgIGZsYXR0ZW5MYXllcnMsXG4gICk7XG4gIGNvbnN0IG1vZGVsR3JhcGggPSBwcm9jZXNzb3IucHJvY2VzcygpO1xuXG4gIC8vIENoZWNrIG5vZGVzIHdpdGggZW1wdHkgaWRzLlxuICBpZiAobW9kZWxHcmFwaC5ub2Rlc0J5SWRbJyddICE9IG51bGwpIHtcbiAgICBlcnJvciA9XG4gICAgICAnU29tZSBub2RlcyBoYXZlIGVtcHR5IHN0cmluZ3MgYXMgaWRzIHdoaWNoIHdpbGwgY2F1c2UgbGF5b3V0IGZhaWx1cmVzLiBTZWUgY29uc29sZSBmb3IgZGV0YWlscy4nO1xuICAgIGNvbnNvbGUud2FybignTm9kZXMgd2l0aCBlbXB0eSBpZHMnLCBtb2RlbEdyYXBoLm5vZGVzQnlJZFsnJ10pO1xuICB9XG5cbiAgLy8gRG8gdGhlIGluaXRpYWwgbGF5b3V0LlxuICBpZiAoIWVycm9yKSB7XG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IEdyYXBoTGF5b3V0KFxuICAgICAgbW9kZWxHcmFwaCxcbiAgICAgIGRhZ3JlLFxuICAgICAgc2hvd0l0ZW1Pbk5vZGVUeXBlcyxcbiAgICAgIG5vZGVEYXRhUHJvdmlkZXJSdW5zLFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGxheW91dC5sYXlvdXQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGBGYWlsZWQgdG8gbGF5b3V0IGdyYXBoOiAke2V9YDtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzKFxuICAgIHBhbmVJZCxcbiAgICBQcm9jZXNzaW5nTGFiZWwuTEFZSU5HX09VVF9ST09UX0xBWUVSLFxuICAgIGVycm9yLFxuICApO1xuXG4gIC8vIEZpbmQgaWRlbnRpY2FsIGdyb3Vwcy5cbiAgY29uc3QgaWRlbnRpY2FsR3JvdXBzRmluZGVyID0gbmV3IElkZW50aWNhbEdyb3Vwc0ZpbmRlcihtb2RlbEdyYXBoKTtcbiAgaWRlbnRpY2FsR3JvdXBzRmluZGVyLm1hcmtJZGVudGljYWxHcm91cHMoKTtcbiAgdXBkYXRlUHJvY2Vzc2luZ1Byb2dyZXNzKHBhbmVJZCwgUHJvY2Vzc2luZ0xhYmVsLkZJTkRJTkdfSURFTlRJQ0FMX0xBWUVSUyk7XG4gIHJldHVybiBtb2RlbEdyYXBoO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFeHBhbmRHcm91cE5vZGUoXG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgsXG4gIGdyb3VwTm9kZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT4sXG4gIG5vZGVEYXRhUHJvdmlkZXJSdW5zOiBSZWNvcmQ8c3RyaW5nLCBOb2RlRGF0YVByb3ZpZGVyUnVuRGF0YT4sXG4gIGFsbDogYm9vbGVhbixcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgZXhwYW5kZXIgPSBuZXcgR3JhcGhFeHBhbmRlcihcbiAgICBtb2RlbEdyYXBoLFxuICAgIGRhZ3JlLFxuICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgbm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICk7XG5cbiAgLy8gRXhwYW5lIGdyb3VwIG5vZGUuXG4gIGlmIChncm91cE5vZGVJZCAhPSBudWxsKSB7XG4gICAgbGV0IGRlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBncm91cE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtncm91cE5vZGVJZF07XG4gICAgaWYgKGdyb3VwTm9kZSAmJiBpc0dyb3VwTm9kZShncm91cE5vZGUpKSB7XG4gICAgICBncm91cE5vZGUuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgLy8gUmVjdXJzaXZlbHkgZXhwYW5kIGNoaWxkIGdyb3VwIG5vZGUgaWYgdGhlcmUgaXMgb25seSBvbmUgY2hpbGQuXG4gICAgICBsZXQgY3VyR3JvdXBOb2RlID0gZ3JvdXBOb2RlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5JZHMgPSBjdXJHcm91cE5vZGUubnNDaGlsZHJlbklkcyB8fCBbXTtcbiAgICAgICAgaWYgKGNoaWxkcmVuSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gbW9kZWxHcmFwaC5ub2Rlc0J5SWRbY2hpbGRyZW5JZHNbMF1dO1xuICAgICAgICAgIGlmIChjaGlsZCAmJiBpc0dyb3VwTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1ckdyb3VwTm9kZSA9IGNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gR2V0IHRoZSBkZWVwZXN0IGV4cGFuZGVkIGdyb3VwIG5vZGVzIGZyb20gdGhlIGN1ckdyb3VwTm9kZSBhbmQgd2Ugd2lsbFxuICAgICAgLy8gYmUgZG9pbmcgcmVsYXlvdXQgZnJvbSB0aGVyZS5cbiAgICAgIGNvbnN0IGlkczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGdldERlZXBlc3RFeHBhbmRlZEdyb3VwTm9kZUlkcyhjdXJHcm91cE5vZGUsIG1vZGVsR3JhcGgsIGlkcyk7XG4gICAgICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZCA9IGlkcy5sZW5ndGggPT09IDAgPyBbY3VyR3JvdXBOb2RlLmlkXSA6IGlkcztcbiAgICAgIC8vIENsZWFyIGxheW91dCBkYXRhIGZvciBhbGwgbm9kZXMgdW5kZXIgY3VyR3JvdXBOb2RlLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIG5vZGUgb3ZlcmxheSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCBzb1xuICAgICAgLy8gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlIG5vZGUgc2l6ZXMuXG4gICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBjdXJHcm91cE5vZGUuZGVzY2VuZGFudHNOb2RlSWRzIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtub2RlSWRdO1xuICAgICAgICBub2RlLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICBub2RlLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbCkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGVJZCBvZiAoZ3JvdXBOb2RlIGFzIEdyb3VwTm9kZSkuZGVzY2VuZGFudHNOb2RlSWRzIHx8XG4gICAgICAgIFtdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtjaGlsZE5vZGVJZF07XG4gICAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICAgIG5vZGUuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZXhwYW5kZXIucmVMYXlvdXRHcmFwaChkZWVwZXN0RXhwYW5kZWRHcm91cE5vZGVJZCk7XG5cbiAgICBjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XG4gICAgZ2V0RGVlcGVzdEV4cGFuZGVkR3JvdXBOb2RlSWRzKHVuZGVmaW5lZCwgbW9kZWxHcmFwaCwgaWRzKTtcbiAgICByZXR1cm4gaWRzO1xuICB9XG4gIC8vIEV4cGFuZCBhbGwgZ3JvdXAgbm9kZXMgaW4gdGhlIGdyYXBoLlxuICBlbHNlIHtcbiAgICByZXR1cm4gZXhwYW5kZXIuZXhwYW5kQWxsR3JvdXBzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29sbGFwc2VHcm91cE5vZGUoXG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgsXG4gIGdyb3VwTm9kZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT4sXG4gIG5vZGVEYXRhUHJvdmlkZXJSdW5zOiBSZWNvcmQ8c3RyaW5nLCBOb2RlRGF0YVByb3ZpZGVyUnVuRGF0YT4sXG4gIGFsbDogYm9vbGVhbixcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgZXhwYW5kZXIgPSBuZXcgR3JhcGhFeHBhbmRlcihcbiAgICBtb2RlbEdyYXBoLFxuICAgIGRhZ3JlLFxuICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgbm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICk7XG5cbiAgaWYgKGdyb3VwTm9kZUlkICE9IG51bGwpIHtcbiAgICBpZiAoYWxsKSB7XG4gICAgICBjb25zdCBncm91cE5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtncm91cE5vZGVJZF0gYXMgR3JvdXBOb2RlO1xuICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGVJZCBvZiBncm91cE5vZGUuZGVzY2VuZGFudHNOb2RlSWRzIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBtb2RlbEdyYXBoLm5vZGVzQnlJZFtjaGlsZE5vZGVJZF07XG4gICAgICAgIGlmIChpc0dyb3VwTm9kZShub2RlKSkge1xuICAgICAgICAgIG5vZGUuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBub2RlLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBtb2RlbEdyYXBoLmVkZ2VzQnlHcm91cE5vZGVJZHNbbm9kZS5pZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZGVyLmNvbGxhcHNlR3JvdXBOb2RlKGdyb3VwTm9kZUlkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwYW5kZXIuY29sbGFwc2VBbGxHcm91cCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlTGF5b3V0R3JhcGgoXG4gIG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgsXG4gIHNob3dPbk5vZGVJdGVtVHlwZXM6IFJlY29yZDxzdHJpbmcsIFNob3dPbk5vZGVJdGVtRGF0YT4sXG4gIG5vZGVEYXRhUHJvdmlkZXJSdW5zOiBSZWNvcmQ8c3RyaW5nLCBOb2RlRGF0YVByb3ZpZGVyUnVuRGF0YT4sXG4gIHRhcmdldERlZXBlc3RHcm91cE5vZGVJZHNUb0V4cGFuZD86IHN0cmluZ1tdLFxuICBjbGVhckFsbEV4cGFuZFN0YXRlcz86IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgZXhwYW5kZXIgPSBuZXcgR3JhcGhFeHBhbmRlcihcbiAgICBtb2RlbEdyYXBoLFxuICAgIGRhZ3JlLFxuICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgbm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICk7XG4gIGV4cGFuZGVyLnJlTGF5b3V0R3JhcGgoXG4gICAgdGFyZ2V0RGVlcGVzdEdyb3VwTm9kZUlkc1RvRXhwYW5kLFxuICAgIGNsZWFyQWxsRXhwYW5kU3RhdGVzLFxuICApO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVMb2NhdGVOb2RlKFxuICBtb2RlbEdyYXBoOiBNb2RlbEdyYXBoLFxuICBzaG93T25Ob2RlSXRlbVR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBTaG93T25Ob2RlSXRlbURhdGE+LFxuICBub2RlRGF0YVByb3ZpZGVyUnVuczogUmVjb3JkPHN0cmluZywgTm9kZURhdGFQcm92aWRlclJ1bkRhdGE+LFxuICBub2RlSWQ6IHN0cmluZyxcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgZXhwYW5kZXIgPSBuZXcgR3JhcGhFeHBhbmRlcihcbiAgICBtb2RlbEdyYXBoLFxuICAgIGRhZ3JlLFxuICAgIHNob3dPbk5vZGVJdGVtVHlwZXMsXG4gICAgbm9kZURhdGFQcm92aWRlclJ1bnMsXG4gICk7XG4gIHJldHVybiBleHBhbmRlci5leHBhbmRUb1JldmVhbE5vZGUobm9kZUlkKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVNb2RlbEdyYXBoKG1vZGVsR3JhcGg6IE1vZGVsR3JhcGgsIHJlbmRlcmVySWQ6IHN0cmluZykge1xuICBNT0RFTF9HUkFQSFNfQ0FDSEVbZ2V0TW9kZWxHcmFwaEtleShtb2RlbEdyYXBoLmlkLCByZW5kZXJlcklkKV0gPSBtb2RlbEdyYXBoO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZWRNb2RlbEdyYXBoKFxuICBtb2RlbEdyYXBoSWQ6IHN0cmluZyxcbiAgcmVuZGVyZXJJZDogc3RyaW5nLFxuKTogTW9kZWxHcmFwaCB7XG4gIGNvbnN0IGNhY2hlZE1vZGVsR3JhcGggPVxuICAgIE1PREVMX0dSQVBIU19DQUNIRVtnZXRNb2RlbEdyYXBoS2V5KG1vZGVsR3JhcGhJZCwgcmVuZGVyZXJJZCldO1xuICBpZiAoY2FjaGVkTW9kZWxHcmFwaCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE1vZGVsR3JhcGggd2l0aCBpZCBcIiR7bW9kZWxHcmFwaElkfVwiIG5vdCBmb3VuZCBmb3IgcmVuZGVyZXJJZCBcIiR7cmVuZGVyZXJJZH1cImAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkTW9kZWxHcmFwaDtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kZWxHcmFwaEtleShtb2RlbEdyYXBoSWQ6IHN0cmluZywgcmVuZGVyZXJJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke21vZGVsR3JhcGhJZH1fX18ke3JlbmRlcmVySWR9YDtcbn1cbiJdfQ==
;return exports;});

